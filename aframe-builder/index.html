<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A-Frame Builder</title>
    
    <!-- THREE.Math polyfill to fix NAF errors -->
    <!-- <script>
        // Immediately execute to ensure THREE.Math is defined before any scripts load
        (function() {
            // Make sure THREE exists
            if (typeof window.THREE === 'undefined') {
                window.THREE = {};
            }
            
            // Add Math if it doesn't exist
            if (!window.THREE.Math) {
                window.THREE.Math = {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: 180 / Math.PI,
                    generateUUID: function() {
                        // Simple UUID generator
                        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                            var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                            return v.toString(16);
                        });
                    }
                };
                console.log("THREE.Math polyfill added immediately");
            }
        })();
    </script> -->
    
    <!-- A-Frame -->
    <script src="/js/aframe.min.js"></script>
    
    <!-- Load Socket.io -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.5.0/socket.io.slim.js"></script>
    
    <!-- Deferred NAF loading -->
    <script>
        // Load NAF after A-Frame is fully initialized
        document.addEventListener('DOMContentLoaded', function() {
            AFRAME.registerComponent('load-naf', {
                init: function() {
                    console.log("A-Frame fully initialized, loading NAF");
                    
                    // Make sure THREE.Math exists before loading NAF
                    if (window.THREE && !window.THREE.Math) {
                        window.THREE.Math = {
                            DEG2RAD: Math.PI / 180,
                            RAD2DEG: 180 / Math.PI
                        };
                    }
                    
                    // Create script element
                    var script = document.createElement('script');
                    script.src = "https://unpkg.com/networked-aframe@0.10.0/dist/networked-aframe.min.js";
                    script.onload = function() {
                        console.log("NAF loaded successfully");
                        
                        // Notify the app
                        if (window.AFRAME && window.AFRAME.BUILDER) {
                            setTimeout(function() {
                                // Re-initialize NAF in the app
                                window.AFRAME.BUILDER.initNetworkedAframe();
                            }, 500);
                        }
                    };
                    
                    // Add to document
                    document.head.appendChild(script);
                }
            });
            
            // Add the component to the scene
            var scene = document.querySelector('a-scene');
            if (scene) {
                scene.setAttribute('load-naf', '');
            }
        });
    </script>
    
    <!-- Monaco Editor -->
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.39.0/min/vs/loader.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .toolbar {
            height: 50px;
            background-color: #2c2c2c;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }
        
        .toolbar-left {
            flex: 1;
            display: flex;
            align-items: center;
        }
        
        .logo {
            font-weight: bold;
            font-size: 1.2rem;
            margin-right: 20px;
        }
        
        .view-buttons {
            display: flex;
        }
        
        .view-button {
            background: none;
            border: none;
            color: #ccc;
            padding: 8px 12px;
            margin-right: 5px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        
        .view-button:hover {
            background-color: #444;
        }
        
        .view-button.active {
            background-color: #4a8fff;
            color: white;
        }
        
        .toolbar-right {
            display: flex;
            align-items: center;
        }
        
        .save-indicator {
            display: flex;
            align-items: center;
            margin-right: 15px;
            color: #aaa;
            font-size: 0.8rem;
            transition: opacity 0.3s ease;
        }
        
        .save-indicator.visible {
            opacity: 1;
        }
        
        .save-indicator.hidden {
            opacity: 0;
        }
        
        .save-indicator-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #4a8fff;
        }
        
        .save-indicator-dot.saving {
            background-color: #ffa500;
        }
        
        .save-indicator-dot.saved {
            background-color: #4caf50;
        }
        
        .save-indicator-dot.error {
            background-color: #f44336;
        }
        
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .sidebar {
            width: 250px;
            background-color: #333;
            color: #eee;
            overflow-y: auto;
            padding: 10px;
        }
        
        .sidebar-section {
            margin-bottom: 20px;
        }
        
        .sidebar-title {
            font-size: 1rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #fff;
        }
        
        .content-area {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        .view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
        }
        
        .view.active {
            display: block;
        }
        
        #code-view {
            background-color: #1e1e1e;
        }
        
        #monaco-editor {
            width: 100%;
            height: 100%;
        }
        
        #preview-view {
            background-color: #f0f0f0;
        }
        
        #preview-container {
            width: 100%;
            height: 100%;
        }
        
        #inspector-view {
            background-color: #f0f0f0;
        }
        
        .a-enter-vr {
            display: none !important;
        }
        
        /* Component buttons */
        .component-button {
            display: block;
            width: 100%;
            padding: 8px;
            margin-bottom: 5px;
            background-color: #444;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-align: left;
            transition: background-color 0.2s;
        }
        
        .component-button:hover {
            background-color: #555;
        }
        
        /* Debug Panel Styles */
        .debug-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            width: 320px;
            display: none;
            z-index: 100;
        }
        
        .debug-panel.visible {
            display: block;
        }
        
        .debug-controls {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        
        .debug-button {
            background-color: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 3px 6px;
            font-size: 11px;
            cursor: pointer;
        }
        
        .debug-button:hover {
            background-color: #444;
        }
        
        .naf-connection-container {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-top: 5px;
        }
        
        .naf-server-input {
            background-color: #333;
            color: white;
            border: 1px solid #555;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 11px;
            width: 180px;
        }
        
        .naf-room-input {
            background-color: #333;
            color: white;
            border: 1px solid #555;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 11px;
            width: 90px;
        }
        
        .camera-history {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 5px;
            border-top: 1px solid #555;
            padding-top: 5px;
            font-size: 10px;
        }
        
        .camera-history-tabs {
            display: flex;
            margin-bottom: 5px;
            border-bottom: 1px solid #555;
        }
        
        .history-tab {
            padding: 2px 8px;
            margin-right: 2px;
            cursor: pointer;
            border-radius: 3px 3px 0 0;
            background-color: #333;
        }
        
        .history-tab.active {
            background-color: #555;
            font-weight: bold;
        }
        
        .camera-history-entry {
            margin-bottom: 3px;
            border-bottom: 1px dotted #555;
            padding-bottom: 2px;
        }
    </style>
</head>
<body>
    <!-- Toolbar -->
    <div class="toolbar">
        <div class="toolbar-left">
            <div class="logo">A-Frame Builder</div>
        <div class="view-buttons">
                <button class="view-button active" data-view="preview">Preview</button>
                <button class="view-button" data-view="code">Code</button>
                <button class="view-button" data-view="inspector">Inspector</button>
            </div>
        </div>
        <div class="toolbar-right">
            <div class="save-indicator hidden">
                <div class="save-indicator-dot"></div>
                <span class="save-indicator-text">Changes saved</span>
            </div>
        </div>
    </div>
    
    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-section">
                <div class="sidebar-title">Components</div>
                <button class="component-button" data-component="box">Box</button>
                <button class="component-button" data-component="sphere">Sphere</button>
                <button class="component-button" data-component="cylinder">Cylinder</button>
                <button class="component-button" data-component="plane">Plane</button>
                <button class="component-button" data-component="sky">Sky</button>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-title">Debug</div>
                <button class="component-button" id="toggle-debug">Show Debug Info</button>
                <button class="component-button" id="change-sky-color">Change Sky Color</button>
                <button class="component-button" id="reset-camera">Reset Camera</button>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-title">Assets</div>
                <!-- Asset management will go here -->
            </div>
            <div class="sidebar-section">
                <div class="sidebar-title">Templates</div>
                <!-- Templates will go here -->
            </div>
        </div>
        
        <!-- Content Area -->
        <div class="content-area">
            <!-- Preview View -->
            <div id="preview-view" class="view active">
                <div id="preview-container">
                    <a-scene id="preview-scene" embedded>
                        <!-- Templates for networked entities -->
                        <a-assets>
                            <template id="avatar-template">
                                <a-entity class="avatar">
                                    <a-sphere color="#5985ff" scale="0.45 0.5 0.4"></a-sphere>
                                </a-entity>
                            </template>
                            
                            <template id="entity-template">
                                <a-entity class="networked-entity"></a-entity>
                            </template>
                        </a-assets>
                        
                        <!-- Initial default scene -->
                        <a-box position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9"></a-box>
                        <a-sphere position="0 1.25 -5" radius="1.25" color="#EF2D5E"></a-sphere>
                        <a-cylinder position="1 0.75 -3" radius="0.5" height="1.5" color="#FFC65D"></a-cylinder>
                        <a-plane position="0 0 -4" rotation="-90 0 0" width="4" height="4" color="#7BC8A4"></a-plane>
                        <a-sky color="#ECECEC"></a-sky>
                        <a-entity id="user-camera" position="0 1.6 0" camera look-controls wasd-controls networked="template:#avatar-template;attachTemplateToLocal:false;"></a-entity>
                    </a-scene>
                </div>
                <div class="debug-panel">
                    <div>Camera Position: <span id="camera-position">0,0,0</span></div>
                    <div>Camera Rotation: <span id="camera-rotation">0,0,0</span></div>
                    <div>Camera Entity: <span id="entity-camera-info">None</span></div>
                    <div>Entity Count: <span id="entity-count">0</span></div>
                    <div>Last Action: <span id="last-action">None</span></div>
                    <div>NAF Status: <span id="naf-status" class="text-warning">Not Initialized</span></div>
                    <div class="debug-controls">
                        <button class="debug-button" id="teleport-camera">Teleport to 0,1.6,5</button>
                        <button class="debug-button" id="log-entities">Log Entities</button>
                        <button class="debug-button" id="check-naf">Check NAF</button>
                        <div class="naf-connection-container">
                            <input type="text" id="naf-server-url" class="naf-server-input" placeholder="NAF Server URL" value="https://networked-aframe-dev-server.herokuapp.com">
                            <input type="text" id="naf-room-name" class="naf-room-input" placeholder="Room Name" value="test-room">
                            <button class="debug-button" id="connect-naf">Connect NAF</button>
                        </div>
                    </div>
                    <div class="camera-history">
                        <div class="camera-history-tabs">
                            <div class="history-tab active" data-mode="all">All</div>
                            <div class="history-tab" data-mode="camera">Camera</div>
                            <div class="history-tab" data-mode="entity">Entity</div>
                        </div>
                        <div id="camera-history-log"></div>
                    </div>
                </div>
            </div>
            
            <!-- Code View -->
            <div id="code-view" class="view">
                <div id="monaco-editor"></div>
            </div>
            
            <!-- Inspector View -->
            <div id="inspector-view" class="view">
                <!-- A-Frame Inspector will be injected here -->
            </div>
        </div>
    </div>
    
    <script>
        // Wait for A-Frame to load before any app initialization
        window.onload = function() {
            // Ensure the preview scene exists and is set up correctly
            const scene = document.getElementById('preview-scene');
            if (!scene) {
                console.error('Preview scene not found!');
                return;
            }
            
            // State Management
            const state = {
                // Scene representation in memory
                scene: {
                    entities: [], // Array to hold entity data
                    assets: [],   // Array to hold asset data
                    camera: {     // Store camera state
                        position: { x: 0, y: 1.6, z: 0 },
                        rotation: { x: 0, y: 0, z: 0 }
                    }
                },
                
                // Current active view
                currentView: 'preview',
                
                // Permission flags
                requirePermissionForEntityCreation: false,
                requirePermissionForEntityAddition: false,
                requirePermissionForEntityRemoval: false,
                requirePermissionForComponentChange: false,
                
                // DOM observation flag for advanced change detection
                shouldObserveDOMChanges: true,
                
                // Initial scene template
                initialScene: `<a-scene embedded networked-scene="
  serverURL: https://networked-aframe-dev-server.herokuapp.com;
  app: aframe-builder-app;
  room: test-room;
  debug: true;
  adapter: socketio;
  audio: false;">
  <a-assets>
    <template id="avatar-template">
      <a-entity class="avatar">
        <a-sphere color="#5985ff" scale="0.45 0.5 0.4"></a-sphere>
      </a-entity>
    </template>
    
    <template id="entity-template">
      <a-entity class="networked-entity"></a-entity>
    </template>
  </a-assets>
  <a-box position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9"></a-box>
  <a-sphere position="0 1.25 -5" radius="1.25" color="#EF2D5E"></a-sphere>
  <a-cylinder position="1 0.75 -3" radius="0.5" height="1.5" color="#FFC65D"></a-cylinder>
  <a-plane position="0 0 -4" rotation="-90 0 0" width="4" height="4" color="#7BC8A4"></a-plane>
  <a-sky color="#ECECEC"></a-sky>
  <a-entity id="user-camera" position="0 1.6 0" camera look-controls wasd-controls networked="template:#avatar-template;attachTemplateToLocal:false;"></a-entity>
</a-scene>`,
                
                // Monaco editor instance
                editor: null,
                
                // Inspector state
                inspectorOpened: false,
                
                // Component templates
                components: {
                    box: '<a-box position="0 1 -3" rotation="0 45 0" color="#4CC3D9"></a-box>',
                    sphere: '<a-sphere position="0 1.25 -3" radius="1.25" color="#EF2D5E"></a-sphere>',
                    cylinder: '<a-cylinder position="0 1 -3" radius="0.5" height="1.5" color="#FFC65D"></a-cylinder>',
                    plane: '<a-plane position="0 0 -3" rotation="-90 0 0" width="4" height="4" color="#7BC8A4"></a-plane>',
                    sky: '<a-sky color="#ECECEC"></a-sky>'
                },
                
                // Initialize application
                initialize: function() {
                    console.log("Initializing aframe-builder application...");
                    this.nafEnabled = false; // Disable NAF by default
                    this.wasConnectedToNAF = false; // Track if we were ever connected
                    
                    // Initialize logging arrays
                    this.cameraHistory = [];
                    this.entityHistory = [];
                    this.historyMode = 'all'; // Default history view
                    
                    // Store the initial scene content for reference
                    const previewScene = document.getElementById('preview-scene');
                    this.initialSceneHTML = this.getCleanSceneHTML(previewScene);
                    
                    // Add a camera if one doesn't exist
                    this.ensureCamera();
                    
                    // Parse scene from DOM
                    this.parseSceneFromDOM();
                    
                    // Initialize component buttons
                    this.initComponentButtons();
                    
                    // Initialize view switcher
                    this.initViewSwitcher();
                    
                    // Initialize Monaco editor
                    this.initMonaco();
                    
                    // Setup A-Frame event listeners and inspector integration
                    this.setupInspectorSync();
                    
                    // Initialize Networked A-Frame support but don't connect automatically
                    this.initNetworkedAframe();
                    
                    // Initialize save indicator
                    this.showSaveIndicator('saved');
                    
                    // Initialize debug tools
                    this.initDebugTools();
                    
                    // Make debug panel visible by default (with animation)
                    const debugPanel = document.querySelector('.debug-panel');
                    if (debugPanel) {
                        setTimeout(() => {
                            debugPanel.classList.add('visible');
                        }, 500);
                        
                        // Start tracking camera changes
                        let lastTrackTime = 0;
                        const trackInterval = 100; // ms
                        
                        const trackLoop = (timestamp) => {
                            if (timestamp - lastTrackTime > trackInterval) {
                                this.trackCameraChanges();
                                this.updateDebugInfo();
                                lastTrackTime = timestamp;
                            }
                            requestAnimationFrame(trackLoop);
                        };
                        
                        requestAnimationFrame(trackLoop);
                    }
                    
                    console.log("Application initialized successfully");
                    this.logCameraEvent('A-Frame Builder initialized', true);
                },
                
                // Setup synchronization between inspector and our model
                setupInspectorSync: function() {
                    // Get the preview scene
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;
                    
                    console.log("Setting up A-Frame event listeners for state sync");
                    
                    // Clear any existing observers and event listeners
                    if (this.sceneObserver) {
                        this.sceneObserver.disconnect();
                        this.sceneObserver = null;
                    }
                    
                    // Remove existing event listeners if any
                    if (this.boundChildAttached) {
                        previewScene.removeEventListener('child-attached', this.boundChildAttached);
                    }
                    if (this.boundChildDetached) {
                        previewScene.removeEventListener('child-detached', this.boundChildDetached);
                    }
                    if (this.boundComponentChanged) {
                        previewScene.removeEventListener('componentchanged', this.boundComponentChanged);
                    }
                    
                    // Flag to prevent circular updates
                    this.isUpdatingFromState = false;
                    
                    // Create bound event handlers for better cleanup
                    this.boundChildAttached = this.handleChildAttached.bind(this);
                    this.boundChildDetached = this.handleChildDetached.bind(this);
                    this.boundComponentChanged = this.handleComponentChanged.bind(this);
                    
                    // Listen for entity added to scene
                    previewScene.addEventListener('child-attached', this.boundChildAttached);
                    
                    // Listen for entity removed from scene
                    previewScene.addEventListener('child-detached', this.boundChildDetached);
                    
                    // Use event delegation to listen for component changes on any entity
                    previewScene.addEventListener('componentchanged', this.boundComponentChanged);
                    
                    // Set up inspector integration with specific event handler
                    if (typeof AFRAME !== 'undefined' && AFRAME.INSPECTOR) {
                        // Listen for inspector close event
                        if (this.boundInspectorClosed) {
                            window.removeEventListener('inspector-closed', this.boundInspectorClosed);
                        }
                        
                        this.boundInspectorClosed = this.handleInspectorClosed.bind(this);
                        window.addEventListener('inspector-closed', this.boundInspectorClosed);
                    }
                    
                    // Set up mutation observer for DOM changes that A-Frame might not catch
                    if (this.shouldObserveDOMChanges) {
                        this.setupDOMObserver();
                    }
                    
                    console.log("A-Frame event listeners established");
                },
                
                // Handle entity added to scene
                handleChildAttached: function(event) {
                    // Skip if we're in the middle of updating from our state
                    if (this.isUpdatingFromState) return;
                    
                    const entity = event.detail.el;
                    
                    // Only track A-Frame entities, not internal elements
                    if (entity.tagName && 
                        entity.tagName.toLowerCase().startsWith('a-') && 
                        !entity.hasAttribute('aframe-injected')) {
                        
                        console.log(`Entity added to scene: ${entity.tagName.toLowerCase()} ${entity.id || 'no-id'}`);
                        
                        // Check permissions if needed (for future extension)
                        if (this.requirePermissionForEntityAddition && typeof this.requestPermission === 'function') {
                            if (!this.requestPermission(`Add ${entity.tagName.toLowerCase()} to scene`)) {
                                // Remove the entity if permission denied
                                entity.parentNode.removeChild(entity);
                                return;
                            }
                        }
                        
                        // Debounce to avoid multiple rapid updates
                        this.debounceSceneUpdate();
                    }
                },
                
                // Handle entity removed from scene
                handleChildDetached: function(event) {
                    // Skip if we're in the middle of updating from our state
                    if (this.isUpdatingFromState) return;
                    
                    const entity = event.detail.el;
                    
                    // Only track A-Frame entities, not internal elements
                    if (entity.tagName && 
                        entity.tagName.toLowerCase().startsWith('a-') && 
                        !entity.hasAttribute('aframe-injected')) {
                        
                        console.log(`Entity removed from scene: ${entity.tagName.toLowerCase()} ${entity.id || 'no-id'}`);
                        
                        // Check permissions if needed (for future extension)
                        if (this.requirePermissionForEntityRemoval && typeof this.requestPermission === 'function') {
                            if (!this.requestPermission(`Remove ${entity.tagName.toLowerCase()} from scene`)) {
                                // We can't really re-add the entity here, but we can log the denial
                                console.warn(`Permission denied for removing ${entity.tagName.toLowerCase()}`);
                            }
                        }
                        
                        // Debounce to avoid multiple rapid updates
                        this.debounceSceneUpdate();
                    }
                },
                
                // Handle component change on entity
                handleComponentChanged: function(event) {
                    // Skip if we're in the middle of updating from our state
                    if (this.isUpdatingFromState) return;
                    
                    const entity = event.detail.target;
                    const component = event.detail.name;
                    const oldData = event.detail.oldData;
                    const newData = event.detail.newData;
                    
                    // Skip camera entities to avoid circular updates from debug
                    if (entity.id === 'user-camera' && component === 'position') return;
                    if (entity.id === 'user-camera' && component === 'rotation') return;
                    
                    console.log(`Component changed on ${entity.tagName.toLowerCase()}: ${component}`, oldData, newData);
                    
                    // Check permissions if needed (for future extension)
                    if (this.requirePermissionForComponentChange && typeof this.requestPermission === 'function') {
                        if (!this.requestPermission(`Change ${component} on ${entity.tagName.toLowerCase()}`)) {
                            // Revert the change if permission denied
                            if (oldData !== undefined) {
                                entity.setAttribute(component, oldData);
                            } else {
                                entity.removeAttribute(component);
                            }
                            return;
                        }
                    }
                    
                    // Debounce to avoid multiple rapid updates
                    this.debounceSceneUpdate();
                },
                
                // Handle inspector closed event
                handleInspectorClosed: function() {
                    this.inspectorOpened = false;
                    
                    // Force update to ensure model is in sync
                    this.parseSceneFromDOM();
                    this.updateEditor();
                    
                    // Log event
                    if (typeof this.logCameraEvent === 'function') {
                        this.logCameraEvent('Inspector closed, scene updated', true);
                    }
                },
                
                // Set up mutation observer for DOM changes
                setupDOMObserver: function() {
                    if (this.sceneObserver) {
                        this.sceneObserver.disconnect();
                    }
                    
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;
                    
                    this.sceneObserver = new MutationObserver(mutations => {
                        // Skip if we're in the middle of updating
                        if (this.isUpdatingFromState) return;
                        
                        // Check if any mutation is relevant to our scene
                        const relevantMutation = mutations.some(mutation => {
                            // Only care about childList changes
                            if (mutation.type !== 'childList') return false;
                            
                            // Check added nodes
                            for (let i = 0; i < mutation.addedNodes.length; i++) {
                                const node = mutation.addedNodes[i];
                                if (node.tagName && node.tagName.toLowerCase().startsWith('a-') && 
                                    !node.hasAttribute('aframe-injected')) {
                                    return true;
                                }
                            }
                            
                            // Check removed nodes
                            for (let i = 0; i < mutation.removedNodes.length; i++) {
                                const node = mutation.removedNodes[i];
                                if (node.tagName && node.tagName.toLowerCase().startsWith('a-') && 
                                    !node.hasAttribute('aframe-injected')) {
                                    return true;
                                }
                            }
                            
                            return false;
                        });
                        
                        if (relevantMutation) {
                            console.log("DOM mutation detected, updating scene model");
                            this.debounceSceneUpdate();
                        }
                    });
                    
                    this.sceneObserver.observe(previewScene, {
                        childList: true,
                        subtree: true,
                        attributes: true,
                        attributeFilter: ['position', 'rotation', 'scale', 'color', 'material', 'geometry']
                    });
                },
                
                // Debounce scene updates to prevent excessive processing
                debounceSceneUpdate: function() {
                    // Clear any existing timeout
                    if (this.sceneUpdateTimeout) {
                        clearTimeout(this.sceneUpdateTimeout);
                    }
                    
                    // Show saving indicator
                    this.showSaveIndicator('saving');
                    
                    // Set a timeout to update after changes settle
                    this.sceneUpdateTimeout = setTimeout(() => {
                        // Update our model from the DOM and update editor
                        this.parseSceneFromDOM();
                        this.updateEditor();
                        
                        // Show saved indicator
                        this.showSaveIndicator('saved');
                        
                        // Log event
                        if (typeof this.logCameraEvent === 'function') {
                            this.logCameraEvent('Scene updated from A-Frame event', true);
                        }
                    }, 500); // Debounce time, adjust as needed
                },
                
                // Initialize Monaco Editor
                initMonaco: function() {
                    console.log("Initializing code editor");
                    
                    require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.39.0/min/vs' }});
                    
                    require(['vs/editor/editor.main'], () => {
                        // Create the editor with standard HTML language
                        this.editor = monaco.editor.create(document.getElementById('monaco-editor'), {
                            value: '<a-scene embedded>\n  <!-- Add your scene content here -->\n</a-scene>',
                            language: 'html',
                    theme: 'vs-dark',
                    automaticLayout: true,
                            minimap: {
                                enabled: false
                            }
                        });
                        
                        console.log("Monaco editor created");
                        
                        // Parse the DOM scene into our model
                        this.parseSceneFromDOM();
                        
                        // Update the editor with the current scene
                        this.updateEditor();
                        
                        // Listen for changes in the editor
                        this.editor.onDidChangeModelContent(() => {
                            // Parse the editor content
                            const html = this.editor.getValue();
                            console.log("Editor content changed");
                            
                            // Show saving indicator
                            this.showSaveIndicator('saving');
                            
                            // Set flag to prevent circular updates
                            this.isUpdatingFromState = true;
                            
                            try {
                                // Update our model from the editor HTML
                                this.parseSceneFromHTML(html);
                                
                                // Apply changes to the preview scene
                                const previewScene = document.getElementById('preview-scene');
                                if (previewScene) {
                                    // Parse the HTML
                                    const parser = new DOMParser();
                                    const doc = parser.parseFromString(html, 'text/html');
                                    const scene = doc.querySelector('a-scene');
                                    
                                    if (scene && scene.children.length > 0) {
                                        // First clear existing entities
                                        Array.from(previewScene.children).forEach(child => {
                                            // Only remove A-Frame entities that aren't the camera
                                            if (child.tagName && 
                                                child.tagName.toLowerCase().startsWith('a-') && 
                                                child.id !== 'user-camera' &&
                                                !child.hasAttribute('aframe-injected')) {
                                                previewScene.removeChild(child);
                                            }
                                        });
                                        
                                        // Add new entities from editor
                                        Array.from(scene.children).forEach(child => {
                                            // Don't add internal A-Frame elements
                                            if (child.tagName && 
                                                child.tagName.toLowerCase().startsWith('a-') && 
                                                child.id !== 'user-camera' &&
                                                !child.hasAttribute('aframe-injected')) {
                                                previewScene.appendChild(document.importNode(child, true));
                                            }
                                        });
                                        
                                        // Ensure A-Frame knows about the changes
                                        if (AFRAME && AFRAME.scenes && AFRAME.scenes.length > 0) {
                                            // Force a tick to process changes
                                            AFRAME.scenes[0].tick();
                                            
                                            // Flush to DOM to ensure all component data is written to attributes
                                            AFRAME.scenes[0].flushToDOM(true);
                                        }
                                        
                                        // Log the update
                                        if (typeof this.logCameraEvent === 'function') {
                                            this.logCameraEvent('Scene updated from editor', true);
                                        }
                                    }
                                }
                            } catch (error) {
                                console.error('Error updating scene from editor:', error);
                                if (typeof this.logCameraEvent === 'function') {
                                    this.logCameraEvent(`Error updating from editor: ${error.message}`, true);
                                }
                            } finally {
                                // Reset flag to allow event-based updates again
                                setTimeout(() => {
                                    this.isUpdatingFromState = false;
                                    
                                    // Show saved indicator after a short delay to ensure everything is settled
                                    this.showSaveIndicator('saved');
                                }, 100);
                            }
                        });
                    });
                },
                
                // Parse A-Frame HTML to scene model
                parseSceneFromHTML: function(html) {
                    console.log("Parsing scene from HTML");
                    
                    // Simple parsing for now - we'll extract entities from the HTML
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const scene = doc.querySelector('a-scene');
                    
                    if (!scene) {
                        console.warn("No a-scene found in HTML");
                        return;
                    }
                    
                    // Reset scene data
                    this.scene.entities = [];
                    this.scene.assets = [];
                    
                    // Parse assets
                    const assetsEl = scene.querySelector('a-assets');
                    if (assetsEl) {
                        Array.from(assetsEl.children).forEach(asset => {
                            this.scene.assets.push({
                                tag: asset.tagName.toLowerCase(),
                                attributes: this.extractAttributes(asset)
                            });
                        });
                    }
                    
                    // Parse entities (excluding a-assets)
                    const entities = Array.from(scene.children).filter(el => {
                        // Only include real A-Frame entity elements, not internal elements
                        const tagName = el.tagName.toLowerCase();
                        if (tagName === 'a-assets') return false;
                        if (el.hasAttribute('aframe-injected')) return false;
                        if (tagName === 'canvas' || tagName === 'div') return false;
                        return tagName.startsWith('a-');
                    });
                    
                    entities.forEach(entity => {
                        // Create entity data
                        const entityData = {
                            id: entity.id || `entity-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
                            tag: entity.tagName.toLowerCase(),
                            attributes: this.extractAttributes(entity)
                        };
                        
                        // Add to entities
                        this.scene.entities.push(entityData);
                    });
                    
                    console.log(`Parsed ${this.scene.entities.length} entities from HTML`);
                },
                
                // Extract attributes from an element
                extractAttributes: function(element) {
                    const attributes = {};
                    Array.from(element.attributes).forEach(attr => {
                        attributes[attr.name] = attr.value;
                    });
                    return attributes;
                },
                
                // Generate A-Frame HTML from scene model
                generateHTML: function() {
                    let html = '<a-scene embedded>\n';
                    
                    // Add assets if any
                    if (this.scene.assets.length > 0) {
                        html += '  <a-assets>\n';
                        this.scene.assets.forEach(asset => {
                            html += `    <${asset.tag}`;
                            Object.entries(asset.attributes).forEach(([key, value]) => {
                                html += ` ${key}="${value}"`;
                            });
                            html += '>\n';
                        });
                        html += '  </a-assets>\n';
                    }
                    
                    // Add root entities (entities without parents)
                    const rootEntities = this.scene.entities.filter(entity => !entity.parentId);
                    rootEntities.forEach(entity => {
                        html += this.generateEntityHTML(entity, 2);
                    });
                    
                    html += '</a-scene>';
                    return html;
                },
                
                // Generate HTML for a single entity and its children
                generateEntityHTML: function(entity, indentation = 0) {
                    const indent = ' '.repeat(indentation);
                    
                    let html = `${indent}<${entity.tag}`;
                    
                    // Add attributes
                    Object.entries(entity.attributes).forEach(([key, value]) => {
                        html += ` ${key}="${value}"`;
                    });
                    
                    // Find children
                    const children = this.scene.entities.filter(e => e.parentId === entity.id);
                    
                    if (children.length > 0) {
                        html += '>\n';
                        
                        // Add children
                        children.forEach(child => {
                            html += this.generateEntityHTML(child, indentation + 2);
                        });
                        
                        html += `${indent}</${entity.tag}>\n`;
                    } else {
                        html += `></${entity.tag}>\n`;
                    }
                    
                    return html;
                },
                
                // Update the editor from scene model
                updateEditor: function() {
                    if (!this.editor) return;
                    
                    // Get the preview scene
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;
                    
                    // Get clean HTML from the DOM
                    const cleanHTML = this.getCleanSceneHTML(previewScene);
                    const html = `<a-scene embedded>\n${cleanHTML}\n</a-scene>`;
                    
                    // Only update if the content has actually changed
                    const currentValue = this.editor.getValue();
                    if (currentValue !== html) {
                        this.editor.setValue(html);
                    }
                },
                
                // Apply model changes to the preview scene
                applyChangesToPreview: function(html) {
                    // Always save camera state before any change
                    this.saveCameraState('Before preview update');
                    
                    try {
                        const previewScene = document.getElementById('preview-scene');
                        if (!previewScene) return;
                        
                        // Set flag to prevent circular updates via event listeners
                        this.isUpdatingFromState = true;
                        
                        // Log the HTML we're about to apply (for debugging only)
                        console.log('[Preview Update] Applying HTML:', html);
                        
                        // Validate HTML content before attempting to apply
                        if (!html || html.trim() === '') {
                            console.error('Empty HTML content, not applying changes');
                            this.isUpdatingFromState = false;
                            this.showSaveIndicator('error');
                        return;
                    }
                    
                        // Process the HTML to get the scene content
                        const template = document.createElement('template');
                        template.innerHTML = html.trim();
                        
                        // Safety check - don't continue if we somehow got empty content
                        if (!template.content.firstChild) {
                            console.error('Empty scene content, not applying changes');
                            this.isUpdatingFromState = false;
                            this.showSaveIndicator('error');
                        return;
                    }
                    
                        // Get all non-camera entities in the current scene
                        const currentEntities = Array.from(previewScene.children).filter(el => 
                            el.tagName && 
                            el.tagName.toLowerCase().startsWith('a-') && 
                            el.id !== 'user-camera' && 
                            !el.hasAttribute('aframe-injected')
                        );
                        
                        // Save references to all current entities 
                        const entityMap = {};
                        currentEntities.forEach(entity => {
                            if (entity.id) {
                                entityMap[entity.id] = entity;
                            }
                        });
                        
                        // Debug log count of entities
                        console.log(`[Entity Count] Current: ${currentEntities.length}, In Model: ${this.scene.entities.length}`);
                        this.logCameraEvent(`Updating scene (${this.scene.entities.length} entities)`, true);
                        
                        // Clear current entities except camera
                        currentEntities.forEach(entity => {
                            previewScene.removeChild(entity);
                        });
                        
                        // Get all non-camera entities from the template
                        const newEntities = Array.from(template.content.children).filter(el => 
                            el.tagName && 
                            el.tagName.toLowerCase().startsWith('a-') && 
                            el.id !== 'user-camera'
                        );
                        
                        // Add the new entities to the scene
                        newEntities.forEach(entity => {
                            previewScene.appendChild(entity);
                        });
                        
                        // Log status after update
                        console.log(`[Entity Update] Added ${newEntities.length} entities to scene`);
                        
                        // Use our centralized method to flush all entities to DOM
                        this.flushAllEntitiesToDOM();
                        
                        // Reset update flag after DOM updates are complete
                        setTimeout(() => {
                            this.isUpdatingFromState = false;
                            
                            // Restore camera state after changes are applied
                            this.restoreCameraState('After preview update');
                        }, 100);
                        
                    } catch (error) {
                        console.error('Error applying changes to preview:', error);
                        this.logCameraEvent(`Error updating scene: ${error.message}`, true);
                        this.isUpdatingFromState = false;
                        this.showSaveIndicator('error');
                    }
                },
                
                // Ensure there's a camera in the scene
                ensureCamera: function() {
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;
                    
                    // Check if there's already a camera
                    let hasCamera = false;
                    Array.from(previewScene.children).forEach(child => {
                        if (child.tagName.toLowerCase() === 'a-camera' || 
                            child.hasAttribute('camera') ||
                            child.id === 'user-camera') {
                            hasCamera = true;
                        }
                    });
                    
                    // If no camera, add the user-camera
                    if (!hasCamera) {
                        const camera = document.createElement('a-entity');
                        camera.setAttribute('camera', '');
                        camera.setAttribute('look-controls', '');
                        camera.setAttribute('wasd-controls', '');
                        camera.setAttribute('position', '0 1.6 0');
                        camera.setAttribute('id', 'user-camera');
                        previewScene.appendChild(camera);
                    }
                },
                
                // Setup optimized observers to reduce performance impact
                setupOptimizedObservers: function() {
                    // This method is kept for backward compatibility
                    // It's just an alias to setupInspectorSync now
                    this.setupInspectorSync();
                },
                
                // Initialize component buttons
                initComponentButtons: function() {
                    console.log("Setting up component buttons");
                    
                    // Get all component buttons directly
                    document.querySelectorAll('.component-button[data-component]').forEach(button => {
                        const componentType = button.getAttribute('data-component');
                        if (componentType) {
                            // Use direct DOM attribute instead of event listener
                            button.onclick = () => {
                                console.log("Button clicked: " + componentType);
                                this.addComponent(componentType);
                            };
                        }
                    });
                    
                    // Debug button uses direct DOM attribute
                    const debugToggle = document.getElementById('toggle-debug');
                    if (debugToggle) {
                        debugToggle.onclick = () => {
                            console.log("Debug toggle clicked");
                            const debugPanel = document.querySelector('.debug-panel');
                            if (debugPanel.classList.contains('visible')) {
                                debugPanel.classList.remove('visible');
                                debugToggle.textContent = 'Show Debug Info';
                            } else {
                                debugPanel.classList.add('visible');
                                debugToggle.textContent = 'Hide Debug Info';
                                
                                // Force an immediate update when showing
                                this.updateDebugInfo();
                                if (typeof this.logCameraEvent === 'function') {
                                    this.logCameraEvent('Debug panel shown', true);
                                }
                            }
                        };
                        
                        // Set the correct initial text
                        const debugPanel = document.querySelector('.debug-panel');
                        if (debugPanel && debugPanel.classList.contains('visible')) {
                            debugToggle.textContent = 'Hide Debug Info';
                        } else {
                            debugToggle.textContent = 'Show Debug Info';
                        }
                    }
                    
                    // Reset camera button
                    const resetCamera = document.getElementById('reset-camera');
                    if (resetCamera) {
                        resetCamera.onclick = () => {
                            console.log("Reset camera clicked");
                            this.resetCameraPosition();
                            const lastAction = document.getElementById('last-action');
                            if (lastAction) lastAction.textContent = 'Reset camera';
                            if (typeof this.logCameraEvent === 'function') {
                                this.logCameraEvent('Camera reset to default position', true);
                            }
                        };
                    }
                    
                    // Sky color button
                    const changeSkyColor = document.getElementById('change-sky-color');
                    if (changeSkyColor) {
                        changeSkyColor.onclick = () => {
                            console.log("Change sky color clicked");
                            this.changeSkyColor();
                            const lastAction = document.getElementById('last-action');
                            if (lastAction) lastAction.textContent = 'Changed sky color';
                            if (typeof this.logCameraEvent === 'function') {
                                this.logCameraEvent('Sky color changed', true);
                            }
                        };
                    }
                },
                
                // Initialize view switcher
                initViewSwitcher: function() {
                    console.log("Setting up view switcher");
                    
                    const viewButtons = document.querySelectorAll('.view-button');
                    
                    viewButtons.forEach(button => {
                        const viewName = button.getAttribute('data-view');
                        
                        // Use direct onclick handler
                        button.onclick = () => {
                            console.log("View switched to: " + viewName);
                            
                            // Update active button
                            viewButtons.forEach(btn => btn.classList.remove('active'));
                            button.classList.add('active');
                            
                            // Update active view
                            document.querySelectorAll('.view').forEach(view => {
                                view.classList.remove('active');
                            });
                            document.getElementById(viewName + '-view').classList.add('active');
                            
                            // Special handling for inspector view
                            if (viewName === 'inspector') {
                                this.openInspector();
                            } else if (this.inspectorOpened) {
                                // Close inspector when switching to other views
                                this.closeInspector();
                            }
                            
                            // Ensure Monaco editor is properly sized when switched to
                            if (viewName === 'code' && this.editor) {
                                this.editor.layout();
                            }
                            
                            this.currentView = viewName;
                        };
                    });
                },
                
                // Toggle A-Frame Inspector
                toggleInspector: function() {
                    if (this.inspectorOpened) {
                        this.closeInspector();
                    } else {
                        this.openInspector();
                    }
                },
                
                // Open A-Frame Inspector safely
                openInspector: function() {
                    // Make sure we're in preview mode first
                    document.querySelectorAll('.view').forEach(view => {
                        view.classList.remove('active');
                    });
                    document.getElementById('preview-view').classList.add('active');
                    
                    const previewScene = document.getElementById('preview-scene');
                    
                    // Store current scene state before opening inspector
                    const sceneHTML = previewScene.innerHTML;
                    
                    // Try the AFRAME.INSPECTOR method first
                    if (AFRAME && AFRAME.INSPECTOR) {
                        try {
                            AFRAME.INSPECTOR.open();
                            this.inspectorOpened = true;
                            
                            // Set up watcher for inspector changes
                            this.setupInspectorWatcher();
                        return;
                        } catch (e) {
                            console.warn('AFRAME.INSPECTOR.open failed:', e);
                        }
                    }
                    
                    // Attempt to open with keyboard shortcut
                    try {
                        // Use keyboard shortcut approach
                    document.dispatchEvent(new KeyboardEvent('keydown', {
                        key: 'i',
                        code: 'KeyI',
                        keyCode: 73,
                        which: 73,
                        ctrlKey: true,
                        altKey: true,
                        bubbles: true
                    }));
                    
                        this.inspectorOpened = true;
                        
                        // Set up watcher for inspector changes
                        this.setupInspectorWatcher();
                        return;
                } catch (e) {
                        console.warn('Inspector keyboard shortcut failed:', e);
                    }
                    
                    console.error('Failed to open inspector');
                },
                
                // Setup watcher for inspector changes
                setupInspectorWatcher: function() {
                    // Stop existing watcher if any
                    if (this.inspectorWatcherInterval) {
                        clearInterval(this.inspectorWatcherInterval);
                    }
                    
                    console.log("Setting up inspector watcher");
                    
                    // If AFRAME.INSPECTOR is available, use its API
                    if (AFRAME && AFRAME.INSPECTOR) {
                        console.log("Using AFRAME.INSPECTOR API");
                        
                        // Set up listener for entity selection changes
                        if (AFRAME.INSPECTOR.on) {
                            AFRAME.INSPECTOR.on('entityselect', entity => {
                                console.log(`Inspector selected entity: ${entity.tagName} ${entity.id || 'no-id'}`);
                            });
                            
                            // Listen for component changes via inspector
                            AFRAME.INSPECTOR.on('componentchange', (entity, component, value) => {
                                console.log(`Inspector changed component ${component} on ${entity.tagName} ${entity.id || 'no-id'}`);
                                this.handleInspectorChange();
                            });
                            
                            // Listen for entity changes via inspector
                            AFRAME.INSPECTOR.on('entityupdate', entity => {
                                console.log(`Inspector updated entity: ${entity.tagName} ${entity.id || 'no-id'}`);
                                this.handleInspectorChange();
                            });
                        }
                    } else {
                        // Fallback to using DOM events if AFRAME.INSPECTOR API not available
                        console.log("Falling back to DOM events for inspector");
                        
                        // Wait for inspector to be fully initialized
                        setTimeout(() => {
                            // Find all inspector panels and controls
                            const inspectorPanels = document.querySelectorAll('.inspector, .components, .property-row, .vector, .color');
                            
                            if (inspectorPanels.length > 0) {
                                const boundHandler = this.handleInspectorChange.bind(this);
                                
                                // Add event listeners to all inspector controls
                                inspectorPanels.forEach(control => {
                                    // Remove existing listeners to avoid duplicates
                                    control.removeEventListener('change', boundHandler);
                                    control.removeEventListener('input', boundHandler);
                                    control.removeEventListener('click', boundHandler);
                                    control.removeEventListener('mouseup', boundHandler);
                                    
                                    // Add new listeners
                                    control.addEventListener('change', boundHandler);
                                    control.addEventListener('input', boundHandler);
                                    control.addEventListener('mouseup', boundHandler);
                                });
                                
                                // Setup mutation observer for inspector components panel
                                const componentsPanel = document.querySelector('.components');
                                if (componentsPanel) {
                                    if (this.inspectorObserver) {
                                        this.inspectorObserver.disconnect();
                                    }
                                    
                                    this.inspectorObserver = new MutationObserver(mutations => {
                                        // Delay to make sure A-Frame has processed all changes
                                        setTimeout(() => {
                                            if (this.inspectorOpened) {
                                                this.handleInspectorChange();
                                            }
                                        }, 200);
                                    });
                                    
                                    this.inspectorObserver.observe(componentsPanel, {
                                        attributes: true,
                                        childList: true,
                                        subtree: true
                                    });
                                }
                            } else {
                                // If we couldn't find the panels, try again later
                                setTimeout(() => this.setupInspectorWatcher(), 1000);
                            }
                        }, 1000);
                    }
                    
                    // Set up a backup interval watcher (least preferred method, but a good safety net)
                    this.inspectorWatcherInterval = setInterval(() => {
                        if (this.inspectorOpened) {
                            // Check for dirty state in the inspector and update if needed
                            if (AFRAME && AFRAME.INSPECTOR && AFRAME.INSPECTOR.history && 
                                AFRAME.INSPECTOR.history.count > 0) {
                                this.handleInspectorChange();
                            }
                        } else {
                            // If inspector is closed, stop the interval
                            clearInterval(this.inspectorWatcherInterval);
                        }
                    }, 2000);
                },
                
                // Handle inspector change events
                handleInspectorChange: function() {
                    // Skip if we're already updating from state
                    if (this.isUpdatingFromState) return;
                    
                    // First, ensure all inspector changes are flushed to the DOM
                    this.flushAllEntitiesToDOM();
                    
                    // Then update our model from the DOM
                    this.parseSceneFromDOM();
                    
                    // Finally, update UI representations based on the model
                    this.updateEditor();
                },
                
                // Close A-Frame Inspector
                closeInspector: function() {
                    try {
                        // Stop inspector watchers
                        if (this.inspectorWatcherInterval) {
                            clearInterval(this.inspectorWatcherInterval);
                            this.inspectorWatcherInterval = null;
                        }
                        
                        if (this.inspectorObserver) {
                            this.inspectorObserver.disconnect();
                            this.inspectorObserver = null;
                        }
                        
                        // Try different methods to close inspector
                        if (AFRAME && AFRAME.INSPECTOR) {
                            AFRAME.INSPECTOR.close();
                        }
                        
                        // Set flag to prevent circular updates
                        this.isUpdatingFromState = true;
                        
                        // Read the scene back if inspector made changes
                        this.parseSceneFromDOM();
                        this.updateEditor();
                        
                        // Reset flag after a delay
                        setTimeout(() => {
                            this.isUpdatingFromState = false;
                        }, 300);
                    } catch (e) {
                        console.error('Error closing inspector:', e);
                        this.isUpdatingFromState = false;
                    }
                    
                    this.inspectorOpened = false;
                },
                
                // Add a new component to the scene
                addComponent: function(componentType) {
                    console.log(`Adding component: ${componentType}`);
                    if (!this.components[componentType]) return;
                    
                    // Show saving indicator
                    this.showSaveIndicator('saving');
                    
                    // Log to debug panel
                    if (typeof this.logCameraEvent === 'function') {
                        this.logCameraEvent(`Adding ${componentType} component`, true);
                    }
                    
                    // Set flag to prevent circular updates
                    this.isUpdatingFromState = true;
                    
                    try {
                        // Parse the component HTML
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(this.components[componentType], 'text/html');
                        const componentEl = doc.body.firstChild;
                        
                        if (componentEl) {
                            // Add to DOM
                            const previewScene = document.getElementById('preview-scene');
                            if (previewScene) {
                                // Generate a unique ID with timestamp and random suffix
                                const id = `${componentType}-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
                                componentEl.setAttribute('id', id);
                                
                                // Save camera position before adding
                                this.saveCameraState('Before adding component');
                                
                                // Ask for permission if needed (for future extension)
                                if (this.requirePermissionForEntityCreation && typeof this.requestPermission === 'function') {
                                    if (!this.requestPermission(`Add ${componentType} to scene`)) {
                                        this.isUpdatingFromState = false;
                                        this.showSaveIndicator('saved');
                                        return;
                                    }
                                }
                                
                                // Add to scene
                                previewScene.appendChild(componentEl);
                                
                                // Add networking component if NAF is available
                                if (this.nafEnabled && window.NAF) {
                                    this.addNetworkedComponent(componentEl);
                                    this.logCameraEvent(`Added networked component to ${componentType} with ID ${id}`, false);
                                }
                                
                                // Force A-Frame to process the new entity
                                if (AFRAME && AFRAME.scenes && AFRAME.scenes.length > 0) {
                                    // Force a tick to process changes
                                    AFRAME.scenes[0].tick();
                                    
                                    // Flush entity to DOM to ensure all component data is written to attributes
                                    this.flushAllEntitiesToDOM();
                                }
                                
                                // Update the model
                                this.parseSceneFromDOM();
                                
                                // Update the editor
                                this.updateEditor();
                                
                                // Update debug info
                                this.updateDebugInfo();
                                
                                // Log component added
                                if (typeof this.logCameraEvent === 'function') {
                                    this.logCameraEvent(`${componentType} component added with id ${id}`, true);
                                }
                                
                                // Show saved indicator
                                this.showSaveIndicator('saved');
                            }
                        }
                    } catch (error) {
                        console.error('Error adding component:', error);
                        if (typeof this.logCameraEvent === 'function') {
                            this.logCameraEvent(`Error adding component: ${error.message}`, true);
                        }
                        this.showSaveIndicator('error');
                    } finally {
                        // Reset flag to allow event-based updates again
                        setTimeout(() => {
                            this.isUpdatingFromState = false;
                        }, 100);
                    }
                },
                
                // Get HTML representation of the scene
                getSceneHTML: function() {
                    // Start with camera entity to ensure it's preserved
                    let html = '<a-entity id="user-camera" position="0 1.6 0" camera look-controls wasd-controls></a-entity>\n';
                    
                    // Add all other entities
                    this.scene.entities.forEach(entity => {
                        if (entity.type) {
                            html += `<a-${entity.type} `;
                            // Add all attributes
                            for (const key in entity) {
                                if (key !== 'type') {
                                    html += `${key}="${entity[key]}" `;
                                }
                            }
                            html += '></a-' + entity.type + '>\n';
                        }
                    });
                    
                    // Return the complete HTML
                    return html;
                },
                
                // Get clean scene HTML that excludes A-Frame internal elements
                getCleanSceneHTML: function(previewScene) {
                    let html = '';
                    
                    // Filter out all internal A-Frame elements and only keep real entity elements
                    const childElements = Array.from(previewScene.children).filter(el => {
                        // Skip any element with these attributes
                        if (el.hasAttribute('aframe-injected') ||
                            el.hasAttribute('data-aframe-inspector') ||
                            el.hasAttribute('data-aframe-default-light') ||
                            el.getAttribute('id') === 'aframeInspectorMouseCursor') {
                            return false;
                        }
                        
                        // Skip specific element types that are A-Frame internals
                        const tagName = el.tagName.toLowerCase();
                        if (tagName === 'canvas' || 
                            tagName === 'div' || 
                            el.classList.contains('a-canvas') ||
                            el.classList.contains('a-enter-vr') ||
                            el.classList.contains('a-orientation-modal') ||
                            el.classList.contains('a-loader-title')) {
                            return false;
                        }
                        
                        // Include only A-Frame entity elements
                        return tagName.startsWith('a-');
                    });
                    
                    // Create a temporary container to get innerHTML of filtered elements
                    childElements.forEach(child => {
                        // Get the outer HTML of each element (with its children)
                        html += child.outerHTML + '\n';
                    });
                    
                    return html;
                },
                
                // Save the current camera state
                saveCameraState: function(reason) {
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;
                    
                    const cameraEl = document.getElementById('user-camera');
                    if (cameraEl) {
                        const position = cameraEl.getAttribute('position');
                        const rotation = cameraEl.getAttribute('rotation');
                        
                        if (position && rotation) {
                            // Store in our primary camera reference
                            this.camera = {
                                position: { x: position.x, y: position.y, z: position.z },
                                rotation: { x: rotation.x, y: rotation.y, z: rotation.z }
                            };
                            
                            // Also update scene camera for compatibility
                            if (this.scene && this.scene.camera) {
                                this.scene.camera.position.x = position.x;
                                this.scene.camera.position.y = position.y;
                                this.scene.camera.position.z = position.z;
                                this.scene.camera.rotation.x = rotation.x;
                                this.scene.camera.rotation.y = rotation.y;
                                this.scene.camera.rotation.z = rotation.z;
                            }
                            
                            console.log(`[Camera State Saved] ${reason || ''}: Position (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}), Rotation (${rotation.x.toFixed(2)}, ${rotation.y.toFixed(2)}, ${rotation.z.toFixed(2)})`);
                            
                            // Log to camera history
                            if (reason) {
                                this.logCameraEvent(`State saved: ${reason} - Pos: ${position.x.toFixed(1)},${position.y.toFixed(1)},${position.z.toFixed(1)}`, true);
                            }
                        } else {
                            console.warn('Could not save camera state: position or rotation is null');
                            this.logCameraEvent(`Warning: Could not save camera state (${reason || 'unspecified reason'})`, true);
                        }
                    } else {
                        console.warn('Could not save camera state: camera entity not found');
                        this.logCameraEvent(`Warning: No camera entity found when saving state (${reason || ''})`, true);
                    }
                },
                
                // Restore the saved camera state
                restoreCameraState: function(reason) {
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;
                    
                    const cameraEl = document.getElementById('user-camera');
                    if (!cameraEl) {
                        console.warn('Could not restore camera: camera entity not found');
                        this.logCameraEvent(`Warning: No camera entity found when restoring state (${reason || ''})`, true);
                        return;
                    }
                    
                    if (!this.camera || !this.camera.position || !this.camera.rotation) {
                        console.warn('Could not restore camera: no saved camera state');
                        this.logCameraEvent(`Warning: No saved camera state to restore (${reason || ''})`, true);
                        return;
                    }
                    
                    // Safety check - make sure the camera has been initialized
                    if (!cameraEl.hasLoaded) {
                        console.warn('Camera entity not loaded yet, cannot restore state');
                        this.logCameraEvent(`Warning: Camera not loaded, cannot restore state (${reason || ''})`, true);
                        return;
                    }
                    
                    try {
                        const position = `${this.camera.position.x} ${this.camera.position.y} ${this.camera.position.z}`;
                        const rotation = `${this.camera.rotation.x} ${this.camera.rotation.y} ${this.camera.rotation.z}`;
                        
                        // Set position and rotation on the entity
                        cameraEl.setAttribute('position', position);
                        cameraEl.setAttribute('rotation', rotation);
                        
                        // Update Three.js camera too if it exists
                        if (previewScene.camera) {
                            previewScene.camera.position.set(
                                this.camera.position.x, 
                                this.camera.position.y, 
                                this.camera.position.z
                            );
                            
                            previewScene.camera.rotation.set(
                                this.camera.rotation.x,
                                this.camera.rotation.y,
                                this.camera.rotation.z
                            );
                            
                            previewScene.camera.updateMatrix();
                            previewScene.camera.updateMatrixWorld(true);
                        }
                        
                        // Update look-controls if they exist
                        if (cameraEl.components && cameraEl.components['look-controls']) {
                            const lookControls = cameraEl.components['look-controls'];
                            if (lookControls.pitchObject) {
                                lookControls.pitchObject.rotation.x = this.camera.rotation.x;
                            }
                            if (lookControls.yawObject) {
                                lookControls.yawObject.rotation.y = this.camera.rotation.y;
                            }

                        }
                        
                        console.log(`[Camera State Restored] ${reason || ''}: Position (${this.camera.position.x.toFixed(2)}, ${this.camera.position.y.toFixed(2)}, ${this.camera.position.z.toFixed(2)}), Rotation (${this.camera.rotation.x.toFixed(2)}, ${this.camera.rotation.y.toFixed(2)}, ${this.camera.rotation.z.toFixed(2)})`);
                        
                        // Log to camera history
                        if (reason) {
                            this.logCameraEvent(`State restored: ${reason}`, true);
                        }
                    } catch (error) {
                        console.error('Error restoring camera state:', error);
                        this.logCameraEvent(`Error restoring camera: ${error.message}`, true);
                    }
                },
                
                // Parse the scene directly from the DOM
                parseSceneFromDOM: function() {
                    console.log("Parsing scene from DOM");
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;
                    
                    // Reset scene data
                    this.scene.entities = [];
                    this.scene.assets = [];
                    
                    // Parse assets if they exist
                    const assetsEl = previewScene.querySelector('a-assets');
                    if (assetsEl) {
                        Array.from(assetsEl.children).forEach(asset => {
                            this.scene.assets.push({
                                tag: asset.tagName.toLowerCase(),
                                attributes: this.extractAttributes(asset)
                            });
                        });
                    }
                    
                    // Parse all top-level A-Frame entities, including their children
                    Array.from(previewScene.children).forEach(child => {
                        if (child.tagName && 
                            child.tagName.toLowerCase().startsWith('a-') && 
                            !child.hasAttribute('aframe-injected') &&
                            child.tagName.toLowerCase() !== 'a-assets') {
                            // Process the entity and its children recursively
                            const entityData = this.serializeEntityRecursive(child);
                            this.scene.entities.push(entityData);
                        }
                    });
                    
                    console.log(`Parsed ${this.scene.entities.length} entities from DOM`);
                },
                
                // Recursively serialize an entity and its children
                serializeEntityRecursive: function(element) {
                    // Build entity data
                    const entityData = {
                        id: element.id || `entity-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
                        tag: element.tagName.toLowerCase(),
                        attributes: this.extractAttributes(element),
                        children: []
                    };
                    
                    // Process children recursively
                    Array.from(element.children).forEach(child => {
                        if (child.tagName && 
                            child.tagName.toLowerCase().startsWith('a-') && 
                            !child.hasAttribute('aframe-injected')) {
                            entityData.children.push(this.serializeEntityRecursive(child));
                        }
                    });
                    
                    return entityData;
                },
                
                // Show save indicator status
                showSaveIndicator: function(status) {
                    const saveIndicator = document.querySelector('.save-indicator');
                    const saveIndicatorDot = document.querySelector('.save-indicator-dot');
                    const saveIndicatorText = document.querySelector('.save-indicator-text');
                    
                    if (!saveIndicator) return;
                    
                    // Remove all status classes
                    saveIndicatorDot.classList.remove('saving', 'saved', 'error');
                    
                    // Set new status
                    if (status === 'saving') {
                        saveIndicatorDot.classList.add('saving');
                        saveIndicatorText.textContent = 'Saving changes...';
                    } else if (status === 'saved') {
                        saveIndicatorDot.classList.add('saved');
                        saveIndicatorText.textContent = 'Changes saved';
                    } else if (status === 'error') {
                        saveIndicatorDot.classList.add('error');
                        saveIndicatorText.textContent = 'Error saving changes';
                    }
                    
                    // Show indicator
                    saveIndicator.classList.remove('hidden');
                    saveIndicator.classList.add('visible');
                    
                    // Hide after a delay if saved successfully
                    if (status === 'saved') {
                        setTimeout(() => {
                            saveIndicator.classList.remove('visible');
                            saveIndicator.classList.add('hidden');
                        }, 3000);
                    }
                },
                
                // Initialize debug tools
                initDebugTools: function() {
                    console.log("Setting up debug tools");
                    
                    const debugPanel = document.querySelector('.debug-panel');
                    const teleportButton = document.getElementById('teleport-camera');
                    const logButton = document.getElementById('log-entities');
                    
                    // Initialize camera history tracking
                    this.cameraHistory = [];
                    this.entityHistory = [];
                    this.lastCameraPosition = null;
                    this.lastCameraRotation = null;
                    this.historyMode = 'all'; // 'all', 'camera', or 'entity'
                    
                    // Add camera history section with tabs if needed
                    if (debugPanel && !debugPanel.querySelector('.camera-history')) {
                        const historySection = document.createElement('div');
                        historySection.className = 'camera-history';
                        
                        // Add tabs for filtering history
                        const tabsDiv = document.createElement('div');
                        tabsDiv.className = 'camera-history-tabs';
                        
                        const createTab = (name, mode, isActive) => {
                            const tab = document.createElement('div');
                            tab.className = 'history-tab' + (isActive ? ' active' : '');
                            tab.textContent = name;
                            tab.setAttribute('data-mode', mode);
                            tab.onclick = () => {
                                // Update active tab
                                tabsDiv.querySelectorAll('.history-tab').forEach(t => t.classList.remove('active'));
                                tab.classList.add('active');
                                
                                // Set history mode
                                this.historyMode = mode;
                                
                                // Update displayed history
                                this.updateHistoryDisplay();
                            };
                            return tab;
                        };
                        
                        tabsDiv.appendChild(createTab('All', 'all', true));
                        tabsDiv.appendChild(createTab('Camera', 'camera', false));
                        tabsDiv.appendChild(createTab('Entity', 'entity', false));
                        
                        historySection.appendChild(tabsDiv);
                        
                        // Add log container
                        const logContainer = document.createElement('div');
                        logContainer.id = 'camera-history-log';
                        historySection.appendChild(logContainer);
                        
                        debugPanel.appendChild(historySection);
                    } else if (debugPanel) {
                        // Make sure existing tabs have correct click handlers
                        const existingTabs = debugPanel.querySelectorAll('.history-tab');
                        existingTabs.forEach(tab => {
                            const mode = tab.getAttribute('data-mode') || tab.textContent.toLowerCase();
                            tab.setAttribute('data-mode', mode);
                            tab.onclick = () => {
                                // Update active tab
                                debugPanel.querySelectorAll('.history-tab').forEach(t => t.classList.remove('active'));
                                tab.classList.add('active');
                                
                                // Set history mode
                                this.historyMode = mode;
                                
                                // Update displayed history
                                this.updateHistoryDisplay();
                            };
                        });
                    }
                    
                    // Set direct onclick handlers
                    if (teleportButton) {
                        // Update button text to reflect the new position
                        teleportButton.textContent = 'Teleport to 0,1.6,5';
                        
                        teleportButton.onclick = () => {
                            console.log("Teleport button clicked");
                            // Update to teleport to positive Z-axis for better overview
                            this.teleportCamera(0, 1.6, 5);
                            const lastAction = document.getElementById('last-action');
                            if (lastAction) lastAction.textContent = 'Teleported camera';
                        };
                    }
                    
                    if (logButton) {
                        logButton.onclick = () => {
                            console.log("Log entities button clicked");
                            this.logSceneEntities();
                            const lastAction = document.getElementById('last-action');
                            if (lastAction) lastAction.textContent = 'Logged entities to console and history';
                        };
                    }
                    
                    // NAF check button
                    const checkNafButton = document.getElementById('check-naf');
                    if (checkNafButton) {
                        checkNafButton.onclick = () => {
                            console.log("Check NAF button clicked");
                            this.checkNafStatus();
                            const lastAction = document.getElementById('last-action');
                            if (lastAction) lastAction.textContent = 'NAF status checked';
                        };
                    }
                    
                    // NAF connect button
                    const connectNafButton = document.getElementById('connect-naf');
                    if (connectNafButton) {
                        connectNafButton.onclick = () => {
                            console.log("Connect NAF button clicked");
                            this.connectNaf();
                            const lastAction = document.getElementById('last-action');
                            if (lastAction) lastAction.textContent = 'NAF connection initiated';
                        };
                    }
                    
                    // Add clear history button
                    const clearHistoryButton = document.createElement('button');
                    clearHistoryButton.className = 'debug-button';
                    clearHistoryButton.id = 'clear-history';
                    clearHistoryButton.textContent = 'Clear History';
                    clearHistoryButton.onclick = () => {
                        console.log("Clear history button clicked");
                        this.cameraHistory = [];
                        this.entityHistory = [];
                        const historyLog = document.getElementById('camera-history-log');
                        if (historyLog) historyLog.innerHTML = '';
                    };
                    
                    const debugControls = document.querySelector('.debug-controls');
                    if (debugControls) {
                        debugControls.appendChild(clearHistoryButton);
                    }
                    
                    // Setup continuous updating for debug panel when visible
                    const startDebugUpdates = () => {
                        // Initial update
                        this.updateDebugInfo();
                        
                        // Set up continuous updates using requestAnimationFrame for smooth updating
                        let lastUpdate = 0;
                        const updateInterval = 100; // Update every 100ms
                        
                        const checkAndUpdate = (timestamp) => {
                            if (debugPanel.classList.contains('visible')) {
                                // Only update at the specified interval
                                if (timestamp - lastUpdate > updateInterval) {
                                    this.updateDebugInfo();
                                    lastUpdate = timestamp;
                                }
                                requestAnimationFrame(checkAndUpdate);
                            }
                        };
                        
                        requestAnimationFrame(checkAndUpdate);
                    };
                    
                    // Start debug updates if panel is already visible, or when it becomes visible
                    if (debugPanel.classList.contains('visible')) {
                        startDebugUpdates();
                    }
                    
                    // Add visibility change detection (this works with the toggle button)
                    const observer = new MutationObserver((mutations) => {
                        mutations.forEach((mutation) => {
                            if (mutation.attributeName === 'class' && 
                                debugPanel.classList.contains('visible')) {
                                startDebugUpdates();
                            }
                        });
                    });
                    
                    observer.observe(debugPanel, { attributes: true });
                },
                
                // Update the history display based on the current mode
                updateHistoryDisplay: function() {
                    console.log("Updating history display, mode:", this.historyMode);
                    const historyLog = document.getElementById('camera-history-log');
                    if (!historyLog) return;
                    
                    // Make sure the correct tab is active
                    const debugPanel = document.querySelector('.debug-panel');
                    if (debugPanel) {
                        const tabs = debugPanel.querySelectorAll('.history-tab');
                        tabs.forEach(tab => {
                            const tabMode = tab.getAttribute('data-mode');
                            if (tabMode === this.historyMode) {
                                tab.classList.add('active');
                            } else {
                                tab.classList.remove('active');
                            }
                        });
                    }
                    
                    let entries = [];
                    
                    if (this.historyMode === 'all') {
                        // Combine and sort all history entries by timestamp
                        entries = [...this.cameraHistory, ...this.entityHistory]
                            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                            .reverse(); // Show oldest first
                    } else if (this.historyMode === 'camera') {
                        entries = [...this.cameraHistory]; // Use a copy to avoid modifying the original
                    } else if (this.historyMode === 'entity') {
                        entries = [...this.entityHistory]; // Use a copy to avoid modifying the original
                    }
                    
                    historyLog.innerHTML = entries.map(entry => 
                        `<div class="camera-history-entry">${entry.timestamp}: ${entry.event}</div>`
                    ).join('');
                    
                    // Auto-scroll to bottom
                    historyLog.scrollTop = historyLog.scrollHeight;
                },
                
                // Track significant camera changes
                trackCameraChanges: function() {
                    const cameraEl = document.getElementById('user-camera');
                    if (!cameraEl) return;
                    
                    const pos = cameraEl.getAttribute('position');
                    const rot = cameraEl.getAttribute('rotation');
                    
                    if (!pos || !rot) return;
                    
                    // Check if position or rotation has changed significantly
                    const positionChanged = !this.lastCameraPosition || 
                        Math.abs(pos.x - this.lastCameraPosition.x) > 0.1 ||
                        Math.abs(pos.y - this.lastCameraPosition.y) > 0.1 ||
                        Math.abs(pos.z - this.lastCameraPosition.z) > 0.1;
                        
                    const rotationChanged = !this.lastCameraRotation || 
                        Math.abs(rot.x - this.lastCameraRotation.x) > 2 ||
                        Math.abs(rot.y - this.lastCameraRotation.y) > 2 ||
                        Math.abs(rot.z - this.lastCameraRotation.z) > 2;
                    
                    // If there's a significant change, log it
                    if (positionChanged || rotationChanged) {
                        const posStr = `${pos.x.toFixed(1)},${pos.y.toFixed(1)},${pos.z.toFixed(1)}`;
                        const rotStr = `${rot.x.toFixed(1)},${rot.y.toFixed(1)},${rot.z.toFixed(1)}`;
                        
                        this.lastCameraPosition = { x: pos.x, y: pos.y, z: pos.z };
                        this.lastCameraRotation = { x: rot.x, y: rot.y, z: rot.z };
                        
                        // Only log if there's a significant change to avoid spamming
                        if (Math.abs(positionChanged) > 0.2 || Math.abs(rotationChanged) > 5) {
                            this.logCameraEvent(`Camera moved to pos:${posStr} rot:${rotStr}`, true);
                        }
                    }
                },
                
                // Log camera event with timestamp
                logCameraEvent: function(event, includeEntityCount = false) {
                    if (!this.cameraHistory) {
                        this.cameraHistory = [];
                    }
                    
                    if (!this.entityHistory) {
                        this.entityHistory = [];
                    }
                    
                    const timestamp = new Date().toLocaleTimeString();
                    
                    // Determine if this is an entity-related event or camera-related event
                    const isEntityEvent = event.toLowerCase().includes('entity') || 
                                          event.toLowerCase().includes('component') ||
                                          event.toLowerCase().includes('scene') ||
                                          event.toLowerCase().includes('sky');
                    
                    // Add entity count if requested
                    if (includeEntityCount) {
                        const previewScene = document.getElementById('preview-scene');
                        if (previewScene) {
                            const entities = Array.from(previewScene.children).filter(el => 
                                el.tagName && 
                                el.tagName.toLowerCase().startsWith('a-') && 
                                !el.hasAttribute('aframe-injected')
                            );
                            
                            const count = entities.length;
                            const types = {};
                            
                            // Count by entity type
                            entities.forEach(entity => {
                                const type = entity.tagName.toLowerCase();
                                types[type] = (types[type] || 0) + 1;
                            });
                            
                            // Format entity counts
                            const typeStr = Object.entries(types)
                                .map(([type, count]) => `${type}:${count}`)
                                .join(', ');
                            
                            event += ` | Entities: ${count} (${typeStr})`;
                        }
                    }
                    
                    // Add to the appropriate history array
                    const historyEntry = { timestamp, event };
                    
                    if (isEntityEvent) {
                        // Keep max 20 entity history entries
                        if (this.entityHistory.length >= 20) {
                            this.entityHistory.shift();
                        }
                        this.entityHistory.push(historyEntry);
                    } else {
                        // Keep max 20 camera history entries
                        if (this.cameraHistory.length >= 20) {
                            this.cameraHistory.shift();
                        }
                        this.cameraHistory.push(historyEntry);
                    }
                    
                    // Update the UI based on current mode
                    this.updateHistoryDisplay();
                    
                    // Also log to console for debugging
                    console.log(`[${isEntityEvent ? 'Entity' : 'Camera'} Event] ${timestamp}: ${event}`);
                },
                
                // Update debug information
                updateDebugInfo: function() {
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;
                    
                    // Get camera entity and scene camera
                    const cameraEl = document.getElementById('user-camera');
                    
                    // Update camera position display
                    if (cameraEl) {
                        const pos = cameraEl.getAttribute('position');
                        const rot = cameraEl.getAttribute('rotation');
                        
                        // Update position display
                        const posDisplay = document.getElementById('camera-position');
                        if (posDisplay && pos) {
                            posDisplay.textContent = `${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}`;
                        }
                        
                        // Update rotation display
                        const rotDisplay = document.getElementById('camera-rotation');
                        if (rotDisplay && rot) {
                            rotDisplay.textContent = `${rot.x.toFixed(1)}°, ${rot.y.toFixed(1)}°, ${rot.z.toFixed(1)}°`;
                        }
                        
                        // Update entity camera info with all details
                        const cameraInfo = document.getElementById('entity-camera-info');
                        if (cameraInfo) {
                            let info = '';
                            if (pos) {
                                info += `Pos: ${pos.x.toFixed(1)},${pos.y.toFixed(1)},${pos.z.toFixed(1)} `;
                            } else {
                                info += 'No position ';
                            }
                            
                            if (rot) {
                                info += `Rot: ${rot.x.toFixed(1)}°,${rot.y.toFixed(1)}°,${rot.z.toFixed(1)}° `;
                            } else {
                                info += 'No rotation ';
                            }
                            
                            // Check which components are attached to the camera entity
                            const components = [];
                            if (cameraEl.components) {
                                for (const name in cameraEl.components) {
                                    components.push(name);
                                }
                            }
                            
                            if (components.length > 0) {
                                info += `(${components.join(', ')})`;
                            } else {
                                info += '(No components)';
                            }
                            
                            cameraInfo.textContent = info;
                        }
                    } else {
                        // No camera entity found, display default values
                        const posDisplay = document.getElementById('camera-position');
                        if (posDisplay) posDisplay.textContent = '0, 0, 0';
                        
                        const rotDisplay = document.getElementById('camera-rotation');
                        if (rotDisplay) rotDisplay.textContent = '0°, 0°, 0°';
                        
                        const cameraInfo = document.getElementById('entity-camera-info');
                        if (cameraInfo) cameraInfo.textContent = 'No camera entity found';
                    }
                    
                    // Update NAF status if changed
                    const nafStatus = document.getElementById('naf-status');
                    if (nafStatus) {
                        if (window.NAF && this.nafEnabled) {
                            // Check if NAF is connected
                            if (window.NAF.connection && window.NAF.connection.isConnected()) {
                                nafStatus.textContent = 'Connected';
                                nafStatus.className = 'text-success';
                            } else if (window.NAF.connection) {
                                nafStatus.textContent = 'Initialized (Not Connected)';
                                nafStatus.className = 'text-warning';
                            } else {
                                nafStatus.textContent = 'Available (Not Connected)';
                                nafStatus.className = 'text-warning';
                            }
                        } else if (window.NAF) {
                            nafStatus.textContent = 'Available (Not Initialized)';
                            nafStatus.className = 'text-warning';
                        } else {
                            nafStatus.textContent = 'Not Available';
                            nafStatus.className = 'text-danger';
                        }
                    }
                    
                    // Update entity count - count both total entities and by type
                    const entityCount = document.getElementById('entity-count');
                    if (entityCount) {
                        const entities = Array.from(previewScene.children).filter(el => 
                            el.tagName && 
                            el.tagName.toLowerCase().startsWith('a-') && 
                            !el.hasAttribute('aframe-injected')
                        );
                        
                        const count = entities.length;
                        const types = {};
                        
                        // Count by entity type
                        entities.forEach(entity => {
                            const type = entity.tagName.toLowerCase();
                            types[type] = (types[type] || 0) + 1;
                        });
                        
                        // Format type counts
                        const typeStr = Object.entries(types)
                            .map(([type, count]) => `${type}:${count}`)
                            .join(', ');
                        
                        entityCount.textContent = `${count} (${typeStr})`;
                    }
                    
                    // Update last action if not set
                    const lastAction = document.getElementById('last-action');
                    if (lastAction && !lastAction.textContent) {
                        lastAction.textContent = 'Debug info updated';
                    }
                },
                
                // Teleport the camera to a specific position
                teleportCamera: function(x, y, z) {
                    console.log(`Teleporting camera to (${x}, ${y}, ${z})`);
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;
                    
                    // We want to keep rotation at 0 0 0 regardless of the position
                    // This simulates stepping back without turning around
                    const rotation = '0 0 0';
                    
                    // Update camera entity
                    const cameraEl = document.getElementById('user-camera');
                    if (cameraEl) {
                        cameraEl.setAttribute('position', `${x} ${y} ${z}`);
                        cameraEl.setAttribute('rotation', rotation);
                        
                        // Update our stored camera state
                        this.scene.camera.position = { x, y, z };
                        
                        // Parse the rotation string to get the values
                        const rotValues = rotation.split(' ').map(parseFloat);
                        this.scene.camera.rotation = { 
                            x: rotValues[0], 
                            y: rotValues[1], 
                            z: rotValues[2] 
                        };
                        
                        // Force look-controls to update if it exists
                        if (cameraEl.components && cameraEl.components['look-controls']) {
                            const lookControls = cameraEl.components['look-controls'];
                            const yRot = rotValues[1] * Math.PI / 180; // Convert to radians
                            if (lookControls.pitchObject) lookControls.pitchObject.rotation.x = 0;
                            if (lookControls.yawObject) lookControls.yawObject.rotation.y = 0; // Keep at 0
                        }
                        
                        // Update debug UI
                        this.updateDebugInfo();
                        if (typeof this.logCameraEvent === 'function') {
                            this.logCameraEvent(`Camera teleported to (${x}, ${y}, ${z}) with default forward orientation`, true);
                        }
                    } else {
                        console.warn("Cannot find camera entity to teleport");
                    }
                },
                
                // Reset camera to default position
                resetCameraPosition: function() {
                    console.log("Resetting camera position");
                    const cameraEl = document.getElementById('user-camera');
                    if (cameraEl) {
                        // Set position and rotation attributes directly
                        cameraEl.setAttribute('position', '0 1.6 0');
                        cameraEl.setAttribute('rotation', '0 0 0');
                        
                        // Force look-controls to update if it exists
                        if (cameraEl.components && cameraEl.components['look-controls']) {
                            const lookControls = cameraEl.components['look-controls'];
                            if (lookControls.pitchObject) lookControls.pitchObject.rotation.x = 0;
                            if (lookControls.yawObject) lookControls.yawObject.rotation.y = 0;
                        }
                        
                        // Update camera state
                        this.camera = {
                            position: { x: 0, y: 1.6, z: 0 },
                            rotation: { x: 0, y: 0, z: 0 }
                        };
                        
                        // Also update scene camera for compatibility
                        if (this.scene && this.scene.camera) {
                            this.scene.camera.position = { x: 0, y: 1.6, z: 0 };
                            this.scene.camera.rotation = { x: 0, y: 0, z: 0 };
                        }
                        
                        console.log("Camera reset to default position");
                        
                        // Update debug info
                        this.updateDebugInfo();
                    } else {
                        console.warn("Cannot find camera entity to reset");
                    }
                },
                
                // Log all scene entities to console for debugging
                logSceneEntities: function() {
                    console.log("Logging scene entities");
                    console.log('Scene entities in model:', this.scene.entities);
                    
                    const previewScene = document.getElementById('preview-scene');
                    if (previewScene) {
                        const entities = Array.from(previewScene.children).filter(el => 
                            el.tagName && 
                            el.tagName.toLowerCase().startsWith('a-') && 
                            !el.hasAttribute('aframe-injected')
                        );
                        
                        // Log to console
                        console.log('Camera entity:', document.getElementById('user-camera'));
                        console.log('All entities in DOM:');
                        entities.forEach(el => {
                            console.log(`${el.id || 'unknown-id'}:`, el);
                        });
                        
                        // Log to history with detailed entity counts
                        this.logCameraEvent(`Entities logged: ${entities.length} total`, true);
                        
                        // Add log entries for each entity
                        const entityDetails = entities.map(entity => {
                            const type = entity.tagName.toLowerCase();
                            const id = entity.id || 'unknown-id';
                            const pos = entity.getAttribute('position');
                            const posStr = pos ? `(${pos.x.toFixed(1)},${pos.y.toFixed(1)},${pos.z.toFixed(1)})` : '';
                            return `${type} ${id} ${posStr}`;
                        });
                        
                        // Log up to 5 entities in detail to avoid overwhelming the history
                        entityDetails.slice(0, 5).forEach(detail => {
                            this.logCameraEvent(`Entity: ${detail}`);
                        });
                        
                        if (entityDetails.length > 5) {
                            this.logCameraEvent(`...and ${entityDetails.length - 5} more entities`);
                        }
                    }
                    
                    // Update last action display
                    const lastAction = document.getElementById('last-action');
                    if (lastAction) lastAction.textContent = 'Logged entities to console and history';
                },
                
                // Change the sky color randomly for visual testing
                changeSkyColor: function() {
                    const colors = ['#ECECEC', '#87CEEB', '#FFA07A', '#B0E0E6', '#FFD700', '#E6E6FA'];
                    const randomColor = colors[Math.floor(Math.random() * colors.length)];
                    
                    const sky = document.querySelector('a-sky');
                    if (sky) {
                        console.log(`Changing sky color to ${randomColor}`);
                        sky.setAttribute('color', randomColor);
                        
                        // Update our model
                        this.parseSceneFromDOM();
                        this.updateEditor();
                    } else {
                        console.warn('No sky entity found');
                    }
                },
                
                // Start application 
                init: function() {
                    console.log("Starting A-Frame Builder...");
                    
                    // Make sure A-Frame has loaded
                    const scene = document.getElementById('preview-scene');
                    if (scene.hasLoaded) {
                        console.log("Scene already loaded, initializing");
                        this.initialize();
                    } else {
                        console.log("Waiting for scene to load");
                        scene.addEventListener('loaded', () => {
                            console.log("Scene loaded, initializing");
                            this.initialize();
                        });
                    }
                },
                
                flushAllEntitiesToDOM: function() {
                    if (AFRAME && AFRAME.scenes && AFRAME.scenes.length > 0) {
                        const aframeScene = AFRAME.scenes[0];
                        // Flush entire scene
                        if (aframeScene.hasLoaded) {
                            aframeScene.flushToDOM(true);
                        }
                    }
                },
                
                // Request permission for an operation (can be overridden for different implementations)
                requestPermission: function(operation) {
                    // Default implementation - check if permission features are enabled
                    const permissionEnabled = 
                        this.requirePermissionForEntityCreation || 
                        this.requirePermissionForEntityAddition || 
                        this.requirePermissionForEntityRemoval || 
                        this.requirePermissionForComponentChange;
                        
                    if (!permissionEnabled) {
                        // If permissions are not enabled, always allow
                        return true;
                    }
                    
                    // Log permission request
                    console.log(`[Permission] Requesting permission for: ${operation}`);
                    
                    // In this default implementation, we'll just confirm with the user
                    const granted = confirm(`Allow operation: ${operation}?`);
                    
                    // Log result
                    console.log(`[Permission] ${granted ? 'Granted' : 'Denied'}: ${operation}`);
                    
                    // Log to history if available
                    if (typeof this.logCameraEvent === 'function') {
                        this.logCameraEvent(`Permission ${granted ? 'granted' : 'denied'}: ${operation}`, true);
                    }
                    
                    return granted;
                },
                
                // Add support for networked entities
                addNetworkedComponent: function(entityEl) {
                    // Only add if NAF is available
                    if (window.NAF && !entityEl.hasAttribute('networked')) {
                        entityEl.setAttribute('networked', {
                            template: '#entity-template',
                            networkId: `${entityEl.id}-${Date.now()}`,
                            owner: 'scene'
                        });
                    }
                },
                
                // Add to state object
                nafEnabled: false,
                nafTemplates: {
                    avatar: '#avatar-template',
                    entity: '#entity-template'
                },
                
                // Add NAF initialization method
                initNetworkedAframe: function() {
                    console.log("Checking for Networked-Aframe library");
                    
                    // Get the NAF status element
                    const nafStatus = document.getElementById('naf-status');
                    
                    try {
                        // Simple check for NAF existence
                        if (typeof window.NAF !== 'undefined') {
                            console.log("NAF detected - ready for manual connection");
                            this.nafEnabled = true;
                            
                            // Update status to indicate NAF is available but not connected
                            if (nafStatus) {
                                nafStatus.textContent = 'Available (Not Connected)';
                                nafStatus.className = 'text-warning';
                            }
                            
                            // Create templates for later use when connecting
                            this.logCameraEvent('Networked-Aframe library detected (not connected)', true);
                        } else {
                            // NAF is not available
                            this.nafEnabled = false;
                            
                            // Update NAF status display
                            if (nafStatus) {
                                nafStatus.textContent = 'Not Available';
                                nafStatus.className = 'text-danger';
                            }
                            
                            console.log("Networked-Aframe is not available");
                        }
                    } catch (error) {
                        // Handle any errors
                        console.error("Error checking NAF:", error);
                        this.nafEnabled = false;
                        
                        if (nafStatus) {
                            nafStatus.textContent = 'Error';
                            nafStatus.className = 'text-danger';
                        }
                    }
                },
                
                // Add to state object
                applyStateToScene: function() {
                    // Flag to prevent circular updates
                    this.isUpdatingFromState = true;
                    
                    try {
                        const previewScene = document.getElementById('preview-scene');
                        if (!previewScene) return;
                        
                        // Clear current entities except camera
                        const currentEntities = Array.from(previewScene.children).filter(el => 
                            el.tagName && 
                            el.tagName.toLowerCase().startsWith('a-') && 
                            el.id !== 'user-camera' && 
                            !el.hasAttribute('aframe-injected')
                        );
                        
                        currentEntities.forEach(entity => {
                            previewScene.removeChild(entity);
                        });
                        
                        // Add entities from state
                        this.scene.entities.forEach(entityData => {
                            const entity = document.createElement(entityData.tag);
                            
                            // Set attributes
                            Object.entries(entityData.attributes).forEach(([key, value]) => {
                                entity.setAttribute(key, value);
                            });
                            
                            // Add to scene
                            previewScene.appendChild(entity);
                        });
                        
                        // Flush to DOM
                        this.flushAllEntitiesToDOM();
                        
                        // Update editor
                        this.updateEditor();
                    } finally {
                        // Reset flag
                        setTimeout(() => {
                            this.isUpdatingFromState = false;
                        }, 100);
                    }
                },
                
                // Add error recovery method
                recoverFromError: function(error, context) {
                    console.error(`Error in ${context}:`, error);
                    
                    // Log to history
                    if (typeof this.logCameraEvent === 'function') {
                        this.logCameraEvent(`Error in ${context}: ${error.message}`, true);
                    }
                    
                    // Show error indicator
                    this.showSaveIndicator('error');
                    
                    // Reset update flag to prevent lock
                    this.isUpdatingFromState = false;
                    
                    // Attempt to recover by parsing from DOM
                    try {
                        this.parseSceneFromDOM();
                        this.updateEditor();
                    } catch (recoveryError) {
                        console.error("Recovery failed:", recoveryError);
                    }
                },
                
                // Check NAF status
                checkNafStatus: function() {
                    // Update the NAF status indicator
                    const nafStatus = document.getElementById('naf-status');
                    
                    if (window.NAF) {
                        console.log("NAF is available");
                        
                        if (window.NAF.connection) {
                            console.log("NAF connection is available");
                            
                            // Check connection status
                            if (window.NAF.connection.isConnected()) {
                                console.log("NAF is connected");
                                if (nafStatus) {
                                    nafStatus.textContent = 'Connected';
                                    nafStatus.className = 'text-success';
                                }
                                this.logCameraEvent('NAF check: Connected to network', true);
                            } else {
                                console.log("NAF is not connected");
                                if (nafStatus) {
                                    nafStatus.textContent = 'Initialized (Not Connected)';
                                    nafStatus.className = 'text-warning';
                                }
                                this.logCameraEvent('NAF check: Not connected to network', true);
                            }
                            
                            // Log connection details if available
                            if (window.NAF.connection.adapter) {
                                const adapter = window.NAF.connection.adapter;
                                console.log("NAF adapter:", adapter.constructor.name);
                                
                                // Get room information if available
                                if (adapter.room) {
                                    console.log("NAF room:", adapter.room);
                                    this.logCameraEvent(`NAF room: ${adapter.room}`, false);
                                }
                                
                                // Get connected clients if available
                                if (typeof adapter.getConnectedClients === 'function') {
                                    const clients = adapter.getConnectedClients();
                                    console.log("NAF connected clients:", clients);
                                    this.logCameraEvent(`NAF clients: ${Object.keys(clients).length} connected`, false);
                                }
                            }
                        } else {
                            console.log("NAF connection is not initialized");
                            if (nafStatus) {
                                nafStatus.textContent = 'Available (Not Initialized)';
                                nafStatus.className = 'text-warning';
                            }
                            this.logCameraEvent('NAF check: NAF is available but not initialized', true);
                            
                            // Try to initialize NAF
                            this.logCameraEvent('Attempting to initialize NAF...', false);
                            this.initNetworkedAframe();
                        }
                    } else {
                        console.log("NAF is not available");
                        if (nafStatus) {
                            nafStatus.textContent = 'Not Available';
                            nafStatus.className = 'text-danger';
                        }
                        this.logCameraEvent('NAF check: NAF library is not available', true);
                        
                        // Include information about what's needed to enable NAF
                        this.logCameraEvent('To enable NAF, include networked-aframe.min.js in your page', false);
                    }
                    
                    // Update debug display
                    this.updateDebugInfo();
                },
                
                // Connect NAF
                connectNaf: function() {
                    console.log("Connecting to NAF...");
                    this.connectToNAFServer();
                },
                
                // NAF - Connect to server manually
                connectToNAFServer: function() {
                    try {
                        if (!window.NAF) {
                            console.log("NAF library not found, can't connect");
                            this.logCameraEvent('NAF library not detected, cannot connect to server', true);
                            const nafStatus = document.getElementById('naf-status');
                            if (nafStatus) {
                                nafStatus.textContent = 'Library Not Found';
                                nafStatus.className = 'text-danger';
                            }
                            return;
                        }
                        
                        // Try to fix THREE.Math.DEG2RAD issue
                        if (window.THREE && !window.THREE.Math) {
                            console.log("Fixing THREE.Math reference for NAF");
                            window.THREE.Math = {
                                DEG2RAD: Math.PI / 180,
                                RAD2DEG: 180 / Math.PI
                            };
                        }
                        
                        const nafStatus = document.getElementById('naf-status');
                        if (nafStatus) {
                            nafStatus.textContent = 'Connecting...';
                            nafStatus.className = 'text-warning';
                        }
                        
                        // Get the server URL from the input field
                        const serverUrlInput = document.getElementById('naf-server-url');
                        const serverURL = serverUrlInput ? serverUrlInput.value : 'https://networked-aframe-dev-server.herokuapp.com';
                        
                        // Get the room name from the input field
                        const roomNameInput = document.getElementById('naf-room-name');
                        const roomName = roomNameInput ? roomNameInput.value : 'test-room';
                        
                        // Log the connection info
                        console.log(`Connecting to NAF server: ${serverURL}, room: ${roomName}`);
                        this.logCameraEvent(`Connecting to NAF server: ${serverURL}, room: ${roomName}`, true);
                        
                        // Ensure NAF templates are in the scene
                        this.ensureNAFTemplates();
                        
                        // Add networked-scene component to the scene if it doesn't exist
                        const previewScene = document.getElementById('preview-scene');
                        if (previewScene && !previewScene.hasAttribute('networked-scene')) {
                            // Set up connection to the specified server
                            previewScene.setAttribute('networked-scene', {
                                serverURL: serverURL,       // Use the custom URL
                                app: 'aframe-builder-app',  // Namespace
                                room: roomName,             // Use the custom room name
                                debug: true,                // Debug mode
                                adapter: 'socketio',        // Using socket.io adapter
                                audio: false                // No audio for simplicity
                            });
                            
                            this.logCameraEvent('Added networked-scene component', true);
                        }
                        
                        // Make sure camera is networked if needed
                        const cameraEl = document.getElementById('user-camera');
                        if (cameraEl && !cameraEl.hasAttribute('networked')) {
                            cameraEl.setAttribute('networked', {
                                template: this.nafTemplates.avatar,
                                networkId: `user-camera-${Date.now()}`,
                                owner: 'scene'
                            });
                        }
                        
                        // Set up connection event listeners
                        if (window.NAF.connection) {
                            window.NAF.connection.subscribeToDataChannel('connection-event', (senderId, dataType, data) => {
                                console.log('Connection event:', senderId, dataType, data);
                                this.logCameraEvent(`NAF connection event from ${senderId}: ${dataType}`, false);
                            });
                            
                            // Listen for client connected
                            document.body.addEventListener('clientConnected', (evt) => {
                                const clientId = evt.detail.clientId;
                                console.log('clientConnected event:', clientId);
                                this.logCameraEvent(`New client connected: ${clientId}`, true);
                            });
                            
                            // Listen for client disconnected
                            document.body.addEventListener('clientDisconnected', (evt) => {
                                const clientId = evt.detail.clientId;
                                console.log('clientDisconnected event:', clientId);
                                this.logCameraEvent(`Client disconnected: ${clientId}`, true);
                            });
                        }
                        
                        // Check connection status after a delay
                        setTimeout(() => {
                            this.updateDebugInfo();
                            if (window.NAF.connection && window.NAF.connection.isConnected()) {
                                this.logCameraEvent('Successfully connected to NAF server', true);
                                if (nafStatus) {
                                    nafStatus.textContent = 'Connected';
                                    nafStatus.className = 'text-success';
                                }
                                
                                // Add the networked component to all entities
                                this.addNetworkToEntities();
                            } else {
                                this.logCameraEvent('Failed to connect to NAF server', true);
                                if (nafStatus) {
                                    nafStatus.textContent = 'Connection Failed';
                                    nafStatus.className = 'text-danger';
                                }
                            }
                        }, 3000);
                    } catch (error) {
                        console.error("Error connecting to NAF:", error);
                        this.logCameraEvent(`Error connecting to NAF: ${error.message}`, true);
                        
                        const nafStatus = document.getElementById('naf-status');
                        if (nafStatus) {
                            nafStatus.textContent = 'Connection Error';
                            nafStatus.className = 'text-danger';
                        }
                    }
                },
                
                // Add networked component to all entities
                addNetworkToEntities: function() {
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;
                    
                    // Get all entities
                    const entities = Array.from(previewScene.children).filter(el => 
                        el.tagName && 
                        el.tagName.toLowerCase().startsWith('a-') && 
                        !el.hasAttribute('aframe-injected') &&
                        el.id !== 'user-camera' // Skip camera as it's already networked
                    );
                    
                    // Add networked component to each entity
                    entities.forEach(entity => {
                        if (!entity.hasAttribute('networked')) {
                            this.addNetworkedComponent(entity);
                            this.logCameraEvent(`Added networked component to ${entity.tagName.toLowerCase()} with ID ${entity.id || 'unknown'}`, false);
                        }
                    });
                    
                    console.log(`Added networking to ${entities.length} entities`);
                    this.logCameraEvent(`Added networking to ${entities.length} entities`, true);
                },
                
                // Ensure NAF templates are in the scene
                ensureNAFTemplates: function() {
                    try {
                        const previewScene = document.getElementById('preview-scene');
                        if (!previewScene) return;
                        
                        // Get or create a-assets element
                        let assetsEl = previewScene.querySelector('a-assets');
                        if (!assetsEl) {
                            assetsEl = document.createElement('a-assets');
                            previewScene.prepend(assetsEl); // Insert at the beginning
                            console.log('Created a-assets element for NAF templates');
                        }
                        
                        // Add avatar template if not already present
                        if (!document.getElementById('avatar-template')) {
                            console.log('Creating avatar template');
                            const avatarTemplate = document.createElement('template');
                            avatarTemplate.id = 'avatar-template';
                            avatarTemplate.innerHTML = `
                                <a-entity class="avatar">
                                    <a-sphere color="#5985ff" scale="0.45 0.5 0.4"></a-sphere>
                                </a-entity>
                            `;
                            assetsEl.appendChild(avatarTemplate);
                        }
                        
                        // Add entity template if not already present
                        if (!document.getElementById('entity-template')) {
                            console.log('Creating entity template');
                            const entityTemplate = document.createElement('template');
                            entityTemplate.id = 'entity-template';
                            entityTemplate.innerHTML = `
                                <a-entity class="networked-entity">
                                </a-entity>
                            `;
                            assetsEl.appendChild(entityTemplate);
                        }
                        
                        // Flush to DOM to ensure templates are available to NAF
                        if (previewScene.flushToDOM) {
                            previewScene.flushToDOM(true);
                        }
                        
                        console.log('NAF templates ensured');
                    } catch (error) {
                        console.error("Error ensuring NAF templates:", error);
                        this.logCameraEvent(`Error with NAF templates: ${error.message}`, true);
                    }
                },
                
                // When making any change:
                updateEntity: function(entityId, newAttributes) {
                    // 1. Update the model first
                    const entityIndex = this.scene.entities.findIndex(e => e.id === entityId);
                    if (entityIndex >= 0) {
                        // Merge attributes
                        this.scene.entities[entityIndex].attributes = {
                            ...this.scene.entities[entityIndex].attributes,
                            ...newAttributes
                        };
                        
                        // 2. Then update the DOM
                        this.applyModelToDOM();
                        
                        // 3. Update UI representations (editor, inspector)
                        this.updateEditor();
                    }
                },
                
                // Apply model changes to DOM
                applyModelToDOM: function() {
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;
                    
                    // Set flag to prevent circular updates
                    this.isUpdatingFromState = true;
                    
                    try {
                        // Apply model changes to DOM
                        this.updateSceneFromModel(previewScene);
                        
                        // Force A-Frame to process the changes
                        this.flushAllEntitiesToDOM();
                    } finally {
                        // Reset flag to allow event-based updates again
                        setTimeout(() => {
                            this.isUpdatingFromState = false;
                        }, 100);
                    }
                },
                
                // Add state versioning
                stateHistory: [],
                currentStateIndex: -1,
                
                saveStateVersion: function() {
                    // Create a deep copy of the current state
                    const stateCopy = JSON.parse(JSON.stringify(this.scene));
                    
                    // If we're not at the latest state, remove future states
                    if (this.currentStateIndex < this.stateHistory.length - 1) {
                        this.stateHistory = this.stateHistory.slice(0, this.currentStateIndex + 1);
                    }
                    
                    // Add new state to history
                    this.stateHistory.push(stateCopy);
                    this.currentStateIndex = this.stateHistory.length - 1;
                    
                    // Limit history size
                    if (this.stateHistory.length > 50) {
                        this.stateHistory.shift();
                        this.currentStateIndex--;
                    }
                    
                    // Update undo/redo buttons
                    this.updateUndoRedoUI();
                }
            };
            
            // Initialize the application
            state.init();
            
            // Expose the BUILDER object globally
            window.AFRAME.BUILDER = state;
        };
    </script>
</body>
</html>

