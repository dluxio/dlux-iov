<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A-Frame Builder</title>

    <!-- THREE.Math polyfill to fix NAF errors -->
    <!-- <script>
        // Immediately execute to ensure THREE.Math is defined before any scripts load
        (function() {
            // Make sure THREE exists
            if (typeof window.THREE === 'undefined') {
                window.THREE = {};
            }
            
            // Add Math if it doesn't exist
            if (!window.THREE.Math) {
                window.THREE.Math = {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: 180 / Math.PI,
                    generateUUID: function() {
                        // Simple UUID generator
                        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                            var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                            return v.toString(16);
                        });
                    }
                };
                console.log("THREE.Math polyfill added immediately");
            }
        })();
    </script> -->

    <!-- A-Frame -->
    <script src="aframe.min.js"></script>

    <!-- Load Socket.io -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.5.0/socket.io.slim.js"></script>

    <!-- Deferred NAF loading -->
    <script>
        // Load NAF after A-Frame is fully initialized
        document.addEventListener('DOMContentLoaded', function () {
            AFRAME.registerComponent('load-naf', {
                init: function () {
                    console.log("A-Frame fully initialized, loading NAF");

                    // Make sure THREE.Math exists before loading NAF
                    if (window.THREE && !window.THREE.Math) {
                        window.THREE.Math = {
                            DEG2RAD: Math.PI / 180,
                            RAD2DEG: 180 / Math.PI
                        };
                    }

                    // Create script element
                    var script = document.createElement('script');
                    script.src = "https://unpkg.com/networked-aframe@0.10.0/dist/networked-aframe.min.js";
                    script.onload = function () {
                        console.log("NAF loaded successfully");

                        // Notify the app
                        if (window.AFRAME && window.AFRAME.BUILDER) {
                            setTimeout(function () {
                                // Re-initialize NAF in the app
                                window.AFRAME.BUILDER.initNetworkedAframe();
                            }, 500);
                        }
                    };

                    // Add to document
                    document.head.appendChild(script);
                }
            });

            // Add the component to the scene
            var scene = document.querySelector('a-scene');
            if (scene) {
                scene.setAttribute('load-naf', '');
            }
        });
    </script>

    <!-- Monaco Editor -->
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.39.0/min/vs/loader.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            height: 50px;
            background-color: #2c2c2c;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        .toolbar-left {
            flex: 1;
            display: flex;
            align-items: center;
        }

        .logo {
            font-weight: bold;
            font-size: 1.2rem;
            margin-right: 20px;
        }

        .view-buttons {
            display: flex;
        }

        .view-button {
            background: none;
            border: none;
            color: #ccc;
            padding: 8px 12px;
            margin-right: 5px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        .view-button:hover {
            background-color: #444;
        }

        .view-button.active {
            background-color: #4a8fff;
            color: white;
        }

        .toolbar-right {
            display: flex;
            align-items: center;
        }

        .save-indicator {
            display: flex;
            align-items: center;
            margin-right: 15px;
            color: #aaa;
            font-size: 0.8rem;
            transition: opacity 0.3s ease;
        }

        .save-indicator.visible {
            opacity: 1;
        }

        .save-indicator.hidden {
            opacity: 0;
        }

        .save-indicator-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #4a8fff;
        }

        .save-indicator-dot.saving {
            background-color: #ffa500;
        }

        .save-indicator-dot.saved {
            background-color: #4caf50;
        }

        .save-indicator-dot.error {
            background-color: #f44336;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 250px;
            background-color: #333;
            color: #eee;
            overflow-y: auto;
            padding: 10px;
        }

        .sidebar-section {
            margin-bottom: 20px;
        }

        .sidebar-title {
            font-size: 1rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #fff;
        }

        .content-area {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
        }

        .view.active {
            display: block;
        }

        #code-view {
            background-color: #1e1e1e;
        }

        #monaco-editor {
            width: 100%;
            height: 100%;
        }

        #preview-view {
            background-color: #f0f0f0;
        }

        #preview-container {
            width: 100%;
            height: 100%;
        }

        #inspector-view {
            background-color: #f0f0f0;
        }

        .a-enter-vr {
            display: none !important;
        }

        /* Component buttons */
        .component-button {
            display: block;
            width: 100%;
            padding: 8px;
            margin-bottom: 5px;
            background-color: #444;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-align: left;
            transition: background-color 0.2s;
        }

        .component-button:hover {
            background-color: #555;
        }

        /* Debug Panel Styles */
        .debug-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            width: 320px;
            display: none;
            z-index: 100;
        }

        .debug-panel.visible {
            display: block;
        }

        .debug-controls {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .debug-button {
            background-color: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 3px 6px;
            font-size: 11px;
            cursor: pointer;
        }

        .debug-button:hover {
            background-color: #444;
        }

        .naf-connection-container {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-top: 5px;
        }

        .naf-server-input {
            background-color: #333;
            color: white;
            border: 1px solid #555;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 11px;
            width: 180px;
        }

        .naf-room-input {
            background-color: #333;
            color: white;
            border: 1px solid #555;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 11px;
            width: 90px;
        }

        .camera-history {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 5px;
            border-top: 1px solid #555;
            padding-top: 5px;
            font-size: 10px;
        }

        .camera-history-tabs {
            display: flex;
            margin-bottom: 5px;
            border-bottom: 1px solid #555;
        }

        .history-tab {
            padding: 2px 8px;
            margin-right: 2px;
            cursor: pointer;
            border-radius: 3px 3px 0 0;
            background-color: #333;
        }

        .history-tab.active {
            background-color: #555;
            font-weight: bold;
        }

        .camera-history-entry {
            margin-bottom: 3px;
            border-bottom: 1px dotted #555;
            padding-bottom: 2px;
        }

        #reset-editor-camera {
            background-color: #2a5;
            color: white;
            font-weight: bold;
        }

        .debug-button:hover {
            background-color: #444;
        }

        .camera-switcher {
            position: relative;
            margin-left: 10px;
        }

        #camera-switch-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 32px;
            width: 32px;
            background-color: #444;
            color: white;
            border: none;
            border-radius: 4px;
        }

        #camera-switch-btn:hover {
            background-color: #555;
        }

        .camera-menu {
            position: absolute;
            top: 100%;
            right: 0;
            width: 180px;
            background-color: #333;
            border: 1px solid #555;
            border-radius: 4px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
        }

        .camera-menu.active {
            display: block;
        }

        .camera-option {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #444;
            transition: background-color 0.2s;
            color: white;
            font-size: 12px;
        }

        .camera-option:hover {
            background-color: #555;
        }

        .camera-option.active {
            background-color: #4c6ef5;
            font-weight: bold;
        }

        .camera-option .camera-info {
            font-size: 10px;
            color: #aaa;
            margin-top: 3px;
        }

        .camera-option.default-camera {
            color: #7bff00;
        }

        .camera-option.default-camera .camera-info {
            color: #aaffaa;
        }
    </style>
</head>

<body>
    <!-- Toolbar -->
    <div class="toolbar">
        <div class="toolbar-left">
            <div class="logo">A-Frame Builder</div>
            <div class="view-buttons">
                <button class="view-button active" data-view="preview">Preview</button>
                <button class="view-button" data-view="code">Code</button>
                <button class="view-button" data-view="inspector">Inspector</button>
            </div>
        </div>
        <div class="toolbar-right">
            <div class="save-indicator hidden">
                <div class="save-indicator-dot"></div>
                <span class="save-indicator-text">Changes saved</span>
            </div>
        </div>
        <div class="toolbar-button camera-switcher">
            <button id="camera-switch-btn" class="btn btn-sm btn-light" title="Switch Camera View">
                <i class="fas fa-video"></i>
            </button>
            <div class="camera-menu" id="camera-menu">
                <div class="camera-option" data-camera="builder">Builder Camera</div>
                <div id="scene-cameras-list">
                    <!-- Scene cameras will be populated here dynamically -->
                </div>
            </div>
        </div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-section">
                <div class="sidebar-title">Components</div>
                <button class="component-button" data-component="box">Box</button>
                <button class="component-button" data-component="sphere">Sphere</button>
                <button class="component-button" data-component="cylinder">Cylinder</button>
                <button class="component-button" data-component="plane">Plane</button>
                <button class="component-button" data-component="sky">Sky</button>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-title">Debug</div>
                <button class="component-button" id="toggle-debug">Show Debug Info</button>
                <button class="component-button" id="change-sky-color">Change Sky Color</button>
                <button class="component-button" id="reset-camera">Reset Camera</button>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-title">Assets</div>
                <!-- Asset management will go here -->
            </div>
            <div class="sidebar-section">
                <div class="sidebar-title">Templates</div>
                <!-- Templates will go here -->
            </div>
        </div>

        <!-- Content Area -->
        <div class="content-area">
            <!-- Preview View -->
            <div id="preview-view" class="view active">
                <div id="preview-container">
                    <a-scene id="preview-scene" embedded>
                        <!-- Templates for networked entities -->
                        <a-assets>
                            <template id="avatar-template">
                                <a-entity class="avatar">
                                    <a-sphere color="#5985ff" scale="0.45 0.5 0.4"></a-sphere>
                                </a-entity>
                            </template>

                            <template id="entity-template">
                                <a-entity class="networked-entity"></a-entity>
                            </template>
                        </a-assets>

                        <!-- Initial default scene -->
                        <a-box position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9"></a-box>
                        <a-sphere position="0 1.25 -5" radius="1.25" color="#EF2D5E"></a-sphere>
                        <a-cylinder position="1 0.75 -3" radius="0.5" height="1.5" color="#FFC65D"></a-cylinder>
                        <a-plane position="0 0 -4" rotation="-90 0 0" width="4" height="4" color="#7BC8A4"></a-plane>
                        <a-sky color="#ECECEC"></a-sky>
                        <a-entity id="user-camera" position="0 1.6 0" camera look-controls wasd-controls
                            networked="template:#avatar-template;attachTemplateToLocal:false;"></a-entity>
                    </a-scene>
                </div>
                <div class="debug-panel">
                    <div>Camera Position: <span id="camera-position">0,0,0</span></div>
                    <div>Camera Rotation: <span id="camera-rotation">0,0,0</span></div>
                    <div>Camera Entity: <span id="entity-camera-info">None</span></div>
                    <div>Stored Camera States: <span id="camera-stored-state"
                            style="font-size: 0.85em; word-break: break-word;">Not available</span></div>
                    <div style="margin-top: 10px; border-top: 1px solid #444; padding-top: 5px;">
                        <strong>Camera State Debug</strong>
                        <div>Editor Camera: <span id="debug-editor-camera">null</span></div>
                        <div>App Camera: <span id="debug-app-camera">null</span></div>
                        <div>Scene Camera: <span id="debug-scene-camera">null</span></div>
                        <div>DOM Camera: <span id="debug-dom-camera">null</span></div>
                        <div>Last Parse: <span id="debug-last-parse-time">never</span></div>
                    </div>
                    <div>Entity Count: <span id="entity-count">0</span></div>
                    <div>Last Action: <span id="last-action">None</span></div>
                    <div>NAF Status: <span id="naf-status" class="text-warning">Not Initialized</span></div>
                    <div class="debug-controls">
                        <button class="debug-button" id="teleport-camera">Teleport to 0,1.6,5</button>
                        <button class="debug-button" id="reset-editor-camera">Reset Editor Camera</button>
                        <button class="debug-button" id="log-entities">Log Entities</button>
                        <button class="debug-button" id="check-naf">Check NAF</button>
                        <button class="debug-button" id="refresh-camera-debug">Refresh Camera Debug</button>
                        <div class="naf-connection-container">
                            <input type="text" id="naf-server-url" class="naf-server-input" placeholder="NAF Server URL"
                                value="https://networked-aframe-dev-server.herokuapp.com">
                            <input type="text" id="naf-room-name" class="naf-room-input" placeholder="Room Name"
                                value="test-room">
                            <button class="debug-button" id="connect-naf">Connect NAF</button>
                        </div>
                    </div>
                    <div class="camera-history">
                        <div class="camera-history-tabs">
                            <div class="history-tab active" data-mode="all">All</div>
                            <div class="history-tab" data-mode="camera">Camera</div>
                            <div class="history-tab" data-mode="entity">Entity</div>
                        </div>
                        <div id="camera-history-log"></div>
                    </div>
                </div>
            </div>

            <!-- Code View -->
            <div id="code-view" class="view">
                <div id="monaco-editor"></div>
            </div>

            <!-- Inspector View -->
            <div id="inspector-view" class="view">
                <!-- A-Frame Inspector will be injected here -->
            </div>
        </div>
    </div>

    <script>
        // Wait for A-Frame to load before any app initialization
        window.onload = function () {
            // Ensure the preview scene exists and is set up correctly
            const scene = document.getElementById('preview-scene');
            if (!scene) {
                console.error('Preview scene not found!');
                return;
            }

            // State Management
            const state = {
                // Core state
                scene: {
                    entities: [],
                    assets: [],
                    defaultCamera: null  // Renamed from camera to defaultCamera for clarity
                },
                activeCamera: null,      // Current camera state for app (renamed from camera)
                buildCamera: null,       // Renamed from editorCamera for consistency

                // Current active view
                currentView: 'preview',

                // Permission flags
                requirePermissionForEntityCreation: false,
                requirePermissionForEntityAddition: false,
                requirePermissionForEntityRemoval: false,
                requirePermissionForComponentChange: false,

                // DOM observation flag for advanced change detection
                shouldObserveDOMChanges: true,

                // Initial scene template
                initialScene: `<a-scene embedded networked-scene="
  serverURL: https://networked-aframe-dev-server.herokuapp.com;
  app: aframe-builder-app;
  room: test-room;
  debug: true;
  adapter: socketio;
  audio: false;">
  <a-assets>
    <template id="avatar-template">
      <a-entity class="avatar">
        <a-sphere color="#5985ff" scale="0.45 0.5 0.4"></a-sphere>
      </a-entity>
    </template>
    
    <template id="entity-template">
      <a-entity class="networked-entity"></a-entity>
    </template>
  </a-assets>
  <a-box position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9"></a-box>
  <a-sphere position="0 1.25 -5" radius="1.25" color="#EF2D5E"></a-sphere>
  <a-cylinder position="1 0.75 -3" radius="0.5" height="1.5" color="#FFC65D"></a-cylinder>
  <a-plane position="0 0 -4" rotation="-90 0 0" width="4" height="4" color="#7BC8A4"></a-plane>
  <a-sky color="#ECECEC"></a-sky>
  <a-entity id="user-camera" position="0 1.6 0" camera look-controls wasd-controls networked="template:#avatar-template;attachTemplateToLocal:false;"></a-entity>
</a-scene>`,

                // Monaco editor instance
                editor: null,

                // Inspector state
                inspectorOpened: false,

                // Component templates
                components: {
                    box: '<a-box position="0 1 -3" rotation="0 45 0" color="#4CC3D9"></a-box>',
                    sphere: '<a-sphere position="0 1.25 -3" radius="1.25" color="#EF2D5E"></a-sphere>',
                    cylinder: '<a-cylinder position="0 1 -3" radius="0.5" height="1.5" color="#FFC65D"></a-cylinder>',
                    plane: '<a-plane position="0 0 -3" rotation="-90 0 0" width="4" height="4" color="#7BC8A4"></a-plane>',
                    sky: '<a-sky color="#ECECEC"></a-sky>'
                },

                // Initialize application
                initialize: function () {
                    console.log("Initializing aframe-builder application...");
                    this.nafEnabled = false; // Disable NAF by default
                    this.wasConnectedToNAF = false; // Track if we were ever connected

                    // Initialize logging arrays
                    this.cameraHistory = [];
                    this.entityHistory = [];
                    this.historyMode = 'all'; // Default history view

                    // Store the initial scene content for reference
                    const previewScene = document.getElementById('preview-scene');
                    this.initialSceneHTML = this.getCleanSceneHTML(previewScene);

                    // Add a camera if one doesn't exist
                    this.ensureCamera();

                    // Set up initial camera states for both scene and editor
                    // Initialize editor camera (separate from scene camera)
                    this.editorCamera = {
                        position: { x: 0, y: 1.6, z: 0 },
                        rotation: { x: 0, y: 0, z: 0 },
                        timestamp: new Date().toISOString(),
                        source: 'initialization'
                    };

                    // Parse scene from DOM
                    this.parseSceneFromDOM();

                    // After parsing, save initial editor camera state from current camera
                    this.saveEditorCameraState('initialization');

                    // Initialize component buttons
                    this.initComponentButtons();

                    // Initialize view switcher
                    this.initViewSwitcher();

                    // Initialize Monaco editor
                    this.initMonaco();

                    // Start camera position tracking using A-Frame's systems
                    this.startCameraTracking();

                    // Setup debug updates at a lower frequency
                    this.setupDebugUpdates();

                    // Setup A-Frame event listeners and inspector integration
                    this.setupInspectorSync();

                    // Initialize Networked A-Frame support but don't connect automatically
                    this.initNetworkedAframe();

                    // Initialize save indicator
                    this.showSaveIndicator('saved');

                    // Initialize debug tools
                    this.initDebugTools();

                    // Make debug panel visible by default (with animation)
                    /* const debugPanel = document.querySelector('.debug-panel');
                    if (debugPanel) {
                        setTimeout(() => {
                            debugPanel.classList.add('visible');
                        }, 500);
                    } */

                    console.log("Application initialized successfully");
                    this.logCameraEvent('A-Frame Builder initialized', true);

                    // Initialize camera controller
                    this.initCameraController();

                    // Setup build camera continuous updates
                    this.setupBuildCameraUpdater();

                    // Start direct debug panel updates
                    setTimeout(() => this.updateDebugPanelDirectly(), 500);

                    // Enforce builder camera mode
                    this.currentCameraMode = 'build';
                    console.log("Enforcing builder camera as active camera mode");

                    // Start continuous build camera updating
                    this.startContinuousBuildCameraUpdate();

                    // Add direct camera debug overlay
                    this.addCameraDebugOverlay();

                    // Add this to the initialization function after the camera controller initialization
                    this.syncCameraMotionToBuilder();

                    // Also add an animation frame loop to align cameras
                    const alignLoop = () => {
                        if (this.currentCameraMode === 'build') {
                            this.alignAllCameraRepresentations();
                        }
                        requestAnimationFrame(alignLoop);
                    };
                    requestAnimationFrame(alignLoop);

                    // Initialize state immutability
                    this.cameraState = Object.freeze({
                        position: { x: 0, y: 1.6, z: 0 },
                        rotation: { x: 0, y: 0, z: 0 },
                        mode: 'build',
                        timestamp: new Date().toISOString(),
                        source: 'initialization'
                    });

                    // Initialize state history
                    this.cameraStateHistory = [];
                    this.cameraStateHistoryIndex = -1;
                    this.maxHistoryStates = 50;

                    // Initialize throttling/debouncing
                    this.lastStateUpdate = 0;
                    this.pendingStateUpdate = null;
                    this.updateThrottleTime = 50; // ms

                    // Initialize render loop optimization
                    this.setupCameraEventListeners();

                    // Initialize debug tools
                    this.setupDebugKeyboardShortcuts();

                    // Initialize state persistence
                    this.loadCameraStates();

                    // Initialize networked camera sync
                    this.setupNetworkedCameraSync();

                    // Initialize public API
                    AFRAME.BUILDER.CameraAPI = {
                        // Get current camera information
                        getCurrentPosition: function () {
                            return JSON.parse(JSON.stringify(state.cameraState.position));
                        },

                        getCurrentRotation: function () {
                            return JSON.parse(JSON.stringify(state.cameraState.rotation));
                        },

                        getMode: function () {
                            return state.cameraState.mode;
                        },

                        // Camera operations
                        switchToBuildCamera: function () {
                            state.switchToBuildCamera();
                        },

                        switchToSceneCamera: function (cameraId) {
                            state.switchToSceneCamera(cameraId);
                        },

                        resetCamera: function () {
                            state.resetCameraPosition();
                        },

                        // Named position management
                        saveCurrentPositionAs: function (name) {
                            if (!state.savedCameraPositions) {
                                state.savedCameraPositions = {};
                            }

                            state.savedCameraPositions[name] = {
                                position: JSON.parse(JSON.stringify(state.cameraState.position)),
                                rotation: JSON.parse(JSON.stringify(state.cameraState.rotation)),
                                timestamp: new Date().toISOString()
                            };

                            state.saveCameraStates();
                            return true;
                        },

                        goToSavedPosition: function (name) {
                            if (!state.savedCameraPositions || !state.savedCameraPositions[name]) {
                                return false;
                            }

                            const savedPos = state.savedCameraPositions[name];
                            state.updateCameraState({
                                position: savedPos.position,
                                rotation: savedPos.rotation
                            }, `goto-saved-position-${name}`);

                            return true;
                        },

                        listSavedPositions: function () {
                            return Object.keys(state.savedCameraPositions || {});
                        }
                    };
                },

                // Setup less-frequent updates for detailed debug info
                setupDebugUpdates: function () {
                    const debugPanel = document.querySelector('.debug-panel');
                    if (!debugPanel) return;

                    // Only update detailed debug when the panel is visible
                    let isDebugVisible = debugPanel.classList.contains('visible');

                    // Watch for visibility changes
                    const observer = new MutationObserver((mutations) => {
                        mutations.forEach((mutation) => {
                            if (mutation.attributeName === 'class') {
                                isDebugVisible = debugPanel.classList.contains('visible');
                            }
                        });
                    });

                    observer.observe(debugPanel, { attributes: true });

                    // Set up an interval for updating detailed debug info
                    // This is much less frequent than the camera state updates
                    setInterval(() => {
                        if (isDebugVisible) {
                            this.updateCameraDebug();
                        }
                    }, 500); // Update every 500ms (2 times per second) when visible
                },

                // Start camera position tracking using A-Frame's built-in systems
                startCameraTracking: function () {
                    console.log("Setting up optimized camera tracking");

                    // Use A-Frame's tick event which is already optimized
                    // This avoids creating our own requestAnimationFrame loop
                    const scene = document.querySelector('a-scene');
                    if (!scene) {
                        console.error("Can't find A-Frame scene for camera tracking");
                        return this.startLegacyCameraTracking(); // Fall back to the original method
                    }

                    // Track last update time to limit updates (no need to update every frame)
                    let lastUpdateTime = 0;
                    const updateInterval = 100; // milliseconds between updates (10 updates/second)

                    // Store a reference to this app instance for the component to use
                    const self = this;

                    // Create an actual AFrame component for camera tracking to ensure it's properly registered
                    if (!AFRAME.components['camera-tracker']) {
                        AFRAME.registerComponent('camera-tracker', {
                            init: function () {
                                console.log("Camera tracker component initialized");
                                this.lastUpdateTime = 0;

                                // Store reference to the app through closure
                                this.appRef = self;
                            },
                            tick: function (time, deltaTime) {
                                // Only update at fixed intervals for performance
                                if (time - this.lastUpdateTime < updateInterval) return;
                                this.lastUpdateTime = time;

                                // Update the application camera state
                                if (this.appRef && typeof this.appRef.updateCameraState === 'function') {
                                    this.appRef.updateCameraState();
                                }
                            }
                        });
                    }

                    // Add the tracker component to the scene
                    scene.setAttribute('camera-tracker', '');

                    // Also use legacy method as backup to ensure UI updates work correctly
                    this.startLegacyCameraTracking();

                    console.log("Camera tracking set up with A-Frame's tick event");
                },

                // The original camera tracking method - kept for compatibility
                startLegacyCameraTracking: function () {
                    console.log("Starting continuous camera position tracking");

                    // Track in every frame to ensure we always have current position
                    const trackCamera = () => {
                        const cameraEl = document.getElementById('user-camera');
                        if (cameraEl && cameraEl.object3D) {
                            // Get position directly from object3D for most accurate values
                            const position = {
                                x: cameraEl.object3D.position.x,
                                y: cameraEl.object3D.position.y,
                                z: cameraEl.object3D.position.z
                            };

                            // Get rotation - use look-controls if available for better accuracy
                            let rotation = { x: 0, y: 0, z: 0 };

                            if (cameraEl.components && cameraEl.components['look-controls']) {
                                const lookControls = cameraEl.components['look-controls'];

                                // Get pitch and yaw from look-controls
                                if (lookControls.pitchObject) {
                                    rotation.x = THREE.MathUtils.radToDeg(lookControls.pitchObject.rotation.x);
                                }

                                if (lookControls.yawObject) {
                                    rotation.y = THREE.MathUtils.radToDeg(lookControls.yawObject.rotation.y);
                                }
                            } else {
                                // Fall back to object3D rotation
                                rotation = {
                                    x: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.x),
                                    y: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.y),
                                    z: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.z)
                                };
                            }

                            // Update our camera state
                            this.camera = {
                                position: position,
                                rotation: rotation
                            };

                            // Update the scene model camera too
                            if (!this.scene.camera) {
                                this.scene.camera = {};
                            }
                            this.scene.camera.position = Object.assign({}, position);
                            this.scene.camera.rotation = Object.assign({}, rotation);

                            // Update the debug panel position and rotation displays
                            const posDisplay = document.getElementById('camera-position');
                            if (posDisplay) {
                                posDisplay.textContent = `${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}`;
                            }

                            const rotDisplay = document.getElementById('camera-rotation');
                            if (rotDisplay) {
                                rotDisplay.textContent = `${rotation.x.toFixed(2)}, ${rotation.y.toFixed(2)}, ${rotation.z.toFixed(2)}`;
                            }

                            // Update the camera debug info occasionally (not every frame for performance)
                            if (Math.random() < 0.1) { // ~10% chance each frame
                                this.updateCameraDebug();
                            }
                        }

                        // Continue tracking in the next frame
                        requestAnimationFrame(trackCamera);
                    };

                    // Start the tracking loop
                    requestAnimationFrame(trackCamera);
                },

                // Update camera state from DOM (separated for reuse)
                updateCameraState: function (newState, source, recordHistory = true) {
                    // Create new state
                    const updatedState = {
                        ...this.cameraState,
                        ...newState,
                        timestamp: new Date().toISOString(),
                        source: source || 'manual-update'
                    };

                    // Record in history if significant change and recordHistory flag is true
                    if (recordHistory && this.isSignificantStateChange(this.cameraState, updatedState)) {
                        // If we're not at the end of the history, truncate 
                        if (this.cameraStateHistoryIndex < this.cameraStateHistory.length - 1) {
                            this.cameraStateHistory = this.cameraStateHistory.slice(0, this.cameraStateHistoryIndex + 1);
                        }

                        // Add current state to history
                        this.cameraStateHistory.push(JSON.parse(JSON.stringify(updatedState)));

                        // Limit history size
                        if (this.cameraStateHistory.length > this.maxHistoryStates) {
                            this.cameraStateHistory.shift();
                        }

                        // Update index to point to current state
                        this.cameraStateHistoryIndex = this.cameraStateHistory.length - 1;
                    }

                    // Update current state
                    this.cameraState = Object.freeze(updatedState);

                    // Continue with rendering...
                },

                // Setup camera position tracking to continuously update stored camera position
                setupCameraTracking: function () {
                    // Track camera position changes every frame to capture WASD movements
                    const trackCameraPosition = () => {
                        const cameraEl = document.getElementById('user-camera');
                        if (cameraEl && cameraEl.object3D) {
                            // Get current position
                            const currentPosition = {
                                x: cameraEl.object3D.position.x,
                                y: cameraEl.object3D.position.y,
                                z: cameraEl.object3D.position.z
                            };

                            // Get current rotation
                            let currentRotation;

                            // If look-controls are present, get rotation from them
                            // This is more accurate for user-controlled camera
                            if (cameraEl.components && cameraEl.components['look-controls']) {
                                const lookControls = cameraEl.components['look-controls'];

                                let pitchX = 0;
                                let yawY = 0;

                                if (lookControls.pitchObject) {
                                    pitchX = lookControls.pitchObject.rotation.x;
                                }

                                if (lookControls.yawObject) {
                                    yawY = lookControls.yawObject.rotation.y;
                                }

                                // Convert rotation from look-controls to degrees
                                currentRotation = {
                                    x: THREE.MathUtils.radToDeg(pitchX),
                                    y: THREE.MathUtils.radToDeg(yawY),
                                    z: 0
                                };
                            } else {
                                // Fall back to object3D rotation if no look-controls
                                currentRotation = {
                                    x: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.x),
                                    y: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.y),
                                    z: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.z)
                                };
                            }

                            // Update the stored camera state
                            this.camera = {
                                position: Object.assign({}, currentPosition),
                                rotation: Object.assign({}, currentRotation)
                            };

                            // Uncomment for debugging
                            // console.log("Tracking camera position:", this.camera.position);
                        }

                        // Continue tracking in the next frame
                        requestAnimationFrame(trackCameraPosition);
                    };

                    // Start the tracking loop
                    requestAnimationFrame(trackCameraPosition);
                },

                // Setup synchronization between inspector and our model
                setupInspectorSync: function () {
                    // Get the preview scene
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;

                    console.log("Setting up A-Frame event listeners for state sync");

                    // Clear any existing observers and event listeners
                    if (this.sceneObserver) {
                        this.sceneObserver.disconnect();
                        this.sceneObserver = null;
                    }

                    // Remove existing event listeners if any
                    if (this.boundChildAttached) {
                        previewScene.removeEventListener('child-attached', this.boundChildAttached);
                    }
                    if (this.boundChildDetached) {
                        previewScene.removeEventListener('child-detached', this.boundChildDetached);
                    }
                    if (this.boundComponentChanged) {
                        previewScene.removeEventListener('componentchanged', this.boundComponentChanged);
                    }

                    // Flag to prevent circular updates
                    this.isUpdatingFromState = false;

                    // Create bound event handlers for better cleanup
                    this.boundChildAttached = this.handleChildAttached.bind(this);
                    this.boundChildDetached = this.handleChildDetached.bind(this);
                    this.boundComponentChanged = this.handleComponentChanged.bind(this);

                    // Listen for entity added to scene
                    previewScene.addEventListener('child-attached', this.boundChildAttached);

                    // Listen for entity removed from scene
                    previewScene.addEventListener('child-detached', this.boundChildDetached);

                    // Use event delegation to listen for component changes on any entity
                    previewScene.addEventListener('componentchanged', this.boundComponentChanged);

                    // Set up inspector integration with specific event handler
                    if (typeof AFRAME !== 'undefined' && AFRAME.INSPECTOR) {
                        // Listen for inspector close event
                        if (this.boundInspectorClosed) {
                            window.removeEventListener('inspector-closed', this.boundInspectorClosed);
                        }

                        this.boundInspectorClosed = this.handleInspectorClosed.bind(this);
                        window.addEventListener('inspector-closed', this.boundInspectorClosed);
                    }

                    // Set up mutation observer for DOM changes that A-Frame might not catch
                    if (this.shouldObserveDOMChanges) {
                        this.setupDOMObserver();
                    }

                    console.log("A-Frame event listeners established");
                },

                // Handle entity added to scene
                handleChildAttached: function (event) {
                    // Skip if we're in the middle of updating from our state
                    if (this.isUpdatingFromState) return;

                    const entity = event.detail.el;

                    // Only track A-Frame entities, not internal elements
                    if (entity.tagName &&
                        entity.tagName.toLowerCase().startsWith('a-') &&
                        !entity.hasAttribute('aframe-injected')) {

                        console.log(`Entity added to scene: ${entity.tagName.toLowerCase()} ${entity.id || 'no-id'}`);

                        // Check permissions if needed (for future extension)
                        if (this.requirePermissionForEntityAddition && typeof this.requestPermission === 'function') {
                            if (!this.requestPermission(`Add ${entity.tagName.toLowerCase()} to scene`)) {
                                // Remove the entity if permission denied
                                entity.parentNode.removeChild(entity);
                                return;
                            }
                        }

                        // Debounce to avoid multiple rapid updates
                        this.debounceSceneUpdate();
                    }
                },

                // Handle entity removed from scene
                handleChildDetached: function (event) {
                    // Skip if we're in the middle of updating from our state
                    if (this.isUpdatingFromState) return;

                    const entity = event.detail.el;

                    // Only track A-Frame entities, not internal elements
                    if (entity.tagName &&
                        entity.tagName.toLowerCase().startsWith('a-') &&
                        !entity.hasAttribute('aframe-injected')) {

                        console.log(`Entity removed from scene: ${entity.tagName.toLowerCase()} ${entity.id || 'no-id'}`);

                        // Check permissions if needed (for future extension)
                        if (this.requirePermissionForEntityRemoval && typeof this.requestPermission === 'function') {
                            if (!this.requestPermission(`Remove ${entity.tagName.toLowerCase()} from scene`)) {
                                // We can't really re-add the entity here, but we can log the denial
                                console.warn(`Permission denied for removing ${entity.tagName.toLowerCase()}`);
                            }
                        }

                        // Debounce to avoid multiple rapid updates
                        this.debounceSceneUpdate();
                    }
                },

                // Handle component change on entity
                handleComponentChanged: function (event) {
                    // Skip if we're in the middle of updating from our state
                    if (this.isUpdatingFromState) return;

                    const entity = event.detail.target;
                    const component = event.detail.name;
                    const oldData = event.detail.oldData;
                    const newData = event.detail.newData;

                    // Skip camera entities to avoid circular updates from debug
                    if (entity.id === 'user-camera' && component === 'position') return;
                    if (entity.id === 'user-camera' && component === 'rotation') return;

                    console.log(`Component changed on ${entity.tagName.toLowerCase()}: ${component}`, oldData, newData);

                    // Check permissions if needed (for future extension)
                    if (this.requirePermissionForComponentChange && typeof this.requestPermission === 'function') {
                        if (!this.requestPermission(`Change ${component} on ${entity.tagName.toLowerCase()}`)) {
                            // Revert the change if permission denied
                            if (oldData !== undefined) {
                                entity.setAttribute(component, oldData);
                            } else {
                                entity.removeAttribute(component);
                            }
                            return;
                        }
                    }

                    // Debounce to avoid multiple rapid updates
                    this.debounceSceneUpdate();
                },

                // Handle inspector closed event
                handleInspectorClosed: function () {
                    this.inspectorOpened = false;

                    // Force update to ensure model is in sync
                    this.parseSceneFromDOM();
                    this.updateEditor();

                    // Log event
                    if (typeof this.logCameraEvent === 'function') {
                        this.logCameraEvent('Inspector closed, scene updated', true);
                    }
                },

                // Set up mutation observer for DOM changes
                setupDOMObserver: function () {
                    if (this.sceneObserver) {
                        this.sceneObserver.disconnect();
                    }

                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;

                    this.sceneObserver = new MutationObserver(mutations => {
                        // Skip if we're in the middle of updating
                        if (this.isUpdatingFromState) return;

                        // Check if any mutation is relevant to our scene
                        const relevantMutation = mutations.some(mutation => {
                            // Only care about childList changes
                            if (mutation.type !== 'childList') return false;

                            // Check added nodes
                            for (let i = 0; i < mutation.addedNodes.length; i++) {
                                const node = mutation.addedNodes[i];
                                if (node.tagName && node.tagName.toLowerCase().startsWith('a-') &&
                                    !node.hasAttribute('aframe-injected')) {
                                    return true;
                                }
                            }

                            // Check removed nodes
                            for (let i = 0; i < mutation.removedNodes.length; i++) {
                                const node = mutation.removedNodes[i];
                                if (node.tagName && node.tagName.toLowerCase().startsWith('a-') &&
                                    !node.hasAttribute('aframe-injected')) {
                                    return true;
                                }
                            }

                            return false;
                        });

                        if (relevantMutation) {
                            console.log("DOM mutation detected, updating scene model");
                            this.debounceSceneUpdate();
                        }
                    });

                    this.sceneObserver.observe(previewScene, {
                        childList: true,
                        subtree: true,
                        attributes: true,
                        attributeFilter: ['position', 'rotation', 'scale', 'color', 'material', 'geometry']
                    });
                },

                // Debounce scene updates to prevent excessive processing
                debounceSceneUpdate: function () {
                    // Clear any existing timeout
                    if (this.sceneUpdateTimeout) {
                        clearTimeout(this.sceneUpdateTimeout);
                    }

                    // Show saving indicator
                    this.showSaveIndicator('saving');

                    // Set a timeout to update after changes settle
                    this.sceneUpdateTimeout = setTimeout(() => {
                        // Update our model from the DOM and update editor
                        this.parseSceneFromDOM();
                        this.updateEditor();

                        // Show saved indicator
                        this.showSaveIndicator('saved');

                        // Log event
                        if (typeof this.logCameraEvent === 'function') {
                            this.logCameraEvent('Scene updated from A-Frame event', true);
                        }
                    }, 500); // Debounce time, adjust as needed
                },

                // Initialize Monaco Editor
                initMonaco: function () {
                    console.log("Initializing code editor");

                    require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.39.0/min/vs' } });

                    require(['vs/editor/editor.main'], () => {
                        // Create the editor with standard HTML language
                        this.editor = monaco.editor.create(document.getElementById('monaco-editor'), {
                            value: '<a-scene embedded>\n  <!-- Add your scene content here -->\n</a-scene>',
                            language: 'html',
                            theme: 'vs-dark',
                            automaticLayout: true,
                            minimap: {
                                enabled: false
                            }
                        });

                        console.log("Monaco editor created");

                        // Parse the DOM scene into our model
                        this.parseSceneFromDOM();

                        // Update the editor with the current scene
                        this.updateEditor();

                        // Listen for changes in the editor
                        this.editor.onDidChangeModelContent(() => {
                            // Parse the editor content
                            const html = this.editor.getValue();
                            console.log("Editor content changed");

                            // Show saving indicator
                            this.showSaveIndicator('saving');

                            // Set flag to prevent circular updates
                            this.isUpdatingFromState = true;

                            try {
                                // Update our model from the editor HTML
                                this.parseSceneFromHTML(html);

                                // Apply changes to the preview scene
                                const previewScene = document.getElementById('preview-scene');
                                if (previewScene) {
                                    // Parse the HTML
                                    const parser = new DOMParser();
                                    const doc = parser.parseFromString(html, 'text/html');
                                    const scene = doc.querySelector('a-scene');

                                    if (scene && scene.children.length > 0) {
                                        // First clear existing entities
                                        Array.from(previewScene.children).forEach(child => {
                                            // Only remove A-Frame entities that aren't the camera
                                            if (child.tagName &&
                                                child.tagName.toLowerCase().startsWith('a-') &&
                                                child.id !== 'user-camera' &&
                                                !child.hasAttribute('aframe-injected')) {
                                                previewScene.removeChild(child);
                                            }
                                        });

                                        // Add new entities from editor
                                        Array.from(scene.children).forEach(child => {
                                            // Don't add internal A-Frame elements
                                            if (child.tagName &&
                                                child.tagName.toLowerCase().startsWith('a-') &&
                                                child.id !== 'user-camera' &&
                                                !child.hasAttribute('aframe-injected')) {
                                                previewScene.appendChild(document.importNode(child, true));
                                            }
                                        });

                                        // Ensure A-Frame knows about the changes
                                        if (AFRAME && AFRAME.scenes && AFRAME.scenes.length > 0) {
                                            // Force a tick to process changes
                                            AFRAME.scenes[0].tick();

                                            // Flush to DOM to ensure all component data is written to attributes
                                            AFRAME.scenes[0].flushToDOM(true);
                                        }

                                        // Log the update
                                        if (typeof this.logCameraEvent === 'function') {
                                            this.logCameraEvent('Scene updated from editor', true);
                                        }
                                    }
                                }
                            } catch (error) {
                                console.error('Error updating scene from editor:', error);
                                if (typeof this.logCameraEvent === 'function') {
                                    this.logCameraEvent(`Error updating from editor: ${error.message}`, true);
                                }
                            } finally {
                                // Reset flag to allow event-based updates again
                                setTimeout(() => {
                                    this.isUpdatingFromState = false;

                                    // Show saved indicator after a short delay to ensure everything is settled
                                    this.showSaveIndicator('saved');
                                }, 100);
                            }
                        });
                    });
                },

                // Parse A-Frame HTML to scene model
                parseSceneFromHTML: function (html) {
                    console.log("Parsing scene from HTML");

                    // Simple parsing for now - we'll extract entities from the HTML
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const scene = doc.querySelector('a-scene');

                    if (!scene) {
                        console.warn("No a-scene found in HTML");
                        return;
                    }

                    // Reset scene data
                    this.scene.entities = [];
                    this.scene.assets = [];

                    // Parse assets
                    const assetsEl = scene.querySelector('a-assets');
                    if (assetsEl) {
                        Array.from(assetsEl.children).forEach(asset => {
                            this.scene.assets.push({
                                tag: asset.tagName.toLowerCase(),
                                attributes: this.extractAttributes(asset)
                            });
                        });
                    }

                    // Parse entities (excluding a-assets)
                    const entities = Array.from(scene.children).filter(el => {
                        // Only include real A-Frame entity elements, not internal elements
                        const tagName = el.tagName.toLowerCase();
                        if (tagName === 'a-assets') return false;
                        if (el.hasAttribute('aframe-injected')) return false;
                        if (tagName === 'canvas' || tagName === 'div') return false;
                        return tagName.startsWith('a-');
                    });

                    entities.forEach(entity => {
                        // Create entity data
                        const entityData = {
                            id: entity.id || `entity-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
                            tag: entity.tagName.toLowerCase(),
                            attributes: this.extractAttributes(entity)
                        };

                        // Add to entities
                        this.scene.entities.push(entityData);
                    });

                    console.log(`Parsed ${this.scene.entities.length} entities from HTML`);
                },

                // Extract attributes from an element
                extractAttributes: function (element) {
                    const attributes = {};
                    Array.from(element.attributes).forEach(attr => {
                        attributes[attr.name] = attr.value;
                    });
                    return attributes;
                },

                // Generate A-Frame HTML from scene model
                generateHTML: function () {
                    let html = '<a-scene embedded>\n';

                    // Add assets if any
                    if (this.scene.assets.length > 0) {
                        html += '  <a-assets>\n';
                        this.scene.assets.forEach(asset => {
                            html += `    <${asset.tag}`;
                            Object.entries(asset.attributes).forEach(([key, value]) => {
                                html += ` ${key}="${value}"`;
                            });
                            html += '>\n';
                        });
                        html += '  </a-assets>\n';
                    }

                    // Add root entities (entities without parents)
                    const rootEntities = this.scene.entities.filter(entity => !entity.parentId);
                    rootEntities.forEach(entity => {
                        html += this.generateEntityHTML(entity, 2);
                    });

                    html += '</a-scene>';
                    return html;
                },

                // Generate HTML for a single entity and its children
                generateEntityHTML: function (entity, indentation = 0) {
                    const indent = ' '.repeat(indentation);

                    let html = `${indent}<${entity.tag}`;

                    // Add attributes
                    Object.entries(entity.attributes).forEach(([key, value]) => {
                        html += ` ${key}="${value}"`;
                    });

                    // Find children
                    const children = this.scene.entities.filter(e => e.parentId === entity.id);

                    if (children.length > 0) {
                        html += '>\n';

                        // Add children
                        children.forEach(child => {
                            html += this.generateEntityHTML(child, indentation + 2);
                        });

                        html += `${indent}</${entity.tag}>\n`;
                    } else {
                        html += `></${entity.tag}>\n`;
                    }

                    return html;
                },

                // Update the editor from scene model
                updateEditor: function () {
                    if (!this.editor) return;

                    // Get the preview scene
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;

                    // Get current camera state
                    const cameraEl = document.getElementById('user-camera');
                    let cameraPosition = null;
                    let cameraRotation = null;

                    if (cameraEl && cameraEl.object3D) {
                        // Get position directly from object3D for accuracy
                        cameraPosition = {
                            x: cameraEl.object3D.position.x,
                            y: cameraEl.object3D.position.y,
                            z: cameraEl.object3D.position.z
                        };

                        // Get rotation - prefer look-controls for user camera
                        if (cameraEl.components && cameraEl.components['look-controls']) {
                            const lookControls = cameraEl.components['look-controls'];

                            cameraRotation = {
                                x: lookControls.pitchObject ? THREE.MathUtils.radToDeg(lookControls.pitchObject.rotation.x) : 0,
                                y: lookControls.yawObject ? THREE.MathUtils.radToDeg(lookControls.yawObject.rotation.y) : 0,
                                z: 0
                            };
                        } else {
                            // Fall back to object3D rotation
                            cameraRotation = {
                                x: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.x),
                                y: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.y),
                                z: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.z)
                            };
                        }
                    }

                    // Generate HTML with explicit camera and exclude the camera from the scene's content
                    let html = "<a-scene embedded>\n";

                    // Add camera with current position
                    if (cameraPosition && cameraRotation) {
                        html += `  <a-entity id="user-camera" position="${cameraPosition.x} ${cameraPosition.y} ${cameraPosition.z}" `;
                        html += `rotation="${cameraRotation.x} ${cameraRotation.y} ${cameraRotation.z}" `;
                        html += `camera look-controls wasd-controls></a-entity>\n`;

                        // Update the camera model for consistency
                        if (!this.scene.camera) {
                            this.scene.camera = {};
                        }

                        this.scene.camera.position = Object.assign({}, cameraPosition);
                        this.scene.camera.rotation = Object.assign({}, cameraRotation);

                        this.camera = {
                            position: Object.assign({}, cameraPosition),
                            rotation: Object.assign({}, cameraRotation)
                        };
                    }

                    // Get clean HTML from the DOM (now excludes camera)
                    const cleanHTML = this.getCleanSceneHTML(previewScene);
                    html += cleanHTML;
                    html += "</a-scene>";

                    // Only update if the content has actually changed
                    const currentValue = this.editor.getValue();
                    if (currentValue !== html) {
                        this.editor.setValue(html);
                    }
                },

                // Apply HTML changes to preview
                applyChangesToPreview: function (html, preventCameraReset) {
                    // Get the preview scene
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return false;

                    // Save editor camera state always - this is our building camera view
                    this.saveEditorCameraState('before-html-change');
                    console.log("Saved editor camera state before applying changes");

                    // Validate HTML content
                    if (!html || typeof html !== 'string') {
                        console.error("Invalid HTML content provided to applyChangesToPreview");
                        return false;
                    }

                    // Create a template element to parse the HTML
                    const template = document.createElement('template');
                    template.innerHTML = html.trim();

                    try {
                        // Track processed entity IDs to avoid duplicates
                        const processedIds = new Set();

                        // Check for camera in the HTML - this is the scene camera, not our editor camera
                        let sceneCamera = null;

                        Array.from(template.content.children).forEach(el => {
                            // Look for a-entity with camera component
                            if (el.hasAttribute('camera') ||
                                (el.tagName.toLowerCase() === 'a-camera')) {

                                // Parse the camera's attributes
                                const attributes = {};
                                Array.from(el.attributes).forEach(attr => {
                                    attributes[attr.name] = attr.value;
                                });

                                // Extract position and rotation
                                const position = this.parseVectorAttribute(attributes.position) || { x: 0, y: 1.6, z: 0 };
                                const rotation = this.parseVectorAttribute(attributes.rotation) || { x: 0, y: 0, z: 0 };

                                // Save as scene camera (representative camera)
                                sceneCamera = {
                                    id: el.id || 'scene-camera',
                                    position: position,
                                    rotation: rotation,
                                    attributes: attributes
                                };

                                console.log("Found scene camera in HTML:", sceneCamera);
                            }
                        });

                        // If we found a scene camera, update the scene model
                        if (sceneCamera) {
                            this.scene.camera = sceneCamera;
                        }

                        // Get all non-camera entities in the current scene
                        const currentEntities = Array.from(previewScene.children).filter(el =>
                            el.tagName &&
                            el.tagName.toLowerCase().startsWith('a-') &&
                            el.id !== 'user-camera' &&
                            !el.hasAttribute('aframe-injected')
                        );

                        // Save references to all current entities 
                        const entityMap = {};
                        currentEntities.forEach(entity => {
                            if (entity.id) {
                                entityMap[entity.id] = entity;
                            }
                        });

                        // Debug log count of entities
                        console.log(`[Entity Count] Current: ${currentEntities.length}, Model: ${this.scene.entities.length}`);

                        // Get all non-camera entities from the template
                        const newEntities = Array.from(template.content.children).filter(el =>
                            el.tagName &&
                            el.tagName.toLowerCase().startsWith('a-') &&
                            el.id !== 'user-camera'
                        );

                        // First pass: remove all current entities except camera
                        currentEntities.forEach(entity => {
                            previewScene.removeChild(entity);
                        });

                        // Second pass: add all new entities from template
                        newEntities.forEach(entity => {
                            previewScene.appendChild(entity);
                            if (entity.id) {
                                processedIds.add(entity.id);
                            }
                        });

                        // Ensure all entities are properly registered with A-Frame
                        setTimeout(() => {
                            // Force a flush of all entities to update the DOM
                            this.flushAllEntitiesToDOM();

                            // Force A-Frame to reprocess the scene
                            if (AFRAME && AFRAME.scenes && AFRAME.scenes.length > 0) {
                                const aframeScene = AFRAME.scenes[0];
                                if (aframeScene.renderStarted) {
                                    // Force a tick cycle to process newly added entities
                                    aframeScene.tick();
                                    aframeScene.tock();
                                }
                            }

                            // Log status after update
                            console.log(`[Entity Update] Added ${newEntities.length} entities to scene`);

                            // Always restore editor camera for preview - this keeps our building view
                            if (this.editorCamera && this.editorCamera.position) {
                                this.restoreEditorCameraState('after-scene-update');
                            }

                            // Update our model from the DOM - but don't affect the editor camera
                            this.parseSceneFromDOM(true); // true = preserve camera

                            // Log to history
                            this.logCameraEvent(`Preview updated with ${newEntities.length} entities`, true);
                        }, 50);

                        return true;
                    } catch (error) {
                        console.error("Error applying changes to preview:", error);
                        return false;
                    }
                },

                // Parse vector attribute (position, rotation) into xyz object
                parseVectorAttribute: function (attrValue) {
                    if (!attrValue) return null;

                    // Handle object format
                    if (typeof attrValue === 'object' && attrValue.x !== undefined) {
                        return {
                            x: parseFloat(attrValue.x) || 0,
                            y: parseFloat(attrValue.y) || 0,
                            z: parseFloat(attrValue.z) || 0
                        };
                    }

                    // Handle string format "x y z"
                    if (typeof attrValue === 'string') {
                        const parts = attrValue.split(' ').map(part => parseFloat(part) || 0);
                        return {
                            x: parts[0] || 0,
                            y: parts[1] || 0,
                            z: parts[2] || 0
                        };
                    }

                    return null;
                },

                // Ensure there's a camera in the scene
                ensureCamera: function () {
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;

                    // Check if there's already a camera
                    let hasCamera = false;
                    Array.from(previewScene.children).forEach(child => {
                        if (child.tagName.toLowerCase() === 'a-camera' ||
                            child.hasAttribute('camera') ||
                            child.id === 'user-camera') {
                            hasCamera = true;
                        }
                    });

                    // If no camera, add the user-camera
                    if (!hasCamera) {
                        const camera = document.createElement('a-entity');
                        camera.setAttribute('camera', '');
                        camera.setAttribute('look-controls', '');
                        camera.setAttribute('wasd-controls', '');

                        // Use stored camera position or default
                        let position = '0 1.6 0';
                        if (this.camera && this.camera.position) {
                            const pos = this.camera.position;
                            position = `${pos.x} ${pos.y} ${pos.z}`;
                        }

                        camera.setAttribute('position', position);
                        camera.setAttribute('id', 'user-camera');
                        previewScene.appendChild(camera);
                    }
                },

                // Setup optimized observers to reduce performance impact
                setupOptimizedObservers: function () {
                    // This method is kept for backward compatibility
                    // It's just an alias to setupInspectorSync now
                    this.setupInspectorSync();
                },

                // Initialize component buttons
                initComponentButtons: function () {
                    console.log("Setting up component buttons");

                    // Get all component buttons directly
                    document.querySelectorAll('.component-button[data-component]').forEach(button => {
                        const componentType = button.getAttribute('data-component');
                        if (componentType) {
                            // Use direct DOM attribute instead of event listener
                            button.onclick = () => {
                                console.log("Button clicked: " + componentType);
                                this.addComponent(componentType);
                            };
                        }
                    });

                    // Debug button uses direct DOM attribute
                    const debugToggle = document.getElementById('toggle-debug');
                    if (debugToggle) {
                        debugToggle.onclick = () => {
                            console.log("Debug toggle clicked");
                            const debugPanel = document.querySelector('.debug-panel');
                            if (debugPanel.classList.contains('visible')) {
                                debugPanel.classList.remove('visible');
                                debugToggle.textContent = 'Show Debug Info';
                            } else {
                                debugPanel.classList.add('visible');
                                debugToggle.textContent = 'Hide Debug Info';

                                // Force an immediate update when showing
                                this.updateDebugInfo();
                                if (typeof this.logCameraEvent === 'function') {
                                    this.logCameraEvent('Debug panel shown', true);
                                }
                            }
                        };

                        // Set the correct initial text
                        const debugPanel = document.querySelector('.debug-panel');
                        if (debugPanel && debugPanel.classList.contains('visible')) {
                            debugToggle.textContent = 'Hide Debug Info';
                        } else {
                            debugToggle.textContent = 'Show Debug Info';
                        }
                    }

                    // Reset camera button
                    const resetCamera = document.getElementById('reset-camera');
                    if (resetCamera) {
                        resetCamera.onclick = () => {
                            console.log("Reset camera clicked");
                            this.resetCamera();
                            const lastAction = document.getElementById('last-action');
                            if (lastAction) lastAction.textContent = 'Reset camera';
                            if (typeof this.logCameraEvent === 'function') {
                                this.logCameraEvent('Camera reset to default position', true);
                            }
                        };
                    }

                    // Sky color button
                    const changeSkyColor = document.getElementById('change-sky-color');
                    if (changeSkyColor) {
                        changeSkyColor.onclick = () => {
                            console.log("Change sky color clicked");
                            this.changeSkyColor();
                            const lastAction = document.getElementById('last-action');
                            if (lastAction) lastAction.textContent = 'Changed sky color';
                            if (typeof this.logCameraEvent === 'function') {
                                this.logCameraEvent('Sky color changed', true);
                            }
                        };
                    }
                },

                // Initialize view switcher
                initViewSwitcher: function () {
                    console.log("Setting up view switcher");

                    const viewButtons = document.querySelectorAll('.view-button');

                    viewButtons.forEach(button => {
                        const viewName = button.getAttribute('data-view');

                        // Use direct onclick handler
                        button.onclick = () => {
                            console.log("View switched to: " + viewName);

                            // Update active button
                            viewButtons.forEach(btn => btn.classList.remove('active'));
                            button.classList.add('active');

                            // Update active view
                            document.querySelectorAll('.view').forEach(view => {
                                view.classList.remove('active');
                            });
                            document.getElementById(viewName + '-view').classList.add('active');

                            // Special handling for inspector view
                            if (viewName === 'inspector') {
                                this.openInspector();
                            } else if (this.inspectorOpened) {
                                // Close inspector when switching to other views
                                this.closeInspector();
                            }

                            // Ensure Monaco editor is properly sized when switched to
                            if (viewName === 'code' && this.editor) {
                                this.editor.layout();
                            }

                            this.currentView = viewName;
                        };
                    });
                },

                // Toggle A-Frame Inspector
                toggleInspector: function () {
                    if (this.inspectorOpened) {
                        this.closeInspector();
                    } else {
                        this.openInspector();
                    }
                },

                // Open A-Frame Inspector safely
                openInspector: function () {
                    // Make sure we're in preview mode first
                    document.querySelectorAll('.view').forEach(view => {
                        view.classList.remove('active');
                    });
                    document.getElementById('preview-view').classList.add('active');

                    const previewScene = document.getElementById('preview-scene');

                    // Store current scene state before opening inspector
                    const sceneHTML = previewScene.innerHTML;

                    // Try the AFRAME.INSPECTOR method first
                    if (AFRAME && AFRAME.INSPECTOR) {
                        try {
                            AFRAME.INSPECTOR.open();
                            this.inspectorOpened = true;

                            // Set up watcher for inspector changes
                            this.setupInspectorWatcher();
                            return;
                        } catch (e) {
                            console.warn('AFRAME.INSPECTOR.open failed:', e);
                        }
                    }

                    // Attempt to open with keyboard shortcut
                    try {
                        // Use keyboard shortcut approach
                        document.dispatchEvent(new KeyboardEvent('keydown', {
                            key: 'i',
                            code: 'KeyI',
                            keyCode: 73,
                            which: 73,
                            ctrlKey: true,
                            altKey: true,
                            bubbles: true
                        }));

                        this.inspectorOpened = true;

                        // Set up watcher for inspector changes
                        this.setupInspectorWatcher();
                        return;
                    } catch (e) {
                        console.warn('Inspector keyboard shortcut failed:', e);
                    }

                    console.error('Failed to open inspector');
                },

                // Setup watcher for inspector changes
                setupInspectorWatcher: function () {
                    // Stop existing watcher if any
                    if (this.inspectorWatcherInterval) {
                        clearInterval(this.inspectorWatcherInterval);
                    }

                    console.log("Setting up inspector watcher");

                    // If AFRAME.INSPECTOR is available, use its API
                    if (AFRAME && AFRAME.INSPECTOR) {
                        console.log("Using AFRAME.INSPECTOR API");

                        // Set up listener for entity selection changes
                        if (AFRAME.INSPECTOR.on) {
                            AFRAME.INSPECTOR.on('entityselect', entity => {
                                console.log(`Inspector selected entity: ${entity.tagName} ${entity.id || 'no-id'}`);
                            });

                            // Listen for component changes via inspector
                            AFRAME.INSPECTOR.on('componentchange', (entity, component, value) => {
                                console.log(`Inspector changed component ${component} on ${entity.tagName} ${entity.id || 'no-id'}`);
                                this.handleInspectorChange();
                            });

                            // Listen for entity changes via inspector
                            AFRAME.INSPECTOR.on('entityupdate', entity => {
                                console.log(`Inspector updated entity: ${entity.tagName} ${entity.id || 'no-id'}`);
                                this.handleInspectorChange();
                            });
                        }
                    } else {
                        // Fallback to using DOM events if AFRAME.INSPECTOR API not available
                        console.log("Falling back to DOM events for inspector");

                        // Wait for inspector to be fully initialized
                        setTimeout(() => {
                            // Find all inspector panels and controls
                            const inspectorPanels = document.querySelectorAll('.inspector, .components, .property-row, .vector, .color');

                            if (inspectorPanels.length > 0) {
                                const boundHandler = this.handleInspectorChange.bind(this);

                                // Add event listeners to all inspector controls
                                inspectorPanels.forEach(control => {
                                    // Remove existing listeners to avoid duplicates
                                    control.removeEventListener('change', boundHandler);
                                    control.removeEventListener('input', boundHandler);
                                    control.removeEventListener('click', boundHandler);
                                    control.removeEventListener('mouseup', boundHandler);

                                    // Add new listeners
                                    control.addEventListener('change', boundHandler);
                                    control.addEventListener('input', boundHandler);
                                    control.addEventListener('mouseup', boundHandler);
                                });

                                // Setup mutation observer for inspector components panel
                                const componentsPanel = document.querySelector('.components');
                                if (componentsPanel) {
                                    if (this.inspectorObserver) {
                                        this.inspectorObserver.disconnect();
                                    }

                                    this.inspectorObserver = new MutationObserver(mutations => {
                                        // Delay to make sure A-Frame has processed all changes
                                        setTimeout(() => {
                                            if (this.inspectorOpened) {
                                                this.handleInspectorChange();
                                            }
                                        }, 200);
                                    });

                                    this.inspectorObserver.observe(componentsPanel, {
                                        attributes: true,
                                        childList: true,
                                        subtree: true
                                    });
                                }
                            } else {
                                // If we couldn't find the panels, try again later
                                setTimeout(() => this.setupInspectorWatcher(), 1000);
                            }
                        }, 1000);
                    }

                    // Set up a backup interval watcher (least preferred method, but a good safety net)
                    this.inspectorWatcherInterval = setInterval(() => {
                        if (this.inspectorOpened) {
                            // Check for dirty state in the inspector and update if needed
                            if (AFRAME && AFRAME.INSPECTOR && AFRAME.INSPECTOR.history &&
                                AFRAME.INSPECTOR.history.count > 0) {
                                this.handleInspectorChange();
                            }
                        } else {
                            // If inspector is closed, stop the interval
                            clearInterval(this.inspectorWatcherInterval);
                        }
                    }, 2000);
                },

                // Handle inspector change events
                handleInspectorChange: function () {
                    // Skip if we're already updating from state
                    if (this.isUpdatingFromState) return;

                    // First, ensure all inspector changes are flushed to the DOM
                    this.flushAllEntitiesToDOM();

                    // Then update our model from the DOM
                    this.parseSceneFromDOM();

                    // Finally, update UI representations based on the model
                    this.updateEditor();
                },

                // Close A-Frame Inspector
                closeInspector: function () {
                    try {
                        // Stop inspector watchers
                        if (this.inspectorWatcherInterval) {
                            clearInterval(this.inspectorWatcherInterval);
                            this.inspectorWatcherInterval = null;
                        }

                        if (this.inspectorObserver) {
                            this.inspectorObserver.disconnect();
                            this.inspectorObserver = null;
                        }

                        // Try different methods to close inspector
                        if (AFRAME && AFRAME.INSPECTOR) {
                            AFRAME.INSPECTOR.close();
                        }

                        // Set flag to prevent circular updates
                        this.isUpdatingFromState = true;

                        // Read the scene back if inspector made changes
                        this.parseSceneFromDOM();
                        this.updateEditor();

                        // Reset flag after a delay
                        setTimeout(() => {
                            this.isUpdatingFromState = false;
                        }, 300);
                    } catch (e) {
                        console.error('Error closing inspector:', e);
                        this.isUpdatingFromState = false;
                    }

                    this.inspectorOpened = false;
                },

                // Add a new component to the scene
                addComponent: function (componentType) {
                    console.log(`Adding component: ${componentType}`);
                    if (!this.components[componentType]) return;

                    // Show saving indicator
                    this.showSaveIndicator('saving');

                    // Log to debug panel
                    this.logCameraEvent(`Adding ${componentType} component`, true);

                    try {
                        // Set a flag to prevent camera reset during the process
                        this.preventCameraReset = true;


                        // Capture exact DOM camera position before any changes
                        const cameraEl = document.getElementById('user-camera');
                        let savedCameraPosition = null;
                        let savedCameraRotation = null;
                        let savedLookControlsState = null;

                        if (cameraEl && cameraEl.object3D) {
                            // Get current position directly from object3D (most accurate)
                            savedCameraPosition = {
                                x: cameraEl.object3D.position.x,
                                y: cameraEl.object3D.position.y,
                                z: cameraEl.object3D.position.z
                            };

                            // Check for NaN values and fix them
                            if (isNaN(savedCameraPosition.x)) savedCameraPosition.x = 0;
                            if (isNaN(savedCameraPosition.y)) savedCameraPosition.y = 1.6;
                            if (isNaN(savedCameraPosition.z)) savedCameraPosition.z = 5;

                            // Save exact look-controls state for more accurate rotation
                            if (cameraEl.components && cameraEl.components['look-controls']) {
                                const lookControls = cameraEl.components['look-controls'];
                                savedLookControlsState = {};

                                if (lookControls.pitchObject) {
                                    savedLookControlsState.pitchX = lookControls.pitchObject.rotation.x;
                                    // Fix NaN
                                    if (isNaN(savedLookControlsState.pitchX)) savedLookControlsState.pitchX = 0;
                                }

                                if (lookControls.yawObject) {
                                    savedLookControlsState.yawY = lookControls.yawObject.rotation.y;
                                    // Fix NaN
                                    if (isNaN(savedLookControlsState.yawY)) savedLookControlsState.yawY = 0;
                                }

                                // Save rotation from look-controls
                                savedCameraRotation = {
                                    // Store in degrees for easier debugging
                                    x: lookControls.pitchObject ? THREE.MathUtils.radToDeg(lookControls.pitchObject.rotation.x) : 0,
                                    y: lookControls.yawObject ? THREE.MathUtils.radToDeg(lookControls.yawObject.rotation.y) : 0,
                                    z: 0
                                };
                            } else {
                                // Fallback to rotation from object3D
                                savedCameraRotation = {
                                    x: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.x),
                                    y: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.y),
                                    z: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.z)
                                };
                            }

                            // Check for NaN values in rotation
                            if (isNaN(savedCameraRotation.x)) savedCameraRotation.x = 0;
                            if (isNaN(savedCameraRotation.y)) savedCameraRotation.y = 0;
                            if (isNaN(savedCameraRotation.z)) savedCameraRotation.z = 0;

                            console.log("Saved camera position before adding component:", savedCameraPosition);
                            console.log("Saved camera rotation before adding component:", savedCameraRotation);
                        }

                        // Parse the component HTML
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(this.components[componentType], 'text/html');
                        const componentEl = doc.body.firstChild;

                        if (componentEl) {
                            // Add to DOM
                            const previewScene = document.getElementById('preview-scene');
                            if (previewScene) {
                                // Generate a unique ID with timestamp and random suffix
                                const id = `${componentType}-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
                                componentEl.setAttribute('id', id);

                                // CRITICAL: Save the state to our model BEFORE touching DOM
                                // This ensures the camera position is preserved in our data model
                                if (savedCameraPosition && savedCameraRotation) {
                                    // Store camera state before any DOM changes
                                    if (!this.scene.camera) {
                                        this.scene.camera = {};
                                    }

                                    this.scene.camera.position = Object.assign({}, savedCameraPosition);
                                    this.scene.camera.rotation = Object.assign({}, savedCameraRotation);

                                    // Also update the main app camera reference
                                    this.camera = {
                                        position: Object.assign({}, savedCameraPosition),
                                        rotation: Object.assign({}, savedCameraRotation)
                                    };

                                }

                                // Fix NaN rotation values
                                const rot = cameraEl.object3D.rotation;
                                if (isNaN(rot.x) || isNaN(rot.y) || isNaN(rot.z)) {
                                    console.warn("Fixing NaN rotation values in camera");

                                    // Get valid rotation
                                    let validRot = { x: 0, y: 0, z: 0 };

                                    // Try from model
                                    if (this.camera && this.camera.rotation) {
                                        const modelRot = this.camera.rotation;
                                        if (!isNaN(modelRot.x) && !isNaN(modelRot.y) && !isNaN(modelRot.z)) {
                                            validRot = {
                                                x: THREE.MathUtils.degToRad(modelRot.x),
                                                y: THREE.MathUtils.degToRad(modelRot.y),
                                                z: THREE.MathUtils.degToRad(modelRot.z)
                                            };
                                        }
                                    }

                                    // Apply fix
                                    console.log(" Stored camera state in model:", this.camera);
                                }

                                // Set flag to disable auto camera updates during the add operation
                                const isUpdatingEntitiesBefore = this.isUpdatingEntities;
                                this.isUpdatingEntities = true;

                                // Add to scene
                                previewScene.appendChild(componentEl);

                                // Force A-Frame to process the new entity
                                if (AFRAME && AFRAME.scenes && AFRAME.scenes.length > 0) {
                                    // Force a tick to process changes
                                    AFRAME.scenes[0].tick();

                                    // Flush entity to DOM to ensure all component data is written to attributes
                                    this.flushAllEntitiesToDOM();
                                }

                                // Use a custom version of parseSceneFromDOM that preserves camera
                                const originalParseMethod = this.parseSceneFromDOM;

                                this.parseSceneFromDOM = function () {
                                    console.log("Using camera-preserving parseSceneFromDOM");
                                    const timestamp = new Date().toISOString();
                                    const previewScene = document.getElementById('preview-scene');
                                    if (!previewScene) return;

                                    // Update last parse time in debug
                                    const lastParseTimeEl = document.getElementById('debug-last-parse-time');
                                    if (lastParseTimeEl) {
                                        lastParseTimeEl.textContent = timestamp;
                                    }

                                    // Preserve our camera data exactly as it was before
                                    const oldCamera = this.camera ? Object.assign({}, this.camera) : null;

                                    // Reset scene data
                                    this.scene.entities = [];
                                    this.scene.assets = [];

                                    // Parse assets if they exist
                                    const assetsEl = previewScene.querySelector('a-assets');
                                    if (assetsEl) {
                                        Array.from(assetsEl.children).forEach(asset => {
                                            this.scene.assets.push({
                                                tag: asset.tagName.toLowerCase(),
                                                attributes: this.extractAttributes(asset)
                                            });
                                        });
                                    }

                                    // Parse all entities EXCEPT camera
                                    Array.from(previewScene.children).forEach(child => {
                                        if (child.tagName &&
                                            child.tagName.toLowerCase().startsWith('a-') &&
                                            !child.hasAttribute('aframe-injected') &&
                                            child.tagName.toLowerCase() !== 'a-assets' &&
                                            child.id !== 'user-camera') {

                                            // Process entity and children
                                            const entityData = this.serializeEntityRecursive(child);
                                            this.scene.entities.push(entityData);
                                        }
                                    });

                                    // Restore camera data EXACTLY as it was
                                    if (oldCamera) {
                                        // Update both references to ensure consistency
                                        this.camera = oldCamera;
                                        if (!this.scene.camera) {
                                            this.scene.camera = {};
                                        }
                                        this.scene.camera.position = Object.assign({}, oldCamera.position);
                                        this.scene.camera.rotation = Object.assign({}, oldCamera.rotation);
                                    }

                                    console.log(`[${timestamp}] Parsed ${this.scene.entities.length} entities from DOM, preserving camera:`, this.camera);
                                }.bind(this);

                                // Use our custom implementation to update the model, but not the DOM
                                this.parseSceneFromDOM();

                                // Restore original implementation
                                this.parseSceneFromDOM = originalParseMethod;

                                // Disable the editor update during component addition to prevent cycles
                                // We'll manually update it with our preserved camera state
                                const originalUpdateEditorMethod = this.updateEditor;

                                this.updateEditor = function () {
                                    console.log("Using camera-safe updateEditor");
                                    const previewScene = document.getElementById('preview-scene');
                                    if (!previewScene) return;

                                    // We'll generate the HTML manually to ensure camera position is preserved
                                    let html = "<a-scene embedded>\n";

                                    // Add camera with preserved position
                                    if (this.camera && this.camera.position) {
                                        const pos = this.camera.position;
                                        const rot = this.camera.rotation;
                                        html += `  <a-entity id="user-camera" position="${pos.x} ${pos.y} ${pos.z}" `;
                                        html += `rotation="${rot.x} ${rot.y} ${rot.z}" `;
                                        html += `camera look-controls wasd-controls></a-entity>\n`;
                                    }

                                    // Add all other entities except camera
                                    const cleanHTML = this.getCleanSceneHTML(previewScene);
                                    html += cleanHTML;
                                    html += "</a-scene>";

                                    // Update the editor value, but only if it's changed
                                    const currentValue = this.editor.getValue();
                                    if (currentValue !== html) {
                                        console.log("Updating editor with preserved camera");
                                        this.editor.setValue(html);
                                    } else {
                                        console.log("Editor content unchanged, preserving state");
                                    }
                                }.bind(this);

                                // Update the editor text with our preserved camera model
                                this.updateEditor();

                                // Restore the original editor update method
                                this.updateEditor = originalUpdateEditorMethod;

                                // Now explicitly restore the camera position in the DOM
                                if (savedCameraPosition && cameraEl) {
                                    console.log("Directly restoring saved camera position:", savedCameraPosition);

                                    // First check if position values are valid
                                    if (isNaN(savedCameraPosition.x) || isNaN(savedCameraPosition.y) || isNaN(savedCameraPosition.z)) {
                                        console.warn("NaN detected in saved position, using defaults");
                                        savedCameraPosition = { x: 0, y: 1.6, z: 5 };
                                    }

                                    // Update object3D directly (most reliable)
                                    cameraEl.object3D.position.set(
                                        savedCameraPosition.x,
                                        savedCameraPosition.y,
                                        savedCameraPosition.z
                                    );

                                    // Update rotation if available
                                    if (savedCameraRotation) {
                                        // Check for NaN values
                                        if (isNaN(savedCameraRotation.x)) savedCameraRotation.x = 0;
                                        if (isNaN(savedCameraRotation.y)) savedCameraRotation.y = 0;
                                        if (isNaN(savedCameraRotation.z)) savedCameraRotation.z = 0;

                                        const rotX = THREE.MathUtils.degToRad(savedCameraRotation.x);
                                        const rotY = THREE.MathUtils.degToRad(savedCameraRotation.y);
                                        const rotZ = THREE.MathUtils.degToRad(savedCameraRotation.z);
                                        cameraEl.object3D.rotation.set(rotX, rotY, rotZ);
                                    }

                                    // Restore precise look-controls state if we have it
                                    if (savedLookControlsState && cameraEl.components && cameraEl.components['look-controls']) {
                                        const lookControls = cameraEl.components['look-controls'];

                                        // Restore exact pitch and yaw values
                                        if (lookControls.pitchObject && savedLookControlsState.pitchX !== undefined) {
                                            if (!isNaN(savedLookControlsState.pitchX)) {
                                                lookControls.pitchObject.rotation.x = savedLookControlsState.pitchX;
                                                lookControls.pitchObject.updateMatrix();
                                            }
                                        }

                                        if (lookControls.yawObject && savedLookControlsState.yawY !== undefined) {
                                            if (!isNaN(savedLookControlsState.yawY)) {
                                                lookControls.yawObject.rotation.y = savedLookControlsState.yawY;
                                                lookControls.yawObject.updateMatrix();
                                            }
                                        }
                                    }

                                    // Reset WASD controls velocity
                                    if (cameraEl.components && cameraEl.components['wasd-controls']) {
                                        const wasdControls = cameraEl.components['wasd-controls'];
                                        if (wasdControls.velocity) {
                                            wasdControls.velocity.set(0, 0, 0);
                                        }
                                    }

                                    // Update the DOM attributes to match the object3D
                                    cameraEl.setAttribute('position', savedCameraPosition);

                                    if (savedCameraRotation) {
                                        cameraEl.setAttribute('rotation', {
                                            x: savedCameraRotation.x,
                                            y: savedCameraRotation.y,
                                            z: savedCameraRotation.z
                                        });
                                    }

                                    // Force A-Frame to synchronize
                                    if (AFRAME && AFRAME.scenes && AFRAME.scenes.length > 0) {
                                        AFRAME.scenes[0].tick();
                                    }
                                }

                                // Restore the flags
                                this.isUpdatingEntities = isUpdatingEntitiesBefore;

                                // Update debug info
                                this.updateDebugInfo();

                                // Log component added
                                this.logCameraEvent(`${componentType} component added with id ${id}`, true);

                                // Show saved indicator
                                this.showSaveIndicator('saved');
                            }
                        }
                    } catch (error) {
                        console.error('Error adding component:', error);
                        this.logCameraEvent(`Error adding component: ${error.message}`, true);
                        this.showSaveIndicator('error');
                    } finally {
                        // Always clear the prevention flag
                        this.preventCameraReset = false;
                    }
                },

                // Get HTML representation of the scene
                getSceneHTML: function () {
                    // Directly get camera element position from DOM
                    const cameraEl = document.getElementById('user-camera');
                    let cameraPos = '0 1.6 0';  // Default fallback
                    let cameraRot = '0 0 0';    // Default fallback

                    if (cameraEl && cameraEl.object3D) {
                        // Get current DOM position - most accurate source
                        const pos = cameraEl.object3D.position;
                        cameraPos = `${pos.x} ${pos.y} ${pos.z}`;

                        if (cameraEl.components && cameraEl.components['look-controls']) {
                            // Get accurate rotation from look-controls
                            const lookControls = cameraEl.components['look-controls'];
                            let pitchX = 0;
                            let yawY = 0;

                            if (lookControls.pitchObject) {
                                pitchX = THREE.MathUtils.radToDeg(lookControls.pitchObject.rotation.x);
                            }

                            if (lookControls.yawObject) {
                                yawY = THREE.MathUtils.radToDeg(lookControls.yawObject.rotation.y);
                            }

                            cameraRot = `${pitchX} ${yawY} 0`;
                        } else {
                            // Fall back to object3D rotation
                            const rot = cameraEl.object3D.rotation;
                            cameraRot = `${THREE.MathUtils.radToDeg(rot.x)} ${THREE.MathUtils.radToDeg(rot.y)} ${THREE.MathUtils.radToDeg(rot.z)}`;
                        }

                        // Also update our camera state objects for consistency
                        this.camera = {
                            position: {
                                x: pos.x,
                                y: pos.y,
                                z: pos.z
                            },
                            rotation: {
                                x: parseFloat(cameraRot.split(' ')[0]),
                                y: parseFloat(cameraRot.split(' ')[1]),
                                z: parseFloat(cameraRot.split(' ')[2])
                            }
                        };

                        // Update scene.camera too
                        if (!this.scene.camera) {
                            this.scene.camera = {};
                        }
                        this.scene.camera.position = Object.assign({}, this.camera.position);
                        this.scene.camera.rotation = Object.assign({}, this.camera.rotation);
                    } else if (this.scene && this.scene.camera && this.scene.camera.position) {
                        // Fallback to scene.camera if DOM element not available
                        const pos = this.scene.camera.position;
                        cameraPos = `${pos.x} ${pos.y} ${pos.z}`;

                        if (this.scene.camera.rotation) {
                            const rot = this.scene.camera.rotation;
                            cameraRot = `${rot.x} ${rot.y} ${rot.z}`;
                        }
                    }

                    console.log("getSceneHTML using camera position:", cameraPos);

                    // Include all camera attributes that might be present
                    let cameraAttributes = 'camera look-controls wasd-controls';

                    // Include networked attribute if NAF enabled
                    if (this.nafEnabled && window.NAF) {
                        cameraAttributes += ' networked="template:#avatar-template;attachTemplateToLocal:false;"';
                    }

                    let html = `<a-entity id="user-camera" position="${cameraPos}" rotation="${cameraRot}" ${cameraAttributes}></a-entity>\n`;

                    // Add all other entities
                    this.scene.entities.forEach(entity => {
                        if (entity.type) {
                            html += `<a-${entity.type} `;
                            // Add all attributes
                            for (const key in entity) {
                                if (key !== 'type') {
                                    html += `${key}="${entity[key]}" `;
                                }
                            }
                            html += '></a-' + entity.type + '>\n';
                        }
                    });

                    // Return the complete HTML
                    return html;
                },

                // Get clean scene HTML that excludes A-Frame internal elements
                getCleanSceneHTML: function (previewScene) {
                    let html = '';

                    // Filter out all internal A-Frame elements and only keep real entity elements
                    const childElements = Array.from(previewScene.children).filter(el => {
                        // Skip any element with these attributes
                        if (el.hasAttribute('aframe-injected') ||
                            el.hasAttribute('data-aframe-inspector') ||
                            el.hasAttribute('data-aframe-default-light') ||
                            el.getAttribute('id') === 'aframeInspectorMouseCursor') {
                            return false;
                        }

                        // Skip user-camera entity (we'll handle it separately where needed)
                        if (el.id === 'user-camera') {
                            return false;
                        }

                        // Skip specific element types that are A-Frame internals
                        const tagName = el.tagName.toLowerCase();
                        if (tagName === 'canvas' ||
                            tagName === 'div' ||
                            el.classList.contains('a-canvas') ||
                            el.classList.contains('a-enter-vr') ||
                            el.classList.contains('a-orientation-modal') ||
                            el.classList.contains('a-loader-title')) {
                            return false;
                        }

                        // Include only A-Frame entity elements
                        return tagName.startsWith('a-');
                    });

                    // Create a temporary container to get innerHTML of filtered elements
                    childElements.forEach(child => {
                        // Get the outer HTML of each element (with its children)
                        html += child.outerHTML + '\n';
                    });

                    return html;
                },

                // Save the current camera state
                saveCameraState: function (reason, targetState = 'active') {
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;

                    const cameraEl = document.getElementById('user-camera');
                    if (cameraEl) {
                        const position = cameraEl.getAttribute('position');
                        const rotation = cameraEl.getAttribute('rotation');

                        if (position && rotation) {
                            const cameraState = {
                                position: { x: position.x, y: position.y, z: position.z },
                                rotation: { x: rotation.x, y: rotation.y, z: rotation.z }
                            };

                            // Update the correct camera state based on the targetState parameter
                            if (targetState === 'build') {
                                this.buildCamera = Object.assign({}, cameraState);
                                console.log(`[Build Camera State Saved] ${reason || ''}`);
                            } else if (targetState === 'default') {
                                if (!this.scene.defaultCamera) {
                                    this.scene.defaultCamera = {};
                                }
                                this.scene.defaultCamera = Object.assign({}, cameraState);
                                console.log(`[Default Camera State Saved] ${reason || ''}`);
                            } else {
                                // 'active' is the default
                                this.activeCamera = Object.assign({}, cameraState);
                                console.log(`[Active Camera State Saved] ${reason || ''}`);
                            }

                            // Log to camera history
                            if (reason) {
                                this.logCameraEvent(`${targetState} camera state saved: ${reason}`, true);
                            }
                        }
                    }
                },

                // Restore the saved camera state
                restoreCameraState: function (reason) {
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;

                    const cameraEl = document.getElementById('user-camera');
                    if (!cameraEl) {
                        console.warn('Could not restore camera: camera entity not found');
                        this.logCameraEvent(`Warning: No camera entity found when restoring state (${reason || ''})`, true);
                        return;
                    }

                    if (!this.camera || !this.camera.position || !this.camera.rotation) {
                        console.warn('Could not restore camera: no saved camera state');
                        this.logCameraEvent(`Warning: No saved camera state to restore (${reason || ''})`, true);
                        return;
                    }

                    // Safety check - make sure the camera has been initialized
                    if (!cameraEl.hasLoaded) {
                        console.warn('Camera entity not loaded yet, cannot restore state');
                        this.logCameraEvent(`Warning: Camera not loaded, cannot restore state (${reason || ''})`, true);
                        return;
                    }

                    try {
                        // Important: Properly format position and rotation as vectors
                        const position = {
                            x: parseFloat(this.camera.position.x),
                            y: parseFloat(this.camera.position.y),
                            z: parseFloat(this.camera.position.z)
                        };

                        const rotation = {
                            x: parseFloat(this.camera.rotation.x),
                            y: parseFloat(this.camera.rotation.y),
                            z: parseFloat(this.camera.rotation.z)
                        };

                        // Verify values are valid numbers, not NaN
                        if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z) ||
                            isNaN(rotation.x) || isNaN(rotation.y) || isNaN(rotation.z)) {
                            console.warn('Invalid camera values detected, using defaults');
                            position.x = 0;
                            position.y = 1.6;
                            position.z = 0;
                            rotation.x = 0;
                            rotation.y = 0;
                            rotation.z = 0;
                        }

                        // Fixed: Set position with detailed object instead of string
                        cameraEl.setAttribute('position', position);
                        cameraEl.setAttribute('rotation', rotation);

                        // Update the object3D directly to ensure consistency
                        if (cameraEl.object3D) {
                            cameraEl.object3D.position.set(position.x, position.y, position.z);
                            cameraEl.object3D.rotation.set(
                                THREE.MathUtils.degToRad(rotation.x),
                                THREE.MathUtils.degToRad(rotation.y),
                                THREE.MathUtils.degToRad(rotation.z)
                            );
                            cameraEl.object3D.updateMatrix();
                            cameraEl.object3D.updateMatrixWorld(true);
                        }

                        // Fix for wasd-controls - we need to properly handle movement
                        if (cameraEl.components && cameraEl.components['wasd-controls']) {
                            const wasdControls = cameraEl.components['wasd-controls'];

                            // Reset the velocity to prevent NaN
                            if (wasdControls.velocity) {
                                wasdControls.velocity.set(0, 0, 0);
                            }

                            // Force wasd-controls to reevaluate position
                            if (typeof wasdControls.updateVelocity === 'function') {
                                wasdControls.updateVelocity();
                            }
                        }

                        // Update look-controls properly
                        if (cameraEl.components && cameraEl.components['look-controls']) {
                            const lookControls = cameraEl.components['look-controls'];

                            // Convert to radians for ThreeJS
                            if (lookControls.pitchObject) {
                                lookControls.pitchObject.rotation.x = THREE.MathUtils.degToRad(rotation.x);
                            }

                            if (lookControls.yawObject) {
                                lookControls.yawObject.rotation.y = THREE.MathUtils.degToRad(rotation.y);
                            }

                            // Update matrices
                            if (lookControls.pitchObject) lookControls.pitchObject.updateMatrix();
                            if (lookControls.yawObject) lookControls.yawObject.updateMatrix();
                        }

                        console.log(`[Camera State Restored] ${reason || ''}: Position (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}), Rotation (${rotation.x.toFixed(2)}, ${rotation.y.toFixed(2)}, ${rotation.z.toFixed(2)})`);

                        // Log to camera history
                        if (reason) {
                            this.logCameraEvent(`State restored: ${reason}`, true);
                        }
                    } catch (error) {
                        console.error('Error restoring camera state:', error);
                        this.logCameraEvent(`Error restoring camera: ${error.message}`, true);
                    }
                },

                // Parse the scene directly from the DOM
                parseSceneFromDOM: function (options) {
                    // Handle different parameter formats
                    let preserveCamera = true;  // Default to preserving camera

                    if (typeof options === 'boolean') {
                        // Legacy call with just boolean
                        preserveCamera = options;
                    } else if (options && typeof options === 'object') {
                        // New format with options object
                        preserveCamera = options.preserveCamera !== false;
                    }

                    console.log("Parsing scene from DOM" + (preserveCamera ? " (preserving camera)" : ""));
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;

                    // Save current camera state if we're preserving it
                    let currentCameraState = null;
                    if (preserveCamera) {
                        // First check if we have a build camera state
                        if (this.buildCamera && this.buildCamera.position) {
                            currentCameraState = {
                                position: Object.assign({}, this.buildCamera.position),
                                rotation: Object.assign({}, this.buildCamera.rotation)
                            };
                            console.log("Preserving build camera state during parse:", currentCameraState);
                        }
                        // If no build camera, try regular camera
                        else if (this.camera) {
                            currentCameraState = {
                                position: Object.assign({}, this.camera.position),
                                rotation: Object.assign({}, this.camera.rotation)
                            };
                            console.log("Preserving scene camera state during parse:", currentCameraState);
                        }
                        // Otherwise capture directly from DOM
                        else {
                            const cameraEl = document.getElementById('user-camera');
                            if (cameraEl && cameraEl.object3D) {
                                currentCameraState = {
                                    position: {
                                        x: cameraEl.object3D.position.x,
                                        y: cameraEl.object3D.position.y,
                                        z: cameraEl.object3D.position.z
                                    },
                                    rotation: {
                                        x: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.x),
                                        y: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.y),
                                        z: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.z)
                                    }
                                };
                                console.log("Captured DOM camera state during parse:", currentCameraState);
                            }
                        }
                    }

                    // Reset scene data
                    this.scene.entities = [];
                    this.scene.assets = [];

                    // Parse all A-Frame entities (excluding the user camera)
                    Array.from(previewScene.children).forEach(child => {
                        if (child.tagName &&
                            child.tagName.toLowerCase().startsWith('a-') &&
                            !child.hasAttribute('aframe-injected') &&
                            child.id !== 'user-camera') {
                            // Build entity data
                            const entityData = {
                                id: child.id || `entity-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
                                tag: child.tagName.toLowerCase(),
                                attributes: {}
                            };

                            // Extract attributes
                            Array.from(child.attributes).forEach(attr => {
                                entityData.attributes[attr.name] = attr.value;
                            });

                            // Add to entities
                            this.scene.entities.push(entityData);
                        }
                    });

                    // Restore camera state if we're preserving it
                    if (preserveCamera && currentCameraState && currentCameraState.position) {
                        // Make sure we have a camera in scene model
                        if (!this.scene.camera) {
                            this.scene.camera = {};
                        }

                        // Update scene model with preserved values
                        this.scene.camera.position = Object.assign({}, currentCameraState.position);
                        this.scene.camera.rotation = Object.assign({}, currentCameraState.rotation);

                        // Update app state too
                        this.camera = {
                            position: Object.assign({}, currentCameraState.position),
                            rotation: Object.assign({}, currentCameraState.rotation)
                        };

                        // Most importantly, also update buildCamera to match
                        if (!this.buildCamera) {
                            this.buildCamera = {};
                        }
                        this.buildCamera.position = Object.assign({}, currentCameraState.position);
                        this.buildCamera.rotation = Object.assign({}, currentCameraState.rotation);
                        this.buildCamera.timestamp = new Date().toISOString();
                        this.buildCamera.source = 'parse-scene-camera-restore';

                        console.log("Restored camera values in all models");
                    }

                    console.log(`Parsed ${this.scene.entities.length} entities from DOM`);
                },

                // Recursively serialize an entity and its children
                serializeEntityRecursive: function (element) {
                    // Build entity data
                    const entityData = {
                        id: element.id || `entity-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
                        tag: element.tagName.toLowerCase(),
                        attributes: this.extractAttributes(element),
                        children: []
                    };

                    // Process children recursively
                    Array.from(element.children).forEach(child => {
                        if (child.tagName &&
                            child.tagName.toLowerCase().startsWith('a-') &&
                            !child.hasAttribute('aframe-injected')) {
                            entityData.children.push(this.serializeEntityRecursive(child));
                        }
                    });

                    return entityData;
                },

                // Show save indicator status
                showSaveIndicator: function (status) {
                    const saveIndicator = document.querySelector('.save-indicator');
                    const saveIndicatorDot = document.querySelector('.save-indicator-dot');
                    const saveIndicatorText = document.querySelector('.save-indicator-text');

                    if (!saveIndicator) return;

                    // Remove all status classes
                    saveIndicatorDot.classList.remove('saving', 'saved', 'error');

                    // Set new status
                    if (status === 'saving') {
                        saveIndicatorDot.classList.add('saving');
                        saveIndicatorText.textContent = 'Saving changes...';
                    } else if (status === 'saved') {
                        saveIndicatorDot.classList.add('saved');
                        saveIndicatorText.textContent = 'Changes saved';
                    } else if (status === 'error') {
                        saveIndicatorDot.classList.add('error');
                        saveIndicatorText.textContent = 'Error saving changes';
                    }

                    // Show indicator
                    saveIndicator.classList.remove('hidden');
                    saveIndicator.classList.add('visible');

                    // Hide after a delay if saved successfully
                    if (status === 'saved') {
                        setTimeout(() => {
                            saveIndicator.classList.remove('visible');
                            saveIndicator.classList.add('hidden');
                        }, 3000);
                    }
                },

                // Initialize debug tools
                initDebugTools: function () {
                    console.log("Setting up debug tools");

                    const debugPanel = document.querySelector('.debug-panel');
                    const teleportButton = document.getElementById('teleport-camera');
                    const logButton = document.getElementById('log-entities');
                    const skyColorButton = document.getElementById('change-sky-color');
                    const checkNafButton = document.getElementById('check-naf');
                    const connectNafButton = document.getElementById('connect-naf');
                    const resetCameraButton = document.getElementById('reset-camera');
                    const resetEditorCameraButton = document.getElementById('reset-editor-camera');
                    const refreshCameraDebugButton = document.getElementById('refresh-camera-debug');

                    // Set direct onclick handlers
                    if (teleportButton) {
                        // Set the correct text
                        teleportButton.textContent = 'Teleport to 0,1.6,5';

                        teleportButton.onclick = () => {
                            console.log("Teleport camera clicked");
                            // Use teleportCamera with correct coordinates
                            this.teleportCamera(0, 1.6, 5);
                            const lastAction = document.getElementById('last-action');
                            if (lastAction) lastAction.textContent = 'Teleported camera';
                        };
                    }

                    if (resetEditorCameraButton) {
                        resetEditorCameraButton.onclick = () => {
                            console.log("Reset editor camera to scene camera clicked");
                            this.resetEditorCameraToScene();
                            const lastAction = document.getElementById('last-action');
                            if (lastAction) lastAction.textContent = 'Reset editor camera to scene camera';
                        };
                    }

                    if (refreshCameraDebugButton) {
                        refreshCameraDebugButton.onclick = () => {
                            console.log("Refreshing camera debug info");

                            // Update camera state first
                            this.updateCameraState();

                            // Then update detailed debug info
                            this.updateCameraDebug();
                            this.updateDebugInfo();

                            // Get current DOM camera position for immediate feedback
                            const cameraEl = document.getElementById('user-camera');
                            if (cameraEl && cameraEl.object3D) {
                                const pos = cameraEl.object3D.position;
                                console.log("Current DOM camera position:", pos);
                            }

                            // Update the last parse time with the current time
                            const lastParseTimeEl = document.getElementById('debug-last-parse-time');
                            if (lastParseTimeEl) {
                                const now = new Date();
                                const timeStr = now.toLocaleTimeString();
                                lastParseTimeEl.innerHTML = `<span style="color:#8f8">${timeStr}</span> (manual refresh)`;
                            }

                            const lastAction = document.getElementById('last-action');
                            if (lastAction) lastAction.textContent = 'Refreshed camera debug info';

                            // Briefly highlight the debug panel to show it was refreshed
                            const debugPanel = document.querySelector('.debug-panel');
                            if (debugPanel) {
                                debugPanel.style.backgroundColor = '#335';
                                setTimeout(() => {
                                    debugPanel.style.backgroundColor = '';
                                }, 300);
                            }
                        };
                    }

                    if (skyColorButton) {
                        skyColorButton.onclick = () => {
                            console.log("Change sky color clicked");
                            this.changeSkyColor();
                            const lastAction = document.getElementById('last-action');
                            if (lastAction) lastAction.textContent = 'Changed sky color';
                            if (typeof this.logCameraEvent === 'function') {
                                this.logCameraEvent('Sky color changed', true);
                            }
                        };
                    }

                    if (checkNafButton) {
                        checkNafButton.onclick = () => {
                            console.log("Check NAF button clicked");
                            this.checkNafStatus();
                            const lastAction = document.getElementById('last-action');
                            if (lastAction) lastAction.textContent = 'NAF status checked';
                        };
                    }

                    if (connectNafButton) {
                        connectNafButton.onclick = () => {
                            console.log("Connect NAF button clicked");
                            this.connectNaf();
                            const lastAction = document.getElementById('last-action');
                            if (lastAction) lastAction.textContent = 'NAF connection initiated';
                        };
                    }

                    if (resetCameraButton) {
                        resetCameraButton.onclick = () => {
                            console.log("Reset camera clicked");
                            this.resetCamera();
                            const lastAction = document.getElementById('last-action');
                            if (lastAction) lastAction.textContent = 'Reset camera';
                            if (typeof this.logCameraEvent === 'function') {
                                this.logCameraEvent('Camera reset to default position', true);
                            }
                        };
                    }

                    // Log entities button
                    if (logButton) {
                        logButton.onclick = () => {
                            console.log("Log entities button clicked");
                            this.logSceneEntities();
                            const lastAction = document.getElementById('last-action');
                            if (lastAction) lastAction.textContent = 'Logged entities';
                        };
                    }
                },

                // Update the history display based on the current mode
                updateHistoryDisplay: function () {
                    console.log("Updating history display, mode:", this.historyMode);
                    const historyLog = document.getElementById('camera-history-log');
                    if (!historyLog) return;

                    // Make sure the correct tab is active
                    const debugPanel = document.querySelector('.debug-panel');
                    if (debugPanel) {
                        const tabs = debugPanel.querySelectorAll('.history-tab');
                        tabs.forEach(tab => {
                            const tabMode = tab.getAttribute('data-mode');
                            if (tabMode === this.historyMode) {
                                tab.classList.add('active');
                            } else {
                                tab.classList.remove('active');
                            }
                        });
                    }

                    let entries = [];

                    if (this.historyMode === 'all') {
                        // Combine and sort all history entries by timestamp
                        entries = [...this.cameraHistory, ...this.entityHistory]
                            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                            .reverse(); // Show oldest first
                    } else if (this.historyMode === 'camera') {
                        entries = [...this.cameraHistory]; // Use a copy to avoid modifying the original
                    } else if (this.historyMode === 'entity') {
                        entries = [...this.entityHistory]; // Use a copy to avoid modifying the original
                    }

                    historyLog.innerHTML = entries.map(entry =>
                        `<div class="camera-history-entry">${entry.timestamp}: ${entry.event}</div>`
                    ).join('');

                    // Auto-scroll to bottom
                    historyLog.scrollTop = historyLog.scrollHeight;
                },

                // Track significant camera changes
                trackCameraChanges: function () {
                    const cameraEl = document.getElementById('user-camera');
                    if (!cameraEl) return;

                    const pos = cameraEl.getAttribute('position');
                    const rot = cameraEl.getAttribute('rotation');

                    if (!pos || !rot) return;

                    // Always update the active camera regardless of mode
                    this.activeCamera = {
                        position: { x: pos.x, y: pos.y, z: pos.z },
                        rotation: { x: rot.x, y: rot.y, z: rot.z }
                    };

                    // When in build mode, update the build camera state
                    if (this.currentCameraMode === 'build' || !this.currentCameraMode) {
                        if (!this.buildCamera) {
                            this.buildCamera = {};
                        }

                        // Important: Create new objects to avoid reference issues
                        this.buildCamera.position = {
                            x: pos.x,
                            y: pos.y,
                            z: pos.z
                        };

                        this.buildCamera.rotation = {
                            x: rot.x,
                            y: rot.y,
                            z: rot.z
                        };

                        this.buildCamera.timestamp = new Date().toISOString();
                        this.buildCamera.source = 'tracking';

                        // Update menu if open
                        const cameraMenu = document.getElementById('camera-menu');
                        if (cameraMenu && cameraMenu.classList.contains('active')) {
                            this.updateBuilderCameraInfo();
                        }

                        // Debug output to verify builder camera state is updating
                        console.log("Builder camera updated:",
                            `pos(${this.buildCamera.position.x.toFixed(2)}, ${this.buildCamera.position.y.toFixed(2)}, ${this.buildCamera.position.z.toFixed(2)})`);
                    }

                    // Store for comparison in next update
                    this.lastCameraPosition = { x: pos.x, y: pos.y, z: pos.z };
                    this.lastCameraRotation = { x: rot.x, y: rot.y, z: rot.z };
                },

                // Log camera event with timestamp
                logCameraEvent: function (event, includeEntityCount = false) {
                    if (!this.cameraHistory) {
                        this.cameraHistory = [];
                    }

                    if (!this.entityHistory) {
                        this.entityHistory = [];
                    }

                    const timestamp = new Date().toLocaleTimeString();

                    // Determine if this is an entity-related event or camera-related event
                    const isEntityEvent = event.toLowerCase().includes('entity') ||
                        event.toLowerCase().includes('component') ||
                        event.toLowerCase().includes('scene') ||
                        event.toLowerCase().includes('sky');

                    // Add entity count if requested
                    if (includeEntityCount) {
                        const previewScene = document.getElementById('preview-scene');
                        if (previewScene) {
                            const entities = Array.from(previewScene.children).filter(el =>
                                el.tagName &&
                                el.tagName.toLowerCase().startsWith('a-') &&
                                !el.hasAttribute('aframe-injected')
                            );

                            const count = entities.length;
                            const types = {};

                            // Count by entity type
                            entities.forEach(entity => {
                                const type = entity.tagName.toLowerCase();
                                types[type] = (types[type] || 0) + 1;
                            });

                            // Format entity counts
                            const typeStr = Object.entries(types)
                                .map(([type, count]) => `${type}:${count}`)
                                .join(', ');

                            event += ` | Entities: ${count} (${typeStr})`;
                        }
                    }

                    // Add to the appropriate history array
                    const historyEntry = { timestamp, event };

                    if (isEntityEvent) {
                        // Keep max 20 entity history entries
                        if (this.entityHistory.length >= 20) {
                            this.entityHistory.shift();
                        }
                        this.entityHistory.push(historyEntry);
                    } else {
                        // Keep max 20 camera history entries
                        if (this.cameraHistory.length >= 20) {
                            this.cameraHistory.shift();
                        }
                        this.cameraHistory.push(historyEntry);
                    }

                    // Update the UI based on current mode
                    this.updateHistoryDisplay();

                    // Also log to console for debugging
                    console.log(`[${isEntityEvent ? 'Entity' : 'Camera'} Event] ${timestamp}: ${event}`);
                },

                // Update debug information
                updateDebugInfo: function () {
                    // Get camera info
                    const cameraEl = document.getElementById('user-camera');
                    if (cameraEl && cameraEl.object3D) {
                        // Update camera entity info with more details
                        const cameraInfo = document.getElementById('entity-camera-info');
                        if (cameraInfo) {
                            // Get position and rotation attribute strings
                            const posAttr = cameraEl.getAttribute('position');
                            const rotAttr = cameraEl.getAttribute('rotation');

                            const posAttrStr = posAttr ?
                                `attr:(${posAttr.x.toFixed(2)},${posAttr.y.toFixed(2)},${posAttr.z.toFixed(2)})` :
                                'no position attr';

                            const rotAttrStr = rotAttr ?
                                `attr:(${rotAttr.x.toFixed(2)},${rotAttr.y.toFixed(2)},${rotAttr.z.toFixed(2)})` :
                                'no rotation attr';

                            // Get object3D values
                            const obj3dPos = cameraEl.object3D.position;
                            const obj3dPosStr = `obj3d:(${obj3dPos.x.toFixed(2)},${obj3dPos.y.toFixed(2)},${obj3dPos.z.toFixed(2)})`;

                            // Format the camera entity info
                            const cameraId = cameraEl.id || 'unnamed';
                            const hasLookControls = cameraEl.hasAttribute('look-controls') ? 'look:yes' : 'look:no';
                            const hasWasdControls = cameraEl.hasAttribute('wasd-controls') ? 'wasd:yes' : 'wasd:no';

                            // Create comprehensive info string
                            cameraInfo.textContent = `${cameraId} ${hasLookControls} ${hasWasdControls} ${posAttrStr} ${obj3dPosStr}`;
                        }

                        // Update stored camera state display
                        const storedStateDisplay = document.getElementById('camera-stored-state');
                        if (storedStateDisplay && this.camera) {
                            const pos = this.camera.position;
                            const rot = this.camera.rotation;
                            const cameraStateText = `app:(${pos.x.toFixed(2)},${pos.y.toFixed(2)},${pos.z.toFixed(2)}) scene:(${this.scene.camera?.position?.x.toFixed(2) || '?'},${this.scene.camera?.position?.y.toFixed(2) || '?'},${this.scene.camera?.position?.z.toFixed(2) || '?'})`;
                            storedStateDisplay.textContent = cameraStateText;
                        }
                    }

                    // Update entity count
                    const entityCountEl = document.getElementById('entity-count');
                    if (entityCountEl) {
                        const previewScene = document.getElementById('preview-scene');
                        if (previewScene) {
                            const entities = Array.from(previewScene.children).filter(el =>
                                el.tagName &&
                                el.tagName.toLowerCase().startsWith('a-') &&
                                !el.hasAttribute('aframe-injected')
                            );
                            entityCountEl.textContent = entities.length.toString();
                        }
                    }

                    // Update NAF status if available
                    const nafStatusEl = document.getElementById('naf-status');
                    if (nafStatusEl && window.NAF) {
                        if (NAF.connection.isConnected()) {
                            nafStatusEl.textContent = `Connected to ${NAF.connection.adapterName} (Room: ${NAF.room})`;
                            nafStatusEl.className = 'text-success';
                        } else {
                            nafStatusEl.textContent = 'NAF Available (Not Connected)';
                            nafStatusEl.className = 'text-warning';
                        }
                    }
                },

                // Update detailed camera debug information
                updateCameraDebug: function () {
                    // Update basic camera info in debug panel
                    const cameraPositionDisplay = document.getElementById('camera-position');
                    const cameraRotationDisplay = document.getElementById('camera-rotation');
                    const cameraEntityDisplay = document.getElementById('camera-entity');
                    const storedStateDisplay = document.getElementById('stored-camera-state');

                    // Get user camera
                    const userCamera = document.getElementById('user-camera');

                    if (userCamera) {
                        const pos = userCamera.getAttribute('position');
                        const rot = userCamera.getAttribute('rotation');

                        // Update position display
                        if (cameraPositionDisplay && pos) {
                            cameraPositionDisplay.textContent = `${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}`;
                        }

                        // Update rotation display
                        if (cameraRotationDisplay && rot) {
                            cameraRotationDisplay.textContent = `${rot.x.toFixed(2)}, ${rot.y.toFixed(2)}, ${rot.z.toFixed(2)}`;
                        }

                        // Update entity info display
                        if (cameraEntityDisplay) {
                            const hasLook = userCamera.hasAttribute('look-controls') ? 'yes' : 'no';
                            const hasWASD = userCamera.hasAttribute('wasd-controls') ? 'yes' : 'no';
                            const attrPos = pos ? `(${pos.x.toFixed(2)},${pos.y.toFixed(2)},${pos.z.toFixed(2)})` : 'unknown';
                            const obj3dPos = userCamera.object3D ?
                                `(${userCamera.object3D.position.x.toFixed(2)},${userCamera.object3D.position.y.toFixed(2)},${userCamera.object3D.position.z.toFixed(2)})` :
                                'unknown';

                            cameraEntityDisplay.textContent = `user-camera look:${hasLook} wasd:${hasWASD} attr:${attrPos} obj3d:${obj3dPos}`;
                        }

                        // Update stored state display
                        if (storedStateDisplay) {
                            const buildCameraInfo = this.buildCamera?.position ?
                                `(${this.buildCamera.position.x.toFixed(2)},${this.buildCamera.position.y.toFixed(2)},${this.buildCamera.position.z.toFixed(2)})` :
                                'null';

                            const activeCameraInfo = this.activeCamera?.position ?
                                `(${this.activeCamera.position.x.toFixed(2)},${this.activeCamera.position.y.toFixed(2)},${this.activeCamera.position.z.toFixed(2)})` :
                                'null';

                            const sceneCameraInfo = this.scene.camera?.position ?
                                `(${this.scene.camera.position.x.toFixed(2)},${this.scene.camera.position.y.toFixed(2)},${this.scene.camera.position.z.toFixed(2)})` :
                                'null';

                            const modeText = this.currentCameraMode || 'unknown';

                            storedStateDisplay.innerHTML =
                                `<b>Mode:</b> ${modeText.toUpperCase()} | ` +
                                `<b>Build:</b> ${buildCameraInfo} | ` +
                                `<b>Active:</b> ${activeCameraInfo} | ` +
                                `<b>Scene:</b> ${sceneCameraInfo}`;
                        }

                        // Update detailed camera debug info
                        const editorCameraDisplay = document.getElementById('editor-camera');
                        const appCameraDisplay = document.getElementById('app-camera');
                        const sceneCameraDisplay = document.getElementById('scene-camera');
                        const domCameraDisplay = document.getElementById('dom-camera');

                        if (editorCameraDisplay) {
                            editorCameraDisplay.textContent = JSON.stringify(this.buildCamera || null, null, 2);
                        }

                        if (appCameraDisplay) {
                            appCameraDisplay.textContent = JSON.stringify(this.activeCamera || null, null, 2);
                        }

                        if (sceneCameraDisplay) {
                            sceneCameraDisplay.textContent = JSON.stringify(this.scene.camera || null, null, 2);
                        }

                        if (domCameraDisplay) {
                            const cameraData = {
                                position: pos,
                                rotation: rot,
                                el: userCamera ? userCamera.id : null,
                                parent: userCamera && userCamera.parentElement ? userCamera.parentElement.id : null
                            };
                            domCameraDisplay.textContent = JSON.stringify(cameraData, null, 2);
                        }
                    } else {
                        // No camera found
                        if (cameraEntityDisplay) {
                            cameraEntityDisplay.textContent = 'None';
                        }

                        if (storedStateDisplay) {
                            storedStateDisplay.textContent = 'Not available';
                        }
                    }
                },

                // Teleport the camera to a specific position
                teleportCamera: function (x, y, z) {
                    console.log(`Teleporting camera to (${x}, ${y}, ${z})`);
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;

                    // We want to keep rotation at 0 0 0 regardless of the position
                    // This simulates stepping back without turning around
                    const rotation = '0 0 0';

                    // Update camera entity
                    const cameraEl = document.getElementById('user-camera');
                    if (cameraEl) {
                        cameraEl.setAttribute('position', `${x} ${y} ${z}`);
                        cameraEl.setAttribute('rotation', rotation);

                        // Update our stored camera state
                        this.scene.camera.position = { x, y, z };

                        // Parse the rotation string to get the values
                        const rotValues = rotation.split(' ').map(parseFloat);
                        this.scene.camera.rotation = {
                            x: rotValues[0],
                            y: rotValues[1],
                            z: rotValues[2]
                        };

                        // Force look-controls to update if it exists
                        if (cameraEl.components && cameraEl.components['look-controls']) {
                            const lookControls = cameraEl.components['look-controls'];
                            const yRot = rotValues[1] * Math.PI / 180; // Convert to radians
                            if (lookControls.pitchObject) lookControls.pitchObject.rotation.x = 0;
                            if (lookControls.yawObject) lookControls.yawObject.rotation.y = 0; // Keep at 0
                        }

                        // Update debug UI
                        this.updateDebugInfo();
                        if (typeof this.logCameraEvent === 'function') {
                            this.logCameraEvent(`Camera teleported to (${x}, ${y}, ${z}) with default forward orientation`, true);
                        }
                    } else {
                        console.warn("Cannot find camera entity to teleport");
                    }
                },

                // Reset camera to default position
                resetCamera: function () {
                    const cameraEl = document.getElementById('user-camera');
                    if (!cameraEl) return;

                    try {
                        // Set default position (0,1.6,0) and rotation
                        const defaultPosition = { x: 0, y: 1.6, z: 0 }; // Reset to origin
                        const defaultRotation = { x: 0, y: 0, z: 0 };

                        // Update camera attributes
                        cameraEl.setAttribute('position', defaultPosition);
                        cameraEl.setAttribute('rotation', defaultRotation);

                        // Reset object3D directly
                        if (cameraEl.object3D) {
                            cameraEl.object3D.position.set(defaultPosition.x, defaultPosition.y, defaultPosition.z);
                            cameraEl.object3D.rotation.set(0, 0, 0);
                            cameraEl.object3D.updateMatrix();
                            cameraEl.object3D.updateMatrixWorld(true);
                        }

                        // Clean any dangling references in look-controls
                        if (cameraEl.components && cameraEl.components['look-controls']) {
                            const lookControls = cameraEl.components['look-controls'];
                            if (lookControls.pitchObject) {
                                lookControls.pitchObject.rotation.x = 0;
                                lookControls.pitchObject.updateMatrix();
                            }
                            if (lookControls.yawObject) {
                                lookControls.yawObject.rotation.y = 0;
                                lookControls.yawObject.updateMatrix();
                            }
                        }

                        // Reset wasd-controls velocity
                        if (cameraEl.components && cameraEl.components['wasd-controls']) {
                            const wasdControls = cameraEl.components['wasd-controls'];
                            if (wasdControls.velocity) {
                                wasdControls.velocity.set(0, 0, 0);
                            }
                        }

                        // Save as current camera state
                        this.camera = {
                            position: Object.assign({}, defaultPosition),
                            rotation: Object.assign({}, defaultRotation)
                        };

                        this.logCameraEvent(`Camera reset to default position (0, 1.6, 0)`, true);
                        console.log('Camera reset to default position');

                        // Update debug display
                        this.updateDebugInfo();
                    } catch (error) {
                        console.error('Error resetting camera:', error);
                        this.logCameraEvent(`Error resetting camera: ${error.message}`, true);
                    }
                },

                // Log all scene entities to console for debugging
                logSceneEntities: function () {
                    console.log("Logging scene entities");
                    console.log('Scene entities in model:', this.scene.entities);

                    const previewScene = document.getElementById('preview-scene');
                    if (previewScene) {
                        const entities = Array.from(previewScene.children).filter(el =>
                            el.tagName &&
                            el.tagName.toLowerCase().startsWith('a-') &&
                            !el.hasAttribute('aframe-injected')
                        );

                        // Log to console
                        console.log('Camera entity:', document.getElementById('user-camera'));
                        console.log('All entities in DOM:');
                        entities.forEach(el => {
                            console.log(`${el.id || 'unknown-id'}:`, el);
                        });

                        // Log to history with detailed entity counts
                        this.logCameraEvent(`Entities logged: ${entities.length} total`, true);

                        // Add log entries for each entity
                        const entityDetails = entities.map(entity => {
                            const type = entity.tagName.toLowerCase();
                            const id = entity.id || 'unknown-id';
                            const pos = entity.getAttribute('position');
                            const posStr = pos ? `(${pos.x.toFixed(1)},${pos.y.toFixed(1)},${pos.z.toFixed(1)})` : '';
                            return `${type} ${id} ${posStr}`;
                        });

                        // Log up to 5 entities in detail to avoid overwhelming the history
                        entityDetails.slice(0, 5).forEach(detail => {
                            this.logCameraEvent(`Entity: ${detail}`);
                        });

                        if (entityDetails.length > 5) {
                            this.logCameraEvent(`...and ${entityDetails.length - 5} more entities`);
                        }
                    }

                    // Update last action display
                    const lastAction = document.getElementById('last-action');
                    if (lastAction) lastAction.textContent = 'Logged entities to console and history';
                },

                // Change the sky color randomly for visual testing
                changeSkyColor: function () {
                    const colors = ['#ECECEC', '#87CEEB', '#FFA07A', '#B0E0E6', '#FFD700', '#E6E6FA'];
                    const randomColor = colors[Math.floor(Math.random() * colors.length)];

                    const sky = document.querySelector('a-sky');
                    if (sky) {
                        console.log(`Changing sky color to ${randomColor}`);
                        sky.setAttribute('color', randomColor);

                        // Update our model
                        this.parseSceneFromDOM();
                        this.updateEditor();
                    } else {
                        console.warn('No sky entity found');
                    }
                },

                // Start application 
                init: function () {
                    console.log("Starting A-Frame Builder...");

                    // Make sure A-Frame has loaded
                    const scene = document.getElementById('preview-scene');
                    if (scene.hasLoaded) {
                        console.log("Scene already loaded, initializing");
                        this.initialize();
                    } else {
                        console.log("Waiting for scene to load");
                        scene.addEventListener('loaded', () => {
                            console.log("Scene loaded, initializing");
                            this.initialize();
                        });
                    }

                    // Set up camera position monitoring
                    this.startCameraMonitoring();
                },

                flushAllEntitiesToDOM: function () {
                    if (AFRAME && AFRAME.scenes && AFRAME.scenes.length > 0) {
                        const aframeScene = AFRAME.scenes[0];
                        // Flush entire scene
                        if (aframeScene.hasLoaded) {
                            aframeScene.flushToDOM(true);
                        }
                    }
                },

                // Request permission for an operation (can be overridden for different implementations)
                requestPermission: function (operation) {
                    // Default implementation - check if permission features are enabled
                    const permissionEnabled =
                        this.requirePermissionForEntityCreation ||
                        this.requirePermissionForEntityAddition ||
                        this.requirePermissionForEntityRemoval ||
                        this.requirePermissionForComponentChange;

                    if (!permissionEnabled) {
                        // If permissions are not enabled, always allow
                        return true;
                    }

                    // Log permission request
                    console.log(`[Permission] Requesting permission for: ${operation}`);

                    // In this default implementation, we'll just confirm with the user
                    const granted = confirm(`Allow operation: ${operation}?`);

                    // Log result
                    console.log(`[Permission] ${granted ? 'Granted' : 'Denied'}: ${operation}`);

                    // Log to history if available
                    if (typeof this.logCameraEvent === 'function') {
                        this.logCameraEvent(`Permission ${granted ? 'granted' : 'denied'}: ${operation}`, true);
                    }

                    return granted;
                },

                // Add support for networked entities
                addNetworkedComponent: function (entityEl) {
                    // Only add if NAF is available
                    if (window.NAF && !entityEl.hasAttribute('networked')) {
                        entityEl.setAttribute('networked', {
                            template: '#entity-template',
                            networkId: `${entityEl.id}-${Date.now()}`,
                            owner: 'scene'
                        });
                    }
                },

                // Add to state object
                nafEnabled: false,
                nafTemplates: {
                    avatar: '#avatar-template',
                    entity: '#entity-template'
                },

                // Add NAF initialization method
                initNetworkedAframe: function () {
                    console.log("Checking for Networked-Aframe library");

                    // Get the NAF status element
                    const nafStatus = document.getElementById('naf-status');

                    try {
                        // Simple check for NAF existence
                        if (typeof window.NAF !== 'undefined') {
                            console.log("NAF detected - ready for manual connection");
                            this.nafEnabled = true;

                            // Update status to indicate NAF is available but not connected
                            if (nafStatus) {
                                nafStatus.textContent = 'Available (Not Connected)';
                                nafStatus.className = 'text-warning';
                            }

                            // Create templates for later use when connecting
                            this.logCameraEvent('Networked-Aframe library detected (not connected)', true);
                        } else {
                            // NAF is not available
                            this.nafEnabled = false;

                            // Update NAF status display
                            if (nafStatus) {
                                nafStatus.textContent = 'Not Available';
                                nafStatus.className = 'text-danger';
                            }

                            console.log("Networked-Aframe is not available");
                        }
                    } catch (error) {
                        // Handle any errors
                        console.error("Error checking NAF:", error);
                        this.nafEnabled = false;

                        if (nafStatus) {
                            nafStatus.textContent = 'Error';
                            nafStatus.className = 'text-danger';
                        }
                    }
                },

                // Add to state object
                applyStateToScene: function () {
                    // Flag to prevent circular updates
                    this.isUpdatingFromState = true;

                    try {
                        const previewScene = document.getElementById('preview-scene');
                        if (!previewScene) return;

                        // Clear current entities except camera
                        const currentEntities = Array.from(previewScene.children).filter(el =>
                            el.tagName &&
                            el.tagName.toLowerCase().startsWith('a-') &&
                            el.id !== 'user-camera' &&
                            !el.hasAttribute('aframe-injected')
                        );

                        currentEntities.forEach(entity => {
                            previewScene.removeChild(entity);
                        });

                        // Add entities from state
                        this.scene.entities.forEach(entityData => {
                            const entity = document.createElement(entityData.tag);

                            // Set attributes
                            Object.entries(entityData.attributes).forEach(([key, value]) => {
                                entity.setAttribute(key, value);
                            });

                            // Add to scene
                            previewScene.appendChild(entity);
                        });

                        // Flush to DOM
                        this.flushAllEntitiesToDOM();

                        // Update editor
                        this.updateEditor();
                    } finally {
                        // Reset flag
                        setTimeout(() => {
                            this.isUpdatingFromState = false;
                        }, 100);
                    }
                },

                // Add error recovery method
                recoverFromError: function (error, context) {
                    console.error(`Error in ${context}:`, error);

                    // Log to history
                    if (typeof this.logCameraEvent === 'function') {
                        this.logCameraEvent(`Error in ${context}: ${error.message}`, true);
                    }

                    // Show error indicator
                    this.showSaveIndicator('error');

                    // Reset update flag to prevent lock
                    this.isUpdatingFromState = false;

                    // Attempt to recover by parsing from DOM
                    try {
                        this.parseSceneFromDOM();
                        this.updateEditor();
                    } catch (recoveryError) {
                        console.error("Recovery failed:", recoveryError);
                    }
                },

                // Check NAF status
                checkNafStatus: function () {
                    // Update the NAF status indicator
                    const nafStatus = document.getElementById('naf-status');

                    if (window.NAF) {
                        console.log("NAF is available");

                        if (window.NAF.connection) {
                            console.log("NAF connection is available");

                            // Check connection status
                            if (window.NAF.connection.isConnected()) {
                                console.log("NAF is connected");
                                if (nafStatus) {
                                    nafStatus.textContent = 'Connected';
                                    nafStatus.className = 'text-success';
                                }
                                this.logCameraEvent('NAF check: Connected to network', true);
                            } else {
                                console.log("NAF is not connected");
                                if (nafStatus) {
                                    nafStatus.textContent = 'Initialized (Not Connected)';
                                    nafStatus.className = 'text-warning';
                                }
                                this.logCameraEvent('NAF check: Not connected to network', true);
                            }

                            // Log connection details if available
                            if (window.NAF.connection.adapter) {
                                const adapter = window.NAF.connection.adapter;
                                console.log("NAF adapter:", adapter.constructor.name);

                                // Get room information if available
                                if (adapter.room) {
                                    console.log("NAF room:", adapter.room);
                                    this.logCameraEvent(`NAF room: ${adapter.room}`, false);
                                }

                                // Get connected clients if available
                                if (typeof adapter.getConnectedClients === 'function') {
                                    const clients = adapter.getConnectedClients();
                                    console.log("NAF connected clients:", clients);
                                    this.logCameraEvent(`NAF clients: ${Object.keys(clients).length} connected`, false);
                                }
                            }
                        } else {
                            console.log("NAF connection is not initialized");
                            if (nafStatus) {
                                nafStatus.textContent = 'Available (Not Initialized)';
                                nafStatus.className = 'text-warning';
                            }
                            this.logCameraEvent('NAF check: NAF is available but not initialized', true);

                            // Try to initialize NAF
                            this.logCameraEvent('Attempting to initialize NAF...', false);
                            this.initNetworkedAframe();
                        }
                    } else {
                        console.log("NAF is not available");
                        if (nafStatus) {
                            nafStatus.textContent = 'Not Available';
                            nafStatus.className = 'text-danger';
                        }
                        this.logCameraEvent('NAF check: NAF library is not available', true);

                        // Include information about what's needed to enable NAF
                        this.logCameraEvent('To enable NAF, include networked-aframe.min.js in your page', false);
                    }

                    // Update debug display
                    this.updateDebugInfo();
                },

                // Connect NAF
                connectNaf: function () {
                    console.log("Connecting to NAF...");
                    this.connectToNAFServer();
                },

                // NAF - Connect to server manually
                connectToNAFServer: function () {
                    try {
                        if (!window.NAF) {
                            console.log("NAF library not found, can't connect");
                            this.logCameraEvent('NAF library not detected, cannot connect to server', true);
                            const nafStatus = document.getElementById('naf-status');
                            if (nafStatus) {
                                nafStatus.textContent = 'Library Not Found';
                                nafStatus.className = 'text-danger';
                            }
                            return;
                        }

                        // Try to fix THREE.Math.DEG2RAD issue
                        if (window.THREE && !window.THREE.Math) {
                            console.log("Fixing THREE.Math reference for NAF");
                            window.THREE.Math = {
                                DEG2RAD: Math.PI / 180,
                                RAD2DEG: 180 / Math.PI
                            };
                        }

                        const nafStatus = document.getElementById('naf-status');
                        if (nafStatus) {
                            nafStatus.textContent = 'Connecting...';
                            nafStatus.className = 'text-warning';
                        }

                        // Get the server URL from the input field
                        const serverUrlInput = document.getElementById('naf-server-url');
                        const serverURL = serverUrlInput ? serverUrlInput.value : 'https://networked-aframe-dev-server.herokuapp.com';

                        // Get the room name from the input field
                        const roomNameInput = document.getElementById('naf-room-name');
                        const roomName = roomNameInput ? roomNameInput.value : 'test-room';

                        // Log the connection info
                        console.log(`Connecting to NAF server: ${serverURL}, room: ${roomName}`);
                        this.logCameraEvent(`Connecting to NAF server: ${serverURL}, room: ${roomName}`, true);

                        // Ensure NAF templates are in the scene
                        this.ensureNAFTemplates();

                        // Add networked-scene component to the scene if it doesn't exist
                        const previewScene = document.getElementById('preview-scene');
                        if (previewScene && !previewScene.hasAttribute('networked-scene')) {
                            // Set up connection to the specified server
                            previewScene.setAttribute('networked-scene', {
                                serverURL: serverURL,       // Use the custom URL
                                app: 'aframe-builder-app',  // Namespace
                                room: roomName,             // Use the custom room name
                                debug: true,                // Debug mode
                                adapter: 'socketio',        // Using socket.io adapter
                                audio: false                // No audio for simplicity
                            });

                            this.logCameraEvent('Added networked-scene component', true);
                        }

                        // Make sure camera is networked if needed
                        const cameraEl = document.getElementById('user-camera');
                        if (cameraEl && !cameraEl.hasAttribute('networked')) {
                            cameraEl.setAttribute('networked', {
                                template: this.nafTemplates.avatar,
                                networkId: `user-camera-${Date.now()}`,
                                owner: 'scene'
                            });
                        }

                        // Set up connection event listeners
                        if (window.NAF.connection) {
                            window.NAF.connection.subscribeToDataChannel('connection-event', (senderId, dataType, data) => {
                                console.log('Connection event:', senderId, dataType, data);
                                this.logCameraEvent(`NAF connection event from ${senderId}: ${dataType}`, false);
                            });

                            // Listen for client connected
                            document.body.addEventListener('clientConnected', (evt) => {
                                const clientId = evt.detail.clientId;
                                console.log('clientConnected event:', clientId);
                                this.logCameraEvent(`New client connected: ${clientId}`, true);
                            });

                            // Listen for client disconnected
                            document.body.addEventListener('clientDisconnected', (evt) => {
                                const clientId = evt.detail.clientId;
                                console.log('clientDisconnected event:', clientId);
                                this.logCameraEvent(`Client disconnected: ${clientId}`, true);
                            });
                        }

                        // Check connection status after a delay
                        setTimeout(() => {
                            this.updateDebugInfo();
                            if (window.NAF.connection && window.NAF.connection.isConnected()) {
                                this.logCameraEvent('Successfully connected to NAF server', true);
                                if (nafStatus) {
                                    nafStatus.textContent = 'Connected';
                                    nafStatus.className = 'text-success';
                                }

                                // Add the networked component to all entities
                                this.addNetworkToEntities();
                            } else {
                                this.logCameraEvent('Failed to connect to NAF server', true);
                                if (nafStatus) {
                                    nafStatus.textContent = 'Connection Failed';
                                    nafStatus.className = 'text-danger';
                                }
                            }
                        }, 3000);
                    } catch (error) {
                        console.error("Error connecting to NAF:", error);
                        this.logCameraEvent(`Error connecting to NAF: ${error.message}`, true);

                        const nafStatus = document.getElementById('naf-status');
                        if (nafStatus) {
                            nafStatus.textContent = 'Connection Error';
                            nafStatus.className = 'text-danger';
                        }
                    }
                },

                // Add networked component to all entities
                addNetworkToEntities: function () {
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;

                    // Get all entities
                    const entities = Array.from(previewScene.children).filter(el =>
                        el.tagName &&
                        el.tagName.toLowerCase().startsWith('a-') &&
                        !el.hasAttribute('aframe-injected') &&
                        el.id !== 'user-camera' // Skip camera as it's already networked
                    );

                    // Add networked component to each entity
                    entities.forEach(entity => {
                        if (!entity.hasAttribute('networked')) {
                            this.addNetworkedComponent(entity);
                            this.logCameraEvent(`Added networked component to ${entity.tagName.toLowerCase()} with ID ${entity.id || 'unknown'}`, false);
                        }
                    });

                    console.log(`Added networking to ${entities.length} entities`);
                    this.logCameraEvent(`Added networking to ${entities.length} entities`, true);
                },

                // Ensure NAF templates are in the scene
                ensureNAFTemplates: function () {
                    try {
                        const previewScene = document.getElementById('preview-scene');
                        if (!previewScene) return;

                        // Get or create a-assets element
                        let assetsEl = previewScene.querySelector('a-assets');
                        if (!assetsEl) {
                            assetsEl = document.createElement('a-assets');
                            previewScene.prepend(assetsEl); // Insert at the beginning
                            console.log('Created a-assets element for NAF templates');
                        }

                        // Add avatar template if not already present
                        if (!document.getElementById('avatar-template')) {
                            console.log('Creating avatar template');
                            const avatarTemplate = document.createElement('template');
                            avatarTemplate.id = 'avatar-template';
                            avatarTemplate.innerHTML = `
                                <a-entity class="avatar">
                                    <a-sphere color="#5985ff" scale="0.45 0.5 0.4"></a-sphere>
                                </a-entity>
                            `;
                            assetsEl.appendChild(avatarTemplate);
                        }

                        // Add entity template if not already present
                        if (!document.getElementById('entity-template')) {
                            console.log('Creating entity template');
                            const entityTemplate = document.createElement('template');
                            entityTemplate.id = 'entity-template';
                            entityTemplate.innerHTML = `
                                <a-entity class="networked-entity">
                                </a-entity>
                            `;
                            assetsEl.appendChild(entityTemplate);
                        }

                        // Flush to DOM to ensure templates are available to NAF
                        if (previewScene.flushToDOM) {
                            previewScene.flushToDOM(true);
                        }

                        console.log('NAF templates ensured');
                    } catch (error) {
                        console.error("Error ensuring NAF templates:", error);
                        this.logCameraEvent(`Error with NAF templates: ${error.message}`, true);
                    }
                },

                // When making any change:
                updateEntity: function (entityId, newAttributes) {
                    // 1. Update the model first
                    const entityIndex = this.scene.entities.findIndex(e => e.id === entityId);
                    if (entityIndex >= 0) {
                        // Merge attributes
                        this.scene.entities[entityIndex].attributes = {
                            ...this.scene.entities[entityIndex].attributes,
                            ...newAttributes
                        };

                        // 2. Then update the DOM
                        this.applyModelToDOM();


                        // 3. Update UI representations (editor, inspector)
                        this.updateEditor();
                    }
                },

                // Apply model changes to DOM
                applyModelToDOM: function () {
                    const previewScene = document.getElementById('preview-scene');
                    if (!previewScene) return;

                    // Set flag to prevent circular updates
                    this.isUpdatingFromState = true;

                    try {
                        // Apply model changes to DOM
                        this.updateSceneFromModel(previewScene);

                        // Force A-Frame to process the changes
                        this.flushAllEntitiesToDOM();
                    } finally {
                        // Reset flag to allow event-based updates again
                        setTimeout(() => {
                            this.isUpdatingFromState = false;
                        }, 100);
                    }
                },

                // Add state versioning
                stateHistory: [],
                currentStateIndex: -1,

                saveStateVersion: function () {
                    // Create a deep copy of the current state
                    const stateCopy = JSON.parse(JSON.stringify(this.scene));

                    // If we're not at the latest state, remove future states
                    if (this.currentStateIndex < this.stateHistory.length - 1) {
                        this.stateHistory = this.stateHistory.slice(0, this.currentStateIndex + 1);
                    }

                    // Add new state to history
                    this.stateHistory.push(stateCopy);
                    this.currentStateIndex = this.stateHistory.length - 1;

                    // Limit history size
                    if (this.stateHistory.length > 50) {
                        this.stateHistory.shift();
                        this.currentStateIndex--;
                    }

                    // Update undo/redo buttons
                    this.updateUndoRedoUI();
                },

                // Fix common camera issues
                fixCameraIssues: function () {
                    // Get camera element
                    const cameraEl = document.getElementById('user-camera');
                    if (!cameraEl || !cameraEl.object3D) return;

                    // Fix NaN position values
                    const pos = cameraEl.object3D.position;
                    if (isNaN(pos.x) || isNaN(pos.y) || isNaN(pos.z)) {
                        console.warn("Fixing NaN position values in camera");

                        // Get a valid position, trying different sources
                        let validPos = { x: 0, y: 1.6, z: 5 };

                        // Try from model
                        if (this.camera && this.camera.position) {
                            const modelPos = this.camera.position;
                            if (!isNaN(modelPos.x) && !isNaN(modelPos.y) && !isNaN(modelPos.z)) {
                                validPos = modelPos;
                            }
                        }

                        // Apply fix
                        pos.set(validPos.x, validPos.y, validPos.z);
                        cameraEl.setAttribute('position', validPos);

                        // Log the fix
                        this.logCameraEvent(`Fixed NaN camera position: (${validPos.x.toFixed(2)}, ${validPos.y.toFixed(2)}, ${validPos.z.toFixed(2)})`, true);
                    }

                    // Fix NaN rotation values
                    const rot = cameraEl.object3D.rotation;
                    if (isNaN(rot.x) || isNaN(rot.y) || isNaN(rot.z)) {
                        console.warn("Fixing NaN rotation values in camera");

                        // Get valid rotation
                        let validRot = { x: 0, y: 0, z: 0 };

                        // Try from model
                        if (this.camera && this.camera.rotation) {
                            const modelRot = this.camera.rotation;
                            if (!isNaN(modelRot.x) && !isNaN(modelRot.y) && !isNaN(modelRot.z)) {
                                validRot = {
                                    x: THREE.MathUtils.degToRad(modelRot.x),
                                    y: THREE.MathUtils.degToRad(modelRot.y),
                                    z: THREE.MathUtils.degToRad(modelRot.z)
                                };
                            }
                        }

                        // Apply fix
                        rot.set(validRot.x, validRot.y, validRot.z);
                        cameraEl.setAttribute('rotation', {
                            x: THREE.MathUtils.radToDeg(validRot.x),
                            y: THREE.MathUtils.radToDeg(validRot.y),
                            z: THREE.MathUtils.radToDeg(validRot.z)
                        });

                        // Log the fix
                        this.logCameraEvent(`Fixed NaN camera rotation`, true);
                    }

                    // Fix look-controls
                    if (cameraEl.components && cameraEl.components['look-controls']) {
                        const lookControls = cameraEl.components['look-controls'];

                        if (lookControls.pitchObject && isNaN(lookControls.pitchObject.rotation.x)) {
                            console.warn("Fixing NaN pitch rotation in look-controls");
                            lookControls.pitchObject.rotation.x = 0;
                            lookControls.pitchObject.updateMatrix();
                        }

                        if (lookControls.yawObject && isNaN(lookControls.yawObject.rotation.y)) {
                            console.warn("Fixing NaN yaw rotation in look-controls");
                            lookControls.yawObject.rotation.y = 0;
                            lookControls.yawObject.updateMatrix();
                        }
                    }

                    // Fix wasd-controls
                    if (cameraEl.components && cameraEl.components['wasd-controls']) {
                        const wasdControls = cameraEl.components['wasd-controls'];

                        if (wasdControls.velocity) {
                            if (isNaN(wasdControls.velocity.x) || isNaN(wasdControls.velocity.y) || isNaN(wasdControls.velocity.z)) {
                                console.warn("Fixing NaN velocity in wasd-controls");
                                wasdControls.velocity.set(0, 0, 0);

                                // Try to reset component
                                if (wasdControls.updateVelocity) {
                                    wasdControls.updateVelocity();
                                }
                            }
                        }
                    }

                    // Update our model to match the fixed camera
                    this.updateCameraInModel();
                },

                // Update the camera position in our model from DOM
                updateCameraInModel: function () {
                    const cameraEl = document.getElementById('user-camera');
                    if (!cameraEl || !cameraEl.object3D) return;

                    // Get the current position and rotation
                    const pos = cameraEl.object3D.position;
                    let rot = { x: 0, y: 0, z: 0 };

                    // Get rotation from look-controls if available
                    if (cameraEl.components && cameraEl.components['look-controls']) {
                        const lookControls = cameraEl.components['look-controls'];

                        if (lookControls.pitchObject && !isNaN(lookControls.pitchObject.rotation.x)) {
                            rot.x = THREE.MathUtils.radToDeg(lookControls.pitchObject.rotation.x);
                        }

                        if (lookControls.yawObject && !isNaN(lookControls.yawObject.rotation.y)) {
                            rot.y = THREE.MathUtils.radToDeg(lookControls.yawObject.rotation.y);
                        }
                    } else {
                        // Fallback to object3D rotation
                        rot.x = THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.x);
                        rot.y = THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.y);
                        rot.z = THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.z);
                    }

                    // Update our model
                    if (!this.scene.camera) {
                        this.scene.camera = {};
                    }

                    this.scene.camera.position = {
                        x: pos.x,
                        y: pos.y,
                        z: pos.z
                    };

                    this.scene.camera.rotation = {
                        x: rot.x,
                        y: rot.y,
                        z: rot.z
                    };

                    // Also update main app camera reference
                    this.camera = {
                        position: Object.assign({}, this.scene.camera.position),
                        rotation: Object.assign({}, this.scene.camera.rotation)
                    };
                },

                // Start monitoring camera position for NaN values
                startCameraMonitoring: function () {
                    // Avoid duplicate monitors
                    if (this._cameraMonitorInterval) {
                        clearInterval(this._cameraMonitorInterval);
                    }

                    // Check camera position every 200ms
                    this._cameraMonitorInterval = setInterval(() => {
                        const cameraEl = document.getElementById('user-camera');
                        if (!cameraEl || !cameraEl.object3D) return;

                        const pos = cameraEl.object3D.position;

                        // Check for NaN values
                        if (isNaN(pos.x) || isNaN(pos.y) || isNaN(pos.z)) {
                            console.warn("NaN detected in camera position during monitoring");
                            this.fixCameraIssues();
                            this.logCameraEvent("Fixed NaN camera position during movement", true);
                        }

                        // Also check wasd-controls for NaN velocity
                        if (cameraEl.components && cameraEl.components['wasd-controls']) {
                            const wasdControls = cameraEl.components['wasd-controls'];
                            if (wasdControls.velocity) {
                                if (isNaN(wasdControls.velocity.x) ||
                                    isNaN(wasdControls.velocity.y) ||
                                    isNaN(wasdControls.velocity.z)) {
                                    console.warn("NaN detected in wasd-controls velocity");
                                    wasdControls.velocity.set(0, 0, 0);

                                    if (wasdControls.updateVelocity) {
                                        wasdControls.updateVelocity();
                                    }
                                }
                            }
                        }
                    }, 200);
                },

                // Initialize the editor field
                initEditor: function () {
                    console.log("Initializing editor...");
                    const editorContainer = document.getElementById('editor-container');
                    if (!editorContainer) return;

                    try {
                        // Create Monaco editor
                        this.editor = monaco.editor.create(editorContainer, {
                            value: '<a-scene>\n  <!-- Your A-Frame scene here -->\n</a-scene>',
                            language: 'html',
                            minimap: { enabled: false },
                            theme: 'vs-dark',
                            automaticLayout: true,
                            wordWrap: 'on',
                            lineNumbers: 'on',
                            tabSize: 2,
                            scrollBeyondLastLine: false
                        });

                        // Set up change listener with debounce
                        let lastValue = this.editor.getValue();
                        let timeout = null;

                        this.editor.onDidChangeModelContent(() => {
                            clearTimeout(timeout);

                            timeout = setTimeout(() => {
                                // Only apply if content actually changed
                                const newValue = this.editor.getValue();
                                if (newValue !== lastValue) {
                                    console.log("Editor content changed, applying to preview...");

                                    lastValue = newValue;

                                    // IMPORTANT: When editing HTML, we need to ensure camera state is preserved
                                    const cameraEl = document.getElementById('user-camera');
                                    let savedCameraPosition = null;
                                    let savedCameraRotation = null;

                                    // Save current camera state before applying HTML changes
                                    if (cameraEl && cameraEl.object3D) {
                                        // Get position directly from object3D
                                        savedCameraPosition = {
                                            x: cameraEl.object3D.position.x,
                                            y: cameraEl.object3D.position.y,
                                            z: cameraEl.object3D.position.z
                                        };

                                        // Get rotation from look-controls if available
                                        if (cameraEl.components && cameraEl.components['look-controls']) {
                                            const lookControls = cameraEl.components['look-controls'];
                                            savedCameraRotation = {
                                                x: lookControls.pitchObject ? THREE.MathUtils.radToDeg(lookControls.pitchObject.rotation.x) : 0,
                                                y: lookControls.yawObject ? THREE.MathUtils.radToDeg(lookControls.yawObject.rotation.y) : 0,
                                                z: 0
                                            };
                                        } else {
                                            // Fallback to object3D rotation
                                            savedCameraRotation = {
                                                x: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.x),
                                                y: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.y),
                                                z: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.z)
                                            };
                                        }

                                        // Store the position and rotation for use in applyChangesToPreview
                                        if (!this.scene.camera) {
                                            this.scene.camera = {};
                                        }

                                        // Update both data models
                                        this.scene.camera.position = Object.assign({}, savedCameraPosition);
                                        this.scene.camera.rotation = Object.assign({}, savedCameraRotation);

                                        this.camera = {
                                            position: Object.assign({}, savedCameraPosition),
                                            rotation: Object.assign({}, savedCameraRotation)
                                        };

                                        console.log("Preserved camera position from editor change:", savedCameraPosition);
                                    }

                                    // Show saving indicator
                                    this.showSaveIndicator('saving');

                                    // Apply changes to the preview scene, preserving camera
                                    this.applyChangesToPreview(newValue, true);
                                }
                            }, 500); // 500ms debounce
                        });

                        console.log("Editor initialized successfully");
                    } catch (error) {
                        console.error("Error initializing editor:", error);
                    }
                },

                // Handle changes from A-Frame editor
                handleEditorChanges: function (changes) {
                    // Apply the changes to the preview
                    this.applyChangesToPreview(changes, this.preventCameraReset);
                },

                // Save editor camera state (separate from scene camera)
                saveEditorCameraState: function (source) {
                    const cameraEl = document.getElementById('user-camera');
                    if (!cameraEl || !cameraEl.object3D) return null;

                    // Get position directly from object3D for accuracy
                    const position = {
                        x: cameraEl.object3D.position.x,
                        y: cameraEl.object3D.position.y,
                        z: cameraEl.object3D.position.z
                    };

                    // Get rotation - prefer look-controls for user camera
                    let rotation = { x: 0, y: 0, z: 0 };

                    if (cameraEl.components && cameraEl.components['look-controls']) {
                        const lookControls = cameraEl.components['look-controls'];

                        rotation = {
                            x: lookControls.pitchObject ? THREE.MathUtils.radToDeg(lookControls.pitchObject.rotation.x) : 0,
                            y: lookControls.yawObject ? THREE.MathUtils.radToDeg(lookControls.yawObject.rotation.y) : 0,
                            z: 0
                        };
                    } else {
                        // Fall back to object3D rotation
                        rotation = {
                            x: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.x),
                            y: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.y),
                            z: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.z)
                        };
                    }

                    // Save to editor camera state - this is separate from the scene camera
                    this.editorCamera = {
                        position: Object.assign({}, position),
                        rotation: Object.assign({}, rotation),
                        timestamp: new Date().toISOString(),
                        source: source || 'manual'
                    };

                    console.log("Saved editor camera state:", this.editorCamera);

                    return this.editorCamera;
                },

                // Restore editor camera state (separate from scene camera)
                restoreEditorCameraState: function (source) {
                    const cameraEl = document.getElementById('user-camera');
                    if (!cameraEl || !this.editorCamera || !this.editorCamera.position) {
                        console.warn("Cannot restore editor camera - missing camera element or saved state");
                        return false;
                    }

                    const pos = this.editorCamera.position;
                    const rot = this.editorCamera.rotation || { x: 0, y: 0, z: 0 };

                    console.log(`Restoring editor camera to: pos(${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}) rot(${rot.x.toFixed(2)}, ${rot.y.toFixed(2)}, ${rot.z.toFixed(2)})`);

                    // Set position directly
                    cameraEl.object3D.position.set(pos.x, pos.y, pos.z);

                    // Set rotation
                    if (cameraEl.components && cameraEl.components['look-controls']) {
                        const lookControls = cameraEl.components['look-controls'];

                        if (lookControls.pitchObject) {
                            lookControls.pitchObject.rotation.x = THREE.MathUtils.degToRad(rot.x);
                            lookControls.pitchObject.updateMatrix();
                        }

                        if (lookControls.yawObject) {
                            lookControls.yawObject.rotation.y = THREE.MathUtils.degToRad(rot.y);
                            lookControls.yawObject.updateMatrix();
                        }
                    } else {
                        // Fall back to object3D rotation
                        const rotX = THREE.MathUtils.degToRad(rot.x);
                        const rotY = THREE.MathUtils.degToRad(rot.y);
                        const rotZ = THREE.MathUtils.degToRad(rot.z);
                        cameraEl.object3D.rotation.set(rotX, rotY, rotZ);
                    }

                    // Update attributes to match
                    cameraEl.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
                    cameraEl.setAttribute('rotation', `${rot.x} ${rot.y} ${rot.z}`);

                    // Force A-Frame to update
                    if (AFRAME && AFRAME.scenes && AFRAME.scenes.length > 0) {
                        const aframeScene = AFRAME.scenes[0];
                        if (aframeScene.renderStarted) {
                            aframeScene.tick();
                        }
                    }

                    // Log to history
                    this.logCameraEvent(`Editor camera restored from ${source || 'unknown'}`, true);

                    return true;
                },

                // Reset editor camera to match scene camera or default position
                resetEditorCameraToScene: function () {
                    // Get the scene camera state (from HTML representation)
                    const sceneCamera = this.scene.camera;

                    if (sceneCamera && sceneCamera.position) {
                        // Use scene camera position
                        this.editorCamera = {
                            position: Object.assign({}, sceneCamera.position),
                            rotation: Object.assign({}, sceneCamera.rotation || { x: 0, y: 0, z: 0 }),
                            timestamp: new Date().toISOString(),
                            source: 'scene-reset'
                        };
                    } else {
                        // Use default camera position
                        this.editorCamera = {
                            position: { x: 0, y: 1.6, z: 0 },
                            rotation: { x: 0, y: 0, z: 0 },
                            timestamp: new Date().toISOString(),
                            source: 'default-reset'
                        };
                    }

                    // Restore the editor camera
                    this.restoreEditorCameraState('reset');

                    // Log to history
                    this.logCameraEvent("Editor camera reset to match scene camera", true);
                },

                // Sync scene camera from HTML to editor camera (for editing in HTML mode)
                syncCameraWithHTML: function () {
                    // Parse the editor value to get camera information
                    const editorValue = this.editor.getValue();
                    if (!editorValue) return;

                    // Create temporary element to parse the HTML
                    const template = document.createElement('template');
                    template.innerHTML = editorValue.trim();

                    // Look for camera elements
                    const cameraElements = Array.from(template.content.querySelectorAll('a-entity[camera], a-camera'));

                    if (cameraElements.length > 0) {
                        // Take the first camera element
                        const cameraEl = cameraElements[0];

                        // Parse position and rotation
                        let position = { x: 0, y: 1.6, z: 0 };
                        let rotation = { x: 0, y: 0, z: 0 };

                        // Get position
                        const posAttr = cameraEl.getAttribute('position');
                        if (posAttr) {
                            if (typeof posAttr === 'string') {
                                const parts = posAttr.split(' ').map(p => parseFloat(p) || 0);
                                position = { x: parts[0] || 0, y: parts[1] || 0, z: parts[2] || 0 };
                            } else if (typeof posAttr === 'object') {
                                position = { x: posAttr.x || 0, y: posAttr.y || 0, z: posAttr.z || 0 };
                            }
                        }

                        // Get rotation
                        const rotAttr = cameraEl.getAttribute('rotation');
                        if (rotAttr) {
                            if (typeof rotAttr === 'string') {
                                const parts = rotAttr.split(' ').map(p => parseFloat(p) || 0);
                                rotation = { x: parts[0] || 0, y: parts[1] || 0, z: parts[2] || 0 };
                            } else if (typeof rotAttr === 'object') {
                                rotation = { x: rotAttr.x || 0, y: rotAttr.y || 0, z: rotAttr.z || 0 };
                            }
                        }

                        // Update the scene camera
                        this.scene.camera = {
                            position: position,
                            rotation: rotation
                        };

                        // Log that we found a camera in the HTML
                        console.log("Found camera in HTML, updating scene camera:", this.scene.camera);

                        // Return true to indicate we found a camera
                        return true;
                    }

                    return false;
                },

                saveBuildCameraState: function (source) {
                    const cameraEl = document.getElementById('user-camera');
                    if (!cameraEl || !cameraEl.object3D) return null;

                    // Get position directly from object3D for accuracy
                    const position = {
                        x: cameraEl.object3D.position.x,
                        y: cameraEl.object3D.position.y,
                        z: cameraEl.object3D.position.z
                    };

                    // Get rotation - prefer look-controls for user camera
                    let rotation = { x: 0, y: 0, z: 0 };

                    if (cameraEl.components && cameraEl.components['look-controls']) {
                        const lookControls = cameraEl.components['look-controls'];

                        rotation = {
                            x: lookControls.pitchObject ? THREE.MathUtils.radToDeg(lookControls.pitchObject.rotation.x) : 0,
                            y: lookControls.yawObject ? THREE.MathUtils.radToDeg(lookControls.yawObject.rotation.y) : 0,
                            z: 0
                        };
                    } else {
                        // Fall back to object3D rotation
                        rotation = {
                            x: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.x),
                            y: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.y),
                            z: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.z)
                        };
                    }

                    // Save to build camera state
                    this.buildCamera = {
                        position: Object.assign({}, position),
                        rotation: Object.assign({}, rotation),
                        timestamp: new Date().toISOString(),
                        source: source || 'manual'
                    };

                    console.log("Saved build camera state:", this.buildCamera);

                    return this.buildCamera;
                },

                restoreBuildCameraState: function (source) {
                    const cameraEl = document.getElementById('user-camera');
                    if (!cameraEl || !this.buildCamera || !this.buildCamera.position) {
                        console.warn("Cannot restore build camera - missing camera element or saved state");
                        return false;
                    }

                    const pos = this.buildCamera.position;
                    const rot = this.buildCamera.rotation || { x: 0, y: 0, z: 0 };

                    console.log(`Restoring build camera to: pos(${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}) rot(${rot.x.toFixed(2)}, ${rot.y.toFixed(2)}, ${rot.z.toFixed(2)})`);

                    // Set position directly
                    cameraEl.object3D.position.set(pos.x, pos.y, pos.z);

                    // Convert numeric rotation if needed
                    const rotX = typeof rot.x === 'number' ? rot.x : parseFloat(rot.x) || 0;
                    const rotY = typeof rot.y === 'number' ? rot.y : parseFloat(rot.y) || 0;
                    const rotZ = typeof rot.z === 'number' ? rot.z : parseFloat(rot.z) || 0;

                    // Set rotation - handle radians vs degrees properly
                    if (cameraEl.components && cameraEl.components['look-controls']) {
                        const lookControls = cameraEl.components['look-controls'];

                        if (lookControls.pitchObject) {
                            lookControls.pitchObject.rotation.x = THREE.MathUtils.degToRad(rotX);
                            lookControls.pitchObject.updateMatrix();
                        }

                        if (lookControls.yawObject) {
                            lookControls.yawObject.rotation.y = THREE.MathUtils.degToRad(rotY);
                            lookControls.yawObject.updateMatrix();
                        }
                    } else {
                        // Fall back to object3D rotation
                        cameraEl.object3D.rotation.set(
                            THREE.MathUtils.degToRad(rotX),
                            THREE.MathUtils.degToRad(rotY),
                            THREE.MathUtils.degToRad(rotZ)
                        );
                    }

                    // Update DOM attributes
                    cameraEl.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
                    cameraEl.setAttribute('rotation', `${rotX} ${rotY} ${rotZ}`);

                    // Update current active camera state
                    this.activeCamera = {
                        position: { x: pos.x, y: pos.y, z: pos.z },
                        rotation: { x: rotX, y: rotY, z: rotZ }
                    };

                    // Log the operation
                    this.logCameraEvent(`Build camera restored from ${source || 'unknown'}`, true);

                    return true;
                },

                resetBuildCameraToDefault: function () {
                    // Get the default camera state
                    const defaultCamera = this.scene.defaultCamera;

                    if (defaultCamera && defaultCamera.position) {
                        // Use default camera position
                        this.buildCamera = {
                            position: Object.assign({}, defaultCamera.position),
                            rotation: Object.assign({}, defaultCamera.rotation || { x: 0, y: 0, z: 0 }),
                            timestamp: new Date().toISOString(),
                            source: 'default-reset'
                        };
                    } else {
                        // Use fallback default camera position
                        this.buildCamera = {
                            position: { x: 0, y: 1.6, z: 0 },
                            rotation: { x: 0, y: 0, z: 0 },
                            timestamp: new Date().toISOString(),
                            source: 'fallback-reset'
                        };
                    }

                    // Restore the build camera
                    this.restoreBuildCameraState('reset-to-default');

                    // Log to history
                    this.logCameraEvent("Build camera reset to match default camera", true);
                },

                switchToBuildCamera: function () {
                    // Only restore if we have a saved build camera state
                    if (!this.buildCamera || !this.buildCamera.position) {
                        console.warn("No build camera state to restore");
                        return;
                    }

                    // Restore the build camera
                    this.restoreBuildCameraState('camera-menu-switch');

                    // Set the current camera mode
                    this.currentCameraMode = 'build';
                    this.currentSceneCameraId = null;

                    // Begin continuous build camera updating
                    this.startContinuousBuildCameraUpdate();

                    // Log the camera switch
                    this.logCameraEvent("Switched to builder camera", true);
                },

                switchToDefaultCamera: function () {
                    if (this.scene.defaultCamera) {
                        const cameraEl = document.getElementById('user-camera');
                        if (cameraEl) {
                            const pos = this.scene.defaultCamera.position;
                            const rot = this.scene.defaultCamera.rotation || { x: 0, y: 0, z: 0 };

                            // Set camera position and rotation
                            cameraEl.object3D.position.set(pos.x, pos.y, pos.z);

                            // Update look-controls if applicable
                            if (cameraEl.components && cameraEl.components['look-controls']) {
                                const lookControls = cameraEl.components['look-controls'];

                                if (lookControls.pitchObject) {
                                    lookControls.pitchObject.rotation.x = THREE.MathUtils.degToRad(rot.x);
                                    lookControls.pitchObject.updateMatrix();
                                }

                                if (lookControls.yawObject) {
                                    lookControls.yawObject.rotation.y = THREE.MathUtils.degToRad(rot.y);
                                    lookControls.yawObject.updateMatrix();
                                }
                            } else {
                                // Fall back to object3D rotation
                                const rotX = THREE.MathUtils.degToRad(rot.x);
                                const rotY = THREE.MathUtils.degToRad(rot.y);
                                const rotZ = THREE.MathUtils.degToRad(rot.z);
                                cameraEl.object3D.rotation.set(rotX, rotY, rotZ);
                            }

                            // Update attributes
                            cameraEl.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
                            cameraEl.setAttribute('rotation', `${rot.x} ${rot.y} ${rot.z}`);

                            // Update active camera
                            this.activeCamera = {
                                position: Object.assign({}, pos),
                                rotation: Object.assign({}, rot)
                            };

                            // Log the change
                            this.logCameraEvent("Switched to default camera", true);
                        }
                    } else {
                        console.warn("No default camera state available");
                    }
                },

                findSceneCameras: function () {
                    const sceneCameras = [];
                    const sceneEl = document.getElementById('preview-scene');
                    if (!sceneEl) return sceneCameras;

                    // Find all camera entities (a-camera) in the scene
                    const cameraEls = sceneEl.querySelectorAll('a-camera, [camera]');

                    // Process each camera
                    cameraEls.forEach((cameraEl, index) => {
                        // Include the user-camera but mark it specially
                        const isUserCamera = cameraEl.id === 'user-camera';

                        const cameraId = cameraEl.id || `scene-camera-${index}`;
                        const position = cameraEl.getAttribute('position');
                        const rotation = cameraEl.getAttribute('rotation');

                        // Get camera name from data-name attribute or generate one
                        let cameraName = cameraEl.getAttribute('data-name') ||
                            cameraEl.getAttribute('name') ||
                            (isUserCamera ? 'Default Camera' : `Camera ${index + 1}`);

                        sceneCameras.push({
                            id: cameraId,
                            el: cameraEl,
                            name: cameraName,
                            isUserCamera: isUserCamera,
                            position: position ? {
                                x: position.x || 0,
                                y: position.y || 0,
                                z: position.z || 0
                            } : { x: 0, y: 1.6, z: 0 },
                            rotation: rotation ? {
                                x: rotation.x || 0,
                                y: rotation.y || 0,
                                z: rotation.z || 0
                            } : { x: 0, y: 0, z: 0 }
                        });
                    });

                    return sceneCameras;
                },

                updateCameraMenu: function () {
                    const sceneCamerasList = document.getElementById('scene-cameras-list');
                    if (!sceneCamerasList) return;

                    // Clear existing camera list
                    sceneCamerasList.innerHTML = '';

                    // Get all scene cameras
                    const sceneCameras = this.findSceneCameras();

                    // No scene cameras found
                    if (sceneCameras.length === 0) {
                        const noCamerasEl = document.createElement('div');
                        noCamerasEl.className = 'camera-option';
                        noCamerasEl.textContent = 'No scene cameras found';
                        noCamerasEl.style.fontStyle = 'italic';
                        noCamerasEl.style.color = '#999';
                        sceneCamerasList.appendChild(noCamerasEl);
                        return;
                    }

                    // Add each scene camera to the menu
                    sceneCameras.forEach(camera => {
                        const cameraOptionEl = document.createElement('div');
                        cameraOptionEl.className = 'camera-option';
                        cameraOptionEl.setAttribute('data-camera-id', camera.id);

                        // Set active state if this is the current camera
                        if (this.currentCameraMode === 'scene' && this.currentSceneCameraId === camera.id) {
                            cameraOptionEl.classList.add('active');
                        } else if (this.currentCameraMode === 'default' && camera.isUserCamera) {
                            cameraOptionEl.classList.add('active');
                        }

                        // Main camera name
                        const cameraNameEl = document.createElement('div');

                        // For the user camera, show it as "Default Camera" with special styling
                        if (camera.isUserCamera) {
                            cameraNameEl.textContent = `${camera.name} [Default]`;
                            cameraOptionEl.classList.add('default-camera');
                        } else {
                            cameraNameEl.textContent = camera.name;
                        }

                        cameraOptionEl.appendChild(cameraNameEl);

                        // Camera position info
                        const cameraInfoEl = document.createElement('div');
                        cameraInfoEl.className = 'camera-info';
                        const pos = camera.position;
                        cameraInfoEl.textContent = `Pos: ${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
                        cameraOptionEl.appendChild(cameraInfoEl);

                        // Add click handler
                        cameraOptionEl.addEventListener('click', () => {
                            // For user camera, we restore the original scene default camera state
                            if (camera.isUserCamera) {
                                this.resetToDefaultCamera();
                            } else {
                                this.switchToSceneCamera(camera.id);
                            }
                            this.toggleCameraMenu(false);
                        });

                        sceneCamerasList.appendChild(cameraOptionEl);
                    });

                    // Update active state
                    this.updateCameraMenuActiveState();
                },

                toggleCameraMenu: function (show) {
                    const cameraMenu = document.getElementById('camera-menu');
                    if (!cameraMenu) return;

                    if (show === undefined) {
                        // Toggle if no specific state provided
                        cameraMenu.classList.toggle('active');
                    } else {
                        // Set to specific state
                        if (show) {
                            cameraMenu.classList.add('active');
                        } else {
                            cameraMenu.classList.remove('active');
                        }
                    }

                    // Update the camera list when opening
                    if (cameraMenu.classList.contains('active')) {
                        this.updateCameraMenu();
                        this.updateBuilderCameraInfo(); // Update builder camera position
                    }
                },

                switchToSceneCamera: function (cameraId) {
                    const sceneCameras = this.findSceneCameras();
                    const camera = sceneCameras.find(cam => cam.id === cameraId);

                    if (!camera) {
                        console.warn(`Camera with ID ${cameraId} not found`);
                        return;
                    }

                    console.log(`Switching to scene camera: ${camera.name}`);

                    // Save builder camera state first if needed
                    this.saveBuildCameraState('before-camera-switch');

                    // Get user camera (our controllable camera)
                    const userCameraEl = document.getElementById('user-camera');

                    if (userCameraEl) {
                        // Set position and rotation to match scene camera
                        userCameraEl.setAttribute('position', camera.position);
                        userCameraEl.setAttribute('rotation', camera.rotation);

                        // Update camera controls if they exist
                        if (userCameraEl.components && userCameraEl.components['look-controls']) {
                            const lookControls = userCameraEl.components['look-controls'];

                            if (lookControls.pitchObject) {
                                lookControls.pitchObject.rotation.x = THREE.MathUtils.degToRad(camera.rotation.x);
                                lookControls.pitchObject.updateMatrix();
                            }

                            if (lookControls.yawObject) {
                                lookControls.yawObject.rotation.y = THREE.MathUtils.degToRad(camera.rotation.y);
                                lookControls.yawObject.updateMatrix();
                            }
                        }

                        // Update the active camera state
                        this.activeCamera = {
                            position: Object.assign({}, camera.position),
                            rotation: Object.assign({}, camera.rotation)
                        };

                        // Set the current camera mode
                        this.currentCameraMode = 'scene';
                        this.currentSceneCameraId = cameraId;

                        // Log the camera switch
                        this.logCameraEvent(`Switched to scene camera: ${camera.name}`, true);
                    }
                },

                switchToBuildCamera: function () {
                    // Only restore if we have a saved build camera state
                    if (!this.buildCamera || !this.buildCamera.position) {
                        console.warn("No build camera state to restore");
                        return;
                    }

                    // Restore the build camera
                    this.restoreBuildCameraState('camera-menu-switch');

                    // Set the current camera mode
                    this.currentCameraMode = 'build';
                    this.currentSceneCameraId = null;

                    // Begin continuous build camera updating
                    this.startContinuousBuildCameraUpdate();

                    // Log the camera switch
                    this.logCameraEvent("Switched to builder camera", true);
                },

                initCameraController: function () {
                    // Make sure we have a build camera state initialized
                    if (!this.buildCamera || !this.buildCamera.position) {
                        const cameraEl = document.getElementById('user-camera');
                        if (cameraEl) {
                            // Use direct position for accuracy
                            this.buildCamera = {
                                position: {
                                    x: cameraEl.object3D.position.x,
                                    y: cameraEl.object3D.position.y,
                                    z: cameraEl.object3D.position.z
                                },
                                rotation: {
                                    x: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.x),
                                    y: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.y),
                                    z: THREE.MathUtils.radToDeg(cameraEl.object3D.rotation.z)
                                },
                                timestamp: new Date().toISOString(),
                                source: 'initialization'
                            };

                            // Force log to verify initial position
                            console.log("Initial builder camera position set:",
                                `(${this.buildCamera.position.x.toFixed(2)}, ${this.buildCamera.position.y.toFixed(2)}, ${this.buildCamera.position.z.toFixed(2)})`);
                        } else {
                            this.buildCamera = {
                                position: { x: 0, y: 1.6, z: 0 },
                                rotation: { x: 0, y: 0, z: 0 },
                                timestamp: new Date().toISOString(),
                                source: 'initialization'
                            };
                        }
                    }

                    // Set initial camera mode to build
                    this.currentCameraMode = 'build';
                    this.currentSceneCameraId = null;

                    // Set up camera switch button
                    const cameraSwitchBtn = document.getElementById('camera-switch-btn');
                    if (cameraSwitchBtn) {
                        cameraSwitchBtn.addEventListener('click', () => {
                            this.toggleCameraMenu();
                        });
                    }

                    // Set up builder camera option
                    const builderCameraOption = document.querySelector('.camera-option[data-camera="builder"]');
                    if (builderCameraOption) {
                        // Mark builder camera as active by default
                        builderCameraOption.classList.add('active');

                        // Add position info
                        const infoEl = document.createElement('div');
                        infoEl.className = 'camera-info';
                        const pos = this.buildCamera.position;
                        infoEl.textContent = `Pos: ${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
                        builderCameraOption.appendChild(infoEl);

                        builderCameraOption.addEventListener('click', () => {
                            this.switchToBuildCamera();
                            this.toggleCameraMenu(false);
                        });
                    }

                    // Close menu if clicking outside
                    document.addEventListener('click', (event) => {
                        const cameraMenu = document.getElementById('camera-menu');
                        const cameraSwitchBtn = document.getElementById('camera-switch-btn');

                        if (cameraMenu && cameraSwitchBtn) {
                            if (!cameraMenu.contains(event.target) && !cameraSwitchBtn.contains(event.target)) {
                                this.toggleCameraMenu(false);
                            }
                        }
                    });

                    // Initial camera menu update
                    this.updateCameraMenu();

                    console.log("Camera controller initialized");

                    // Start continuous build camera updating
                    this.startContinuousBuildCameraUpdate();
                },

                resetToDefaultCamera: function () {
                    // The user-camera is our default scene camera
                    const userCameraEl = document.getElementById('user-camera');

                    if (userCameraEl) {
                        // If we have a saved default position in scene.defaultCamera, use that
                        if (this.scene.defaultCamera && this.scene.defaultCamera.position) {
                            // Set position and rotation to match default
                            userCameraEl.setAttribute('position', this.scene.defaultCamera.position);
                            userCameraEl.setAttribute('rotation', this.scene.defaultCamera.rotation || { x: 0, y: 0, z: 0 });

                            // Update look-controls if they exist
                            if (userCameraEl.components && userCameraEl.components['look-controls']) {
                                const lookControls = userCameraEl.components['look-controls'];
                                const rot = this.scene.defaultCamera.rotation || { x: 0, y: 0, z: 0 };

                                if (lookControls.pitchObject) {
                                    lookControls.pitchObject.rotation.x = THREE.MathUtils.degToRad(rot.x);
                                    lookControls.pitchObject.updateMatrix();
                                }

                                if (lookControls.yawObject) {
                                    lookControls.yawObject.rotation.y = THREE.MathUtils.degToRad(rot.y);
                                    lookControls.yawObject.updateMatrix();
                                }
                            }

                            // Update active camera state
                            this.activeCamera = {
                                position: Object.assign({}, this.scene.defaultCamera.position),
                                rotation: Object.assign({}, this.scene.defaultCamera.rotation || { x: 0, y: 0, z: 0 })
                            };
                        } else {
                            // Reset to initial default camera position
                            userCameraEl.setAttribute('position', '0 1.6 0');
                            userCameraEl.setAttribute('rotation', '0 0 0');

                            // Update look-controls
                            if (userCameraEl.components && userCameraEl.components['look-controls']) {
                                const lookControls = userCameraEl.components['look-controls'];

                                if (lookControls.pitchObject) {
                                    lookControls.pitchObject.rotation.x = 0;
                                    lookControls.pitchObject.updateMatrix();
                                }

                                if (lookControls.yawObject) {
                                    lookControls.yawObject.rotation.y = 0;
                                    lookControls.yawObject.updateMatrix();
                                }
                            }

                            // Update active camera state
                            this.activeCamera = {
                                position: { x: 0, y: 1.6, z: 0 },
                                rotation: { x: 0, y: 0, z: 0 }
                            };
                        }

                        // Set current mode
                        this.currentCameraMode = 'default';
                        this.currentSceneCameraId = 'user-camera';

                        // Log camera change
                        this.logCameraEvent("Reset to default camera position", true);
                    }
                },

                updateCameraMenuActiveState: function () {
                    // Clear active state from all options
                    document.querySelectorAll('.camera-option').forEach(option => {
                        option.classList.remove('active');
                    });

                    // Set active state based on current mode
                    if (this.currentCameraMode === 'build' || !this.currentCameraMode) {
                        const builderOption = document.querySelector('.camera-option[data-camera="builder"]');
                        if (builderOption) {
                            builderOption.classList.add('active');
                        }
                    } else if (this.currentCameraMode === 'default' || this.currentCameraMode === 'scene') {
                        const activeOption = document.querySelector(`.camera-option[data-camera-id="${this.currentSceneCameraId}"]`);
                        if (activeOption) {
                            activeOption.classList.add('active');
                        }
                    }
                },

                updateBuilderCameraInfo: function () {
                    const builderOption = document.querySelector('.camera-option[data-camera="builder"]');
                    if (!builderOption || !this.buildCamera) return;

                    // Find or create the info element
                    let infoEl = builderOption.querySelector('.camera-info');
                    if (!infoEl) {
                        infoEl = document.createElement('div');
                        infoEl.className = 'camera-info';
                        builderOption.appendChild(infoEl);
                    }

                    // Update position display
                    const pos = this.buildCamera.position;
                    if (pos) {
                        // Format with more precision
                        infoEl.innerHTML = `Pos: <b>${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}</b>`;

                        // Add a timestamp to verify it's updating
                        const timeStr = new Date().toLocaleTimeString();
                        infoEl.innerHTML += `<br><span style="color:#999;font-size:9px;">Updated: ${timeStr}</span>`;
                    }
                },

                getCurrentCameraPosition: function () {
                    const cameraEl = document.getElementById('user-camera');
                    if (!cameraEl) return null;

                    // Position is straightforward from object3D
                    const position = {
                        x: cameraEl.object3D.position.x,
                        y: cameraEl.object3D.position.y,
                        z: cameraEl.object3D.position.z
                    };

                    // For rotation, try to use look-controls if available
                    // as they provide more accurate camera orientation
                    let rotation;

                    if (cameraEl.components && cameraEl.components['look-controls']) {
                        const lookControls = cameraEl.components['look-controls'];

                        rotation = {
                            x: lookControls.pitchObject ? lookControls.pitchObject.rotation.x : cameraEl.object3D.rotation.x,
                            y: lookControls.yawObject ? lookControls.yawObject.rotation.y : cameraEl.object3D.rotation.y,
                            z: cameraEl.object3D.rotation.z
                        };
                    } else {
                        // Fall back to object3D rotation
                        rotation = {
                            x: cameraEl.object3D.rotation.x,
                            y: cameraEl.object3D.rotation.y,
                            z: cameraEl.object3D.rotation.z
                        };
                    }

                    return { position, rotation };
                },

                updateBuildCameraPosition: function () {
                    // Get the current camera position and rotation
                    const currentCamera = this.getCurrentCameraPosition();
                    if (!currentCamera) return;

                    // Convert rotations from radians to degrees for storage
                    const convertedRotation = {
                        x: THREE.MathUtils.radToDeg(currentCamera.rotation.x),
                        y: THREE.MathUtils.radToDeg(currentCamera.rotation.y),
                        z: THREE.MathUtils.radToDeg(currentCamera.rotation.z)
                    };

                    // Create a completely new object to prevent reference issues
                    this.buildCamera = {
                        position: {
                            x: currentCamera.position.x,
                            y: currentCamera.position.y,
                            z: currentCamera.position.z
                        },
                        rotation: convertedRotation,
                        timestamp: new Date().toISOString(),
                        source: 'live-update'
                    };

                    // Force update the builder camera info in the menu if it's open
                    const cameraMenu = document.getElementById('camera-menu');
                    if (cameraMenu && cameraMenu.classList.contains('active')) {
                        this.updateBuilderCameraInfo();
                    }

                    // Removed logging here
                },

                setupBuildCameraUpdater: function () {
                    // Update the build camera position multiple times per second
                    // when in build mode to ensure it's always current
                    this.buildCameraUpdateInterval = setInterval(() => {
                        if (this.currentCameraMode === 'build') {
                            this.updateBuildCameraPosition();
                        }
                    }, 100); // Update 10 times per second

                    console.log("Build camera live updating enabled");
                },

                updateDebugPanelDirectly: function () {
                    // Get the camera element
                    const cameraEl = document.getElementById('user-camera');
                    if (!cameraEl) {
                        console.warn("Cannot update debug panel - user-camera not found");
                        return;
                    }

                    // Get position and rotation
                    const pos = cameraEl.getAttribute('position');
                    const rot = cameraEl.getAttribute('rotation');

                    // Update debug panel directly with querySelector
                    const debugPanel = document.querySelector('.debug-panel');
                    if (!debugPanel) return;

                    // Position
                    const positionEl = debugPanel.querySelector('#camera-position') ||
                        debugPanel.querySelector('.camera-position');
                    if (positionEl && pos) {
                        positionEl.textContent = `${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}`;
                    }

                    // Rotation
                    const rotationEl = debugPanel.querySelector('#camera-rotation') ||
                        debugPanel.querySelector('.camera-rotation');
                    if (rotationEl && rot) {
                        rotationEl.textContent = `${rot.x.toFixed(2)}, ${rot.y.toFixed(2)}, ${rot.z.toFixed(2)}`;
                    }

                    // Camera entity info
                    const entityEl = debugPanel.querySelector('#camera-entity') ||
                        debugPanel.querySelector('.camera-entity');
                    if (entityEl) {
                        const hasLook = cameraEl.hasAttribute('look-controls') ? 'yes' : 'no';
                        const hasWASD = cameraEl.hasAttribute('wasd-controls') ? 'yes' : 'no';
                        entityEl.textContent = `user-camera look:${hasLook} wasd:${hasWASD}`;
                    }

                    // Stored states
                    const statesEl = debugPanel.querySelector('#stored-camera-state') ||
                        debugPanel.querySelector('.stored-camera-state');
                    if (statesEl) {
                        const buildPos = this.buildCamera && this.buildCamera.position
                            ? `build:(${this.buildCamera.position.x.toFixed(2)},${this.buildCamera.position.y.toFixed(2)},${this.buildCamera.position.z.toFixed(2)})`
                            : 'build:null';

                        const activePos = this.activeCamera && this.activeCamera.position
                            ? `active:(${this.activeCamera.position.x.toFixed(2)},${this.activeCamera.position.y.toFixed(2)},${this.activeCamera.position.z.toFixed(2)})`
                            : 'active:null';

                        statesEl.textContent = `${buildPos} ${activePos}`;
                    }

                    // Force update the debug panel more often
                    setTimeout(() => this.updateDebugPanelDirectly(), 200);
                },
                addCameraDebugOverlay: function () {
                    // Create a direct overlay that shows camera positions
                    const overlay = document.createElement('div');
                    overlay.style.position = 'fixed';
                    overlay.style.bottom = '10px';
                    overlay.style.right = '10px';
                    overlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
                    overlay.style.color = 'white';
                    overlay.style.padding = '10px';
                    overlay.style.borderRadius = '4px';
                    overlay.style.fontFamily = 'monospace';
                    overlay.style.fontSize = '12px';
                    overlay.style.zIndex = '9999';
                    overlay.id = 'camera-debug-overlay';

                    document.body.appendChild(overlay);

                    // Update function
                    const updateOverlay = () => {
                        const cameraEl = document.getElementById('user-camera');
                        if (!cameraEl) {
                            overlay.textContent = 'Camera not found';
                            return;
                        }

                        const pos = cameraEl.getAttribute('position');
                        const rot = cameraEl.getAttribute('rotation');
                        const buildPos = this.buildCamera && this.buildCamera.position;
                        const buildRot = this.buildCamera && this.buildCamera.rotation;

                        // Get direct object3D values which are used for the actual position
                        const obj3dPos = cameraEl.object3D.position;
                        const obj3dRot = cameraEl.object3D.rotation;

                        // Calculate difference between live and saved positions
                        let buildConfidence = "N/A";
                        let buildConfidenceStyle = "";
                        if (pos && buildPos) {
                            const diff = Math.sqrt(
                                Math.pow(pos.x - buildPos.x, 2) +
                                Math.pow(pos.y - buildPos.y, 2) +
                                Math.pow(pos.z - buildPos.z, 2)
                            );
                            buildConfidence = diff.toFixed(3);
                            // Color code based on difference (green = good, red = bad)
                            if (diff < 0.01) {
                                buildConfidenceStyle = "color: #00FF00; font-weight: bold;"; // Perfect match
                            } else if (diff < 0.1) {
                                buildConfidenceStyle = "color: #88FF00;"; // Very close
                            } else if (diff < 0.5) {
                                buildConfidenceStyle = "color: #FFFF00;"; // Warning
                            } else {
                                buildConfidenceStyle = "color: #FF0000;"; // Error - significant difference
                            }
                        }

                        // Format the timestamp to be more readable
                        let buildTimestamp = "N/A";
                        let timeSinceUpdate = "N/A";
                        if (this.buildCamera && this.buildCamera.timestamp) {
                            const updateTime = new Date(this.buildCamera.timestamp);
                            buildTimestamp = updateTime.toLocaleTimeString();

                            // Calculate time since last update
                            const now = new Date();
                            const diffMs = now - updateTime;
                            if (diffMs < 1000) {
                                timeSinceUpdate = `${diffMs}ms ago`;
                            } else if (diffMs < 60000) {
                                timeSinceUpdate = `${Math.round(diffMs / 1000)}s ago`;
                            } else {
                                timeSinceUpdate = `${Math.round(diffMs / 60000)}m ago`;
                            }
                        }

                        // Style definitions
                        const headerStyle = "font-weight: bold; margin-top: 10px; border-bottom: 1px solid #ccc;";
                        const sectionStyle = "margin-left: 10px;";

                        overlay.innerHTML = `
                            <div style="${headerStyle}">CAMERA STATE INFO</div>
                            <div style="${sectionStyle}">
                                <div><b>Mode:</b> ${this.currentCameraMode || 'unknown'}</div>
                                <div><b>Scene Camera ID:</b> ${this.currentSceneCameraId || 'none'}</div>
                            </div>
                            
                            <div style="${headerStyle}">LIVE CAMERA POSITIONS</div>
                            <div style="${sectionStyle}">
                                <div><b>getAttribute() Position:</b> ${pos ? `${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}` : 'null'}</div>
                                <div><b>getAttribute() Rotation:</b> ${rot ? `${rot.x.toFixed(2)}, ${rot.y.toFixed(2)}, ${rot.z.toFixed(2)}` : 'null'}</div>
                                <div><b>object3D.position:</b> ${obj3dPos ? `${obj3dPos.x.toFixed(2)}, ${obj3dPos.y.toFixed(2)}, ${obj3dPos.z.toFixed(2)}` : 'null'}</div>
                                <div><b>object3D.rotation:</b> ${obj3dRot ? `${THREE.MathUtils.radToDeg(obj3dRot.x).toFixed(2)}, ${THREE.MathUtils.radToDeg(obj3dRot.y).toFixed(2)}, ${THREE.MathUtils.radToDeg(obj3dRot.z).toFixed(2)}` : 'null'}</div>
                            </div>
                            
                            <div style="${headerStyle}">SAVED BUILD CAMERA STATE</div>
                            <div style="${sectionStyle}">
                                <div><b>Position:</b> ${buildPos ? `${buildPos.x.toFixed(2)}, ${buildPos.y.toFixed(2)}, ${buildPos.z.toFixed(2)}` : 'null'}</div>
                                <div><b>Rotation:</b> ${buildRot ? `${buildRot.x.toFixed(2)}, ${buildRot.y.toFixed(2)}, ${buildRot.z.toFixed(2)}` : 'null'}</div>
                                <div><b>Last update source:</b> ${this.buildCamera ? this.buildCamera.source || 'unknown' : 'none'}</div>
                                <div><b>Last update time:</b> ${buildTimestamp} (${timeSinceUpdate})</div>
                                <div><b>Build confidence:</b> <span style="${buildConfidenceStyle}">Diff: ${buildConfidence}</span></div>
                            </div>
                            
                            <div style="${headerStyle}">ACTIVE UPDATE METHODS</div>
                            <div style="${sectionStyle}">
                                <div><b>Continuous updater:</b> ${this.continuousBuildUpdateInterval ? 'RUNNING' : 'STOPPED'}</div>
                                <div><b>Build camera updater:</b> ${this.buildCameraUpdateInterval ? 'RUNNING' : 'STOPPED'}</div>
                            </div>
                            
                            <div style="${headerStyle}">UPDATE SOURCES EXPLAINED</div>
                            <div style="${sectionStyle}">
                                <div><b>camera-menu-switch:</b> Camera position when button was clicked</div>
                                <div><b>continuous-update:</b> Uses getAttribute() at 20Hz (DOM values)</div>
                                <div><b>live-update:</b> Uses object3D directly at 10Hz (THREE.js values)</div>
                                <div><b>initialization:</b> Initial camera position at startup</div>
                            </div>
                        `;
                    };

                    // Update regularly
                    setInterval(updateOverlay, 200);

                    console.log("Added camera debug overlay");
                },
                startContinuousBuildCameraUpdate: function () {
                    // Clear any existing update interval
                    if (this.continuousBuildUpdateInterval) {
                        clearInterval(this.continuousBuildUpdateInterval);
                    }

                    // Cancel any existing animation frame
                    if (this.continuousBuildUpdateAnimFrame) {
                        cancelAnimationFrame(this.continuousBuildUpdateAnimFrame);
                    }

                    // Create a function that directly syncs from THREE.js object3D
                    const syncFromObject3D = () => {
                        if (this.currentCameraMode !== 'build') return;

                        const cameraEl = document.getElementById('user-camera');
                        if (!cameraEl || !cameraEl.object3D) return;

                        // Get position and rotation directly from the THREE.js object
                        const position = cameraEl.object3D.position;
                        const rotation = cameraEl.object3D.rotation;

                        // Update the build camera state
                        this.buildCamera = {
                            position: {
                                x: position.x,
                                y: position.y,
                                z: position.z
                            },
                            rotation: {
                                x: THREE.MathUtils.radToDeg(rotation.x),
                                y: THREE.MathUtils.radToDeg(rotation.y),
                                z: THREE.MathUtils.radToDeg(rotation.z)
                            },
                            timestamp: new Date().toISOString(),
                            source: 'direct-three-update'
                        };

                        // Very important: also update the DOM attributes to match
                        // This ensures consistency between object3D and getAttribute() values
                        cameraEl.setAttribute('position', `${position.x} ${position.y} ${position.z}`);
                        cameraEl.setAttribute('rotation',
                            `${THREE.MathUtils.radToDeg(rotation.x)} ${THREE.MathUtils.radToDeg(rotation.y)} ${THREE.MathUtils.radToDeg(rotation.z)}`);

                        // Removed logging here
                    };

                    // Set up direct sync on animation frame which is better than interval
                    // This aligns with the render loop for smoother results
                    const animFrameSync = () => {
                        syncFromObject3D();
                        this.continuousBuildUpdateAnimFrame = requestAnimationFrame(animFrameSync);
                    };

                    // Start the sync process
                    this.continuousBuildUpdateAnimFrame = requestAnimationFrame(animFrameSync);

                    // Also set an interval as a backup to ensure it runs even if animation frames are paused
                    this.continuousBuildUpdateInterval = setInterval(syncFromObject3D, 50);

                    // Log once at setup, but not during operation
                    console.log("Started enhanced continuous build camera updating");
                },
                setupCameraMovementTracking: function () {
                    const camera = document.getElementById('user-camera');
                    if (!camera) return;

                    // Save the initial state
                    this.saveBuildCameraState('camera-movement-tracking-setup');

                    // Track position changes using a MutationObserver
                    const observer = new MutationObserver((mutations) => {
                        mutations.forEach((mutation) => {
                            if (mutation.attributeName === 'position' || mutation.attributeName === 'rotation') {
                                if (this.currentCameraMode === 'build') {
                                    // Save camera state when position or rotation attributes change
                                    this.saveBuildCameraState('camera-movement-detected');
                                }
                            }
                        });
                    });

                    // Observe position and rotation attribute changes
                    observer.observe(camera, { attributes: true, attributeFilter: ['position', 'rotation'] });

                    console.log("Camera movement tracking enabled");
                },
                syncCameraMotionToBuilder: function () {
                    // Add a camera movement listener directly on the scene
                    const scene = document.querySelector('a-scene');
                    if (!scene) return;

                    // Add a tick handler to constantly save camera position during motion
                    scene.addEventListener('tick', () => {
                        if (this.currentCameraMode === 'build') {
                            // Get current camera position
                            const userCamera = document.getElementById('user-camera');
                            if (userCamera && userCamera.object3D) {
                                // Only update if position has changed significantly to avoid spam
                                const position = userCamera.object3D.position;
                                const rotation = userCamera.object3D.rotation;

                                // Check if we already have a saved position to compare against
                                if (this.buildCamera && this.buildCamera.position) {
                                    const oldPos = this.buildCamera.position;
                                    // Calculate movement distance
                                    const distance = Math.sqrt(
                                        Math.pow(position.x - oldPos.x, 2) +
                                        Math.pow(position.y - oldPos.y, 2) +
                                        Math.pow(position.z - oldPos.z, 2)
                                    );

                                    // Only update if moved more than a small threshold
                                    if (distance > 0.001) {
                                        // Store current position in build camera
                                        this.buildCamera = {
                                            position: {
                                                x: position.x,
                                                y: position.y,
                                                z: position.z
                                            },
                                            rotation: {
                                                x: THREE.MathUtils.radToDeg(rotation.x),
                                                y: THREE.MathUtils.radToDeg(rotation.y),
                                                z: THREE.MathUtils.radToDeg(rotation.z)
                                            },
                                            timestamp: new Date().toISOString(),
                                            source: 'camera-motion-tick'
                                        };

                                        // Removed logging here
                                    }
                                }
                            }
                        }
                    });

                    // Log once at setup, but not during operation
                    console.log("Camera motion sync to builder camera enabled");
                },
                alignAllCameraRepresentations: function () {
                    const cameraEl = document.getElementById('user-camera');
                    if (!cameraEl || !cameraEl.object3D) return;

                    // Get current object3D position which is the most accurate
                    const position = cameraEl.object3D.position;
                    const rotation = cameraEl.object3D.rotation;

                    // Convert rotation to degrees for A-Frame attributes
                    const rotDeg = {
                        x: THREE.MathUtils.radToDeg(rotation.x),
                        y: THREE.MathUtils.radToDeg(rotation.y),
                        z: THREE.MathUtils.radToDeg(rotation.z)
                    };

                    // 1. Update the element attributes in the DOM
                    cameraEl.setAttribute('position', `${position.x} ${position.y} ${position.z}`);
                    cameraEl.setAttribute('rotation', `${rotDeg.x} ${rotDeg.y} ${rotDeg.z}`);

                    // 2. Update the build camera state
                    this.buildCamera = {
                        position: {
                            x: position.x,
                            y: position.y,
                            z: position.z
                        },
                        rotation: rotDeg,
                        timestamp: new Date().toISOString(),
                        source: 'alignment-sync'
                    };

                    // 3. Also update the scene model camera
                    if (!this.scene.camera) {
                        this.scene.camera = {};
                    }
                    this.scene.camera.position = { x: position.x, y: position.y, z: position.z };
                    this.scene.camera.rotation = rotDeg;

                    // 4. Update the general camera reference
                    this.camera = {
                        position: { x: position.x, y: position.y, z: position.z },
                        rotation: rotDeg
                    };

                    // 5. Update the active camera reference
                    this.activeCamera = {
                        position: { x: position.x, y: position.y, z: position.z },
                        rotation: rotDeg
                    };

                    // Removed logging here
                },
                // Single source of truth for camera state
                cameraState: {
                    position: { x: 0, y: 1.6, z: 0 },
                    rotation: { x: 0, y: 0, z: 0 },
                    mode: 'build', // 'build' or 'scene'
                    sceneId: null, // ID of selected scene camera if any
                    timestamp: new Date().toISOString(),
                    source: 'initialization',
                    networkId: null, // For networked sync
                    lastNetworkUpdate: null
                },
                renderCameraPosition: function () {
                    // Get current state (source of truth)
                    const pos = this.cameraState.position;
                    const rot = this.cameraState.rotation;

                    // Skip render if elements are missing
                    const cameraEl = document.getElementById('user-camera');
                    if (!cameraEl || !cameraEl.object3D) return;

                    // Prevent circular updates by temporarily disabling listeners if needed
                    this.preventCircularUpdates = true;

                    try {
                        // Update THREE.js object (most important for visual rendering)
                        cameraEl.object3D.position.set(pos.x, pos.y, pos.z);

                        // Convert rotation format if needed and set rotation
                        const rotX = THREE.MathUtils.degToRad(rot.x);
                        const rotY = THREE.MathUtils.degToRad(rot.y);
                        const rotZ = THREE.MathUtils.degToRad(rot.z);

                        // Handle look-controls specifically for user camera
                        if (cameraEl.components && cameraEl.components['look-controls']) {
                            const lookControls = cameraEl.components['look-controls'];

                            if (lookControls.pitchObject) {
                                lookControls.pitchObject.rotation.x = rotX;
                                lookControls.pitchObject.updateMatrix();
                            }

                            if (lookControls.yawObject) {
                                lookControls.yawObject.rotation.y = rotY;
                                lookControls.yawObject.updateMatrix();
                            }
                        } else {
                            // Fall back to direct object3D rotation
                            cameraEl.object3D.rotation.set(rotX, rotY, rotZ);
                        }

                        // Update DOM attributes for A-Frame component access
                        cameraEl.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
                        cameraEl.setAttribute('rotation', `${rot.x} ${rot.y} ${rot.z}`);

                        // Update any UI displaying the camera position
                        this.updateCameraUI();
                    } finally {
                        // Re-enable updates
                        this.preventCircularUpdates = false;
                    }
                },
                setupCameraEventListeners: function () {
                    const scene = document.querySelector('a-scene');
                    const cameraEl = document.getElementById('user-camera');
                    if (!scene || !cameraEl) return;

                    // Track last position to detect changes
                    let lastPos = { x: 0, y: 0, z: 0 };
                    let lastUpdate = 0;
                    const updateInterval = 50; // ms

                    scene.addEventListener('tick', (e) => {
                        // Skip if we're preventing circular updates
                        if (this.preventCircularUpdates) return;

                        // Only update state if we're in build mode
                        if (this.cameraState.mode !== 'build') return;

                        // Throttle updates
                        const now = performance.now();
                        if (now - lastUpdate < updateInterval) return;

                        // Get current THREE.js values
                        const position = cameraEl.object3D.position;

                        // Calculate distance moved
                        const distance = Math.sqrt(
                            Math.pow(position.x - lastPos.x, 2) +
                            Math.pow(position.y - lastPos.y, 2) +
                            Math.pow(position.z - lastPos.z, 2)
                        );

                        // Only update if moved significantly
                        if (distance > 0.001) {
                            const rotation = cameraEl.object3D.rotation;
                            const rotDeg = {
                                x: THREE.MathUtils.radToDeg(rotation.x),
                                y: THREE.MathUtils.radToDeg(rotation.y),
                                z: THREE.MathUtils.radToDeg(rotation.z)
                            };

                            // Update state via throttled method
                            this.throttledUpdateCameraState({
                                position: {
                                    x: position.x,
                                    y: position.y,
                                    z: position.z
                                },
                                rotation: rotDeg
                            }, 'camera-motion-tick');

                            // Store last position
                            lastPos = { x: position.x, y: position.y, z: position.z };
                            lastUpdate = now;
                        }
                    });
                },
                // Throttled network sync to avoid flooding the network
                throttledNetworkSync: function () {
                    // Skip if network sync is disabled
                    if (!this.nafEnabled || !window.NAF || !window.NAF.connection.isConnected()) return;

                    // Check if we should throttle
                    const now = Date.now();
                    if (this.lastNetworkSync && now - this.lastNetworkSync < 100) { // Max 10 updates/second
                        // Schedule a sync for later if we haven't already
                        if (!this.pendingNetworkSync) {
                            this.pendingNetworkSync = setTimeout(() => {
                                this.syncCameraToNetwork();
                                this.pendingNetworkSync = null;
                            }, 100 - (now - this.lastNetworkSync));
                        }
                        return;
                    }

                    // Perform the sync now
                    this.syncCameraToNetwork();
                    this.lastNetworkSync = now;
                },

                // Actual network sync function
                syncCameraToNetwork: function () {
                    if (!this.nafEnabled || !window.NAF || !window.NAF.connection.isConnected()) return;

                    const cameraEl = document.getElementById('user-camera');
                    if (!cameraEl) return;

                    // Use the networked component if available
                    if (cameraEl.components.networked) {
                        // Get current state
                        const state = this.cameraState;

                        // Create network message
                        const cameraData = {
                            position: state.position,
                            rotation: state.rotation,
                            mode: state.mode,
                            timestamp: state.timestamp
                        };

                        // Send camera update to network
                        NAF.connection.broadcastData('camera-update', cameraData);

                        console.log("Camera state synced to network");
                    }
                },

                // Setup network listeners
                setupNetworkListeners: function () {
                    if (!window.NAF) return;

                    // Listen for camera updates from network
                    NAF.connection.subscribeToDataChannel('camera-update', (senderId, dataType, data) => {
                        // Only process if it's not our own data
                        if (senderId !== NAF.clientId) {
                            console.log(`Received camera update from ${senderId}`);

                            // Update remote user camera if needed
                            // Or store this data for your application's needs
                        }
                    });
                },
                updateDebugDisplay: function () {
                    // Use existing debug update function if available
                    if (typeof this.updateDebugInfo === 'function') {
                        this.updateDebugInfo();
                    }

                    // Use direct debug panel update if available
                    if (typeof this.updateDebugPanelDirectly === 'function') {
                        this.updateDebugPanelDirectly();
                    }
                },
                // Initialize state history
                cameraStateHistory: [],
                cameraStateHistoryIndex: -1,
                maxHistoryStates: 50,

                // Helper to determine if a change is significant enough for history
                isSignificantStateChange: function (oldState, newState) {
                    if (!oldState || !newState) return true;

                    // Check position change
                    const positionChange =
                        Math.abs(oldState.position.x - newState.position.x) > 0.1 ||
                        Math.abs(oldState.position.y - newState.position.y) > 0.1 ||
                        Math.abs(oldState.position.z - newState.position.z) > 0.1;

                    // Check rotation change (with wrap-around handling)
                    const rotationChange =
                        Math.abs(oldState.rotation.x - newState.rotation.x) > 5 ||
                        Math.abs(oldState.rotation.y - newState.rotation.y) > 5 ||
                        Math.abs(oldState.rotation.z - newState.rotation.z) > 5;

                    // Check mode change
                    const modeChange = oldState.mode !== newState.mode;

                    return positionChange || rotationChange || modeChange;
                },

                // Add undo/redo functions
                undoCameraState: function () {
                    if (this.cameraStateHistoryIndex > 0) {
                        this.cameraStateHistoryIndex--;
                        const previousState = this.cameraStateHistory[this.cameraStateHistoryIndex];
                        this.updateCameraState(previousState, 'undo-operation', false);
                    }
                },

                redoCameraState: function () {
                    if (this.cameraStateHistoryIndex < this.cameraStateHistory.length - 1) {
                        this.cameraStateHistoryIndex++;
                        const nextState = this.cameraStateHistory[this.cameraStateHistoryIndex];
                        this.updateCameraState(nextState, 'redo-operation', false);
                    }
                },

                // Add at initialization
                lastStateUpdate: 0,
                pendingStateUpdate: null,
                updateThrottleTime: 50, // ms

                // Throttled state update
                throttledUpdateCameraState: function (newState, source) {
                    const now = Date.now();

                    // If we recently updated, schedule an update
                    if (now - this.lastStateUpdate < this.updateThrottleTime) {
                        // Clear any existing pending update
                        if (this.pendingStateUpdate) {
                            clearTimeout(this.pendingStateUpdate);
                        }

                        // Set a timeout to ensure the update happens after throttle time
                        this.pendingStateUpdate = setTimeout(() => {
                            this.updateCameraState(newState, source);
                            this.pendingStateUpdate = null;
                            this.lastStateUpdate = Date.now();
                        }, this.updateThrottleTime);
                    } else {
                        // Update immediately
                        this.updateCameraState(newState, source);
                        this.lastStateUpdate = now;
                    }
                },
                // Add keyboard shortcuts for camera state debugging
                setupDebugKeyboardShortcuts: function () {
                    document.addEventListener('keydown', (e) => {
                        // Only activate if Alt+D is pressed (customize as needed)
                        if (e.altKey && e.key === 'd') {
                            console.group('Camera State Debug');
                            console.log('Current State:', JSON.parse(JSON.stringify(this.cameraState)));
                            console.log('History Size:', this.cameraStateHistory?.length || 0);
                            console.log('Current Mode:', this.cameraState.mode);
                            console.log('DOM Position:', document.getElementById('user-camera')?.getAttribute('position'));
                            console.log('THREE.js Position:', document.getElementById('user-camera')?.object3D.position);
                            console.groupEnd();
                        }

                        // Undo/Redo shortcuts
                        if (e.ctrlKey && e.key === 'z') {
                            this.undoCameraState();
                        }
                        if (e.ctrlKey && e.key === 'y') {
                            this.redoCameraState();
                        }
                    });
                },
                // Save camera states to localStorage
                saveCameraStates: function () {
                    // Save current state
                    try {
                        const stateToSave = {
                            currentState: this.cameraState,
                            savedPositions: this.savedCameraPositions || {}
                        };
                        localStorage.setItem('aframe-builder-camera-states', JSON.stringify(stateToSave));
                        console.log('Camera states saved to localStorage');
                    } catch (e) {
                        console.warn('Failed to save camera states:', e);
                    }
                },

                // Load camera states from localStorage
                loadCameraStates: function () {
                    try {
                        const savedData = localStorage.getItem('aframe-builder-camera-states');
                        if (savedData) {
                            const parsedData = JSON.parse(savedData);

                            // Restore current state if valid
                            if (parsedData.currentState && parsedData.currentState.position) {
                                this.updateCameraState(parsedData.currentState, 'localStorage-restore');
                            }

                            // Restore saved positions
                            if (parsedData.savedPositions) {
                                this.savedCameraPositions = parsedData.savedPositions;
                            }

                            console.log('Camera states loaded from localStorage');
                        }
                    } catch (e) {
                        console.warn('Failed to load camera states:', e);
                    }
                },

                setupNetworkedCameraSync: function () {
                    if (!window.NAF || !this.nafEnabled) return;

                    // Register schema for camera data
                    NAF.schemas.add({
                        template: '#camera-template',
                        components: [
                            {
                                component: 'position',
                                requiresNetworkUpdate: true
                            },
                            {
                                component: 'rotation',
                                requiresNetworkUpdate: true
                            }
                        ]
                    });

                    // Set up throttled network updates
                    this.lastNetworkUpdate = 0;
                    this.networkUpdateInterval = 100; // ms

                    // Add NAF tick callback
                    const tickHandler = () => {
                        if (!this.nafEnabled || !NAF.connection.isConnected()) return;

                        const now = Date.now();
                        if (now - this.lastNetworkUpdate < this.networkUpdateInterval) return;

                        // Only sync if we own the camera
                        const cameraEl = document.getElementById('user-camera');
                        if (cameraEl && NAF.utils.isMine(cameraEl)) {
                            NAF.utils.takeOwnership(cameraEl);
                            this.lastNetworkUpdate = now;
                        }
                    };

                    // Register tick handler with NAF
                    NAF.connection.onConnect(() => {
                        NAF.connection.subscribeToDataChannel('camera-updates', this.handleNetworkCameraUpdate.bind(this));
                        document.querySelector('a-scene').addEventListener('tick', tickHandler);
                        console.log('Networked camera sync enabled');
                    });
                },

                handleNetworkCameraUpdate: function (senderId, dataType, data) {
                    // Ignore our own updates
                    if (senderId === NAF.clientId) return;

                    console.log(`Received camera update from ${senderId}`);

                    // Only process if in 'networked' mode
                    if (this.cameraState.mode === 'networked') {
                        // Update remote user camera position
                        const remoteCamera = document.getElementById(`remote-camera-${senderId}`);
                        if (remoteCamera) {
                            remoteCamera.setAttribute('position', data.position);
                            remoteCamera.setAttribute('rotation', data.rotation);
                        } else {
                            // Create remote camera representation if it doesn't exist
                            this.createRemoteCameraRepresentation(senderId, data);
                        }
                    }
                },
                optimizeAssetLoading: function () {
                    // Preload critical assets first
                    const criticalAssets = document.querySelectorAll('a-assets > img[critical], a-assets > audio[critical]');

                    // Track loading progress
                    let loaded = 0;
                    const total = criticalAssets.length;

                    // Create a loading indicator
                    const loadingIndicator = document.createElement('div');
                    loadingIndicator.className = 'loading-indicator';
                    loadingIndicator.innerHTML = `<div class="loading-progress"></div><div class="loading-text">Loading assets (0/${total})</div>`;
                    document.body.appendChild(loadingIndicator);

                    // Update progress function
                    const updateProgress = () => {
                        loaded++;
                        const progress = document.querySelector('.loading-progress');
                        const text = document.querySelector('.loading-text');

                        if (progress && text) {
                            progress.style.width = `${(loaded / total) * 100}%`;
                            text.textContent = `Loading assets (${loaded}/${total})`;
                        }

                        if (loaded >= total) {
                            loadingIndicator.classList.add('complete');
                            setTimeout(() => loadingIndicator.remove(), 1000);
                        }
                    };

                    // Load non-critical assets after scene initialization
                    const lazyLoadAssets = () => {
                        const nonCriticalAssets = document.querySelectorAll('a-assets > *:not([critical])');
                        nonCriticalAssets.forEach(asset => {
                            if (asset.tagName === 'IMG' || asset.tagName === 'AUDIO' || asset.tagName === 'VIDEO') {
                                // Force asset to load if it hasn't already
                                if (!asset.hasAttribute('src') && asset.hasAttribute('data-src')) {
                                    asset.setAttribute('src', asset.getAttribute('data-src'));
                                }
                            }
                        });
                    };

                    // Add event listeners for critical assets
                    criticalAssets.forEach(asset => {
                        if (asset.complete) {
                            updateProgress();
                        } else {
                            asset.addEventListener('load', updateProgress);
                            asset.addEventListener('error', updateProgress);
                        }
                    });

                    // Lazy load non-critical assets
                    document.querySelector('a-scene').addEventListener('loaded', lazyLoadAssets);
                },
                initializeEntityPooling: function () {
                    // Create pools for frequently used entities
                    this.entityPools = {
                        box: [],
                        sphere: [],
                        cylinder: []
                    };

                    // Pool size per entity type
                    const poolSize = 20;

                    // Pre-create entities
                    Object.keys(this.entityPools).forEach(type => {
                        const pool = this.entityPools[type];
                        const scene = document.querySelector('a-scene');

                        for (let i = 0; i < poolSize; i++) {
                            const entity = document.createElement(`a-${type}`);
                            entity.setAttribute('visible', false);
                            entity.setAttribute('pool-entity', '');
                            scene.appendChild(entity);
                            pool.push(entity);
                        }
                    });

                    console.log("Entity pooling initialized");
                },

                getPooledEntity: function (type) {
                    if (!this.entityPools || !this.entityPools[type]) return null;

                    // Find an available entity in the pool
                    const pool = this.entityPools[type];
                    let entity = pool.find(e => !e.getAttribute('visible'));

                    if (entity) {
                        // Reset entity to default state
                        entity.setAttribute('visible', true);
                        return entity;
                    }

                    // If no entities available, create a new one
                    console.warn(`Entity pool for ${type} exhausted, creating new entity`);
                    entity = document.createElement(`a-${type}`);
                    entity.setAttribute('pool-entity', '');
                    document.querySelector('a-scene').appendChild(entity);
                    pool.push(entity);
                    return entity;
                },

                returnToPool: function (entity) {
                    if (!entity || !entity.hasAttribute('pool-entity')) return;

                    // Reset entity and hide it
                    entity.setAttribute('visible', false);

                    // Remove any dynamic components/attributes
                    Array.from(entity.attributes).forEach(attr => {
                        if (!['id', 'pool-entity', 'visible'].includes(attr.name)) {
                            entity.removeAttribute(attr.name);
                        }
                    });
                },
                enhanceNAFIntegration: function () {
                    // Check if NAF is available
                    if (!window.NAF) {
                        console.warn("NAF not available for integration enhancement");
                        return;
                    }

                    // Add custom NAF schemas for camera sync
                    NAF.schemas.add({
                        template: '#camera-template',
                        components: [
                            'position',
                            'rotation',
                            {
                                component: 'camera-state',
                                property: 'mode'
                            }
                        ]
                    });

                    // Create a camera template if needed
                    if (!document.getElementById('camera-template')) {
                        const templateEl = document.createElement('template');
                        templateEl.id = 'camera-template';
                        templateEl.innerHTML = `
                            <a-entity class="remote-camera">
                                <a-box class="camera-avatar" color="#00AAFF" scale="0.2 0.2 0.4" position="0 0 -0.25"></a-box>
                                <a-text value="Remote User" position="0 0.25 0" align="center" color="#FFFFFF"></a-text>
                            </a-entity>
                        `;

                        // Add to assets
                        const assets = document.querySelector('a-assets');
                        if (assets) {
                            assets.appendChild(templateEl);
                        } else {
                            document.querySelector('a-scene').insertAdjacentElement('afterbegin', templateEl);
                        }
                    }

                    // Setup network event handling
                    NAF.connection.subscribeToDataChannel('camera-state-update', (senderId, dataType, data) => {
                        // Skip own data
                        if (senderId === NAF.clientId) return;

                        // Handle remote camera state update
                        const remoteAvatar = document.querySelector(`[data-owner-id="${senderId}"]`);
                        if (remoteAvatar && data.cameraState) {
                            console.log(`Received camera state from ${senderId}:`, data.cameraState);

                            // Update remote avatar with camera state
                            if (data.cameraState.mode === 'build') {
                                remoteAvatar.setAttribute('color', '#00FF00'); // Green for build mode
                            } else {
                                remoteAvatar.setAttribute('color', '#0088FF'); // Blue for scene mode
                            }
                        }
                    });

                    // Enable periodic camera state sharing
                    setInterval(() => {
                        if (this.nafEnabled && NAF.connection.isConnected() && this.cameraState) {
                            NAF.connection.broadcastData('camera-state-update', {
                                cameraState: this.cameraState
                            });
                        }
                    }, 1000); // Send update every second

                    console.log("Enhanced NAF integration completed");
                },
                setupEnhancedNAF: function () {
                    // Skip if NAF isn't available
                    if (!window.NAF) {
                        console.warn("NAF not available for enhanced setup");
                        return;
                    }

                    // Register custom camera schema for better synchronization
                    NAF.schemas.add({
                        template: '#remote-camera-template',
                        components: [
                            'position',
                            'rotation',
                            {
                                component: 'camera-state',
                                property: 'mode'
                            }
                        ]
                    });

                    console.log("Enhanced NAF schemas registered");
                },
                addRemoteCameraTemplate: function () {
                    // Skip if template already exists
                    if (document.getElementById('remote-camera-template')) {
                        return;
                    }

                    // Create template for remote cameras
                    const template = document.createElement('template');
                    template.id = 'remote-camera-template';
                    template.innerHTML = `
                        <a-entity class="remote-user-camera">
                            <a-box class="avatar-head" color="#00AAFF" scale="0.2 0.2 0.4" position="0 0 -0.25"></a-box>
                            <a-text value="Remote User" position="0 0.3 0" align="center" scale="0.5 0.5 0.5" color="#FFFFFF"></a-text>
                        </a-entity>
                    `;

                    // Add template to assets
                    const assets = document.querySelector('a-assets');
                    if (assets) {
                        assets.appendChild(template);
                    } else {
                        // If no assets container, add to scene
                        document.querySelector('a-scene').insertAdjacentElement('afterbegin', template);
                    }

                    console.log("Added remote camera template to scene");
                },
                createCameraStateComponent: function () {
                    // Skip if already registered
                    if (AFRAME.components['camera-state']) {
                        return;
                    }

                    // Register custom component for camera state
                    AFRAME.registerComponent('camera-state', {
                        schema: {
                            mode: { type: 'string', default: 'build' }
                        },

                        init: function () {
                            this.el.classList.add('networked-camera');

                            // Apply visual indicator based on mode
                            this.updateVisualMode();
                        },

                        update: function () {
                            // Update visual representation when properties change
                            this.updateVisualMode();
                        },

                        updateVisualMode: function () {
                            // Find avatar head box
                            const avatarHead = this.el.querySelector('.avatar-head');
                            if (!avatarHead) return;

                            // Set color based on mode
                            if (this.data.mode === 'build') {
                                avatarHead.setAttribute('color', '#00FF00'); // Green for build mode
                            } else if (this.data.mode === 'scene') {
                                avatarHead.setAttribute('color', '#0088FF'); // Blue for scene mode
                            } else {
                                avatarHead.setAttribute('color', '#FF8800'); // Orange for unknown modes
                            }

                            // Update text label if present
                            const label = this.el.querySelector('a-text');
                            if (label) {
                                label.setAttribute('value', `Remote User (${this.data.mode} mode)`);
                            }
                        }
                    });

                    console.log("Registered camera-state A-Frame component");
                },
                setupCameraDataChannel: function () {
                    // Skip if NAF isn't available or already connected
                    if (!window.NAF || !NAF.connection) {
                        return;
                    }

                    // When NAF connects
                    NAF.connection.onConnect(() => {
                        // Subscribe to camera updates channel
                        NAF.connection.subscribeToDataChannel('camera-state-update', (senderId, dataType, data) => {
                            // Skip our own updates
                            if (senderId === NAF.clientId) return;

                            console.log(`Received camera update from ${senderId}:`, data);

                            // Find the remote user's camera entity
                            const remoteEntity = document.querySelector(`[data-owner="${senderId}"]`);
                            if (remoteEntity) {
                                // Update remote user's entity with additional state
                                if (data.cameraState) {
                                    // Update camera state component
                                    remoteEntity.setAttribute('camera-state', {
                                        mode: data.cameraState.mode
                                    });

                                    // You could update other properties here
                                    if (data.cameraState.source) {
                                        // This is optional - adds a data attribute to show what triggered the update
                                        remoteEntity.setAttribute('data-source', data.cameraState.source);
                                    }
                                }
                            }
                        });

                        console.log("Subscribed to camera-state-update data channel");
                    });
                },
                startCameraStateSharing: function () {
                    // Make sure we only set up one interval
                    if (this.cameraStateSharingInterval) {
                        clearInterval(this.cameraStateSharingInterval);
                    }

                    // Set up periodic sharing (every 500ms)
                    this.cameraStateSharingInterval = setInterval(() => {
                        // Only send if NAF is connected and we have camera state
                        if (window.NAF &&
                            NAF.connection &&
                            NAF.connection.isConnected() &&
                            this.cameraState) {

                            // Send current camera state to all clients
                            NAF.connection.broadcastDataGuaranteed('camera-state-update', {
                                cameraState: {
                                    position: this.cameraState.position,
                                    rotation: this.cameraState.rotation,
                                    mode: this.cameraState.mode,
                                    source: this.cameraState.source,
                                    timestamp: this.cameraState.timestamp
                                }
                            });
                        }
                    }, 500); // Update twice per second

                    console.log("Started camera state sharing over network");
                },
                setupUserCameraForNetworking: function () {
                    const userCamera = document.getElementById('user-camera');
                    if (!userCamera) {
                        console.warn("Cannot find user-camera for network setup");
                        return;
                    }

                    // Add networked component to user camera
                    if (!userCamera.hasAttribute('networked')) {
                        userCamera.setAttribute('networked', {
                            template: '#remote-camera-template',
                            attachTemplateToLocal: false
                        });
                    }

                    // Add camera-state component to sync mode
                    if (!userCamera.hasAttribute('camera-state')) {
                        userCamera.setAttribute('camera-state', {
                            mode: this.cameraState.mode || 'build'
                        });
                    }

                    // Update camera-state when camera mode changes
                    this.updateCameraStateForNetworking = (newState) => {
                        if (newState.mode && userCamera.hasAttribute('camera-state')) {
                            userCamera.setAttribute('camera-state', 'mode', newState.mode);
                        }
                    };

                    console.log("User camera configured for networking");
                },
                initializeNetworkedCamera: function () {
                    // Only proceed if NAF is available
                    if (!window.NAF) {
                        console.log("NAF not available, skipping networked camera setup");
                        return;
                    }

                    // Set up all NAF camera components
                    this.addRemoteCameraTemplate();
                    this.createCameraStateComponent();
                    this.setupEnhancedNAF();
                    this.setupCameraDataChannel();
                    this.setupUserCameraForNetworking();

                    // Start sharing camera state
                    this.startCameraStateSharing();

                    // Hook into camera state updates
                    const originalUpdateCameraState = this.updateCameraState;
                    this.updateCameraState = function (newState, source) {
                        // Call original function
                        const result = originalUpdateCameraState.call(this, newState, source);

                        // Update networking components
                        if (this.updateCameraStateForNetworking) {
                            this.updateCameraStateForNetworking(newState);
                        }

                        return result;
                    };

                    console.log("Networked camera system fully initialized");
                },
                // Find in your code where you connect to NAF
                connectToNetworked: function () {
                    this.nafEnabled = true;

                    // Add this before connecting
                    this.initializeNetworkedCamera();

                    // Then connect
                    if (window.NAF && NAF.connection) {
                        NAF.connection.connect(this.roomName, this.getClientOptions());
                    }
                }
            };

            // Initialize the application
            state.init();

            // Expose the BUILDER object globally
            window.AFRAME.BUILDER = state;
        };
        // Find all debug panel elements and log their IDs
        document.getElementById('toggle-debug').addEventListener('click', function () {
            console.log("Debug panel elements:");
            const debugPanel = document.querySelector('.debug-panel');
            if (debugPanel) {
                const elements = debugPanel.querySelectorAll('*[id]');
                elements.forEach(el => {
                    console.log(`ID: ${el.id}, Content: ${el.textContent.substring(0, 30)}`);
                });
            } else {
                console.log("Debug panel not found");
            }
        });

        // Find the debug panel toggle button and add a refresh button next to it
        const toggleDebugBtn = document.getElementById('toggle-debug');
        if (toggleDebugBtn) {
            const refreshBtn = document.createElement('button');
            refreshBtn.className = 'component-button';
            refreshBtn.id = 'refresh-debug';
            refreshBtn.textContent = 'Refresh Debug';
            refreshBtn.style.marginLeft = '5px';
            refreshBtn.addEventListener('click', () => {
                console.log("Manually refreshing debug panel");
                this.updateDebugPanelDirectly();
            });

            toggleDebugBtn.parentNode.insertBefore(refreshBtn, toggleDebugBtn.nextSibling);
        }
    </script>
    <script>
        // Initialize AFRAME_BUILDER if it doesn't exist
        if (typeof window.AFRAME_BUILDER === 'undefined') {
            window.AFRAME_BUILDER = {};
        }

        // Create the main API
        window.AFRAME_BUILDER.core = {
            /**
             * Gets the version of the builder
             * @returns {string} Version string
             */
            version: "1.0.0",

            /**
             * Gets the underlying state object (use with caution)
             * @returns {Object} The internal state
             */
            getState: function () {
                return window.AFRAME && window.AFRAME.BUILDER ? window.AFRAME.BUILDER : null;
            },

            /**
             * Initialize the modular API
             */
            init: function () {
                console.log("AFRAME_BUILDER API initialized");

                // If we have access to the original init, call it
                if (window.AFRAME && window.AFRAME.BUILDER &&
                    typeof window.AFRAME.BUILDER.init === 'function' &&
                    !window.AFRAME.BUILDER._initialized) {
                    window.AFRAME.BUILDER.init();
                    window.AFRAME.BUILDER._initialized = true;
                }
            }
        };

        // Call init automatically if the original hasn't been initialized yet
        if (window.AFRAME && window.AFRAME.BUILDER && !window.AFRAME.BUILDER._initialized) {
            // Wait for document to be ready
            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                window.AFRAME_BUILDER.core.init();
            } else {
                document.addEventListener('DOMContentLoaded', function () {
                    window.AFRAME_BUILDER.core.init();
                });
            }
        }

        console.log("AFRAME_BUILDER Core module initialized");
    </script>
    <script>
        // Initialize AFRAME_BUILDER if it doesn't exist
        if (typeof window.AFRAME_BUILDER === 'undefined') {
            window.AFRAME_BUILDER = {};
        }

        // Create the UI module
        window.AFRAME_BUILDER.ui = {
            /**
             * Shows a notification message
             * @param {string} message - Message text
             * @param {string} type - Message type ('success', 'error', 'warning', 'info')
             * @param {number} duration - Duration in ms (default: 3000)
             */
            notify: function (message, type, duration) {
                // Use existing notification system if available
                if (window.AFRAME && window.AFRAME.BUILDER &&
                    typeof window.AFRAME.BUILDER.showNotification === 'function') {
                    window.AFRAME.BUILDER.showNotification(message, type, duration);
                    return;
                }

                // Simple fallback
                const notif = document.createElement('div');
                notif.className = `notification ${type || 'info'}`;
                notif.textContent = message;
                notif.style.position = 'fixed';
                notif.style.bottom = '20px';
                notif.style.right = '20px';
                notif.style.padding = '10px 20px';
                notif.style.borderRadius = '4px';
                notif.style.backgroundColor = type === 'error' ? '#ff5555' :
                    type === 'warning' ? '#ffaa00' :
                        type === 'success' ? '#55aa55' : '#5555ff';
                notif.style.color = '#ffffff';
                notif.style.zIndex = '9999';
                notif.style.transition = 'opacity 0.3s';

                document.body.appendChild(notif);

                setTimeout(() => {
                    notif.style.opacity = '0';
                    setTimeout(() => notif.remove(), 300);
                }, duration || 3000);
            },

            /**
             * Updates the debug panel
             */
            updateDebug: function () {
                if (window.AFRAME && window.AFRAME.BUILDER &&
                    typeof window.AFRAME.BUILDER.updateDebugPanelDirectly === 'function') {
                    window.AFRAME.BUILDER.updateDebugPanelDirectly();
                }
            },

            /**
             * Shows or hides the debug panel
             * @param {boolean} show - Whether to show or hide
             */
            toggleDebug: function (show) {
                const debugPanel = document.querySelector('.debug-panel');
                if (!debugPanel) return;

                if (typeof show === 'boolean') {
                    debugPanel.classList.toggle('visible', show);
                } else {
                    debugPanel.classList.toggle('visible');
                }

                // Update toggle button text if it exists
                const toggleBtn = document.getElementById('toggle-debug');
                if (toggleBtn) {
                    toggleBtn.textContent = debugPanel.classList.contains('visible') ?
                        'Hide Debug Info' : 'Show Debug Info';
                }
            }
        };

        console.log("AFRAME_BUILDER UI module initialized");
    </script>
    <script>
        // Initialize AFRAME_BUILDER if it doesn't exist
        if (typeof window.AFRAME_BUILDER === 'undefined') {
            window.AFRAME_BUILDER = {};
        }

        // Document Monaco editor functions
        window.AFRAME_BUILDER.monaco = {
            /**
             * Gets the value from the Monaco editor
             * @returns {string} Current editor content
             */
            getValue: function () {
                if (window.AFRAME && window.AFRAME.BUILDER && window.AFRAME.BUILDER.editor) {
                    return window.AFRAME.BUILDER.editor.getValue();
                }
                return '';
            },

            /**
             * Sets the value in the Monaco editor
             * @param {string} content - Content to set
             */
            setValue: function (content) {
                if (window.AFRAME && window.AFRAME.BUILDER && window.AFRAME.BUILDER.editor) {
                    window.AFRAME.BUILDER.editor.setValue(content);
                }
            },

            /**
             * Changes the Monaco editor language
             * @param {string} language - Language ID (e.g., 'html', 'javascript')
             */
            setLanguage: function (language) {
                if (window.AFRAME && window.AFRAME.BUILDER && window.AFRAME.BUILDER.editor) {
                    monaco.editor.setModelLanguage(window.AFRAME.BUILDER.editor.getModel(), language);
                }
            }
        };

        // Add to global AFRAME.BUILDER object for backward compatibility
        if (window.AFRAME && window.AFRAME.BUILDER) {
            window.AFRAME.BUILDER.monaco = window.AFRAME_BUILDER.monaco;
        }

        console.log("AFRAME_BUILDER Monaco interface initialized");
    </script>
    <script>
        // Initialize AFRAME_BUILDER if it doesn't exist
        if (typeof window.AFRAME_BUILDER === 'undefined') {
            window.AFRAME_BUILDER = {};
        }

        // Create the camera module
        window.AFRAME_BUILDER.camera = {
            /**
             * Gets the current camera position
             * @returns {Object} Position with x,y,z properties
             */
            getPosition: function () {
                if (window.AFRAME && window.AFRAME.BUILDER && window.AFRAME.BUILDER.cameraState) {
                    return Object.assign({}, window.AFRAME.BUILDER.cameraState.position);
                }
                return { x: 0, y: 1.6, z: 0 }; // Default position
            },

            /**
             * Gets the current camera rotation
             * @returns {Object} Rotation with x,y,z properties in degrees
             */
            getRotation: function () {
                if (window.AFRAME && window.AFRAME.BUILDER && window.AFRAME.BUILDER.cameraState) {
                    return Object.assign({}, window.AFRAME.BUILDER.cameraState.rotation);
                }
                return { x: 0, y: 0, z: 0 }; // Default rotation
            },

            /**
             * Switches to builder camera view
             */
            switchToBuildCamera: function () {
                if (window.AFRAME && window.AFRAME.BUILDER &&
                    typeof window.AFRAME.BUILDER.switchToBuildCamera === 'function') {
                    window.AFRAME.BUILDER.switchToBuildCamera();
                }
            },

            /**
             * Switches to a specific scene camera
             * @param {string} cameraId - ID of the scene camera to switch to
             */
            switchToSceneCamera: function (cameraId) {
                if (window.AFRAME && window.AFRAME.BUILDER &&
                    typeof window.AFRAME.BUILDER.switchToSceneCamera === 'function') {
                    window.AFRAME.BUILDER.switchToSceneCamera(cameraId);
                }
            }
        };

        console.log("AFRAME_BUILDER Camera module initialized");
    </script>
    <script>
        // Initialize AFRAME_BUILDER if it doesn't exist
        if (typeof window.AFRAME_BUILDER === 'undefined') {
            window.AFRAME_BUILDER = {};
        }

        // Create the entities module
        window.AFRAME_BUILDER.entities = {
            /**
             * Gets all entities in the scene
             * @returns {Array} Array of entity objects
             */
            getAll: function () {
                if (window.AFRAME && window.AFRAME.BUILDER && window.AFRAME.BUILDER.scene) {
                    return (window.AFRAME.BUILDER.scene.entities || []).map(e => Object.assign({}, e));
                }
                return [];
            },

            /**
             * Finds an entity by ID
             * @param {string} id - Entity ID to find
             * @returns {Object|null} Entity object if found, null otherwise
             */
            findById: function (id) {
                if (window.AFRAME && window.AFRAME.BUILDER && window.AFRAME.BUILDER.scene) {
                    const entity = (window.AFRAME.BUILDER.scene.entities || []).find(e => e.id === id);
                    return entity ? Object.assign({}, entity) : null;
                }
                return null;
            },

            /**
             * Creates a new entity in the scene
             * @param {string} type - Entity type (e.g., 'box', 'sphere')
             * @param {Object} attributes - Entity attributes
             * @returns {string|null} ID of created entity or null if failed
             */
            create: function (type, attributes) {
                if (window.AFRAME && window.AFRAME.BUILDER &&
                    typeof window.AFRAME.BUILDER.addEntity === 'function') {
                    return window.AFRAME.BUILDER.addEntity(type, attributes);
                }
                return null;
            },

            /**
             * Updates an existing entity
             * @param {string} id - Entity ID to update
             * @param {Object} attributes - New attributes to set
             * @returns {boolean} Success status
             */
            update: function (id, attributes) {
                if (window.AFRAME && window.AFRAME.BUILDER &&
                    typeof window.AFRAME.BUILDER.updateEntity === 'function') {
                    return window.AFRAME.BUILDER.updateEntity(id, attributes);
                }
                return false;
            },

            /**
             * Deletes an entity from the scene
             * @param {string} id - Entity ID to delete
             * @returns {boolean} Success status
             */
            delete: function (id) {
                if (window.AFRAME && window.AFRAME.BUILDER &&
                    typeof window.AFRAME.BUILDER.deleteEntity === 'function') {
                    return window.AFRAME.BUILDER.deleteEntity(id);
                }
                return false;
            }
        };

        console.log("AFRAME_BUILDER Entities module initialized");
    </script>
    <script>
        // Initialize AFRAME_BUILDER if it doesn't exist
        if (typeof window.AFRAME_BUILDER === 'undefined') {
            window.AFRAME_BUILDER = {};
        }

        // Create the network module
        window.AFRAME_BUILDER.network = {
            /**
             * Checks if NAF is available
             * @returns {boolean} Whether NAF is available
             */
            isAvailable: function () {
                return typeof window.NAF !== 'undefined';
            },

            /**
             * Checks if currently connected to NAF
             * @returns {boolean} Connection status
             */
            isConnected: function () {
                return this.isAvailable() &&
                    window.NAF.connection &&
                    window.NAF.connection.isConnected();
            },

            /**
             * Connects to a networked room
             * @param {string} roomName - Room name to connect to
             * @returns {Promise} Promise resolving when connected
             */
            connect: function (roomName) {
                if (!this.isAvailable() || !window.AFRAME || !window.AFRAME.BUILDER) {
                    return Promise.reject(new Error("NAF or AFRAME_BUILDER not available"));
                }

                // Enable NAF
                window.AFRAME.BUILDER.nafEnabled = true;

                // Set room name if provided
                if (roomName) {
                    window.AFRAME.BUILDER.roomName = roomName;
                }

                // Initialize networked camera if available
                if (typeof window.AFRAME.BUILDER.initializeNetworkedCamera === 'function') {
                    window.AFRAME.BUILDER.initializeNetworkedCamera();
                }

                // Connect to NAF
                if (window.NAF.connection) {
                    const options = window.AFRAME.BUILDER.getClientOptions ?
                        window.AFRAME.BUILDER.getClientOptions() : {};

                    return window.NAF.connection.connect(
                        window.AFRAME.BUILDER.roomName || 'default',
                        options
                    );
                }

                return Promise.reject(new Error("NAF connection unavailable"));
            },

            /**
             * Disconnects from the networked room
             */
            disconnect: function () {
                if (this.isConnected()) {
                    window.NAF.connection.disconnect();

                    if (window.AFRAME && window.AFRAME.BUILDER) {
                        window.AFRAME.BUILDER.nafEnabled = false;
                    }

                    console.log("Disconnected from NAF");
                }
            },

            /**
             * Gets the current client ID
             * @returns {string|null} Client ID or null if not connected
             */
            getClientId: function () {
                return this.isConnected() ? window.NAF.clientId : null;
            }
        };

        console.log("AFRAME_BUILDER Network module initialized");
    </script>
    <script>
        // Initialize AFRAME_BUILDER if it doesn't exist
        if (typeof window.AFRAME_BUILDER === 'undefined') {
            window.AFRAME_BUILDER = {};
        }
        // Make sure core exists
        if (typeof window.AFRAME_BUILDER.core === 'undefined') {
            window.AFRAME_BUILDER.core = {};
        }

        // Add to the core module
        window.AFRAME_BUILDER.core.apiMap = {
            // Map of old method names to new module methods
            'switchToBuildCamera': 'camera.switchToBuildCamera',
            'switchToSceneCamera': 'camera.switchToSceneCamera',
            'addEntity': 'entities.create',
            'updateEntity': 'entities.update',
            'deleteEntity': 'entities.delete',
            // Add more mappings as needed
        };
    </script>


</body>

</html>