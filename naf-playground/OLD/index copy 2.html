<!DOCTYPE html>
<html>

<head>
    <title>DLUX Scene Builder</title>
    <!-- aframe -->
    <script src="/js/aframe.min.js"></script>
    <script src="/js/aframe-extras.min.js"></script>
    <script src="/js/aframe-environment-component.min.js"></script>
    <!-- codemirror -->
    <link rel="stylesheet" href="/css/codemirror.min.css">
    <link rel="stylesheet" href="/css/codemirror-monokai.min.css">
    <script src="/js/codemirror.min.js"></script>
    <script src="/js/codemirror-xml.min.js"></script>
    <!-- model-viewer -->
    <script type="module" src="/js/model-viewer.min.js"></script>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Space+Grotesk:wght@300..700&display=swap"
        rel="stylesheet">
    <script src="https://kit.fontawesome.com/0f693ffc58.js" crossorigin="anonymous"></script>

    <style>
        .logotype {
            font-size: 2.5em;
            font-weight: 400;
            font-family: "Audiowide", serif;
            color: #fff;
            margin: 0;
        }

        h3 {
            font-family: 'Space Grotesk', serif;
            font-size: 1.25rem;
            font-weight: 700;
            line-height: 1.3;
        }

        body,
        button {
            font-size: .85rem;
            line-height: 1.3;
            font-weight: 300;
            font-family: Verdana, Geneva, Tahoma, sans-serif;
        }

        .brand-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .nav-logo {
            width: 40px;
            height: 40px;
            fill: #fff;
        }

        .nav-logo .cls-1 {
            fill: #fff;
        }

        .nav-logo .cls-2 {
            fill: #666;
        }

        .nav-logo .cls-3 {
            fill: #999;
        }

        /* Update CSS rules to use A-Frame's class */
        body.aframe-inspector-opened .sidebar,
        body.aframe-inspector-opened .toolbar {
            display: none !important;
        }

        body:not(.aframe-inspector-opened) .sidebar,
        body:not(.aframe-inspector-opened) .toolbar {
            display: block;
        }

        body:not(.aframe-inspector-opened) .toggle-edit {
            display: none;
        }

        body.aframe-inspector-opened .scene-container {
            margin-left: 0 !important;
            width: 100% !important;
        }

        body {
            margin: 0;
        }

        .sponsor-btn {
            display: none !important;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 200px;
            background: #1B1B1B;
            padding: 15px;
            overflow-y: auto;
            color: #fff;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .scene-container {
            flex: 1;
            position: relative;
        }

        .toolbar {
            padding: 10px;
            background: #1B1B1B;
        }

        .hidden {
            display: none;
        }

        #asset-preview {
            max-width: 100%;
            margin-top: 10px;
        }

        .CodeMirror {
            height: 100%;
            font-size: 14px;
        }


        #scene {
            width: 100%;
            height: 100%;
        }

        #code-panel {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            display: none;
        }

        /* Hide the default file input text */
        input[type="file"] {
            color: transparent;
            width: 90px;
            /* Adjust width to only show the button */
        }

        /* Show the "Choose File" button text */
        input[type="file"]::-webkit-file-upload-button {
            visibility: visible;
            color: initial;
        }

        /* Hide the selected filename */
        input[type="file"]::file-selector-button {
            color: initial;
        }

        .asset-preview {
            width: 100%;
            max-height: 150px;
            margin-bottom: 5px;
            display: block;
        }

        .asset-container {
            margin-bottom: 15px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .model-preview {
            width: 100%;
            height: 150px;
            margin-bottom: 5px;
        }

        model-viewer {
            width: 100%;
            height: 100%;
            background-color: #f0f0f0;
        }

        .asset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            padding: 5px;
        }

        .asset-item {
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 4px;
            transition: border-color 0.2s;
        }

        .asset-item:hover {
            border-color: #666;
        }

        .asset-item.active {
            border-color: #fff;
        }

        /* Skybox button styles */
        button.active {
            background-color: #4CAF50;
            color: white;
        }

        /* Styles for assets marked as skyboxes */
        .asset-container.is-skybox {
            background-color: rgba(76, 175, 80, 0.1);
            border-color: #4CAF50;
        }

        .preview-wrapper {
            width: 100%;
            padding-bottom: 100%;
            position: relative;
            overflow: hidden;
            border-radius: 4px;
        }

        .preview-wrapper img,
        .preview-wrapper video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* New styles for the sync button */
        .sync-to-code-panel-container {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #323232;
            padding: 5px 10px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #fff;
            cursor: pointer;
            z-index: 9999;
            white-space: nowrap;
            max-width: 180px;
            transition: left 0.3s;
        }

        .sync-to-code-panel-container.hidden {
            display: none;
        }

        .sync-to-code-panel-container:hover {
            background-color: #424242;
        }

        .sync-to-code-panel-container.syncing {
            background-color: #2196f3;
        }

        .sync-to-code-panel-container.synced {
            background-color: #4caf50;
        }

        .sync-to-code-panel-container.error {
            background-color: #f44336;
        }

        .sync-to-code-panel-status {
            margin-left: 5px;
        }

        body.aframe-inspector-opened .sync-to-code-panel-container {
            display: flex !important;
        }

        body:not(.aframe-inspector-opened) .sync-to-code-panel-container {
            display: none;
        }

        .geometry-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            margin-bottom: 15px;
        }

        .geometry-buttons button {
            width: 100%;
            padding: 8px 5px;
            background: #2c2c2c;
            border: 1px solid #3c3c3c;
            color: #fff;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            justify-content: center;
        }

        .geometry-buttons button:hover {
            background: #3c3c3c;
            border-color: #4c4c4c;
        }

        .geometry-buttons svg {
            width: 24px;
            height: 24px;
            stroke: currentColor;
            stroke-width: 2;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .geometry-buttons .filled {
            fill: currentColor;
            fill-opacity: 0.2;
        }

        .playing {
            background-color: #35a35f;
        }

        .playing:hover {
            background-color: #2d8a50;
        }

        .paused {
            background-color: #2c2c2c;
        }

        .paused:hover {
            background-color: #3c3c3c;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="sidebar">
            <div class="brand-header">
                <svg class="nav-logo" viewBox="0 0 333 333" xmlns="http://www.w3.org/2000/svg">
                    <polygon class="cls-1"
                        points="184.59 135.97 184.21 135.97 110.55 11.06 219.49 9.03 228.91 24.43 137.69 26.25 146.62 41 165.61 72.39 184.6 103.79 193.82 119.03 211.76 119.03 248.48 119.03 284.59 119.02 302.68 119.02 256.79 39.98 273.78 40.15 329.46 134.96 184.59 135.97" />
                    <polygon class="cls-2"
                        points="110.55 11.06 184.21 135.97 184.59 135.97 175.83 150.85 175.52 150.85 101.87 27.04 110.55 11.06" />
                    <polygon class="cls-3"
                        points="184.01 40.5 146.62 41 137.69 26.25 228.91 24.43 184.6 103.79 174.99 87.86 201.39 40.27 184.08 40.5 184.01 40.5" />
                    <polygon class="cls-1" points="56.71 41.63 74.44 41.74 148.19 166.21 129.63 166.16 56.71 41.63" />
                    <polygon class="cls-2"
                        points="85.44 214.65 102.95 182.4 111.45 166.74 102.39 151.26 83.85 119.57 65.61 88.41 56.48 72.79 11.43 152.31 2.99 137.56 56.71 41.63 129.63 166.16 60.3 293.15 3.54 200.14 12.08 184.24 59.71 262.05 67.94 246.89 85.44 214.65" />
                    <polygon class="cls-2"
                        points="184.08 40.5 201.39 40.27 174.99 87.86 184.6 103.79 165.61 72.39 184.01 40.5 184.08 40.5" />
                    <polygon class="cls-2"
                        points="211.76 118.76 256.63 39.89 256.79 39.98 302.68 119.02 284.59 119.02 284.59 118.95 266.04 87.37 256.42 71.01 230.02 118.48 211.76 118.76" />
                    <polygon class="cls-3"
                        points="56.48 72.79 65.61 88.41 65.55 88.45 47.66 120.4 38.4 136.96 92.7 135.78 102.16 151.4 11.43 152.5 11.43 152.31 56.48 72.79" />
                    <polygon class="cls-3"
                        points="256.42 71.01 266.04 87.37 265.75 87.54 248.48 118.39 248.48 119.03 211.76 119.03 211.76 118.76 230.02 118.48 256.42 71.01" />
                    <polygon class="cls-1"
                        points="83.85 119.57 102.39 151.26 102.16 151.4 92.7 135.78 38.4 136.96 47.66 120.4 47.95 120.56 83.29 119.89 83.85 119.57" />
                    <polygon class="cls-3"
                        points="175.83 150.85 184.59 135.97 329.46 134.96 320.41 150.21 175.83 150.85" />
                    <polygon class="cls-3"
                        points="129.63 166.16 148.19 166.21 148.38 166.53 78.48 292.56 60.3 293.15 129.63 166.16" />
                    <polygon class="cls-1"
                        points="48.62 214.87 67.94 246.89 59.71 262.05 12.08 184.24 102.95 182.4 94.06 198.74 39.65 199.99 48.59 214.81 48.62 214.87" />
                    <polygon class="cls-3"
                        points="102.95 182.4 85.44 214.65 48.62 214.87 48.59 214.81 39.65 199.99 94.06 198.74 102.95 182.4" />
                    <polygon class="cls-1"
                        points="175.84 182.61 319.13 180.4 330.01 196.91 185.61 198.39 175.84 182.61 175.84 182.61" />
                    <polygon class="cls-2"
                        points="175.47 182.61 175.84 182.61 175.84 182.61 185.61 198.39 113.76 323.97 104.73 308.18 175.47 182.61" />
                    <polygon class="cls-3"
                        points="167.45 261.43 149.16 293.24 140.56 308.18 231.79 307.99 222.72 323.59 113.76 323.97 185.61 198.39 330.01 196.91 276.31 291.28 259.33 291.82 303.59 213.44 284.52 213.57 249.4 213.81 230.83 213.93 212.56 214.06 194.63 214.18 185.75 229.62 167.45 261.43" />
                    <polygon class="cls-2"
                        points="212.56 214.06 230.83 213.93 258.27 260.81 267.49 244.22 284.52 213.57 303.59 213.44 259.33 291.82 259.17 291.92 212.56 214.06" />
                    <polygon class="cls-1"
                        points="230.83 213.93 249.4 213.81 267.23 244.08 267.49 244.22 258.27 260.81 230.83 213.93" />
                    <polygon class="cls-2"
                        points="167.45 261.43 185.75 229.62 176.49 245.76 203.93 292.76 186.62 292.91 186.56 292.91 167.45 261.43" />
                    <polygon class="cls-1"
                        points="186.56 292.91 186.62 292.91 203.93 292.76 176.49 245.76 185.75 229.62 231.79 307.99 140.56 308.18 149.16 293.24 186.56 292.91" />
                </svg>
                <h1 class="logotype">DLUX</h1>
            </div>
            <!-- Add environment presets section -->
            <div class="panel-section">
                <h3>Environment</h3>
                <div style="margin-bottom: 15px; position: relative;">
                    <div style="position: relative; width: 100%;">
                        <select id="environment-preset"
                            style="width: 100%; background: #2c2c2c; color: #fff; border: 1px solid #3c3c3c; padding: 100px 8px 8px 8px; border-radius: 4px; appearance: none; text-align: left;">
                            <option value="none">None (Disable)</option>
                            <option value="default">Default</option>
                            <option value="contact">Contact</option>
                            <option value="forest">Forest</option>
                            <option value="egypt">Egypt</option>
                            <option value="checkerboard">Checkerboard</option>
                            <option value="goaland">Goaland</option>
                            <option value="yavapai">Yavapai</option>
                            <option value="goldmine">Goldmine</option>
                            <option value="threetowers">Three Towers</option>
                            <option value="poison">Poison</option>
                            <option value="arches">Arches</option>
                            <option value="tron">Tron</option>
                            <option value="japan">Japan</option>
                            <option value="dream">Dream</option>
                            <option value="volcano">Volcano</option>
                            <option value="starry">Starry</option>
                            <option value="osiris">Osiris</option>
                            <option value="moon">Moon</option>
                        </select>
                        <div id="environment-icon"
                            style="position: absolute; left: 0; top: 0; width: 100%; height: 92px; pointer-events: none; overflow: hidden; border-radius: 4px 4px 0 0;">
                            <img src="/playground/env_thumbs/none.png" alt="none environment"
                                style="width: 100%; height: 100%; object-fit: cover;">
                        </div>
                        <!-- Previous button -->
                        <div id="prev-environment"
                            style="position: absolute; left: 0; top: 0; width: 40px; height: 92px; display: flex; align-items: center; justify-content: center; cursor: pointer; background: linear-gradient(to right, rgba(0,0,0,0.5), transparent);">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M15 6l-6 6 6 6" />
                            </svg>
                        </div>
                        <!-- Next button -->
                        <div id="next-environment"
                            style="position: absolute; right: 0; top: 0; width: 40px; height: 92px; display: flex; align-items: center; justify-content: center; cursor: pointer; background: linear-gradient(to left, rgba(0,0,0,0.5), transparent);">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M9 6l6 6-6 6" />
                            </svg>
                        </div>
                        <div style="position: absolute; right: 8px; bottom: 8px; pointer-events: none;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M7 10l5 5 5-5z" />
                            </svg>
                        </div>
                    </div>
                </div>
                <script>
                    // Environment thumbnails mapping (to be populated with actual images)
                    const environmentThumbnails = {
                        none: '/playground/env_thumbs/none.png',
                        default: '/playground/env_thumbs/default.png',
                        contact: '/playground/env_thumbs/contact.png',
                        forest: '/playground/env_thumbs/forest.png',
                        egypt: '/playground/env_thumbs/egypt.png',
                        checkerboard: '/playground/env_thumbs/checkerboard.png',
                        goaland: '/playground/env_thumbs/goaland.png',
                        yavapai: '/playground/env_thumbs/yavapai.png',
                        goldmine: '/playground/env_thumbs/goldmine.png',
                        threetowers: '/playground/env_thumbs/threetowers.png',
                        poison: '/playground/env_thumbs/poison.png',
                        arches: '/playground/env_thumbs/arches.png',
                        tron: '/playground/env_thumbs/tron.png',
                        japan: '/playground/env_thumbs/japan.png',
                        dream: '/playground/env_thumbs/dream.png',
                        volcano: '/playground/env_thumbs/volcano.png',
                        starry: '/playground/env_thumbs/starry.png',
                        osiris: '/playground/env_thumbs/osiris.png',
                        moon: '/playground/env_thumbs/moon.png'
                    };

                    const select = document.getElementById('environment-preset');
                    const iconContainer = document.getElementById('environment-icon');

                    // Get ordered list of environments
                    const environments = Array.from(select.options).map(option => option.value);

                    // Update thumbnail when environment changes
                    function updateEnvironmentDisplay(value) {
                        const thumbnailPath = environmentThumbnails[value];
                        if (thumbnailPath) {
                            iconContainer.innerHTML = `<img src="${thumbnailPath}" alt="${value} environment" style="width: 100%; height: 100%; object-fit: cover;">`;
                        } else {
                            iconContainer.innerHTML = `<div style="width: 100%; height: 100%; background: #1c1c1c; display: flex; align-items: center; justify-content: center; color: #666;">Environment Preview</div>`;
                        }
                    }

                    // Handle environment changes
                    select.addEventListener('change', function (e) {
                        updateEnvironmentDisplay(e.target.value);
                    });

                    // Navigate to previous environment
                    document.getElementById('prev-environment').addEventListener('click', function (e) {
                        e.stopPropagation();
                        const currentIndex = environments.indexOf(select.value);
                        const prevIndex = (currentIndex - 1 + environments.length) % environments.length;
                        select.value = environments[prevIndex];
                        select.dispatchEvent(new Event('change'));
                    });

                    // Navigate to next environment
                    document.getElementById('next-environment').addEventListener('click', function (e) {
                        e.stopPropagation();
                        const currentIndex = environments.indexOf(select.value);
                        const nextIndex = (currentIndex + 1) % environments.length;
                        select.value = environments[nextIndex];
                        select.dispatchEvent(new Event('change'));
                    });
                </script>
                <div class="background-color-picker" style="margin-bottom: 15px;">
                    <label for="background-color" style="display: block; margin-bottom: 5px;">Background Color</label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="color" id="background-color" value="#ECECEC"
                            style="width: 50px; height: 30px; padding: 0;">
                        <input type="text" id="background-color-hex" value="#ECECEC"
                            style="width: 80px; background: #2c2c2c; color: #fff; border: 1px solid #3c3c3c; padding: 5px;">
                    </div>
                </div>

            </div>
            <div class="fog-controls"
                style="margin-bottom: 15px; border: 1px solid #3c3c3c; border-radius: 4px; overflow: hidden;">
                <div class="collapsible-button"
                    style="background: #3c3c3c; padding: 8px 12px; cursor: pointer; user-select: none; display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s;"
                    onclick="toggleFogControls()" onmouseover="this.style.background='#4a4a4a'"
                    onmouseout="this.style.background='#3c3c3c'">
                    <h3 style="margin: 0; padding: 0; color: #fff; font-size: 16px;">Fog</h3>
                    <span id="fog-collapse-icon"
                        style="font-size: 12px; transition: transform 0.3s; transform: rotate(0deg); color: #fff;">▼</span>
                </div>
                <div id="fog-collapse-content"
                    style="overflow: hidden; transition: max-height 0.3s ease-out; max-height: 0px; background: #2c2c2c; border-top: 1px solid #3c3c3c;">
                    <div style="padding: 10px;">
                        <div style="margin-bottom: 10px;">
                            <label style="display: block; margin-bottom: 5px;">Fog Color</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="color" id="fog-color" value="#ffffff"
                                    style="width: 50px; height: 30px; padding: 0;">
                                <input type="text" id="fog-color-hex" value="#ECECEC"
                                    style="width: 80px; background: #2c2c2c; color: #fff; border: 1px solid #3c3c3c; padding: 5px;">
                            </div>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label style="display: block; margin-bottom: 5px;">Fog Type</label>
                            <div
                                style="display: flex; gap: 10px; align-items: center; background: #2c2c2c; padding: 5px; border-radius: 4px; border: 1px solid #3c3c3c;">
                                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                    <input type="radio" name="fog-type" value="linear" style="margin: 0;">
                                    <span style="color: #fff;">Linear</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                    <input type="radio" name="fog-type" value="exponential" checked style="margin: 0;">
                                    <span style="color: #fff;">Exponential</span>
                                </label>
                            </div>
                        </div>
                        <div id="fog-linear-controls" style="margin-bottom: 10px; display: none;">
                            <div style="margin-bottom: 10px;">
                                <label style="display: block; margin-bottom: 5px;">Near Distance</label>
                                <input type="range" id="fog-near" min="0" max="100" step="0.1" value="1"
                                    style="width: 100%;">
                            </div>
                            <div style="margin-bottom: 10px;">
                                <label style="display: block; margin-bottom: 5px;">Far Distance</label>
                                <input type="range" id="fog-far" min="0" max="250" step="0.1" value="50"
                                    style="width: 100%;">
                            </div>
                        </div>
                        <div id="fog-exponential-controls" style="margin-bottom: 10px; display: block;">
                            <label style="display: block; margin-bottom: 5px;">Density</label>
                            <input type="range" id="fog-intensity" min="0" max="1" step="0.01" value="0.25"
                                style="width: 100%;">
                        </div>
                        <button id="toggle-fog-btn" onclick="toggleFog()" class="effect-btn" style="width: 100%;">
                            <span>Add Fog</span>
                        </button>
                    </div>
                </div>
            </div>
            <h3>Assets</h3>
            <div style="margin-bottom: 15px;">
                <input type="file" id="asset-upload" accept="image/*,video/*,.gltf,.glb" onchange="handleFileUpload()"
                    style="display: none;">
                <button onclick="document.getElementById('asset-upload').click()" class="effect-btn"
                    style="width: 100%;">
                    <svg viewBox="0 0 24 24">
                        <path d="M12,4L12,20" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                        <path d="M4,12L20,12" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                    </svg>
                    <span>Add File</span>
                </button>
            </div>
            <div id="asset-library"></div>
            <h3>Add Objects</h3>
            <div class="geometry-buttons">
                <!-- Basic Shapes -->
                <button onclick="addEntity('box')">
                    <svg viewBox="0 0 24 24">
                        <rect x="4" y="4" width="16" height="16" class="filled" />
                    </svg>
                    Box
                </button>
                <button onclick="addEntity('sphere')">
                    <svg viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="8" class="filled" />
                        <ellipse cx="12" cy="12" rx="8" ry="3" />
                        <line x1="4" y1="12" x2="20" y2="12" />
                    </svg>
                    Sphere
                </button>
                <button onclick="addEntity('cylinder')">
                    <svg viewBox="0 0 24 24">
                        <path d="M6 7 C6 7 6 17 6 17 C6 19 12 19 12 17 C12 17 12 7 12 7 C12 5 6 5 6 7" class="filled" />
                        <ellipse cx="9" cy="7" rx="3" ry="1" />
                        <ellipse cx="9" cy="17" rx="3" ry="1" />
                    </svg>
                    Cylinder
                </button>
                <button onclick="addEntity('plane')">
                    <svg viewBox="0 0 24 24">
                        <path d="M4 12 L12 6 L20 12 L12 18 Z" class="filled" />
                    </svg>
                    Plane
                </button>
                <button onclick="addEntity('cone')">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 4 L4 20 L20 20 Z" class="filled" />
                    </svg>
                    Cone
                </button>
                <button onclick="addEntity('torus')">
                    <svg viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="8" class="filled" />
                        <circle cx="12" cy="12" r="4" />
                    </svg>
                    Torus
                </button>
                <button onclick="addEntity('ring')">
                    <svg viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="8" />
                        <circle cx="12" cy="12" r="4" />
                    </svg>
                    Ring
                </button>
                <button onclick="addEntity('circle')">
                    <svg viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="8" />
                    </svg>
                    Circle
                </button>
                <button onclick="addEntity('dodecahedron')">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 4 L18 8 L18 16 L12 20 L6 16 L6 8 Z" class="filled" />
                        <line x1="12" y1="4" x2="12" y2="20" />
                        <line x1="6" y1="8" x2="18" y2="8" />
                        <line x1="6" y1="16" x2="18" y2="16" />
                    </svg>
                    Dodecahedron
                </button>
                <button onclick="addEntity('octahedron')">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 4 L20 12 L12 20 L4 12 Z" class="filled" />
                    </svg>
                    Octahedron
                </button>
                <button onclick="addEntity('tetrahedron')">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 4 L18 18 L6 18 Z" class="filled" />
                        <line x1="6" y1="18" x2="18" y2="18" />
                    </svg>
                    Tetrahedron
                </button>
                <button onclick="addEntity('triangle')">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 4 L20 18 L4 18 Z" />
                    </svg>
                    Triangle
                </button>
                <button onclick="addEntity('torusKnot')">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 8 C16 8 16 16 12 16 C8 16 8 8 12 8" class="filled" />
                        <path d="M8 12 C8 8 16 8 16 12 C16 16 8 16 8 12" />
                    </svg>
                    Torus Knot
                </button>
                <button onclick="addEntity('ocean')">
                    <svg viewBox="0 0 24 24">
                        <path d="M4 14 Q8 10 12 14 Q16 18 20 14" class="filled" />
                        <path d="M4 18 Q8 14 12 18 Q16 22 20 18" />
                    </svg>
                    Ocean
                </button>
                <button onclick="addEntity('tube')">
                    <svg viewBox="0 0 24 24">
                        <path d="M4 12 C8 6 16 18 20 12" class="filled" />
                    </svg>
                    Tube
                </button>
                <button onclick="addEntity('grid')">
                    <svg viewBox="0 0 24 24">
                        <path d="M4 4 L20 4 L20 20 L4 20 Z" />
                        <line x1="9" y1="4" x2="9" y2="20" />
                        <line x1="15" y1="4" x2="15" y2="20" />
                        <line x1="4" y1="9" x2="20" y2="9" />
                        <line x1="4" y1="15" x2="20" y2="15" />
                    </svg>
                    Grid
                </button>
            </div>

            <h3>Particle Effects</h3>
            <div class="particle-buttons"
                style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; margin-bottom: 15px;">
                <button id="snow-btn" onclick="toggleParticleSystem('snow')" class="effect-btn">
                    <svg viewBox="0 0 24 24">
                        <circle cx="6" cy="6" r="1" />
                        <circle cx="10" cy="12" r="1" />
                        <circle cx="15" cy="6" r="1" />
                        <circle cx="19" cy="12" r="1" />
                        <circle cx="8" cy="18" r="1" />
                        <circle cx="16" cy="18" r="1" />
                        <circle cx="12" cy="4" r="1" />
                        <circle cx="4" cy="12" r="1" />
                        <circle cx="20" cy="4" r="1" />
                    </svg>
                    Snow
                </button>
                <button id="dust-btn" onclick="toggleParticleSystem('dust')" class="effect-btn">
                    <svg viewBox="0 0 24 24">
                        <circle cx="6" cy="6" r="1" />
                        <circle cx="10" cy="12" r="1" />
                        <circle cx="15" cy="6" r="1" />
                        <circle cx="19" cy="12" r="1" />
                        <circle cx="8" cy="18" r="1" />
                        <circle cx="16" cy="18" r="1" />
                        <circle cx="12" cy="4" r="1" />
                        <circle cx="4" cy="12" r="1" />
                        <circle cx="20" cy="4" r="1" />
                    </svg>
                    Dust
                </button>
                <button id="rain-btn" onclick="toggleParticleSystem('rain')" class="effect-btn">
                    <svg viewBox="0 0 24 24">
                        <!-- Simplified rain drops icon - just vertical lines -->
                        <path d="M6,8L6,20" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                        <path d="M10,4L10,18" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                        <path d="M14,6L14,19" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                        <path d="M18,5L18,16" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                    </svg>
                    Rain
                </button>
                <button id="toggle-animation-btn" onclick="toggleParticleAnimation()" class="effect-btn" disabled>
                    <svg viewBox="0 0 24 24">
                        <path d="M8 5v14l11-7z" id="animation-icon" />
                    </svg>
                    <span id="animation-text">Start</span>
                </button>
            </div>
            
            <!-- Commenting out skybox uploader - to be replaced
            <div class="panel-section">
                <h3>Skybox</h3>

                <div id="skybox-container" class="asset-grid" style="margin-bottom: 10px;">
                    
                </div>
                <div style="margin-bottom: 15px;">
                  
                    <input type="file" id="skybox-input" accept="image/*,video/*" style="display: none;">
                    <button onclick="document.getElementById('skybox-input').click()" class="effect-btn"
                        style="width: 100%;">
                        <svg viewBox="0 0 24 24">
                            <path d="M12,4L12,20" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                            <path d="M4,12L20,12" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                        </svg>
                        Upload Skybox
                    </button>
                   
                </div>
            </div> -->
        </div>

        <div class="main-content">
            <div class="toolbar" id="view-selector">
                <button onclick="switchToView('code')">Edit Code</button>
                <button onclick="switchToView('scene')">Preview Scene</button>
                <button onclick="switchToView('inspector')">Inspector</button>
                <button onclick="saveScene()">Save Scene</button>
                <button onclick="resetScene()">Reset Scene</button>
                <button onclick="clearScene()">Clear Scene</button>
                <button onclick="clearEntities()">Clear Entities</button>
            </div>

            <div class="scene-container">
                <a-scene embedded id="scene" background="color: #ECECEC">
                    <a-assets id="asset-container">
                        <!-- Uploaded assets will be added here -->
                    </a-assets>

                    <!-- Default scene setup -->
                    <a-box position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9"></a-box>
                    <a-sphere position="0 1.25 -5" radius="1.25" color="#EF2D5E"></a-sphere>
                    <a-cylinder position="1 0.75 -3" radius="0.5" height="1.5" color="#FFC65D"></a-cylinder>
                    <a-plane position="0 0 -4" rotation="-90 0 0" width="4" height="4" color="#7BC8A4"></a-plane>
                    <a-camera position="0 1.6 0"></a-camera>
                </a-scene>
                <div id="code-panel"></div>
            </div>
        </div>
    </div>

    <div class="sync-to-code-panel-container hidden">
        <span class="sync-to-code-panel-status">Sync to Code Panel</span>
    </div>

    <script>
        let currentView = 'scene';
        let scene = document.querySelector('a-scene');
        const codePanel = document.querySelector('#code-panel');
        let editor;

        // Initialize CodeMirror with performance tweaks
        editor = CodeMirror(codePanel, {
            mode: 'xml',
            theme: 'monokai',
            lineNumbers: true,
            lineWrapping: true,
            indentUnit: 4,
            autoCloseTags: true,
            value: '',
            inputStyle: 'contenteditable', // Reduce touch event blocking
            viewportMargin: 10 // Improve scroll performance
        });

        /* // Add passive event listeners to suppress warnings
        const cmElement = codePanel.querySelector('.CodeMirror');
        cmElement.addEventListener('touchstart', () => { }, { passive: true });
        cmElement.addEventListener('touchmove', () => { }, { passive: true });
        cmElement.addEventListener('mousewheel', () => { }, { passive: true }); */

        function switchToView(view) {
            const previousView = currentView;
            currentView = view;

            cleanupInspector(); // Ensure inspector is closed and cleaned up before switching views

            switch (view) {
                case 'scene':
                    scene.style.display = 'block';
                    codePanel.style.display = 'none';
                    if (previousView === 'code') {
                        updateSceneFromCode();
                    } else {
                        // Even when not coming from code view, sync environment dropdown
                        syncEnvironmentPresetDropdown();

                        // Also check for and fix default light duplication
                        fixDefaultLightDuplication();
                    }
                    break;

                case 'code':
                    scene.style.display = 'none';
                    codePanel.style.display = 'block';
                    // Update code panel before switching to code view
                    updateCodePanel();
                    break;

                case 'inspector':
                    scene.style.display = 'block';
                    codePanel.style.display = 'none';
                    if (previousView === 'code') {
                        updateSceneFromCode();
                    } else {
                        // Fix light duplication before opening inspector
                        fixDefaultLightDuplication();
                    }
                    setTimeout(() => {
                        openInspector();
                    }, 100);
                    break;
            }
        }

        function updateSceneFromCode(code) {
            // If no code is provided, get it from the editor
            if (!code && editor) {
                code = editor.getValue();
            }
            
            // Create a temporary container
            const tempContainer = document.createElement('div');
            tempContainer.innerHTML = code;

            // Get the scene element from the temporary container
            const newScene = tempContainer.querySelector('a-scene');
            if (!newScene) {
                console.error('No scene element found in code, changes made to the code aren\'t saved to the dom');
                return;
            }

            // Create a new scene with the same configuration
            const scene = document.createElement('a-scene');
            scene.setAttribute('embedded', '');
            scene.setAttribute('renderer', 'antialias: true; colorManagement: true; physicallyCorrectLights: true; sortObjects: true;');

            // Set scene attributes from the new scene
            const sceneAttributes = newScene.attributes;
            for (let i = 0; i < sceneAttributes.length; i++) {
                const attr = sceneAttributes[i];
                if (attr.name !== 'embedded') { // Skip embedded as we set it above
                    scene.setAttribute(attr.name, attr.value);
                }
            }

            // Transfer all children from the new scene to our scene
            Array.from(newScene.children).forEach(child => {
                scene.appendChild(child.cloneNode(true));
            });

            // Replace the old scene with the new one
            const oldScene = document.querySelector('a-scene');
            oldScene.parentNode.replaceChild(scene, oldScene);

            // Update the scene reference
            window.scene = scene;

            // Wait for the scene to initialize
            setTimeout(() => {
                // Check for environment
                const environment = scene.querySelector('a-entity[environment]');
                if (!environment) {
                    // If no environment, add default ambient and directional lights
                    const ambientLight = document.createElement('a-entity');
                    ambientLight.setAttribute('light', 'color: #BBB; type: ambient');
                    scene.appendChild(ambientLight);

                    const directionalLight = document.createElement('a-entity');
                    directionalLight.setAttribute('light', 'color: #FFF; intensity: 1.884; castShadow: true');
                    directionalLight.setAttribute('position', '-0.5 1 1');
                    scene.appendChild(directionalLight);

                  
                }

                // Force a render
                if (scene.renderer) {
                    scene.renderer.render(scene.object3D, scene.camera);
                }

                // Check for environments or custom skybox
                const hasEnvironment = scene.querySelector('a-entity[environment]');
                const hasCustomSkybox = scene.querySelector('a-sky[src]');
                if (hasEnvironment || hasCustomSkybox) {
                    // Enable sky color picker for overriding background
                    document.getElementById('sky-color').disabled = false;
                }

                // Update code panel
                updateCodePanel();
            }, 100);

            // Add event listener for when scene is loaded
            scene.addEventListener('loaded', function () {
                // Force a render
                if (scene.renderer) {
                    scene.renderer.render(scene.object3D, scene.camera);
                }

                // Check for environments or custom skybox
                const hasEnvironment = scene.querySelector('a-entity[environment]');
                const hasCustomSkybox = scene.querySelector('a-sky[src]');
                if (hasEnvironment || hasCustomSkybox) {
                    // Enable sky color picker for overriding background
                    document.getElementById('sky-color').disabled = false;
                }

                // Update code panel
                updateCodePanel();
            });
        }

        function syncAssetsWithSidebar() {
            const assetContainer = document.getElementById('asset-container');
            const sidebarAssets = document.querySelectorAll('.asset-container');

            sidebarAssets.forEach(sidebarAsset => {
                const assetId = sidebarAsset.dataset.assetId;
                if (!assetContainer.querySelector(`#${assetId}`)) {
                    sidebarAsset.remove();
                }
            });
        }

        function toggleInspector() {
            // Check if AFRAME.INSPECTOR exists, if not load it
            if (!AFRAME.INSPECTOR || !AFRAME.INSPECTOR.opened) {
                // Inject the inspector script if it hasn't been loaded
                const inspectorScript = document.createElement('script');
                inspectorScript.src = 'https://cdn.jsdelivr.net/gh/aframevr/aframe-inspector@master/dist/aframe-inspector.min.js';
                inspectorScript.onload = () => {
                    AFRAME.INSPECTOR.open();
                    setupInspectorListeners();
                };
                document.head.appendChild(inspectorScript);
            } else {
                // Toggle the inspector if it's already loaded
                AFRAME.INSPECTOR.opened ? AFRAME.INSPECTOR.close() : AFRAME.INSPECTOR.open();
            }
        }

        function setupInspectorListeners() {
            // Disconnect existing observer if present
            if (window.sceneObserver) {
                window.sceneObserver.disconnect();
            }

            // Create a new observer
            window.sceneObserver = new MutationObserver(() => {
                updateCodePanel();
            });

            // Observe all entities for attribute changes
            scene.querySelectorAll('*').forEach(entity => {
                window.sceneObserver.observe(entity, {
                    attributes: true,
                    childList: true,
                    subtree: true
                });
            });

            // Listen for new entities being added
            scene.addEventListener('child-attached', (evt) => {
                window.sceneObserver.observe(evt.detail.el, {
                    attributes: true,
                    childList: true,
                    subtree: true
                });
                updateCodePanel();
            });

            // Inspector events
            document.addEventListener('inspector-loaded', () => {
                document.body.classList.add('aframe-inspector-opened');
                setupInspectorChangeWatcher();
            });

            document.addEventListener('inspector-closed', () => {
                document.body.classList.remove('aframe-inspector-opened');
                if (currentView === 'inspector') {
                    switchToView('scene');
                }
                flushAllEntitiesToDOM();
                updateCodePanel();
            });
        }

        function updateCodePanel() {
            fixDefaultLightDuplication();
            const sceneClone = scene.cloneNode(true);
            cleanupSceneElement(sceneClone);

            // Start with the scene tag and its attributes
            let content = '';

            content += '<a-scene';
            if (scene.hasAttribute('embedded')) content += ' embedded';

            // Always include background color if present
            if (scene.hasAttribute('background')) {
                const background = scene.getAttribute('background');
                // Format the background attribute properly
                if (typeof background === 'string') {
                    // New format (string)
                    // Extract color and ensure it's uppercase
                    const match = background.match(/color:\s*(#[0-9A-Fa-f]{6})/i);
                    if (match) {
                        const color = match[1].toUpperCase();
                        content += ` background="color: ${color}"`;
                    } else {
                        content += ` background="${background}"`;
                    }
                } else {
                    // Old format (object)
                    const color = background.color || '#ECECEC';
                    content += ` background="color: ${color.toUpperCase()}"`;
                }
            }

            // Add fog if active
            if (fogActive && scene.hasAttribute('fog')) {
                const fogColor = document.getElementById('fog-color').value.toUpperCase();
                const fogType = document.querySelector('input[name="fog-type"]:checked').value;
                let fogString;
                if (fogType === 'linear') {
                    const fogNear = document.getElementById('fog-near').value;
                    const fogFar = document.getElementById('fog-far').value;
                    fogString = `type: linear; color: ${fogColor}; near: ${fogNear}; far: ${fogFar}`;
                } else {
                    const fogIntensity = document.getElementById('fog-intensity').value;
                    fogString = `type: exponential; color: ${fogColor}; density: ${fogIntensity}`;
                }
                content += ` fog="${fogString}"`;
            }
            content += '>\n';

            // Add all the scene content
            content += formatSceneContent(sceneClone);

            // Close the scene tag
            content += '</a-scene>';

            // Update the editor
            editor.setValue(content);
            editor.refresh();
        }

        function cleanupSceneElement(el) {
            const injectedSelectors = [
                'canvas',
                '.a-enter-vr',
                '.a-orientation-modal',
                '.a-loader-title',
                '[aframe-injected]'
            ];
            injectedSelectors.forEach(selector => {
                el.querySelectorAll(selector).forEach(node => node.remove());
            });

            const attributesToRemove = [
                'aframe-injected',
                'data-aframe-canvas',
                'data-engine',
                'geometry',
                'camera',
                'look-controls',
                'wasd-controls'
            ];
            el.querySelectorAll('*').forEach(node => {
                attributesToRemove.forEach(attr => {
                    if (node.getAttribute(attr) === '') {
                        node.removeAttribute(attr);
                    }
                });
            });
        }

        function addEntity(type) {
            let entity;
            if (type === 'ocean') {
                entity = document.createElement('a-ocean');
                entity.setAttribute('color', '#92E2E2');
                entity.setAttribute('width', '25');
                entity.setAttribute('depth', '25');
                entity.setAttribute('density', '15');
                entity.setAttribute('speed', '2');
                entity.setAttribute('position', '0 0 0');
                entity.setAttribute('rotation', '-90 0 0');
            } else if (type === 'torusKnot') {
                entity = document.createElement('a-entity');
                const randomColor = Math.floor(Math.random() * 16777215).toString(16);
                entity.setAttribute('position', '0 1.5 -3');
                entity.setAttribute('geometry', {
                    primitive: 'torusKnot',
                    radius: 1,
                    radiusTubular: 0.1,
                    p: 2,
                    q: 3
                });
                entity.setAttribute('material', {
                    color: '#' + randomColor,
                    metalness: 0.3,
                    roughness: 0.6
                });
            } else if (type === 'tube') {
                entity = document.createElement('a-tube');
                const randomColor = Math.floor(Math.random() * 16777215).toString(16);
                entity.setAttribute('path', '5 0 5, 5 0 -5, -5 0 -5');
                entity.setAttribute('radius', '0.5');
                entity.setAttribute('material', {
                    color: '#' + randomColor,
                    metalness: 0.3,
                    roughness: 0.6
                });
            } else if (type === 'grid') {
                entity = document.createElement('a-grid');
                entity.setAttribute('width', 20);
                entity.setAttribute('height', 20);
                entity.setAttribute('position', '0 0 0');
                entity.setAttribute('rotation', '-90 0 0');
                entity.setAttribute('material', {
                    color: '#666666',
                    opacity: 0.5
                });
            } else {
                entity = document.createElement(`a-${type}`);
                const randomColor = Math.floor(Math.random() * 16777215).toString(16);
                entity.setAttribute('position', '0 1.5 -3');
                entity.setAttribute('color', '#' + randomColor);
                entity.setAttribute('material', 'color: #' + randomColor);
                entity.setAttribute('geometry', 'primitive: ' + type);
            }

            insertEntityInScene(entity);
            flushAllEntitiesToDOM();
            updateCodePanel();
        }

        function useAsset(assetId, type) {
            let entity;
            const entityId = `${type.split('/')[0]}-${assetId}`; // Unique ID for the entity
            const assetElement = document.getElementById(assetId);

            if (type.startsWith('image/')) {
                // Calculate aspect ratio for images
                const aspectRatio = assetElement.naturalWidth / assetElement.naturalHeight;
                const baseWidth = 5; // Base width in meters
                const height = baseWidth / aspectRatio;

                entity = document.createElement('a-image');
                entity.setAttribute('src', `#${assetId}`);
                entity.setAttribute('width', baseWidth);
                entity.setAttribute('height', height);
                entity.setAttribute('position', '0 1.5 -3');
                entity.setAttribute('id', entityId);
            } else if (type.startsWith('video/')) {
                // For videos, we need to wait for metadata to load to get dimensions
                const video = assetElement;
                const setVideoDimensions = () => {
                    const aspectRatio = video.videoWidth / video.videoHeight;
                    const baseWidth = 8; // Base width in meters for videos
                    const height = baseWidth / aspectRatio;

                    entity.setAttribute('width', baseWidth);
                    entity.setAttribute('height', height);
                };

                entity = document.createElement('a-video');
                entity.setAttribute('src', `#${assetId}`);
                entity.setAttribute('position', '0 1.5 -3');
                entity.setAttribute('id', entityId);

                // If video metadata is already loaded, set dimensions immediately
                if (video.videoWidth) {
                    setVideoDimensions();
                } else {
                    // Otherwise wait for metadata to load
                    video.addEventListener('loadedmetadata', setVideoDimensions);
                }
            } else if (type.includes('gltf')) {
                entity = document.createElement('a-entity');
                entity.setAttribute('gltf-model', `#${assetId}`);
                entity.setAttribute('position', '0 1.5 -3');
                entity.setAttribute('scale', '1 1 1');
                entity.setAttribute('id', entityId);
            }

            insertEntityInScene(entity);
            flushAllEntitiesToDOM();
            updateCodePanel();
        }

        // Helper function to insert entities correctly
        function insertEntityInScene(entity) {
            // First check if we have an environment
            const hasEnvironment = !!scene.querySelector('a-entity[environment]');

            if (hasEnvironment) {
                // When environment is active, insert new entities at the beginning
                // so they appear in front of the environment
                const firstChild = scene.firstElementChild;
                if (firstChild && firstChild !== entity) {
                    scene.insertBefore(entity, firstChild);
                } else {
                    scene.appendChild(entity);
                }
            } else {
                // Normal insertion logic when no environment is active
                const sky = scene.querySelector('a-sky');
                const firstLight = scene.querySelector('[light]');

                // Make sure the elements are actually children of the scene before using insertBefore
                if (sky && sky.parentNode === scene) {
                    scene.insertBefore(entity, sky);
                } else if (firstLight && firstLight.parentNode === scene) {
                    scene.insertBefore(entity, firstLight);
                } else {
                    scene.appendChild(entity);
                }
            }

            // Notify inspector of new entity
            scene.emit('child-attached', { el: entity });

            updateCodePanel();
        }

        function handleFileUpload() {
            const fileInput = document.getElementById('asset-upload');
            const file = fileInput.files[0];
            const assetContainer = document.getElementById('asset-container');

            if (file) {
                const assetId = 'asset-' + Date.now();
                const assetUrl = URL.createObjectURL(file);

                let assetEl;
                if (file.type.startsWith('image/')) {
                    assetEl = document.createElement('img');
                    assetEl.setAttribute('src', assetUrl);
                    assetEl.setAttribute('id', assetId);
                    addToAssetLibrary(assetId, file.type, file);
                } else if (file.type.startsWith('video/')) {
                    assetEl = document.createElement('video');
                    assetEl.setAttribute('src', assetUrl);
                    assetEl.setAttribute('id', assetId);
                    assetEl.setAttribute('loop', 'true');
                    assetEl.setAttribute('autoplay', 'auto');
                    addToAssetLibrary(assetId, file.type, file);
                } else if (file.name.endsWith('.gltf') || file.name.endsWith('.glb')) {
                    assetEl = document.createElement('a-asset-item');
                    assetEl.setAttribute('id', assetId);
                    assetEl.setAttribute('src', assetUrl);
                    assetEl.setAttribute('response-type', 'arraybuffer');
                    assetEl.addEventListener('loaded', () => {
                        addToAssetLibrary(assetId, 'model/gltf-binary', file);
                    });
                }

                assetContainer.appendChild(assetEl);
                updateCodePanel();

                // Reset file input to allow re-uploading the same file
                fileInput.value = '';
            }
        }

        function addToAssetLibrary(assetId, type, file) {
            const library = document.getElementById('asset-library');
            const container = document.createElement('div');
            container.className = 'asset-container';
            container.dataset.assetId = assetId;

            const fileName = file.name;

            // Add preview based on type
            if (type.startsWith('image/')) {
                const preview = document.createElement('img');
                preview.src = URL.createObjectURL(file);
                preview.className = 'asset-preview';
                container.appendChild(preview);
            } else if (type.startsWith('video/')) {
                const preview = document.createElement('video');
                preview.src = URL.createObjectURL(file);
                preview.className = 'asset-preview';
                preview.setAttribute('muted', '');
                preview.setAttribute('loop', '');
                preview.play();
                container.appendChild(preview);
            } else if (type.includes('gltf')) {
                const preview = document.createElement('div');
                preview.className = 'model-preview';

                const modelViewer = document.createElement('model-viewer');
                modelViewer.src = URL.createObjectURL(file);
                modelViewer.setAttribute('auto-rotate', '');
                modelViewer.setAttribute('camera-controls', '');
                modelViewer.setAttribute('ar', '');
                modelViewer.setAttribute('shadow-intensity', '1');
                modelViewer.setAttribute('camera-orbit', '45deg 55deg 2.5m');
                modelViewer.setAttribute('auto-rotate-delay', '0');
                modelViewer.setAttribute('rotation-per-second', '30deg');

                preview.appendChild(modelViewer);
                container.appendChild(preview);
            }

            const button = document.createElement('button');
            button.textContent = type.includes('gltf') ? 'Use 3D Model' : `Use ${type.split('/')[0]}`;
            button.onclick = () => useAsset(assetId, type);

            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete';
            deleteButton.style.marginLeft = '5px';
            deleteButton.onclick = () => deleteAsset(assetId);

            // Add Skybox button for images and videos only
            if (type.startsWith('image/') || type.startsWith('video/')) {
                const skyboxButton = document.createElement('button');
                skyboxButton.textContent = 'Skybox';
                skyboxButton.style.marginLeft = '5px';
                skyboxButton.onclick = () => {
                    // Get the actual asset element in the DOM
                    const assetElement = document.getElementById(assetId);

                    // Toggle skybox marker class
                    if (container.classList.contains('is-skybox')) {
                        container.classList.remove('is-skybox');
                        skyboxButton.classList.remove('active');
                        // Remove data attribute from the asset element
                        if (assetElement) {
                            assetElement.removeAttribute('data-skybox');
                        }
                    } else {
                        container.classList.add('is-skybox');
                        skyboxButton.classList.add('active');
                        // Add data attribute to the asset element
                        if (assetElement) {
                            assetElement.setAttribute('data-skybox', 'true');
                        }
                    }
                    // Flush all entities to DOM and update code panel
                    flushAllEntitiesToDOM();
                    updateCodePanel();
                };
                container.appendChild(skyboxButton);
            }

            const label = document.createElement('span');
            label.textContent = ` - ${fileName}`;
            label.style.marginLeft = '5px';

            container.appendChild(button);
            container.appendChild(deleteButton);
            container.appendChild(label);
            library.appendChild(container);
        }

        function saveScene() {
            // Implement save functionality here
            // Could save to localStorage, server, or download as file
            const sceneContent = scene.innerHTML;
            localStorage.setItem('savedScene', sceneContent);
            alert('Scene saved!');
        }

        function initInspector() {
            window.addEventListener('keydown', function (evt) {
                if (evt.keyCode === 73 && evt.shiftKey && evt.ctrlKey) {
                    AFRAME.INSPECTOR.toggle();
                }
            });
        }

        function resetScene() {
            if (confirm('Are you sure you want to reset the scene to default?')) {
                // Close inspector if it's open
                try {
                    if (AFRAME.INSPECTOR && AFRAME.INSPECTOR.opened) {
                        AFRAME.INSPECTOR.close();
                    }
                } catch (e) {
                    console.warn('Inspector cleanup skipped:', e);
                }

                try {
                    // Get the current scene
                    let currentScene = document.querySelector('a-scene');

                    // First, safely detach all Three.js objects from entities to prevent reference errors
                    const allEntities = currentScene.querySelectorAll('a-entity, a-light');
                    allEntities.forEach(entity => {
                        if (entity.object3D && typeof entity.removeObject3D === 'function') {
                            try {
                                // Safely detach object3D instances
                                const objectKeys = Object.keys(entity.object3D);
                                objectKeys.forEach(key => {
                                    if (key !== 'el') {
                                        entity.removeObject3D(key);
                                    }
                                });
                            } catch (err) {
                                console.warn('Error detaching entity objects:', err);
                            }
                        }
                    });

                    // Save all assets
                    const currentAssets = Array.from(currentScene.querySelectorAll('a-assets > *'))
                        .map(asset => asset.cloneNode(true));

                    // Create new scene with same configuration
                    let newScene = document.createElement('a-scene');
                    newScene.setAttribute('embedded', '');
                    newScene.setAttribute('renderer', 'antialias: true; colorManagement: true; physicallyCorrectLights: true; sortObjects: true;');

                    // Set default content
                    newScene.innerHTML = `
                        <a-assets id="asset-container">
                            <!-- Assets will be re-added here -->
                        </a-assets>
                        
                        <!-- Camera -->
                        <a-camera position="0 1.6 0"></a-camera>

                        <!-- Scene Entities -->
                        <a-box position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9"></a-box>
                        <a-sphere position="0 1.25 -5" radius="1.25" color="#EF2D5E"></a-sphere>
                        <a-cylinder position="1 0.75 -3" radius="0.5" height="1.5" color="#FFC65D"></a-cylinder>
                        <a-plane position="0 0 -4" rotation="-90 0 0" width="4" height="4" color="#7BC8A4"></a-plane>

                        <!-- Environment -->
                        <a-sky color="#ECECEC"></a-sky>
                    `;

                    // Replace the old scene
                    currentScene.parentNode.replaceChild(newScene, currentScene);

                    // Update the scene reference
                    scene = document.querySelector('a-scene');

                    // Re-add all assets to the new scene
                    const newAssetContainer = scene.querySelector('#asset-container');
                    currentAssets.forEach(asset => {
                        newAssetContainer.appendChild(asset);
                    });

                    // Clean up inspector reference
                    if (typeof AFRAME.INSPECTOR !== 'undefined') {
                        delete AFRAME.INSPECTOR;
                    }

                    // Reset environment preset selector
                    const environmentPreset = document.getElementById('environment-preset');
                    if (environmentPreset) {
                        environmentPreset.value = 'none';
                    }

                    // Reset fog button state
                    const fogBtn = document.getElementById('toggle-fog-btn');
                    if (fogBtn) {
                        fogBtn.style.backgroundColor = '#2c2c2c';
                        fogBtn.textContent = 'Add Fog';
                    }
                    fogActive = false;

                    // Reset particle effect buttons
                    const particleButtons = ['snow', 'dust', 'rain'];
                    particleButtons.forEach(preset => {
                        const btn = document.getElementById(`${preset}-btn`);
                        if (btn) {
                            btn.style.backgroundColor = '#2c2c2c';
                        }
                    });

                    // Reset animation button
                    const animationBtn = document.getElementById('toggle-animation-btn');
                    if (animationBtn) {
                        animationBtn.style.backgroundColor = '#2c2c2c';
                        animationBtn.style.opacity = 0.5;
                        animationBtn.disabled = true;
                        document.getElementById('animation-text').textContent = 'Start';
                        document.getElementById('animation-icon').setAttribute('d', 'M8 5v14l11-7z');
                    }

                    // Clear active particle systems
                    Object.keys(activeParticleSystems).forEach(preset => {
                        activeParticleSystems[preset] = null;
                    });

                    // Hide the scene if it's not the current view
                    if (currentView != 'scene') {
                        scene.style.display = 'none';
                    }

                    // Wait for scene to initialize
                    setTimeout(() => {
                        // Add default lights that match A-Frame's defaults
                        const ambientLight = document.createElement('a-entity');
                        ambientLight.setAttribute('light', 'type: ambient; color: #BBB;');
                        ambientLight.setAttribute('data-aframe-default-light', '');
                        ambientLight.setAttribute('aframe-injected', '');
                        scene.appendChild(ambientLight);

                        const directionalLight = document.createElement('a-entity');
                        directionalLight.setAttribute('light', 'intensity: 0.6; castShadow: true');
                        directionalLight.setAttribute('position', '-0.5 1 1');
                        directionalLight.setAttribute('data-aframe-default-light', '');
                        directionalLight.setAttribute('aframe-injected', '');
                        scene.appendChild(directionalLight);
                    }, 100);

                    // Wait for scene to load then update code panel
                    scene.addEventListener('loaded', () => {
                        // Force a render to make sure everything is visible
                        if (scene.renderer) {
                            scene.renderer.render(scene.object3D, scene.camera);
                        }
                        flushAllEntitiesToDOM();
                        updateCodePanel();
                        updateSkyColorPicker();
                    });

                    // Force a reload of the scene if it seems stuck
                    setTimeout(() => {
                        if (scene && scene.hasLoaded) {
                            // If already loaded, dispatch a fake loaded event
                            scene.emit('loaded');
                        }
                    }, 500);
                } catch (error) {
                    console.error("Error during scene reset:", error);
                    alert("There was a problem resetting the scene. Please refresh the page.");
                }
            }
        }

        // Improve inspector change tracking
        function setupInspectorChangeWatcher() {
            if (!window.AFRAME || !window.AFRAME.INSPECTOR) return;

            console.log('Setting up Inspector change watcher');

            // Remove any existing sync buttons first
            const existingButtons = document.querySelectorAll('.sync-to-code-panel-container');
            existingButtons.forEach(button => button.remove());

            // Create a floating container for our button
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'sync-to-code-panel-container';
            buttonContainer.style.position = 'fixed';
            buttonContainer.style.bottom = '10px';  // Position at bottom
            buttonContainer.style.left = '50%';     // Center horizontally
            buttonContainer.style.transform = 'translateX(-50%)'; // Center alignment
            buttonContainer.style.zIndex = '9999999';  // Very high z-index
            buttonContainer.style.backgroundColor = '#323232'; // Match inspector toolbar color
            buttonContainer.style.padding = '5px 10px';
            buttonContainer.style.borderRadius = '4px';
            buttonContainer.style.flexDirection = 'row'; // Put items in a row
            buttonContainer.style.alignItems = 'center';
            buttonContainer.style.gap = '10px';

            // Create a button to force sync changes to code panel
            const syncButton = document.createElement('button');
            syncButton.textContent = 'Sync to Code Panel';
            syncButton.className = 'sync-to-code-panel';
            syncButton.style.padding = '5px 10px';
            syncButton.style.backgroundColor = '#4285f4';
            syncButton.style.color = 'white';
            syncButton.style.border = 'none';
            syncButton.style.borderRadius = '3px';
            syncButton.style.cursor = 'pointer';
            syncButton.style.fontWeight = 'bold';
            syncButton.style.fontSize = '12px';

            syncButton.onclick = () => {
                flushAllEntitiesToDOM();
                updateCodePanel();

                // Visual feedback
                syncButton.textContent = 'Synced! ✓';
                syncButton.style.backgroundColor = '#0f9d58';
                setTimeout(() => {
                    syncButton.textContent = 'Sync to Code Panel';
                    syncButton.style.backgroundColor = '#4285f4';
                }, 2000);
            };

            // Create a status message element
            const statusMessage = document.createElement('div');
            statusMessage.textContent = 'Inspector watcher active';
            statusMessage.style.color = '#ccc';
            statusMessage.style.fontSize = '11px';
            statusMessage.style.whiteSpace = 'nowrap';

            // Add button and status to container
            buttonContainer.appendChild(syncButton);
            buttonContainer.appendChild(statusMessage);

            // Add container to document body
            document.body.appendChild(buttonContainer);

            // Add CSS to show/hide button based on body class
            const style = document.createElement('style');
            style.textContent = `
                .sync-to-code-panel {
                    transition: background-color 0.3s ease;
                }
                .sync-to-code-panel:hover {
                    background-color: #1a73e8;
                }
                .sync-to-code-panel-container {
                    transition: opacity 0.3s;
                    display: none !important; /* Hidden by default */
                }
                body.aframe-inspector-opened .sync-to-code-panel-container {
                    display: flex !important; /* Only show when inspector is open */
                }
            `;
            document.head.appendChild(style);

            console.log('Sync button container added, positioned at bottom toolbar');

            // Watch for changes in Inspector panels
            const inspectorPanels = document.querySelectorAll('.inspector-panel');
            if (inspectorPanels.length > 0) {
                inspectorPanels.forEach(panel => {
                    panel.addEventListener('change', () => {
                        flushAllEntitiesToDOM();
                    });

                    panel.addEventListener('input', () => {
                        flushAllEntitiesToDOM();
                    });
                });
            }

            // Add event listeners for Inspector changes
            document.addEventListener('componentchanged', event => {
                if (event.detail && event.detail.target) {
                    event.detail.target.flushToDOM();
                    updateCodePanel();
                    statusMessage.textContent = 'Component changed, DOM updated';
                    setTimeout(() => {
                        statusMessage.textContent = 'Inspector watcher active';
                    }, 2000);
                }
            });

            document.addEventListener('entitycreated', event => {
                if (event.detail && event.detail.entity) {
                    event.detail.entity.flushToDOM();
                    updateCodePanel();
                    statusMessage.textContent = 'Entity created, DOM updated';
                    setTimeout(() => {
                        statusMessage.textContent = 'Inspector watcher active';
                    }, 2000);
                }
            });

            document.addEventListener('entityremoved', () => {
                updateCodePanel();
                statusMessage.textContent = 'Entity removed, DOM updated';
                setTimeout(() => {
                    statusMessage.textContent = 'Inspector watcher active';
                }, 2000);
            });

            // Override Inspector's save function
            if (AFRAME.INSPECTOR) {
                const originalSaveFunction = AFRAME.INSPECTOR.onSaveButtonClick;
                AFRAME.INSPECTOR.onSaveButtonClick = function () {
                    // Call the original function (which will show the aframe-watcher message)
                    if (originalSaveFunction) originalSaveFunction.call(AFRAME.INSPECTOR);

                    // Now do our own saving logic
                    flushAllEntitiesToDOM();
                    updateCodePanel();
                    statusMessage.textContent = 'Changes synced to code panel';
                    setTimeout(() => {
                        statusMessage.textContent = 'Inspector watcher active';
                    }, 2000);
                };
            }

            // Override the "Back to Scene" button functionality
            setTimeout(() => {
                // Find the back to scene button
                const backButtons = document.querySelectorAll('.toggle-edit');
                backButtons.forEach(backButton => {
                    // Check if this button has been modified already
                    if (backButton.dataset.modifiedWithSync) return;

                    // Mark as modified to prevent duplicate handlers
                    backButton.dataset.modifiedWithSync = 'true';

                    // Clone the button to remove existing event listeners
                    const oldButton = backButton;
                    const newButton = oldButton.cloneNode(true);
                    oldButton.parentNode.replaceChild(newButton, oldButton);

                    // Add our custom click handler
                    newButton.addEventListener('click', (e) => {
                        // Prevent default behavior
                        e.preventDefault();
                        e.stopPropagation();

                        // Remove any inspector-specific entities from the DOM
                        const inspectorEntities = document.querySelectorAll('[data-aframe-inspector="true"], #aframeInspectorMouseCursor');
                        inspectorEntities.forEach(entity => {
                            console.log('Removing inspector entity:', entity.id);
                            if (entity.parentNode) {
                                entity.parentNode.removeChild(entity);
                            }
                        });

                        // Sync all changes to DOM and code panel
                        console.log('Back to Scene: syncing changes...');
                        flushAllEntitiesToDOM();
                        updateCodePanel();

                        // Show brief confirmation and then return to scene
                        statusMessage.textContent = 'Changes synced before exit';

                        // Small delay to ensure sync completes
                        setTimeout(() => {
                            // Now do the original action of closing the inspector
                            if (AFRAME.INSPECTOR) {
                                AFRAME.INSPECTOR.close();
                            }
                        }, 300);
                    });

                    console.log('Back to Scene button functionality overridden with sync capability');
                });
            }, 1500); // Delay to ensure inspector UI is fully loaded
        }

        // We also need to update the cleanupInspector function to sync before closing
        function cleanupInspector() {
            if (AFRAME.INSPECTOR && AFRAME.INSPECTOR.opened) {
                // Sync changes before closing
                flushAllEntitiesToDOM();

                // Remove any inspector-specific entities from the DOM
                const inspectorEntities = document.querySelectorAll('[data-aframe-inspector="true"], #aframeInspectorMouseCursor');
                inspectorEntities.forEach(entity => {
                    console.log('Removing inspector entity:', entity.id);
                    entity.parentNode.removeChild(entity);
                });

                updateCodePanel();
                console.log('Inspector cleanup: synced changes and removed inspector entities');

                // Then close the inspector
                AFRAME.INSPECTOR.close();
            }
            document.body.classList.remove('aframe-inspector-opened');
        }

        function showSyncButtonContainer() {
            console.log('Showing sync button container');
            const containers = document.querySelectorAll('.sync-to-code-panel-container');
            if (containers.length === 0) {
                console.log('No sync button containers found to show');
            }

            containers.forEach(container => {
                container.style.display = 'flex';
                container.dataset.visible = 'true';
                console.log('Sync button container displayed', container);
            });
        }

        function hideSyncButtonContainer() {
            console.log('Hiding sync button container');
            const containers = document.querySelectorAll('.sync-to-code-panel-container');
            if (containers.length === 0) {
                console.log('No sync button containers found to hide');
            }

            containers.forEach(container => {
                container.style.display = 'none';
                container.dataset.visible = 'false';
                console.log('Sync button container hidden', container);
            });
        }

        // Function to remove Inspector mouse cursor entity
        function removeInspectorCursor() {
            const cursorEntity = document.getElementById('aframeInspectorMouseCursor');
            if (cursorEntity) {
                console.log('Removing inspector cursor entity');
                if (cursorEntity.parentNode) {
                    cursorEntity.parentNode.removeChild(cursorEntity);
                }
            }
        }

        // Add a function specifically to watch for and remove the cursor entity
        function watchForInspectorCursor() {
            // Create a specific observer just for the cursor entity
            const cursorObserver = new MutationObserver(mutations => {
                for (let mutation of mutations) {
                    if (mutation.addedNodes) {
                        for (let node of mutation.addedNodes) {
                            if (node.id === 'aframeInspectorMouseCursor') {
                                console.log('Inspector cursor detected, marking for removal on exit');
                                // Mark for removal on exit
                                node.dataset.removeOnExit = 'true';
                            }
                        }
                    }
                }
            });

            // Start observing
            cursorObserver.observe(document.querySelector('a-scene'), {
                childList: true,
                subtree: true
            });

            // Store for later cleanup
            window.cursorObserver = cursorObserver;

            console.log('Inspector cursor watcher set up');

            // Also set up an interval to check for and mark the cursor
            const cursorCheckInterval = setInterval(() => {
                const cursor = document.getElementById('aframeInspectorMouseCursor');
                if (cursor) {
                    cursor.dataset.removeOnExit = 'true';
                }

                // Stop if inspector is closed
                if (!AFRAME.INSPECTOR || !AFRAME.INSPECTOR.opened) {
                    clearInterval(cursorCheckInterval);
                }
            }, 1000);
        }

        // Modify openInspector function
        function openInspector() {
            if (window.AFRAME.INSPECTOR && window.AFRAME.INSPECTOR.opened) {
                window.AFRAME.INSPECTOR.close();
            }

            // First, ensure any previous cursor is removed
            removeInspectorCursor();

            // Remove existing inspector script if present
            const existingScript = document.querySelector('script[src*="aframe-inspector.min.js"]');
            if (existingScript) existingScript.remove();

            // Remove existing inspector elements
            document.querySelectorAll('.a-inspector-loader, .a-inspector').forEach(el => el.remove());

            // Load inspector fresh each time
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/gh/aframevr/aframe-inspector@master/dist/aframe-inspector.min.js';
            script.onload = () => {
                AFRAME.INSPECTOR.open();
                document.body.classList.add('aframe-inspector-opened');
                setupInspectorListeners();

                // Set up cursor watcher immediately
                watchForInspectorCursor();

                // Set up the inspector change watcher after the inspector loads
                setTimeout(() => {
                    setupInspectorChangeWatcher();
                }, 1000);

                // Patch the inspector close method to always remove cursor
                if (AFRAME.INSPECTOR && !AFRAME.INSPECTOR._cursorRemovalPatched) {
                    const originalClose = AFRAME.INSPECTOR.close;
                    AFRAME.INSPECTOR.close = function () {
                        // Always remove the cursor before closing
                        removeInspectorCursor();

                        // Call original close function
                        originalClose.apply(this, arguments);

                        // Remove again after closing (just to be safe)
                        setTimeout(removeInspectorCursor, 100);

                        // Clean up observer
                        if (window.cursorObserver) {
                            window.cursorObserver.disconnect();
                        }
                    };

                    // Mark as patched to avoid double-patching
                    AFRAME.INSPECTOR._cursorRemovalPatched = true;
                    console.log('Inspector close method patched to remove cursor');
                }
            };
            document.head.appendChild(script);
        }

        // Make sure it's hidden when page loads
        window.addEventListener('load', () => {
            hideSyncButtonContainer();
            initSkyColorPicker();
            initEnvironmentPresets();
        });

        function clearScene() {
            if (confirm('Are you sure you want to clear all models, images, and scene elements?')) {
                // Close inspector if it's open
                try {
                    if (AFRAME.INSPECTOR && AFRAME.INSPECTOR.opened) {
                        AFRAME.INSPECTOR.close();
                    }
                } catch (e) {
                    console.warn('Inspector cleanup skipped:', e);
                }

                // Get the current scene and save all assets
                let currentScene = document.querySelector('a-scene');
                const currentAssets = Array.from(currentScene.querySelectorAll('a-assets > *')).map(asset => asset.cloneNode(true));

                // Create new scene with same configuration
                let newScene = document.createElement('a-scene');
                newScene.setAttribute('embedded', '');
                newScene.setAttribute('renderer', 'antialias: true; colorManagement: true; physicallyCorrectLights: true; sortObjects: true;');

                // Set default content - just assets, camera, sky and lights
                newScene.innerHTML = `
                    <a-assets id="asset-container">
                        <!-- Assets will be re-added here -->
                    </a-assets>

                    <a-camera position="0 1.6 0"></a-camera>
                    <a-sky color="#ECECEC"></a-sky>

                    <!-- Default lighting -->
                    <a-entity light="color: #BBB; type: ambient" data-aframe-default-light="" aframe-injected=""></a-entity>
                    <a-entity light="color: #FFF; intensity: 1.884; castShadow: true" position="-0.5 1 1" data-aframe-default-light="" aframe-injected=""></a-entity>
                `;

                // Replace the old scene
                currentScene.parentNode.replaceChild(newScene, currentScene);

                // Update the scene reference
                scene = document.querySelector('a-scene');

                // Re-add all assets to the new scene
                const newAssetContainer = scene.querySelector('#asset-container');
                currentAssets.forEach(asset => {
                    newAssetContainer.appendChild(asset);
                });

                // Clean up inspector reference
                if (typeof AFRAME.INSPECTOR !== 'undefined') {
                    delete AFRAME.INSPECTOR;
                }

                // Reset environment preset selector
                const environmentPreset = document.getElementById('environment-preset');
                if (environmentPreset) {
                    environmentPreset.value = 'none';
                }

                // Reset fog button state
                const fogBtn = document.getElementById('toggle-fog-btn');
                if (fogBtn) {
                    fogBtn.style.backgroundColor = '#2c2c2c';
                    fogBtn.textContent = 'Add Fog';
                }
                fogActive = false;

                // Reset particle effect buttons
                const particleButtons = ['snow', 'dust', 'rain'];
                particleButtons.forEach(preset => {
                    const btn = document.getElementById(`${preset}-btn`);
                    if (btn) {
                        btn.style.backgroundColor = '#2c2c2c';
                    }
                });

                // Reset animation button
                const animationBtn = document.getElementById('toggle-animation-btn');
                if (animationBtn) {
                    animationBtn.style.backgroundColor = '#2c2c2c';
                    animationBtn.style.opacity = 0.5;
                    animationBtn.disabled = true;
                    document.getElementById('animation-text').textContent = 'Start';
                    document.getElementById('animation-icon').setAttribute('d', 'M8 5v14l11-7z');
                }

                // Clear active particle systems
                Object.keys(activeParticleSystems).forEach(preset => {
                    activeParticleSystems[preset] = null;
                });

                // Hide the scene if it's not the current view
                if (currentView != 'scene') {
                    scene.style.display = 'none';
                }

                // Wait for scene to load then update code panel
                scene.addEventListener('loaded', () => {
                    updateCodePanel();
                    updateSkyColorPicker();
                });
            }
        }

        let skyboxCounter = 0;

        /* Commenting out skybox uploader - to be replaced
        document.getElementById('skybox-input').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) {
                console.log('No file selected');
                return;
            }
            console.log('File selected:', file.type);

            const url = URL.createObjectURL(file);
            const isVideo = file.type.startsWith('video/');
            const assetId = `skybox-asset-${skyboxCounter++}`;

            // Create preview element
            const previewDiv = document.createElement('div');
            previewDiv.className = 'asset-item';
            previewDiv.innerHTML = `
        <div class="preview-wrapper">
            ${isVideo ?
                    `<video src="${url}" style="width: 100%; height: 100%; object-fit: cover;" loop muted autoplay></video>` :
                    `<img src="${url}" style="width: 100%; height: 100%; object-fit: cover;">`
                }
        </div>
    `;

            // Add click handler to set as active skybox
            previewDiv.addEventListener('click', () => {
                const scene = document.querySelector('a-scene');

                // Get current background color before potentially changing it
                let currentBackground = scene.getAttribute('background') || 'color: #ECECEC';

                // Remove existing sky/videosphere
                const existingSky = scene.querySelector('a-sky, a-videosphere');
                if (existingSky) {
                    existingSky.remove();
                }

                // Remove any existing environment entity
                const existingEnvironment = scene.querySelector('a-entity[environment]');
                if (existingEnvironment && existingEnvironment.parentElement) {
                    existingEnvironment.removeAttribute('environment');
                    existingEnvironment.parentElement.removeChild(existingEnvironment);
                }

                // Create new sky element
                const skyEl = document.createElement(isVideo ? 'a-videosphere' : 'a-sky');
                skyEl.setAttribute('src', `#${assetId}`);

                // Add to scene
                scene.appendChild(skyEl);

                // Preserve the background attribute even with skybox
                scene.setAttribute('background', currentBackground);

                // If it's a video, ensure it's playing
                if (isVideo) {
                    const videoAsset = document.getElementById(assetId);
                    videoAsset.play().catch(e => console.error('Error playing video:', e));
                }

                // Update active state visually
                document.querySelectorAll('#skybox-container .asset-item').forEach(item => {
                    item.classList.remove('active');
                });
                previewDiv.classList.add('active');

                // Update code panel
                updateCodePanel();
            });

            // Add to skybox container
            document.getElementById('skybox-container').appendChild(previewDiv);

            // Get assets container
            const assets = document.querySelector('a-assets');

            // Create asset element
            const assetEl = document.createElement(isVideo ? 'video' : 'img');
            assetEl.id = assetId;
            assetEl.src = url;
            if (isVideo) {
                assetEl.setAttribute('preload', 'auto');
                assetEl.setAttribute('loop', '');
                assetEl.setAttribute('crossorigin', 'anonymous');
            }

            // Add new asset
            assets.appendChild(assetEl);

            // Trigger click to set as active skybox
            previewDiv.click();
        });
        */

        function formatSceneContent(sceneEl) {
            const assets = sceneEl.querySelector('a-assets');
            const camera = sceneEl.querySelector('a-camera');
            const environment = sceneEl.querySelector('a-entity[environment]');

            // Only get the sky if there's no environment
            const sky = environment ? null : sceneEl.querySelector('a-sky');

            // Get all entities (excluding assets, camera, sky)
            const entities = Array.from(sceneEl.children).filter(el => {
                // Skip assets, camera and sky
                if (el === assets || el === camera || el === sky) {
                    return false;
                }

                // Skip environment and its children - they'll be handled separately
                if (el.hasAttribute('environment') || el.classList.contains('environment')) {
                    return false;
                }

                // Include all other entities
                return true;
            });

            let content = '';

            // Assets
            content += '<a-assets id="asset-container">\n';
            content += '    <!-- Assets -->\n';
            if (assets) {
                Array.from(assets.children).forEach(asset => {
                    // Ensure data-skybox attribute is preserved in the code
                    if (asset.hasAttribute('data-skybox')) {
                        asset.setAttribute('data-skybox', 'true');
                    }
                    content += '    ' + asset.outerHTML + '\n';
                });
            }
            content += '</a-assets>\n\n';

            // Camera
            if (camera) {
                content += '<!-- Camera -->\n';
                content += camera.outerHTML + '\n\n';
            }

            // Sky (only if no environment)
            if (sky) {
                content += '<!-- Sky -->\n';
                const skyClone = sky.cloneNode(false);
                const material = sky.getAttribute('material');
                if (material) {
                    const materialStr = typeof material === 'string' ? material :
                        `shader: ${material.shader}; topColor: ${material.topColor}; bottomColor: ${material.bottomColor}`;
                    skyClone.setAttribute('material', materialStr);
                }
                content += skyClone.outerHTML + '\n\n';
            }

            // Environment and its children
            if (environment) {
                const envPreset = environment.getAttribute('environment');
                // Only show environment if it has a preset
                if (envPreset && envPreset !== '') {
                    content += '<!-- Environment -->\n';
                    // Get the environment entity without its children
                    const envClone = environment.cloneNode(false);
                    content += envClone.outerHTML.replace('></a-entity>', '>\n');

                    // Add all environment children with proper indentation
                    const envChildren = environment.querySelectorAll('.environment');
                    envChildren.forEach(child => {
                        const childClone = child.cloneNode(false);
                        const material = child.getAttribute('material');
                        if (material) {
                            const materialStr = typeof material === 'string' ? material :
                                `shader: ${material.shader}; topColor: ${material.topColor}; bottomColor: ${material.bottomColor}`;
                            childClone.setAttribute('material', materialStr);
                        }
                        content += '    ' + childClone.outerHTML + '\n';
                    });
                    content += '</a-entity>\n\n';
                }
            }

            // Other entities
            entities.forEach(entity => {
                content += entity.outerHTML + '\n';
            });

            return content;
        }

        // Flush all entities to DOM - modified to filter out inspector-specific entities
        function flushAllEntitiesToDOM() {
            // Get all entities in the scene
            const entities = document.querySelectorAll('a-scene > *');
            entities.forEach(entity => {
                // Skip entities created by the inspector itself
                if (entity.hasAttribute('data-aframe-inspector') ||
                    entity.id === 'aframeInspectorMouseCursor') {
                    console.log('Skipping inspector entity during sync:', entity.id);
                    return;
                }

                if (typeof entity.flushToDOM === 'function') {
                    entity.flushToDOM();
                }
            });
            updateCodePanel();
        }

        // Get attributes for an entity
        function getAttributes(entity) {
            const attributes = {};
            for (let i = 0; i < entity.attributes.length; i++) {
                const attr = entity.attributes[i];
                attributes[attr.name] = attr.value;
            }
            return attributes;
        }

        // Set attributes for an entity
        function setAttributes(entity, attributes) {
            Object.entries(attributes).forEach(([name, value]) => {
                entity.setAttribute(name, value);
            });
            entity.flushToDOM();
        }

        // Fix the use3DModel function to set the ID properly
        function use3DModel() {
            const modelUrl = document.getElementById('modelUrlInput').value.trim();
            if (!modelUrl) {
                alert('Please enter a model URL');
                return;
            }

            // Get base name for ID from URL
            let modelId = '';
            try {
                const url = new URL(modelUrl);
                const pathParts = url.pathname.split('/');
                const filename = pathParts[pathParts.length - 1];
                modelId = 'model-' + filename.split('.')[0].toLowerCase().replace(/[^a-z0-9]/g, '-');
            } catch (e) {
                // If URL parsing fails, create a generic ID
                modelId = 'model-' + Math.floor(Math.random() * 1000);
            }

            // Check if the model requires a specific format handler (GLTF vs OBJ)
            let modelEntity;
            if (modelUrl.toLowerCase().endsWith('.glb') || modelUrl.toLowerCase().endsWith('.gltf')) {
                modelEntity = document.createElement('a-entity');
                modelEntity.setAttribute('gltf-model', modelUrl);
                modelEntity.setAttribute('id', modelId);
                modelEntity.setAttribute('position', '0 1.5 -3');
                modelEntity.setAttribute('scale', '1 1 1');
            } else if (modelUrl.toLowerCase().endsWith('.obj')) {
                modelEntity = document.createElement('a-entity');
                modelEntity.setAttribute('obj-model', 'obj: ' + modelUrl);
                modelEntity.setAttribute('id', modelId);
                modelEntity.setAttribute('position', '0 1.5 -3');
                modelEntity.setAttribute('scale', '1 1 1');
            } else {
                alert('Unsupported model format. Please use .glb, .gltf, or .obj');
                return;
            }

            // Add the model to the scene
            scene.appendChild(modelEntity);
            updateCodePanel();

            // Close the model input dialog
            document.getElementById('modelUrlDialog').style.display = 'none';

            // Switch to scene view to see the model
            switchToView('scene');
        }

        function deleteAsset(assetId) {
            // Remove asset from <a-assets>
            const assetEl = document.querySelector(`#${assetId}`);
            if (assetEl) {
                assetEl.parentNode.removeChild(assetEl);
            }

            // Remove asset preview from sidebar
            const assetContainer = document.querySelector(`.asset-container[data-asset-id="${assetId}"]`);
            if (assetContainer) {
                assetContainer.remove();
            }

            // Remove all entities referencing this asset
            const entitiesUsingAsset = document.querySelectorAll(`[src="#${assetId}"], [gltf-model="#${assetId}"]`);
            entitiesUsingAsset.forEach(entity => entity.parentNode.removeChild(entity));

            // Update code panel
            updateCodePanel();
        }

        // Add this new function
        function initSkyColorPicker() {
            const skyColorPicker = document.getElementById('background-color');
            const skyColorHex = document.getElementById('background-color-hex');

            // Get the current background color from the scene
            let currentColor = scene.getAttribute('background');
            let colorValue = '#ECECEC'; // Default color

            if (currentColor) {
                if (typeof currentColor === 'string') {
                    // Extract the color value from the attribute string
                    const match = currentColor.match(/color:\s*(#[0-9A-Fa-f]{6})/i);
                    if (match) {
                        colorValue = match[1];
                    }
                } else if (currentColor.color) {
                    // It's an object with a color property
                    colorValue = currentColor.color;
                }
            }

            // Set the color picker values
            skyColorPicker.value = colorValue;
            skyColorHex.value = colorValue.toUpperCase();

            // Add event listener for color changes
            skyColorPicker.addEventListener('input', function (e) {
                const color = e.target.value.toUpperCase();
                skyColorHex.value = color;
                updateSceneBackground(color);
            });

            // Update color when hex input changes
            skyColorHex.addEventListener('input', function (e) {
                let color = e.target.value.toUpperCase();
                e.target.value = color;

                // Ensure the color starts with #
                if (!color.startsWith('#')) {
                    color = '#' + color;
                    skyColorHex.value = color;
                }

                // Check if input contains valid hex characters
                if (/^#[0-9A-F]*$/.test(color)) {
                    // Create a valid color by padding if needed
                    let validColor = color;

                    // Get the hex part without #
                    const hexPart = color.substring(1);

                    // If we have some valid hex digits
                    if (hexPart.length > 0 && hexPart.length < 6) {
                        // Pad with appropriate characters to make a valid color
                        if (hexPart.length <= 2) {
                            // Repeat the digits we have (e.g. "F" becomes "FFFFFF")
                            validColor = '#' + hexPart.padEnd(6, hexPart).toUpperCase();
                        } else {
                            // Pad with zeros (e.g. "F00" becomes "F00000")
                            validColor = '#' + hexPart.padEnd(6, '0').toUpperCase();
                        }
                    } else if (hexPart.length === 6) {
                        // We have a complete color
                        validColor = color;
                    } else {
                        // Empty or invalid, don't update
                        return;
                    }

                    // Update color picker and scene background
                    skyColorPicker.value = validColor;
                    updateSceneBackground(validColor);
                }
            });

            // Final validation on blur/enter to handle incomplete input
            skyColorHex.addEventListener('change', function (e) {
                let color = e.target.value.toUpperCase();
                e.target.value = color;  // Force uppercase immediately

                // Ensure the color starts with #
                if (!color.startsWith('#')) {
                    color = '#' + color;
                }

                // Validate complete hex color
                if (!/^#[0-9A-F]{6}$/i.test(color)) {
                    // For incomplete input, pad appropriately
                    const hexPart = color.substring(1);
                    if (hexPart.length > 0 && hexPart.length < 6) {
                        if (hexPart.length <= 2) {
                            // Repeat the digits for 1-2 characters
                            color = '#' + hexPart.padEnd(6, hexPart).toUpperCase();
                        } else {
                            // Pad with zeros for 3+ characters
                            color = '#' + hexPart.padEnd(6, '0').toUpperCase();
                        }
                    } else {
                        // Invalid or empty - reset to color picker's value
                        color = skyColorPicker.value.toUpperCase();
                    }
                }

                // Update the input and scene with the final color
                skyColorHex.value = color;
                skyColorPicker.value = color;
                updateSceneBackground(color);
            });
        }

        function updateSceneBackground(color) {
            // Always update the scene's background color
            scene.setAttribute('background', { color: color });
            updateCodePanel();
        }

        function updateSkyColor(color) {
            updateSceneBackground(color.toUpperCase());
        }

        // Initialize environment presets
        function initEnvironmentPresets() {
            const presetSelector = document.getElementById('environment-preset');
            if (!presetSelector) return;

            presetSelector.addEventListener('change', (e) => {
                updateEnvironment(e.target.value);
            });
        }

        // Function to update the environment based on selected preset
        function updateEnvironment(preset) {
            console.log('Updating environment to:', preset);

            // Store current fog state if it exists
            let currentFog = null;
            const scene = document.querySelector('a-scene');
            // Define environment variable
            let environment = scene.querySelector('a-entity[environment]');

            if (fogActive) {
                currentFog = scene.getAttribute('fog');
            }

            // Step 1: Thoroughly remove any existing environment entity and its children
            const existingEnvironment = document.querySelector('a-entity[environment]');
            if (existingEnvironment) {
                existingEnvironment.parentNode.removeChild(existingEnvironment);
            }

            // Also remove any environment-created elements that might be orphaned
            document.querySelectorAll('.environment').forEach(el => {
                if (el.parentNode) {
                    el.parentNode.removeChild(el);
                }
            });

            // Step 2: Handle "none" preset specially
            if (preset === 'none') {
                // Clean up fog if it exists
                if (scene.hasAttribute('fog')) {
                    // Properly remove fog component
                    if (scene.components.fog) {
                        // Remove the component instance
                        scene.components.fog.remove();
                        // Delete the component reference
                        delete scene.components.fog;
                    }

                    // Remove from the systems
                    if (scene.systems.fog) {
                        scene.systems.fog.remove();
                        delete scene.systems.fog;
                    }

                    // Remove the attribute
                    scene.removeAttribute('fog');

                    // Clear Three.js fog
                    if (scene.object3D) {
                        scene.object3D.fog = null;
                    }
                }

                // Set fogActive to false
                fogActive = false;

                // Update fog controls for the 'none' preset
                // 1. Set the fog color to match background color
                const bgColor = document.getElementById('background-color').value;
                const fogColorInput = document.getElementById('fog-color');
                const fogColorHexInput = document.getElementById('fog-color-hex');
                if (fogColorInput) fogColorInput.value = bgColor;
                if (fogColorHexInput) fogColorHexInput.value = bgColor.toUpperCase();

                // 2. Set fog type to exponential
                const exponentialRadio = document.querySelector('input[name="fog-type"][value="exponential"]');
                if (exponentialRadio) {
                    exponentialRadio.checked = true;
                    // Update visibility of controls
                    const linearControls = document.getElementById('fog-linear-controls');
                    const exponentialControls = document.getElementById('fog-exponential-controls');
                    if (linearControls) linearControls.style.display = 'none';
                    if (exponentialControls) exponentialControls.style.display = 'block';
                }

                // Also update the toggle fog button to show "Add Fog"
                const fogBtn = document.getElementById('toggle-fog-btn');
                if (fogBtn) {
                    fogBtn.style.backgroundColor = '#2c2c2c';
                    // Check if the button has a span child before updating its text
                    const span = fogBtn.querySelector('span');
                    if (span) {
                        span.textContent = 'Add Fog';
                    } else {
                        fogBtn.textContent = 'Add Fog';
                    }
                }

                // Remove environment if it exists
                if (environment) {
                    environment.parentNode.removeChild(environment);
                }
            }
            // Step 3: Add new environment entity for selected preset
            else {
                // Remove any existing a-sky entity since environment adds its own
                const existingSky = document.querySelector('a-sky');
                if (existingSky) {
                    existingSky.parentNode.removeChild(existingSky);
                }

                // First remove any existing default lights to prevent duplication
                const existingDefaultLights = document.querySelectorAll('[light][data-aframe-default-light]');
                existingDefaultLights.forEach(light => {
                    if (light.parentNode) {
                        light.parentNode.removeChild(light);
                    }
                });

                // Create new environment entity with only the preset attribute
                const environment = document.createElement('a-entity');
                environment.setAttribute('environment', `preset: ${preset}`);
                scene.appendChild(environment);

                // Disable sky color picker since environment handles sky
                disableSkyColorPicker(true);

                // Update fog controls based on the environment preset
                let defaultFogColor;
                let defaultFogFar;

                // Set default fog settings based on environment preset
                switch (preset) {
                    case 'forest':
                        defaultFogColor = '#B0AF83';
                        defaultFogFar = 84;
                        break;
                    case 'contact':
                        defaultFogColor = '#8C7190';
                        defaultFogFar = 84;
                        break;
                    case 'egypt':
                        defaultFogColor = '#A9855A';
                        defaultFogFar = 104;
                        break;
                    case 'checkerboard':
                        defaultFogColor = '#423B38';
                        defaultFogFar = 80;
                        break;
                    case 'goaland':
                        defaultFogColor = '#809C84';
                        defaultFogFar = 112;
                        break;
                    case 'yavapai':
                        defaultFogColor = '#9CA07E';
                        defaultFogFar = 84;
                        break;
                    case 'goldmine':
                        defaultFogColor = '#725F4F';
                        defaultFogFar = 232;
                        break;
                    case 'threetowers':
                        defaultFogColor = '#B4A056';
                        defaultFogFar = 84;
                        break;
                    case 'poison':
                        defaultFogColor = '#285A2F';
                        defaultFogFar = 84;
                        break;
                    case 'arches':
                        defaultFogColor = '#62717A';
                        defaultFogFar = 136;
                        break;
                    case 'tron':
                        defaultFogColor = '#334173';
                        defaultFogFar = 84;
                        break;
                    case 'japan':
                        defaultFogColor = '#8B8099';
                        defaultFogFar = 44;
                        break;
                    case 'dream':
                        defaultFogColor = '#8A3B6D';
                        defaultFogFar = 84;
                        break;
                    case 'volcano':
                        defaultFogColor = '#B42910';
                        defaultFogFar = 56;
                        break;
                    case 'starry':
                        defaultFogColor = '#000000';
                        defaultFogFar = 124;
                        break;
                    case 'osiris':
                        // No fog for Osiris
                        fogActive = false;
                        const fogBtn = document.getElementById('toggle-fog-btn');
                        if (fogBtn) {
                            fogBtn.style.backgroundColor = '#2c2c2c';
                            // Check if the button has a span child before updating its text
                            const span = fogBtn.querySelector('span');
                            if (span) {
                                span.textContent = 'Add Fog';
                            } else {
                                fogBtn.textContent = 'Add Fog';
                            }
                        }
                        return;
                    case 'moon':
                        defaultFogColor = '#1A1310';
                        defaultFogFar = 84;
                        break;
                    default:
                        defaultFogColor = '#8E9292';
                        defaultFogFar = 92;
                }

                // Update fog controls
                document.getElementById('fog-color').value = defaultFogColor;
                document.getElementById('fog-color-hex').value = defaultFogColor;
                // Always use linear fog for environment presets
                document.querySelector('input[name="fog-type"][value="linear"]').checked = true;
                // Show linear controls, hide exponential controls
                document.getElementById('fog-linear-controls').style.display = 'block';
                document.getElementById('fog-exponential-controls').style.display = 'none';
                // Update distance values
                document.getElementById('fog-near').value = 0;  // All presets use near: 0
                document.getElementById('fog-far').value = defaultFogFar;

                // Enable fog and update button state
                fogActive = true;
                const fogBtn = document.getElementById('toggle-fog-btn');
                fogBtn.style.backgroundColor = '#4c6ef5';
                // Check if the button has a span child before updating its text
                const span = fogBtn.querySelector('span');
                if (span) {
                    span.textContent = 'Remove Fog';
                } else {
                    fogBtn.textContent = 'Remove Fog';
                }

                // Set current fog with the default settings (near is always 0)
                currentFog = `type: linear; color: ${defaultFogColor}; near: 0; far: ${defaultFogFar}`;
            }

            // Step 4: Flush changes to DOM and update the code panel
            flushAllEntitiesToDOM();

            // Step 5: Apply fog settings
            if (currentFog) {
                setTimeout(() => {
                    scene.setAttribute('fog', currentFog);
                    if (scene.renderer) {
                        scene.renderer.render(scene.object3D, scene.camera);
                    }
                    updateCodePanel();
                }, 100); // Small delay to ensure environment component has time to initialize
            } else {
                setTimeout(() => {
                    updateCodePanel();
                }, 100);
            }
        }

        // Function to update sky color picker state
        function updateSkyColorPicker() {
            const skyColorPicker = document.getElementById('background-color');
            const skyColorHex = document.getElementById('background-color-hex');
            const skyboxElements = document.querySelectorAll('#skybox-container .asset-item');

            // Enable sky color picker
            disableSkyColorPicker(false);

            // Update with current background color
            const background = scene.getAttribute('background');
            // Ensure we have a valid color value with proper format
            let colorValue = '#ECECEC'; // Default color

            if (background) {
                // Check if background is a string (new format) or object (old format)
                if (typeof background === 'string') {
                    // Extract the color value from the attribute string
                    const match = background.match(/color:\s*(#[0-9A-Fa-f]{6})/i);
                    if (match) {
                        colorValue = match[1];
                    }
                } else if (background.color) {
                    // Old format with object
                    // Make sure it's a valid hex color
                    if (typeof background.color === 'string' &&
                        background.color.startsWith('#') &&
                        /^#[0-9A-Fa-f]{6}$/i.test(background.color)) {
                        colorValue = background.color;
                    }
                }
            }

            skyColorPicker.value = colorValue;
            skyColorHex.value = colorValue.toUpperCase();
        }

        // Function to enable/disable sky color picker
        function disableSkyColorPicker(disabled) {
            const skyColorPicker = document.getElementById('background-color');
            const skyColorHex = document.getElementById('background-color-hex');
            const skyboxElements = document.querySelectorAll('#skybox-container .asset-item');

            // Always enable the sky color picker regardless of environment
            // This allows users to override the environment background color
            skyColorPicker.disabled = false;
            skyColorHex.disabled = false;
            skyColorPicker.style.opacity = '1';
            skyColorHex.style.opacity = '1';

            // Only disable skybox elements if needed
            if (disabled) {
                skyboxElements.forEach(el => {
                    el.style.pointerEvents = 'none';
                    el.style.opacity = '0.5';
                });
            } else {
                skyboxElements.forEach(el => {
                    el.style.pointerEvents = 'auto';
                    el.style.opacity = '1';
                });
            }
        }

        // Function to sync environment preset dropdown with scene
        function syncEnvironmentPresetDropdown() {
            const environmentPreset = document.getElementById('environment-preset');
            if (!environmentPreset) return;

            const environmentEntity = document.querySelector('a-entity[environment]');
            if (environmentEntity) {
                const preset = environmentEntity.getAttribute('environment').preset ||
                    environmentEntity.getAttribute('environment').split('preset:')[1]?.trim().split(' ')[0] ||
                    'default';
                environmentPreset.value = preset;

                // Keep sky color picker enabled for all environments
                disableSkyColorPicker(false);
                updateSkyColorPicker();
            } else {
                environmentPreset.value = 'none';

                // Check if we have a custom skybox
                const customSky = document.querySelector('a-sky[src]');
                if (customSky) {
                    disableSkyColorPicker(true);
                } else {
                    // Enable sky color picker for the default background
                    disableSkyColorPicker(false);
                    updateSkyColorPicker();
                }
            }
        }

        // Add function to fix default light duplication
        function fixDefaultLightDuplication() {
            // Get all default lights
            const defaultLights = document.querySelectorAll('[light][data-aframe-default-light]');
            if (defaultLights.length > 2) {
                console.log(`Found ${defaultLights.length} default lights, removing duplicates...`);

                // Keep track of which types we've seen
                let ambientLight = null;
                let directionalLight = null;

                // First pass - identify which lights to keep
                defaultLights.forEach(light => {
                    const lightType = light.getAttribute('light').type || 'directional';

                    if (lightType === 'ambient') {
                        if (!ambientLight) {
                            ambientLight = light;
                        }
                    } else {
                        // Assume it's a directional light
                        if (!directionalLight) {
                            directionalLight = light;
                        }
                    }
                });

                // Second pass - safely remove duplicates
                defaultLights.forEach(light => {
                    const lightType = light.getAttribute('light').type || 'directional';

                    // Skip the lights we want to keep
                    if ((lightType === 'ambient' && light === ambientLight) ||
                        (lightType !== 'ambient' && light === directionalLight)) {
                        return;
                    }

                    // Safe removal with checks
                    try {
                        if (light.parentNode) {
                            // Detach any Three.js objects first to prevent reference issues
                            if (light.object3D && typeof light.removeObject3D === 'function') {
                                const objectKeys = Object.keys(light.object3D);
                                objectKeys.forEach(key => {
                                    if (key !== 'el') {  // Don't remove the element reference
                                        light.removeObject3D(key);
                                    }
                                });
                            }

                            // Now safely remove from parent
                            light.parentNode.removeChild(light);
                            console.log('Safely removed duplicate light');
                        }
                    } catch (e) {
                        console.warn('Error removing light:', e);
                    }
                });
            }
        }

        // Global reference to the active particle system entities
        let activeParticleSystems = {
            snow: null,
            dust: null,
            rain: null
        };

        // Custom simplified particle system component
        AFRAME.registerComponent('particle-system', {
            schema: {
                preset: { type: 'string', default: 'snow' },
                particleCount: { type: 'number', default: 1000 },
                texture: { type: 'string', default: '' },
                color: { type: 'color', default: '#FFFFFF' },
                size: { type: 'number', default: 1.0 },
                velocity: { type: 'vec3', default: { x: 0, y: -1, z: 0 } },
                acceleration: { type: 'vec3', default: { x: 0, y: 0, z: 0 } },
                randomizeVelocity: { type: 'vec3', default: { x: 0.2, y: 0.1, z: 0.2 } },
                maxAge: { type: 'number', default: 6 },
                blending: { type: 'string', default: 'additive' },
                active: { type: 'boolean', default: true }
            },

            init: function () {
                // Access THREE through A-Frame to ensure compatibility
                this.THREE = AFRAME.THREE;

                // Initialize the arrays and clock first
                this.particles = [];
                this.time = 0;

                // Use A-Frame's built-in THREE reference
                this.clock = new this.THREE.Clock();

                // Use a paused property instead of pause to avoid conflicts
                this.isPaused = false;

                // Create Three.js particle system
                this.setupParticleSystem();

                // Only start if active is true
                if (this.data.active) {
                    this.startParticles();
                } else {
                    this.isPaused = true;
                }
            },

            // Add proper A-Frame lifecycle methods
            pause: function () {
                this.isPaused = true;
                // Remove these lines that modify the animation button
                // document.getElementById('animation-text').textContent = 'Start';
                // document.getElementById('animation-icon').setAttribute('d', 'M8 5v14l11-7z'); // Play icon
            },

            play: function () {
                this.isPaused = false;

                // Reset the clock if needed
                if (this.clock && typeof this.clock.getElapsedTime === 'function') {
                    this.time = this.clock.getElapsedTime();
                } else {
                    this.time = Date.now() / 1000;
                    this.clock = new this.THREE.Clock();
                }

                // Remove these lines that modify the animation button
                // document.getElementById('animation-text').textContent = 'Stop';
                // document.getElementById('animation-icon').setAttribute('d', 'M6 19h4V5H6v14zm8-14v14h4V5h-4z'); // Pause icon
            },

            setupParticleSystem: function () {
                try {
                    // Reset any existing system
                    if (this.particleGroup) {
                        this.el.removeObject3D('particle-system');

                        // Clear particles array when rebuilding the system
                        this.particles = [];
                    }

                    // Configure based on preset
                    this.applyPreset(this.data.preset);

                    // Create material based on preset settings
                    this.particleMaterial = new this.THREE.PointsMaterial({
                        color: new this.THREE.Color(this.data.color),
                        size: this.data.size * 0.1,
                        transparent: true,
                        blending: this.data.blending === 'additive' ?
                            this.THREE.AdditiveBlending : this.THREE.NormalBlending,
                        depthWrite: false
                    });

                    // Use texture if specified
                    if (this.data.texture) {
                        const loader = new this.THREE.TextureLoader();
                        loader.load(this.data.texture, (texture) => {
                            this.particleMaterial.map = texture;
                            this.particleMaterial.needsUpdate = true;
                        });
                    } else {
                        // Create a basic particle texture
                        const canvas = document.createElement('canvas');
                        canvas.width = 32;
                        canvas.height = 32;
                        const context = canvas.getContext('2d');
                        const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
                        gradient.addColorStop(0, 'rgba(255,255,255,1)');
                        gradient.addColorStop(1, 'rgba(255,255,255,0)');
                        context.fillStyle = gradient;
                        context.fillRect(0, 0, 32, 32);

                        const texture = new this.THREE.CanvasTexture(canvas);
                        this.particleMaterial.map = texture;
                        this.particleMaterial.needsUpdate = true;
                    }

                    // Create geometry
                    this.particleGeometry = new this.THREE.BufferGeometry();

                    // Prepare arrays for particle attributes
                    const positions = new Float32Array(this.data.particleCount * 3);
                    const velocities = new Float32Array(this.data.particleCount * 3);
                    const startTimes = new Float32Array(this.data.particleCount);
                    const lifetimes = new Float32Array(this.data.particleCount);

                    // Initialize particles
                    for (let i = 0; i < this.data.particleCount; i++) {
                        this.initParticle(i, positions, velocities, startTimes, lifetimes);

                        // Track each particle data
                        this.particles.push({
                            position: new this.THREE.Vector3(
                                positions[i * 3],
                                positions[i * 3 + 1],
                                positions[i * 3 + 2]
                            ),
                            velocity: new this.THREE.Vector3(
                                velocities[i * 3],
                                velocities[i * 3 + 1],
                                velocities[i * 3 + 2]
                            ),
                            startTime: startTimes[i],
                            lifetime: lifetimes[i]
                        });
                    }

                    // Add attributes to geometry
                    this.particleGeometry.setAttribute('position',
                        new this.THREE.BufferAttribute(positions, 3));
                    this.particleGeometry.setAttribute('velocity',
                        new this.THREE.BufferAttribute(velocities, 3));
                    this.particleGeometry.setAttribute('startTime',
                        new this.THREE.BufferAttribute(startTimes, 1));
                    this.particleGeometry.setAttribute('lifetime',
                        new this.THREE.BufferAttribute(lifetimes, 1));

                    // Create the particle system
                    this.particleGroup = new this.THREE.Points(this.particleGeometry, this.particleMaterial);

                    // Check that we have a valid Object3D
                    if (!(this.particleGroup instanceof this.THREE.Object3D)) {
                        console.error('Failed to create a valid THREE.Object3D for particles');
                        return;
                    }

                    // Set the object onto the entity
                    this.el.setObject3D('particle-system', this.particleGroup);

                } catch (error) {
                    console.error('Error setting up particle system:', error);
                }
            },

            initParticle: function (i, positions, velocities, startTimes, lifetimes) {
                // Position: random dispersion according to preset
                const posSpread = this.positionSpread || { x: 2, y: 0, z: 2 };
                positions[i * 3] = (Math.random() * 2 - 1) * posSpread.x;
                positions[i * 3 + 1] = (Math.random() * 2 - 1) * posSpread.y;
                positions[i * 3 + 2] = (Math.random() * 2 - 1) * posSpread.z;

                // Velocity: base direction with randomization
                const velBase = this.data.velocity;
                const velRandom = this.data.randomizeVelocity;
                velocities[i * 3] = velBase.x + (Math.random() * 2 - 1) * velRandom.x;
                velocities[i * 3 + 1] = velBase.y + (Math.random() * 2 - 1) * velRandom.y;
                velocities[i * 3 + 2] = velBase.z + (Math.random() * 2 - 1) * velRandom.z;

                // Time values: stagger start times for continuous flow
                startTimes[i] = this.time + Math.random() * this.data.maxAge;
                lifetimes[i] = this.data.maxAge;
            },

            applyPreset: function (preset) {
                switch (preset) {
                    case 'snow':
                        this.data.particleCount = 1500;
                        this.data.color = '#FFFFFF';
                        this.data.size = 1.0;
                        this.data.velocity = { x: 0, y: -0.2, z: 0 };
                        this.data.acceleration = { x: 0, y: 0, z: 0 };
                        this.data.randomizeVelocity = { x: 0.2, y: 0.1, z: 0.2 };
                        this.data.maxAge = 10;
                        this.data.blending = 'additive';
                        this.positionSpread = { x: 10, y: 5, z: 10 };
                        break;
                    case 'dust':
                        this.data.particleCount = 2000;
                        this.data.color = '#FFCC33';
                        this.data.size = 0.5;
                        this.data.velocity = { x: 0.02, y: 0.05, z: 0.02 };
                        this.data.acceleration = { x: 0, y: 0.01, z: 0 };
                        this.data.randomizeVelocity = { x: 0.1, y: 0.1, z: 0.1 };
                        this.data.maxAge = 15;
                        this.data.blending = 'normal';
                        this.positionSpread = { x: 10, y: 5, z: 10 };
                        break;
                    case 'rain':
                        this.data.particleCount = 1000;
                        this.data.color = '#AADDFF';
                        this.data.size = 0.8;
                        this.data.velocity = { x: 0, y: -2, z: 0.3 };  // Angled rain
                        this.data.acceleration = { x: 0, y: -1, z: 0 };
                        this.data.randomizeVelocity = { x: 0.1, y: 0.5, z: 0.1 };
                        this.data.maxAge = 2;
                        this.data.blending = 'normal';
                        this.positionSpread = { x: 10, y: 8, z: 10 };
                        break;
                }
            },

            update: function (oldData) {
                try {
                    const changed = Object.keys(this.data).some(key => oldData[key] !== this.data[key]);
                    if (changed) {
                        this.setupParticleSystem();
                    }

                    // Handle active state change
                    if (oldData.active !== this.data.active) {
                        if (this.data.active) {
                            this.startParticles();
                        } else {
                            this.stopParticles();
                        }
                    }
                } catch (error) {
                    console.error('Error in particle update:', error);
                }
            },

            tick: function (time, delta) {
                try {
                    if (this.isPaused || !this.particleGeometry) return;

                    // Update time
                    this.time += delta / 1000;

                    // Check that all required arrays exist
                    if (!this.particleGeometry.attributes.position ||
                        !this.particleGeometry.attributes.velocity ||
                        !this.particleGeometry.attributes.startTime ||
                        !this.particleGeometry.attributes.lifetime) {
                        return;
                    }

                    // Get positions and update based on physics
                    const positions = this.particleGeometry.attributes.position.array;
                    const velocities = this.particleGeometry.attributes.velocity.array;
                    const startTimes = this.particleGeometry.attributes.startTime.array;
                    const lifetimes = this.particleGeometry.attributes.lifetime.array;

                    const acceleration = this.data.acceleration;

                    for (let i = 0; i < this.data.particleCount; i++) {
                        // Calculate particle age
                        const age = this.time - startTimes[i];

                        // Respawn if too old
                        if (age > lifetimes[i]) {
                            this.initParticle(i, positions, velocities, startTimes, lifetimes);
                            continue;
                        }

                        // Update velocity with acceleration
                        velocities[i * 3] += acceleration.x * delta / 1000;
                        velocities[i * 3 + 1] += acceleration.y * delta / 1000;
                        velocities[i * 3 + 2] += acceleration.z * delta / 1000;

                        // Update position with velocity
                        positions[i * 3] += velocities[i * 3] * delta / 1000;
                        positions[i * 3 + 1] += velocities[i * 3 + 1] * delta / 1000;
                        positions[i * 3 + 2] += velocities[i * 3 + 2] * delta / 1000;

                        // Update particle object for tracking if it exists
                        if (this.particles[i]) {
                            this.particles[i].position.set(
                                positions[i * 3],
                                positions[i * 3 + 1],
                                positions[i * 3 + 2]
                            );
                            this.particles[i].velocity.set(
                                velocities[i * 3],
                                velocities[i * 3 + 1],
                                velocities[i * 3 + 2]
                            );
                        }
                    }

                    // Update geometry
                    this.particleGeometry.attributes.position.needsUpdate = true;
                    this.particleGeometry.attributes.velocity.needsUpdate = true;
                    this.particleGeometry.attributes.startTime.needsUpdate = true;
                } catch (error) {
                    console.error('Error in particle tick:', error);
                    this.isPaused = true; // Stop on error to prevent console spam
                }
            },

            startParticles: function () {
                try {
                    // Use play method instead
                    this.play();

                    // If the component was just created and added, make sure system is set up
                    if (!this.particleGroup) {
                        this.setupParticleSystem();
                    }
                } catch (error) {
                    console.error('Error starting particles:', error);
                }
            },

            stopParticles: function () {
                try {
                    // Use pause method instead
                    this.pause();
                } catch (error) {
                    console.error('Error stopping particles:', error);
                }
            },

            remove: function () {
                try {
                    // First make sure animations are stopped
                    this.isPaused = true;

                    // Clean up when component is removed
                    if (this.particleGroup) {
                        this.el.removeObject3D('particle-system');
                    }

                    if (this.particleMaterial) {
                        this.particleMaterial.dispose();
                    }

                    if (this.particleGeometry) {
                        this.particleGeometry.dispose();
                    }

                    this.particles = [];
                } catch (error) {
                    console.error('Error removing particle system:', error);
                }
            }
        });

        // Toggle particle systems on/off individually
        function toggleParticleSystem(preset) {
            try {
                // If this system is already active, remove it (toggle off)
                if (activeParticleSystems[preset]) {
                    // First pause the system to stop animations before removing
                    const system = activeParticleSystems[preset];
                    if (system.components && system.components['particle-system']) {
                        system.components['particle-system'].pause();
                    }

                    // Small delay before removing to ensure pause completes
                    setTimeout(() => {
                        try {
                            // Make sure the DOM is up to date
                            flushAllEntitiesToDOM();

                            // Check if the system is actually in the DOM and is a child of scene
                            const elementInDOM = document.getElementById(system.id || `particle-effect-${preset}`);

                            if (elementInDOM && scene.contains(elementInDOM)) {
                                scene.removeChild(elementInDOM);
                            } else if (system.parentNode) {
                                // Fallback to the system reference if it has a parentNode
                                system.parentNode.removeChild(system);
                            } else {
                                console.log(`Particle system ${preset} was already removed or not found in DOM`);
                            }

                            // Clear the reference regardless
                            activeParticleSystems[preset] = null;

                            // Update code panel
                            flushAllEntitiesToDOM();
                            updateCodePanel();
                        } catch (e) {
                            console.error('Error removing particle system:', e);
                        }
                    }, 50);

                    // Update button to show inactive state
                    document.getElementById(`${preset}-btn`).style.backgroundColor = '#2c2c2c';

                    // Check if any systems are still active for the animation toggle button
                    const anyActive = Object.values(activeParticleSystems).some(system => system !== null);
                    document.getElementById('toggle-animation-btn').disabled = !anyActive;
                    document.getElementById('toggle-animation-btn').style.opacity = anyActive ? 1 : 0.5;

                    return;
                }

                // Create new particle system entity (toggle on)
                const particleEntity = document.createElement('a-entity');
                particleEntity.setAttribute('position', '0 5 -5'); // Position appropriately above the scene
                particleEntity.setAttribute('id', `particle-effect-${preset}`);

                // Store reference to the new system
                activeParticleSystems[preset] = particleEntity;

                // Highlight active button
                document.getElementById(`${preset}-btn`).style.backgroundColor = '#4c6ef5';

                // Add to scene
                scene.appendChild(particleEntity);

                // Wait a frame for the entity to initialize
                setTimeout(() => {
                    // Now add the component
                    particleEntity.setAttribute('particle-system', `preset: ${preset}`);

                    // Enable toggle animation button
                    document.getElementById('toggle-animation-btn').disabled = false;
                    document.getElementById('toggle-animation-btn').style.opacity = 1;

                    // Update code panel
                    flushAllEntitiesToDOM();
                    updateCodePanel();
                }, 100);
            } catch (error) {
                console.error('Error in toggleParticleSystem:', error);
            }
        }

        // Toggle animation state for all active particle systems
        function toggleParticleAnimation() {
            try {
                // Get all active particle systems
                const activeSystems = Object.values(activeParticleSystems).filter(system => system !== null);
                if (activeSystems.length === 0) return;

                // Determine the action based on any active system's state
                // If any system is paused, we'll start all systems
                let shouldStart = false;
                let allInitialized = true;

                for (const system of activeSystems) {
                    if (!system.components['particle-system']) {
                        allInitialized = false;
                        break;
                    }

                    if (system.components['particle-system'].isPaused) {
                        shouldStart = true;
                    }
                }

                // If not all systems are initialized, wait and try again
                if (!allInitialized) {
                    console.log('Waiting for particle systems to initialize...');
                    setTimeout(toggleParticleAnimation, 100);
                    return;
                }

                // Apply the same action to all systems
                for (const system of activeSystems) {
                    const particleSystem = system.components['particle-system'];

                    if (shouldStart) {
                        particleSystem.play();
                    } else {
                        particleSystem.pause();
                    }
                }

                // Update button appearance
                if (shouldStart) {
                    document.getElementById('toggle-animation-btn').style.backgroundColor = '#4c6ef5';
                    // Update button text and icon for "Stop" state
                    document.getElementById('animation-text').textContent = 'Stop';
                    document.getElementById('animation-icon').setAttribute('d', 'M6 19h4V5H6v14zm8-14v14h4V5h-4z'); // Pause icon
                } else {
                    document.getElementById('toggle-animation-btn').style.backgroundColor = '#2c2c2c';
                    // Update button text and icon for "Start" state
                    document.getElementById('animation-text').textContent = 'Start';
                    document.getElementById('animation-icon').setAttribute('d', 'M8 5v14l11-7z'); // Play icon
                }
            } catch (error) {
                console.error('Error in toggleParticleAnimation:', error);
            }
        }

        // Add some CSS for particle buttons
        document.head.insertAdjacentHTML('beforeend', `
            <style>
                .effect-btn {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    gap: 5px;
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3c3c3c;
                    border-radius: 4px;
                    padding: 8px 5px;
                    cursor: pointer;
                    transition: background-color 0.2s;
                }
                .effect-btn:hover:not(:disabled) {
                    background-color: #3c3c3c;
                }
                .effect-btn:disabled {
                    opacity: 0.5;
                    cursor: not-allowed;
                }
                .effect-btn svg {
                    width: 24px;
                    height: 24px;
                    fill: white;
                }
            </style>
        `);

        document.addEventListener('DOMContentLoaded', function () {
            // Safely get the canvas element
            const canvas = document.getElementById('scene');

            // Check if it's actually a canvas element before proceeding
            let ctx;
            if (canvas && canvas instanceof HTMLCanvasElement) {
                ctx = canvas.getContext('2d');
            } else {
                console.warn('Canvas element not found or is not a proper canvas');
                // Create a fallback canvas if needed to prevent errors
                const fallbackCanvas = document.createElement('canvas');
                fallbackCanvas.width = 1;
                fallbackCanvas.height = 1;
                ctx = fallbackCanvas.getContext('2d');
            }

            let animationId;
            let isAnimating = false;
            let currentParticleType = 'rain'; // Default particle type

            // Set initial global animation state based on button text (with null check)
            const animationText = document.getElementById('animation-text');
            if (animationText) {
                globalAnimationState = animationText.textContent.trim() === 'Stop';
            }

            // Set canvas dimensions if we have a valid canvas
            function resizeCanvas() {
                if (canvas && canvas instanceof HTMLCanvasElement) {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                }
            }

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Remaining initialization code...
        });

        // Global reference to fog state
        let fogActive = false;

        // Function to toggle fog on/off
        function toggleFog() {
            const fogBtn = document.getElementById('toggle-fog-btn');
            // If the button doesn't exist, we can't proceed
            if (!fogBtn) return;

            const fogColor = document.getElementById('fog-color').value;
            const fogType = document.querySelector('input[name="fog-type"]:checked').value;
            let fogString;

            if (!fogActive) {
                // Format fog attributes based on type
                if (fogType === 'linear') {
                    const fogNear = document.getElementById('fog-near').value;
                    const fogFar = document.getElementById('fog-far').value;
                    fogString = `type: linear; color: ${fogColor.toUpperCase()}; near: ${fogNear}; far: ${fogFar}`;
                } else {
                    const fogIntensity = document.getElementById('fog-intensity').value;
                    fogString = `type: exponential; color: ${fogColor.toUpperCase()}; density: ${fogIntensity}`;
                }

                // Set the fog attribute with the properly formatted string
                scene.setAttribute('fog', fogString);

                // Update button appearance
                fogBtn.style.backgroundColor = '#4c6ef5';
                const addSpan = fogBtn.querySelector('span');
                if (addSpan) {
                    addSpan.textContent = 'Remove Fog';
                } else {
                    fogBtn.textContent = 'Remove Fog';
                }

                // Update fog state
                fogActive = true;

                // Force a scene update
                if (scene.renderer) {
                    scene.renderer.render(scene.object3D, scene.camera);
                }
            } else {
                // Properly remove fog component
                if (scene.components.fog) {
                    // Remove the component instance
                    scene.components.fog.remove();
                    // Delete the component reference
                    delete scene.components.fog;
                }

                // Remove from the systems
                if (scene.systems.fog) {
                    scene.systems.fog.remove();
                    delete scene.systems.fog;
                }

                // Remove the attribute
                scene.removeAttribute('fog');

                // Clear Three.js fog
                if (scene.object3D) {
                    scene.object3D.fog = null;
                }

                // Update button appearance
                fogBtn.style.backgroundColor = '#2c2c2c';
                // Check if the button has a span child before updating its text
                const spanRemove = fogBtn.querySelector('span');
                if (spanRemove) {
                    spanRemove.textContent = 'Add Fog';
                } else {
                    fogBtn.textContent = 'Add Fog';
                }

                // Update fog state
                fogActive = false;
            }

            // Force scene to update
            scene.flushToDOM();
            if (scene.renderer) {
                scene.renderer.render(scene.object3D, scene.camera);
            }

            // Update code panel to reflect changes
            updateCodePanel();
        }

        // Add event listeners for fog controls
        document.getElementById('fog-color').addEventListener('input', function () {
            const hexValue = this.value.toUpperCase();
            document.getElementById('fog-color-hex').value = hexValue;

            if (fogActive) {
                updateFog();
            }
        });

        document.getElementById('fog-color-hex').addEventListener('input', function () {
            let color = this.value;

            // Ensure the color starts with #
            if (!color.startsWith('#')) {
                color = '#' + color;
                this.value = color;
            }

            // Check if input contains valid hex characters
            if (/^#[0-9A-Fa-f]*$/.test(color)) {
                // Create a valid color by padding if needed
                let validColor = color;

                // Get the hex part without #
                const hexPart = color.substring(1);

                // If we have some valid hex digits
                if (hexPart.length > 0 && hexPart.length < 6) {
                    // Pad with appropriate characters to make a valid color
                    // For 1-2 digits, repeat them to make 6
                    // For 3+ digits, pad with zeros
                    if (hexPart.length <= 2) {
                        // Repeat the digits we have (e.g. "F" becomes "FFFFFF")
                        validColor = '#' + hexPart.padEnd(6, hexPart).toUpperCase();
                    } else {
                        // Pad with zeros (e.g. "F00" becomes "F00000")
                        validColor = '#' + hexPart.padEnd(6, '0').toUpperCase();
                    }
                } else if (hexPart.length === 6) {
                    // We have a complete color
                    validColor = color;
                } else {
                    // Empty or invalid, don't update
                    return;
                }

                // Update color picker and fog
                document.getElementById('fog-color').value = validColor;
                this.value = validColor.toUpperCase();

                if (fogActive) {
                    updateFog();
                }
            }
        });

        // Function to update fog based on current control values
        function updateFog() {
            const fogColor = document.getElementById('fog-color').value;
            const fogType = document.querySelector('input[name="fog-type"]:checked').value;
            let fogString;

            if (fogType === 'linear') {
                const fogNear = document.getElementById('fog-near').value;
                const fogFar = document.getElementById('fog-far').value;
                fogString = `type: linear; color: ${fogColor.toUpperCase()}; near: ${fogNear}; far: ${fogFar}`;
            } else {
                const fogIntensity = document.getElementById('fog-intensity').value;
                fogString = `type: exponential; color: ${fogColor.toUpperCase()}; density: ${fogIntensity}`;
            }

            scene.setAttribute('fog', fogString);

            // Force a scene update
            if (scene.renderer) {
                scene.renderer.render(scene.object3D, scene.camera);
            }

            // Update code panel
            updateCodePanel();
        }

        // Add event listeners for fog type radio buttons
        document.querySelectorAll('input[name="fog-type"]').forEach(radio => {
            radio.addEventListener('change', function () {
                // Show/hide appropriate controls
                const linearControls = document.getElementById('fog-linear-controls');
                const exponentialControls = document.getElementById('fog-exponential-controls');

                if (this.value === 'linear') {
                    linearControls.style.display = 'block';
                    exponentialControls.style.display = 'none';
                } else {
                    linearControls.style.display = 'none';
                    exponentialControls.style.display = 'block';
                }

                if (fogActive) {
                    updateFog();
                }
            });
        });

        // Add event listeners for fog distance controls
        document.getElementById('fog-near').addEventListener('input', function () {
            if (fogActive) {
                updateFog();
            }
        });

        document.getElementById('fog-far').addEventListener('input', function () {
            if (fogActive) {
                updateFog();
            }
        });

        document.getElementById('fog-intensity').addEventListener('input', function () {
            if (fogActive) {
                updateFog();
            }
        });

        function clearEntities() {
            // Check if we're in the current view
            if (currentView === 'scene') {
                // Store current environment preset if it exists
                const existingEnvironment = document.querySelector('a-entity[environment]');
                let currentPreset = null;
                if (existingEnvironment) {
                    const envAttr = existingEnvironment.getAttribute('environment');
                    // Handle both string and object attribute values
                    if (typeof envAttr === 'string') {
                        currentPreset = envAttr.split(':')[1].trim();
                    } else if (typeof envAttr === 'object') {
                        currentPreset = envAttr.preset;
                    }
                    // Remove the old environment entity
                    existingEnvironment.parentNode.removeChild(existingEnvironment);
                }

                // Force a flush to DOM first
                flushAllEntitiesToDOM();

                // Get all entities except environment-related ones
                const entities = scene.querySelectorAll('a-entity, a-box, a-sphere, a-cylinder, a-plane, a-obj-model, a-gltf-model, a-asset-item, a-video, a-image, a-text, a-curve, a-ring, a-torus, a-torus-knot, a-dodecahedron, a-octahedron, a-tetrahedron, a-icosahedron, a-cone, a-circle, a-ellipse, a-line, a-triangle, a-videosphere, a-videocylinder, a-videoplane');

                // Remove each entity
                entities.forEach(entity => {
                    // Skip environment-related entities
                    if (!entity.hasAttribute('environment') &&
                        !entity.hasAttribute('fog') &&
                        !entity.hasAttribute('particle-system') &&
                        !entity.hasAttribute('animation') &&
                        entity.tagName !== 'a-sky' &&
                        entity.tagName !== 'a-camera' &&
                        entity.tagName !== 'a-assets') {
                        if (entity.parentNode) {
                            entity.parentNode.removeChild(entity);
                        }
                    }
                });

                // Force another flush to DOM after removals
                flushAllEntitiesToDOM();

                // If we had an environment, reinitialize it
                if (currentPreset) {
                    // Create new environment entity with only the preset attribute
                    const environment = document.createElement('a-entity');
                    environment.setAttribute('environment', `preset: ${currentPreset}`);
                    scene.appendChild(environment);

                    // Wait for scene to initialize
                    setTimeout(() => {
                        // Force a render to make sure everything is visible
                        if (scene.renderer) {
                            scene.renderer.render(scene.object3D, scene.camera);
                        }
                        flushAllEntitiesToDOM();
                    }, 100);
                }
            }
        }

        document.getElementById('environment-preset').addEventListener('change', function (e) {
            const preset = e.target.value;
            const scene = document.querySelector('a-scene');
            let environment = scene.querySelector('a-entity[environment]');

            if (preset === 'none') {
                // Clean up fog if it exists
                if (scene.hasAttribute('fog')) {
                    // Properly remove fog component
                    if (scene.components.fog) {
                        // Remove the component instance
                        scene.components.fog.remove();
                        // Delete the component reference
                        delete scene.components.fog;
                    }

                    // Remove from the systems
                    if (scene.systems.fog) {
                        scene.systems.fog.remove();
                        delete scene.systems.fog;
                    }

                    // Remove the attribute
                    scene.removeAttribute('fog');

                    // Clear Three.js fog
                    if (scene.object3D) {
                        scene.object3D.fog = null;
                    }
                }

                // Set fogActive to false
                fogActive = false;

                // Update fog controls for the 'none' preset
                // 1. Set the fog color to match background color
                const bgColor = document.getElementById('background-color').value;
                const fogColorInput = document.getElementById('fog-color');
                const fogColorHexInput = document.getElementById('fog-color-hex');
                if (fogColorInput) fogColorInput.value = bgColor;
                if (fogColorHexInput) fogColorHexInput.value = bgColor.toUpperCase();

                // 2. Set fog type to exponential
                const exponentialRadio = document.querySelector('input[name="fog-type"][value="exponential"]');
                if (exponentialRadio) {
                    exponentialRadio.checked = true;
                    // Update visibility of controls
                    const linearControls = document.getElementById('fog-linear-controls');
                    const exponentialControls = document.getElementById('fog-exponential-controls');
                    if (linearControls) linearControls.style.display = 'none';
                    if (exponentialControls) exponentialControls.style.display = 'block';
                }

                // Also update the toggle fog button to show "Add Fog"
                const fogBtn = document.getElementById('toggle-fog-btn');
                fogBtn.style.backgroundColor = '#2c2c2c';
                fogBtn.textContent = 'Add Fog';

                // Remove environment if it exists
                if (environment) {
                    environment.parentNode.removeChild(environment);
                }

                // Add default lights that match A-Frame's defaults
                const ambientLight = document.createElement('a-entity');
                ambientLight.setAttribute('light', 'type: ambient; color: #BBB;');
                ambientLight.setAttribute('data-aframe-default-light', '');
                ambientLight.setAttribute('aframe-injected', '');
                scene.appendChild(ambientLight);

                const directionalLight = document.createElement('a-entity');
                directionalLight.setAttribute('light', 'color: #FFF; intensity: 1.884; castShadow: true');
                directionalLight.setAttribute('position', '-0.5 1 1');
                directionalLight.setAttribute('data-aframe-default-light', '');
                directionalLight.setAttribute('aframe-injected', '');
                scene.appendChild(directionalLight);
            } else {
                // Create or update environment entity
                if (!environment) {
                    environment = document.createElement('a-entity');
                    environment.setAttribute('environment', '');
                    scene.appendChild(environment);
                }

                // Update environment entity
                environment.setAttribute('environment', preset);
                environment.flushToDOM();
            }

            // Force a scene update and flush all entities
            scene.flushToDOM();
            flushAllEntitiesToDOM();

            // Update code panel to show actual state
            updateCodePanel();
        });



        // Initialize everything once the scene is loaded
        scene.addEventListener('loaded', () => {
            // Ensure the scene has a valid background color
            if (!scene.hasAttribute('background')) {
                scene.setAttribute('background', 'color: #ECECEC');
            } else {
                // Validate the existing background color
                const background = scene.getAttribute('background');
                if (!background || !background.color ||
                    typeof background.color !== 'string' ||
                    !background.color.startsWith('#') ||
                    !/^#[0-9A-Fa-f]{6}$/i.test(background.color)) {
                    scene.setAttribute('background', 'color: #ECECEC');
                }
            }

            initSkyColorPicker();
            initEnvironmentPresets();
            // Remove the call to initFogControls since it doesn't exist yet
            updateCodePanel();
        });

        // Also initialize immediately in case the scene is already loaded
        if (scene.hasLoaded) {
            // Ensure the scene has a valid background color
            if (!scene.hasAttribute('background')) {
                scene.setAttribute('background', 'color: #ECECEC');
            } else {
                // Validate the existing background color
                const background = scene.getAttribute('background');
                if (!background || !background.color ||
                    typeof background.color !== 'string' ||
                    !background.color.startsWith('#') ||
                    !/^#[0-9A-Fa-f]{6}$/i.test(background.color)) {
                    scene.setAttribute('background', 'color: #ECECEC');
                }
            }

            initSkyColorPicker();
            initEnvironmentPresets();
            // Remove the call to initFogControls since it doesn't exist yet
            updateCodePanel();
        } else {
            // Initialize with default values until scene loads
            const skyColorPicker = document.getElementById('background-color');
            const skyColorHex = document.getElementById('background-color-hex');
            if (skyColorPicker && skyColorHex) {
                skyColorPicker.value = '#ECECEC';
                skyColorHex.value = '#ECECEC';
            }
        }

        function initBackgroundColorPicker() {
            const backgroundColorPicker = document.getElementById('background-color');
            const backgroundColorHex = document.getElementById('background-color-hex');

            // Get the current background color from the scene
            let colorValue = '#ECECEC';
            const background = scene.getAttribute('background');
            if (background) {
                if (typeof background === 'string' && background.startsWith('color: ')) {
                    colorValue = background.substring(7);
                } else if (background.color) {
                    colorValue = background.color;
                }
            }

            backgroundColorPicker.value = colorValue;
            backgroundColorHex.value = colorValue.toUpperCase();

            backgroundColorPicker.addEventListener('input', function (e) {
                const color = e.target.value.toUpperCase();
                backgroundColorHex.value = color;
                updateBackgroundColor(color);
            });

            backgroundColorHex.addEventListener('input', function (e) {
                let color = e.target.value;
                if (!color.startsWith('#')) {
                    color = '#' + color;
                }
                updateBackgroundColor(color);
            });

            backgroundColorHex.addEventListener('change', function (e) {
                let color = e.target.value;
                if (!color.startsWith('#')) {
                    color = '#' + color;
                }
                // Validate hex color
                const validColor = validateHexColor(color);
                if (validColor) {
                    updateBackgroundColor(validColor);
                    backgroundColorPicker.value = validColor;
                    backgroundColorHex.value = validColor;
                }
            });
        }

        function updateBackgroundColor(color) {
            scene.setAttribute('background', { color: color });
            updateCodePanel();
        }

        function updateBackgroundColorPicker() {
            const backgroundColorPicker = document.getElementById('background-color');
            const backgroundColorHex = document.getElementById('background-color-hex');

            // Get current background color
            let colorValue = '#ECECEC';
            const background = scene.getAttribute('background');
            if (background) {
                if (typeof background === 'string' && background.startsWith('color: ')) {
                    colorValue = background.substring(7);
                } else if (background.color) {
                    colorValue = background.color;
                }
            }

            backgroundColorPicker.value = colorValue;
            backgroundColorHex.value = colorValue.toUpperCase();
        }

        // Initialize color pickers
        initBackgroundColorPicker();

        // Initialize with default values
        if (scene.hasLoaded) {
            updateBackgroundColorPicker();
        } else {
            // Initialize with default values until scene loads
            const backgroundColorPicker = document.getElementById('background-color');
            const backgroundColorHex = document.getElementById('background-color-hex');
            if (backgroundColorPicker && backgroundColorHex) {
                backgroundColorPicker.value = '#ECECEC';
                backgroundColorHex.value = '#ECECEC';
            }
        }

        // Listen for scene loaded event
        scene.addEventListener('loaded', function () {
            updateBackgroundColorPicker();
        });

        // Initialize scene
        if (scene.hasLoaded) {
            updateBackgroundColorPicker();
        } else {
            scene.addEventListener('loaded', function () {
                updateBackgroundColorPicker();
            });
        }

        // Initialize color pickers
        initBackgroundColorPicker();

        // Handle view changes
        document.getElementById('view-selector').addEventListener('change', function (e) {
            const view = e.target.value;
            currentView = view;

            // Update UI based on view
            document.getElementById('scene-container').style.display = view === 'scene' ? 'block' : 'none';
            document.getElementById('code-container').style.display = view === 'code' ? 'block' : 'none';

            if (view === 'scene') {
                // Update background color picker when switching back to scene view
                updateBackgroundColorPicker();
            }
        });

        // Add event listeners for color inputs
        document.getElementById('background-color').addEventListener('input', function (e) {
            const newColor = e.target.value;
            updateSceneBackground(newColor);
            document.getElementById('background-color-hex').value = newColor;

            // Update fog color if environment preset is 'none'
            const environmentPreset = document.getElementById('environment-preset').value;
            if (environmentPreset === 'none') {
                document.getElementById('fog-color').value = newColor;
                document.getElementById('fog-color-hex').value = newColor.toUpperCase();
            }
        });

        document.getElementById('background-color-hex').addEventListener('input', function (e) {
            const color = e.target.value;
            if (color.match(/^#[0-9A-Fa-f]{6}$/)) {
                document.getElementById('background-color').value = color;
                updateSceneBackground(color);

                // Update fog color if environment preset is 'none'
                const environmentPreset = document.getElementById('environment-preset').value;
                if (environmentPreset === 'none') {
                    document.getElementById('fog-color').value = color;
                    document.getElementById('fog-color-hex').value = color.toUpperCase();
                }
            }
        });

        // Function to toggle the fog controls visibility
        function toggleFogControls() {
            const content = document.getElementById('fog-collapse-content');
            const icon = document.getElementById('fog-collapse-icon');

            // Check if the content is currently visible
            const isVisible = content.style.maxHeight !== '0px';

            if (isVisible) {
                // Hide the content
                content.style.maxHeight = '0px';
                icon.style.transform = 'rotate(0deg)'; // Down arrow when collapsed
            } else {
                // Show the content
                content.style.maxHeight = '500px';
                icon.style.transform = 'rotate(180deg)'; // Up arrow when expanded
            }
        }

        // Function to get all assets marked as skyboxes
        function getSkyboxAssets() {
            const skyboxAssets = [];
            // Look for assets with data-skybox attribute
            const skyboxElements = document.querySelectorAll('a-assets [data-skybox="true"]');

            skyboxElements.forEach(asset => {
                const assetId = asset.id;
                const isVideo = asset.tagName.toLowerCase() === 'video';

                // Find the container to get the file name
                const container = document.querySelector(`.asset-container[data-asset-id="${assetId}"]`);
                const fileNameElement = container ? container.querySelector('span') : null;
                const fileName = fileNameElement ? fileNameElement.textContent.trim().replace(' - ', '') : assetId;

                skyboxAssets.push({
                    id: assetId,
                    element: asset,
                    type: isVideo ? 'video' : 'image',
                    fileName: fileName,
                    src: asset.src
                });
            });

            return skyboxAssets;
        }
    </script>
</body>

</html>