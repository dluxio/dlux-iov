import methodsCommon from './methods-common.js';
import { markRaw } from '/js/vue.esm-browser.js';
import { createMentionSuggestion } from '/js/services/mention-suggestion.js';
import URLProcessor from '/js/utils/url-processor.js';
import EventManager from '/js/services/event-manager.js';
import { permissionService } from '/js/services/PermissionService.js';
import { authStateManager as authStateManagerService } from '/js/services/auth-state-manager.js';
import { documentStorageService } from '/js/services/document-storage-service.js';
import { cacheService } from '/js/services/cache-service.js';
import { documentService } from '/js/services/document-service.js';
import { collaborationService } from '/js/services/collaboration-service.js';
import { hasAllAuthFields, areAuthHeadersExpired, getRequiredAuthFields } from '/js/utils/auth-helpers.js';
import { apiAuthErrorHandler } from '/js/services/api-auth-error-handler.js';
import { ydocService } from '/js/services/ydoc-service.js';

// Debug flag to control logging - set to true to enable verbose logging
const DEBUG = false;

// Valid permission levels constant
const VALID_PERMISSION_LEVELS = ['readonly', 'editable', 'postable', 'owner', 'no-access'];

/**
 * ‚ö° AUTH STATE MANAGER FEATURE FLAG
 * 
 * Control the rollout of the new centralized AuthStateManager service.
 * 
 * Usage:
 * - window.USE_AUTH_STATE_MANAGER = true   // Enable new auth system
 * - window.USE_AUTH_STATE_MANAGER = false  // Force legacy auth system
 * - (not set)                              // Defaults to enabled
 * 
 * The AuthStateManager provides:
 * - Centralized authentication state management
 * - Consistent document access control
 * - Event-driven auth flow handling
 * - Decoupled from parent component dependencies
 * 
 * Rollback: Set to false if issues arise with the new auth system
 */

/**
 * ‚ö†Ô∏è CRITICAL: TipTap Editor Modular Architecture - Following Official Best Practices
 * Version: 2025.01.21.1 - Fixed fragment initialization
 * 
 * üìã TIPTAP v3 COMPLIANCE STATUS:
 * ‚úÖ Using 'field' parameter instead of deprecated 'fragment' in Collaboration extension
 * ‚úÖ UndoRedo disabled in StarterKit when using Collaboration (StarterKit.configure({ undoRedo: false }))
 * ‚úÖ StarterKit v3 includes UndoRedo by default from @tiptap/extensions - must be disabled
 * ‚úÖ Pre-creating Y.js body fragment to prevent "mismatched transaction" errors
 * ‚úÖ All imports using proper @tiptap/* naming convention
 * ‚úÖ @tiptap/y-tiptap@beta is used internally by Collaboration extension for Y.js synchronization
 * ‚ùå REMOVED: Undo/Redo functionality - disabled via StarterKit.configure({ undoRedo: false })
 *    When using Collaboration extension, UndoRedo must be disabled to prevent conflicts
 *    Collaborative undo/redo requires Pro extension @tiptap-pro/extension-undo-redo
 * 
 * ‚úÖ Y.js COMPLIANCE: All direct share access has been removed
 *    Previously had ~21 instances of ydoc.share.get('title') and ydoc.share.get('body')
 *    Now using ContentStateManager for all content checks
 *    TipTap Collaboration extension handles all Y.js synchronization
 *    Content checks are done through editor.getText() after editors are created
 *    Added ContentStateManager class to track content state without Y.js access
 * 
 * üö® COMPREHENSIVE COMPLIANCE ENFORCEMENT - COVERS ALL VIOLATION PATTERNS:
 * 
 * ===== CONTENT MANIPULATION VIOLATIONS =====
 * ‚ùå NEVER MANUALLY SET CONTENT: No setContent(), setHTML(), or insertContent()
 * ‚ùå NEVER SYNC CONTENT IN onUpdate: No editor.getText() or getHTML() in onUpdate
 * ‚ùå NEVER MANIPULATE Y.js XML: No getXmlFragment() manipulation 
 * ‚ùå NEVER ADD Y.js OBSERVERS: No ydoc.on() for content fragments
 * ‚ùå NEVER ACCESS Y.js FRAGMENTS: No ydoc.get('title', Y.XmlFragment) direct access
 * ‚ùå NEVER USE setText() ON FRAGMENTS: No titleFragment.insert() or delete()
 * ‚ùå NEVER CONVERT FRAGMENTS TO STRING: No fragment.toString() for content display
 * 
 * ===== EDITOR LIFECYCLE VIOLATIONS =====
 * ‚ùå NEVER REUSE EDITORS: No changing Y.js document without destroying editors first
 * ‚ùå NEVER LAZY Y.js CREATION: No creating editors before Y.js document exists
 * ‚ùå NEVER DYNAMIC EXTENSIONS: No adding/removing extensions after editor creation
 * ‚ùå NEVER DESTROY FOR CONTENT: No destroying editors just to update content
 * ‚ùå NEVER NULL PROVIDER WITH CURSOR: CollaborationCaret requires valid WebSocket provider
 * 
 * ===== CONTENT SYNC VIOLATIONS =====
 * ‚ùå NEVER BIDIRECTIONAL MANUAL SYNC: TipTap ‚Üî Y.js is automatic via Collaboration extension
 * ‚ùå NEVER CONTENT STATE TRACKING: No this.content.title = editor.getText() patterns
 * ‚ùå NEVER EMIT CONTENT IN EVENTS: No emitting editor content to parent components  
 * ‚ùå NEVER ACCESS CONTENT IN COMPUTED: No content.title/body in computed properties
 * ‚ùå NEVER TEMPLATE CONTENT BINDING: No v-model or direct content access in templates
 * 
 * ===== PERSISTENCE VIOLATIONS =====
 * ‚ùå NEVER STORE CONTENT SEPARATELY: Y.js IS the single source of truth for content
 * ‚ùå NEVER DUPLICATE IN LOCAL STATE: No copying Y.js content to Vue reactive state
 * ‚ùå NEVER MANUAL SAVE/LOAD: No extracting/injecting content during file operations
 * ‚ùå NEVER CONTENT IN FILE OBJECTS: Store metadata only, not title/body content
 * ‚ùå NEVER setContent() ON LOAD: Existing documents load automatically via Y.js sync
 * 
 * ===== METADATA vs CONTENT VIOLATIONS =====
 * ‚ùå NEVER CONFUSE DOCUMENT NAME vs TITLE: config.documentName ‚â† title XmlFragment
 * ‚ùå NEVER EXTRACT NAME FROM TITLE: Document name comes from config, not content
 * ‚ùå NEVER STORE CONTENT AS METADATA: Only store non-content data in Y.js maps
 * ‚ùå NEVER ACCESS FRAGMENTS FOR METADATA: Use getMap('config') for document properties
 * 
 * ===== INITIALIZATION VIOLATIONS =====
 * ‚ùå NEVER CREATE EDITORS WITHOUT Y.js: Always create Y.js document first  
 * ‚ùå NEVER SETUP CONTENT BEFORE SYNC: Wait for onSynced before any content operations
 * ‚ùå NEVER INITIALIZE WITH setContent(): Let Y.js populate content automatically
 * ‚ùå NEVER RACE CONDITIONS: Use initialization flags to prevent premature operations
 * 
 * ‚úÖ ONLY ALLOWED PATTERNS:
 * ‚úÖ Use onUpdate for flags: hasUnsavedChanges, debouncedCreateIndexedDBForTempDocument, UI states
 * ‚úÖ Use editor.getText() ONLY in export/display methods (getMarkdownContent, etc.)
 * ‚úÖ Use Y.js ONLY for metadata storage (config, tags, customJson, documentName)
 * ‚úÖ Let TipTap Collaboration extension handle ALL content sync automatically
 * ‚úÖ Use computed properties for template display (not reactive content sync)
 * ‚úÖ Create Y.js documents immediately with temp strategy (no lazy creation)
 * ‚úÖ Destroy and recreate editors for every file operation
 * ‚úÖ Use onSynced callbacks for IndexedDB and WebSocket initialization
 * ‚úÖ Two-tier system: Tier 1 (no cursors) vs Tier 2 (with cursors)
 * ‚úÖ Store document name in config.documentName, never extract from title content
 * ‚úÖ REACTIVE PATTERNS ONLY: Use onSynced, onUpdate, event callbacks - NEVER setTimeout for async operations
 * 
 * üîç COMMON VIOLATION DETECTION PATTERNS:
 * - Any line with: setContent(), setHTML(), insertContent()
 * - Any line with: editor.getText() or getHTML() assignment (=)
 * - Any line with: ydoc.get('title') or ydoc.get('body') 
 * - Any line with: getXmlFragment(), fragment.toString()
 * - Any line with: content.title = or content.body =
 * - Any line with: onUpdate containing content sync
 * - Any template with: content.title or content.body direct access
 * - Any computed with: content.title or content.body access
 * - Any file operation with: manual content extraction/injection
 * 
 * This file implements the corrected modular architecture that strictly follows TipTap.dev best practices:
 * - Proper onSynced callbacks for providers
 * - NO manual content setting for existing documents  
 * - NO direct Y.js XML manipulation
 * - TipTap Collaboration extension handles all Y.js ‚Üî TipTap sync automatically
 * - Use editor events only, not Y.js events
 * 
 * Architecture: 7 Specialized Managers + Main Component
 * 
 * üåê API ENDPOINTS (Hocuspocus + Custom REST):
 * 
 * Base URL: https://data.dlux.io/api
 * WebSocket: wss://data.dlux.io/collaboration/{owner}/{permlink}
 * 
 * Document Management:
 * - GET /collaboration/documents - List user's collaborative documents
 * - POST /collaboration/documents - Create new collaborative document
 * - DELETE /collaboration/documents/{owner}/{permlink} - Delete document
 * - GET /collaboration/info/{owner}/{permlink} - Get document metadata
 * - POST /collaboration/info/{owner}/{permlink} - Update document metadata
 * 
 * Permissions Management:
 * - GET /collaboration/permissions/{owner}/{permlink} - List permissions
 * - POST /collaboration/permissions/{owner}/{permlink} - Grant permission
 * - DELETE /collaboration/permissions/{owner}/{permlink}/{account} - Revoke permission
 * - GET /collaboration/permissions-detailed/{owner}/{permlink} - Get detailed permissions
 * 
 * Activity & Statistics:
 * - GET /collaboration/activity/{owner}/{permlink} - Get document activity log
 * - GET /collaboration/stats/{owner}/{permlink} - Get document statistics
 * - POST /collaboration/cleanup/manual/{owner}/{permlink} - Manual cleanup (owner only)
 * 
 * Authentication:
 * All requests require DLUX/Hive blockchain authentication headers:
 * - x-account: DLUX username
 * - x-challenge: Unix timestamp (23hr validity)
 * - x-pubkey: Hive public key
 * - x-signature: Signed challenge
 * 
 * Provider: Hocuspocus server (self-hosted) - NOT TipTap Cloud
 * 1. DocumentManager - High-level orchestration
 * 2. TierDecisionManager - Immutable tier logic  
 * 3. YjsDocumentManager - Y.js lifecycle
 * 4. EditorFactory - Tier-specific editor creation
 * 5. PersistenceManager - IndexedDB + WebSocket coordination
 * 6. LifecycleManager - Proper TipTap cleanup patterns
 * 7. SyncManager - Content synchronization (TipTap ‚Üî Vue only)
 * 
 * @see documentation/TIPTAP_OFFLINE_FIRST_BEST_PRACTICES.md
 */

/**
 * ===== EVENT SYSTEM DOCUMENTATION =====
 * 
 * This component uses a comprehensive event system for communication between
 * different parts of the application. Events are categorized by their purpose
 * and origin.
 * 
 * @fires tiptap-editor-ready - Editor initialization complete
 * @fires tiptap-editor-destroyed - Editor cleanup complete
 * @fires content-changed - Document content has changed
 * @fires content-available - Content is available for display
 * @fires request-auth-headers - Request authentication headers
 * @fires closeRemixApp - Close remix application
 * 
 * @listens loginModalClosed - Auth modal has been closed
 * @listens websocket-auth-error - WebSocket authentication failed
 * @listens synced - Y.js provider synchronization complete
 * @listens status - WebSocket connection status changed
 * @listens connection-error - WebSocket connection error
 * @listens update - Y.js document updated
 * @listens destroy - Provider being destroyed
 * 
 * === CUSTOM WINDOW EVENTS ===
 * 
 * tiptap-editor-ready
 * - Dispatched when the TipTap editor is fully initialized and ready
 * - No event data
 * - Used by: External integrations waiting for editor availability
 * 
 * tiptap-editor-destroyed  
 * - Dispatched when the TipTap editor has been completely destroyed
 * - No event data
 * - Used by: Cleanup operations and resource management
 * 
 * loginModalClosed
 * - Listened for login modal closure to retry authentication
 * - Event data: { selectedUser?: string }
 * - Used by: Auth retry mechanism after user interaction
 * 
 * closeRemixApp
 * - Dispatched to signal remix app should close
 * - No event data
 * - Used by: Iframe integration for app lifecycle
 * 
 * === EDITOR EVENT BUS EVENTS ===
 * 
 * content-changed
 * - Dispatched via window.editorEventBus when content changes
 * - Event data: { 
 *     hasTitle: boolean,
 *     hasBody: boolean,
 *     titleLength: number,
 *     bodyLength: number,
 *     timestamp: number
 *   }
 * - Used by: External components monitoring content state
 * 
 * content-available
 * - Dispatched when content becomes available after sync
 * - Event data: { source: string }
 * - Used by: Components waiting for content readiness
 * 
 * request-auth-headers
 * - Dispatched to request current authentication headers
 * - No event data
 * - Response expected via auth state update
 * 
 * === PROVIDER EVENTS ===
 * 
 * synced
 * - Emitted by Y.js providers when synchronization completes
 * - No event data
 * - Used by: Document loading, persistence setup
 * 
 * status
 * - Emitted by WebSocket provider for connection status
 * - Event data: { status: 'connecting'|'connected'|'disconnected' }
 * - Used by: Connection status UI updates
 * 
 * connection-error
 * - Emitted by WebSocket provider on connection failures
 * - Event data: { error: Error }
 * - Used by: Error handling and fallback to offline mode
 * 
 * destroy
 * - Emitted by providers before destruction
 * - No event data
 * - Used by: Cleanup operations
 * 
 * === AUTH STATE MANAGER EVENTS ===
 * 
 * websocket-auth-error
 * - Emitted when WebSocket authentication fails
 * - Event data: { error: string, retryable: boolean }
 * - Used by: Auth retry mechanisms
 * 
 * === Y.JS EVENTS ===
 * 
 * update
 * - Emitted by Y.js document on any change
 * - Event data: Y.js update event
 * - Used by: Change tracking, auto-save triggers
 * 
 * === DOM EVENTS ===
 * 
 * mouseenter
 * - Listened on editor DOM for lazy loading features
 * - Standard DOM MouseEvent
 * - Used by: Floating menu initialization
 * 
 * transitionend
 * - Listened for CSS transition completion
 * - Standard DOM TransitionEvent
 * - Used by: Save message fade animation
 * 
 * message
 * - Window postMessage events for iframe communication
 * - Event data: { type: string, data: any }
 * - Used by: Cross-frame communication
 */

// ==================== MANAGER CLASSES ====================

/**
 * 1. TIER DECISION MANAGER
 * Immutable tier decisions based on document type
 */
class TierDecisionManager {
    static TierType = {
        LOCAL: 'local',     // Tier 1: Offline-first with Y.js persistence
        CLOUD: 'cloud'      // Tier 2: Full collaborative with cursors
    };

    determineTier(file, component) {
        
        console.log('üîê CACHE-CREATE: determineTier called', {
            fileType: file?.type,
            hasOwner: !!file?.owner,
            hasPermlink: !!file?.permlink,
            username: component?.username,
            isAuthenticated: component?.isAuthenticated
        });

        // Tier 2 (Cloud) for true collaborative documents only
        if (file?.type === 'collaborative' && file?.owner && file?.permlink) {
            console.log('üî• CACHE-DEBUG: Selected CLOUD tier for collaborative document', {
                owner: file.owner,
                permlink: file.permlink,
                username: component?.username,
                isAuthenticated: component?.isAuthenticated,
                hasAuthHeaders: !!component?.authHeaders
            });
            return TierDecisionManager.TierType.CLOUD;
        }

        // Check URL parameters for collaborative documents (collab_owner/collab_permlink)
        const urlParams = new URLSearchParams(window.location.search);
        const collabOwner = urlParams.get('collab_owner');
        const collabPermlink = urlParams.get('collab_permlink');
        if (collabOwner && collabPermlink) {
            console.log('üî• CACHE-DEBUG: Selected CLOUD tier from URL params', {
                owner: collabOwner,
                permlink: collabPermlink,
                username: component?.username,
                isAuthenticated: component?.isAuthenticated,
                hasAuthHeaders: !!component?.authHeaders
            });
            return TierDecisionManager.TierType.CLOUD;
        }

        // All other cases: local documents, temp documents, and local_owner URLs
        console.log('üî• CACHE-DEBUG: Selected LOCAL tier');
        return TierDecisionManager.TierType.LOCAL;
    }

    shouldCreateTempDocument(file) {
        // Create temp document when no file provided or for new documents
        return !file || !file.id;
    }
}

/**
 * 2. Y.JS DOCUMENT MANAGER  
 * Handle Y.js document lifecycle following TipTap official patterns
 * 
 * üö® CRITICAL Y.JS VIOLATIONS TO PREVENT:
 * ‚ùå NEVER: ydoc.get('title', Y.XmlFragment) - direct fragment access
 * ‚ùå NEVER: ydoc.get('body', Y.XmlFragment) - direct fragment access  
 * ‚ùå NEVER: titleFragment.toString() - converting fragments to strings
 * ‚ùå NEVER: titleFragment.insert() or delete() - direct fragment manipulation
 * ‚ùå NEVER: ydoc.on('update') for content fragments - use editor events only
 * ‚ùå NEVER: fragment.observe() - TipTap manages fragment observation
 * ‚ùå NEVER: Manual Y.js content sync - TipTap Collaboration handles automatically
 * 
 * ‚úÖ ONLY ALLOWED Y.js PATTERNS:
 * ‚úÖ ydoc.getMap('config') - for document-level settings
 * ‚úÖ ydoc.getMap('metadata') - for ALL content metadata (tags, customJson, beneficiaries, etc.)
 * ‚úÖ config.set('documentName') - for document properties
 * ‚úÖ metadata.set('tags', [...]) - for tag management
 * ‚úÖ metadata.set('customJson', {...}) - for custom metadata
 * ‚úÖ config.observe() - for metadata change detection
 * ‚úÖ Y.js document creation and lifecycle management
 * ‚úÖ IndexedDB and WebSocket provider setup
 */
class YjsDocumentManager {
    constructor(component) {
        this.component = component;
    }

    async createDocument(file, tier) {
        // ‚úÖ FIX: Use window.Y directly as per TipTap v3 bundle setup
        const Y = window.Y;
        if (!Y) {
            throw new Error('Y.js not available - ensure collaboration bundle is loaded');
        }

        // ‚úÖ GOLDEN RULE #2: Use YDocService for Y.js operations
        const docId = file?.id || `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        // ‚úÖ IMPORTANT: Only initialize schema for NEW documents
        // For existing documents, IndexedDB will restore the content
        const isNewDocument = tier === TierDecisionManager.TierType.LOCAL && (!file || !file.id);

        let ydoc;
        if (isNewDocument) {
            // Create new document through YDocService
            ydoc = ydocService.createDocument(docId);
            
            // Additional initialization for temp documents
            if (this.component) {
                this.component.isTemporaryDocument = true;
                this.component.tempDocumentId = docId;
            }
            
            // Set component-specific metadata through YDocService
            if (this.component?.username) {
                ydocService.updateConfig('owner', this.component.username);
                ydocService.updateConfig('documentType', 'collaborative');
            }
        } else {
            // For existing documents, create Y.Doc directly (will be loaded from IndexedDB)
            ydoc = new Y.Doc();
            // Load it into YDocService for centralized management
            ydocService.loadDocument(ydoc, docId);
        }
        
        return ydoc;
    }

    async setupIndexedDBWithOnSynced(ydoc, documentId, isCollaborative = false) {
        // ‚úÖ CORRECT: Use smart access pattern like editor components  
        const tiptapBundle = window.TiptapCollaboration?.Editor
            ? window.TiptapCollaboration
            : window.TiptapCollaboration?.default;
        const IndexeddbPersistence = tiptapBundle?.IndexeddbPersistence;

        if (!IndexeddbPersistence) {
            console.warn('‚ö†Ô∏è IndexedDB persistence not available');
            return null;
        }

        // ‚úÖ CRITICAL FIX: User-isolated IndexedDB keys for collaborative documents
        // This prevents cross-user contamination when multiple users access the same document
        let indexedDBKey = documentId;
        if (isCollaborative) {
            // ‚úÖ SECURITY: Use user isolation for collaborative documents
            // All documents require authenticated user
            const userIdentifier = this.component?.username;
            
            // ‚úÖ VALIDATION: Ensure username is available to prevent phantom databases
            if (!userIdentifier) {
                console.error('‚ùå CACHE-CREATE: Cannot create IndexedDB - username not available!', {
                    documentId,
                    componentExists: !!this.component,
                    attemptedUsername: userIdentifier,
                    willCreatePhantomDB: true
                });
                // CRITICAL: Don't create phantom database - return null
                return null;
            }
            
            indexedDBKey = `${userIdentifier}__${documentId}`;
            
            console.log('üî¥ CACHE-TEST: Creating IndexedDB with key', {
                indexedDBKey,
                username: userIdentifier,
                documentId,
                isCollaborative
            });
            console.log('üîê CACHE-CREATE: Creating IndexedDB with key', {
                indexedDBKey,
                username: userIdentifier,
                documentId,
                isCollaborative
            });
        }

        // Check if Y.js document has content
        const hasContent = ydoc.share.size > 0 || ydoc.store.clients.size > 0;
        console.log('üî¥ CACHE-TEST: Y.js document state before persistence', {
            indexedDBKey,
            hasContent,
            shareSize: ydoc.share.size,
            clientsSize: ydoc.store.clients.size
        });
        
        // üîµ CACHE-PERSIST: Log initial document state
        console.log('üîµ CACHE-PERSIST: Creating IndexeddbPersistence', {
            indexedDBKey,
            documentIsEmpty: !hasContent,
            shareSize: ydoc.share.size,
            clientsSize: ydoc.store.clients.size,
            timestamp: new Date().toISOString()
        });

        let persistence;
        try {
            persistence = new IndexeddbPersistence(indexedDBKey, ydoc);
            console.log('üî¥ CACHE-TEST: IndexeddbPersistence constructor called', {
                indexedDBKey,
                persistenceCreated: !!persistence
            });
        } catch (error) {
            console.error('üî¥ CACHE-TEST: Failed to create IndexeddbPersistence', {
                indexedDBKey,
                error: error.message
            });
            return null;
        }
        
        console.log('üîê CACHE-CREATE: IndexedDB persistence created successfully', {
            indexedDBKey,
            isCollaborative,
            documentId,
            username: this.component?.username
        });

        // ‚úÖ TIPTAP BEST PRACTICE: Use onSynced callback with content verification
        return new Promise((resolve) => {
            // üîµ CACHE-PERSIST: Track Y.js updates to see when content arrives
            const updateHandler = (update, origin) => {
                console.log('üîµ CACHE-PERSIST: Y.js document updated', {
                    indexedDBKey,
                    updateSize: update.length,
                    origin,
                    shareSize: ydoc.share.size,
                    hasContent: ydoc.share.size > 0,
                    timestamp: new Date().toISOString()
                });
            };
            ydoc.on('update', updateHandler);
            
            persistence.once('synced', () => {
                console.log('üî¥ CACHE-TEST: IndexedDB persistence synced!', {
                    indexedDBKey,
                    documentId
                });
                
                // üîµ CACHE-PERSIST: Log when persistence is ready
                console.log('üîµ CACHE-PERSIST: IndexeddbPersistence synced', {
                    indexedDBKey,
                    documentHasContent: ydoc.share.size > 0,
                    shareSize: ydoc.share.size,
                    timestamp: new Date().toISOString()
                });
                
                // Check if database actually exists now
                if (window.indexedDB && window.indexedDB.databases) {
                    window.indexedDB.databases().then(dbs => {
                        const exists = dbs.some(db => db.name === indexedDBKey);
                        console.log('üîµ CACHE-PERSIST: Database existence check after sync', {
                            indexedDBKey,
                            databaseExists: exists,
                            allDatabases: dbs.map(db => db.name),
                            timestamp: new Date().toISOString()
                        });
                    });
                }

                // ‚úÖ TIPTAP BEST PRACTICE: Only check metadata, not content fragments
                const yjsDocumentName = ydocService.getConfig('documentName');
                const hasDocumentMetadata = !!yjsDocumentName;

                // TipTap's Collaboration extension will handle content synchronization
                // Content checks should be done through editor.getText() after editors are created

                // ‚úÖ STABILIZATION: Track Y.js sync completion for command timing
                if (this.component) {
                    this.component.lastContentChange = Date.now();
                }

                // ‚úÖ DEBUG: Check Y.js document state after sync

                // ‚úÖ FIX: Update currentFile object with correct document name from Y.js
                if (yjsDocumentName && this.component?.currentFile) {
                    const isUsernameFallback = this.component.currentFile.name && this.component.currentFile.name.includes('/');
                    const isLocalDocument = this.component.currentFile.type === 'local' || this.component.currentFile.id?.startsWith('local_');

                    // Update for local documents OR if current name is fallback
                    if (isLocalDocument || (isUsernameFallback && yjsDocumentName !== this.component.currentFile.name)) {

                        this.component.currentFile.name = yjsDocumentName;
                        this.component.currentFile.documentName = yjsDocumentName;
                        this.component.currentFile.title = yjsDocumentName;

                        // ‚úÖ REACTIVE: Update reactive document name for Vue
                        if (this.component && typeof this.component.updateReactiveDocumentName === 'function') {
                            this.component.updateReactiveDocumentName(yjsDocumentName);
                        }
                    }
                }

                // ‚úÖ FIX: Update local timestamp to match current load time
                // This ensures the local cache timestamp reflects that we now have the current version
                if (this.component?.currentFile) {
                    const now = new Date().toISOString();
                    this.component.currentFile.lastModified = now;
                    this.component.currentFile.modified = now;

                    // Update localStorage metadata to reflect current sync
                    if (this.component.currentFile.id && this.component.documentManager?.persistenceManager?.updateLocalFileTimestamp) {
                        this.component.documentManager.persistenceManager.updateLocalFileTimestamp(this.component.currentFile.id, now);
                    }
                }

                // ‚úÖ CRITICAL FIX: Signal that IndexedDB content is ready for editor creation
                // This enables proper content loading for read-only users without WebSocket dependency
                if (this.component) {
                    this.component.indexedDBContentReady = true;
                    this.component.yjsContentAvailable = hasDocumentMetadata; // Use metadata as indicator
                }

                // ‚úÖ SEQUENCING FIX: Use $nextTick to ensure Vue reactivity is updated
                this.component.$nextTick(() => {
                });

                // ‚úÖ CORRECT: TipTap will automatically load content when editors are created with this Y.js document
                // Trust TipTap automatic loading - no manual intervention needed

                resolve(persistence);
            });
        });
    }

    async createTempDocument() {
        // ‚úÖ FIX: Use window.Y directly
        const Y = window.Y;
        if (!Y) {
            throw new Error('Y.js not available');
        }

        // ‚úÖ GOLDEN RULE #2: Use YDocService for Y.js operations
        const docId = `temp_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;
        
        // Use YDocService to create the document
        const ydoc = ydocService.createDocument(docId);
        
        // ‚úÖ CRITICAL: Set a unique GUID for the document
        // This helps Y.js properly initialize the document
        ydoc.guid = docId;

        return ydoc;
    }

}

/**
 * 3. PERSISTENCE MANAGER
 * Handle IndexedDB + WebSocket with proper onSynced patterns
 */
class PersistenceManager {
    constructor(component) {
        this.component = component;
    }

    async setupCloudPersistence(yjsDoc, file) {
        // ‚úÖ TIPTAP OFFLINE-FIRST: Load IndexedDB content immediately for instant editing

        // ‚úÖ CRITICAL FIX: Pass isCollaborative=true to enable user isolation
        const documentId = file.id || `${file.owner}/${file.permlink}`;

        // ‚úÖ VALIDATION: Check username availability before creating IndexedDB
        const username = this.component?.username;
        if (!username) {
            console.warn('‚ö†Ô∏è CACHE-CREATE: Username not available when setting up cloud persistence!', {
                documentId,
                fileOwner: file.owner,
                filePermlink: file.permlink,
                componentExists: !!this.component,
                willCreatePhantomDB: true
            });
        }

        // ‚úÖ DEBUG: Log document ID and user for read-only debugging
        const expectedIndexedDBKey = `${username || 'unknown'}__${documentId}`;
        console.log('üî¥ CACHE-TEST: setupCloudPersistence attempting to create cache', {
            expectedIndexedDBKey,
            username,
            documentId,
            hasUsername: !!username
        });
        console.log('üîê CACHE-CREATE: setupCloudPersistence attempting to create IndexedDB', {
            expectedIndexedDBKey,
            username,
            documentId,
            hasUsername: !!username
        });

        const indexedDB = await this.component?.documentManager?.yjsManager?.setupIndexedDBWithOnSynced(yjsDoc, documentId, true);
        
        console.log('üî¥ CACHE-TEST: setupIndexedDBWithOnSynced returned', {
            indexedDBReturned: !!indexedDB,
            expectedKey: expectedIndexedDBKey
        });

        // ‚úÖ VALIDATION: Check if IndexedDB was created successfully
        if (!indexedDB && username) {
            console.error('üî¥ CACHE-TEST: Failed to create IndexedDB persistence!', {
                username,
                documentId,
                reason: 'setupIndexedDBWithOnSynced returned null'
            });
        }

        // ‚úÖ CORRECT: TipTap handles collaborative content loading automatically
        // Trust TipTap automatic loading after IndexedDB + WebSocket sync

        // ‚úÖ OFFLINE-FIRST: Don't wait for WebSocket - connect in background

        const webSocketPromise = this.setupWebSocketWithOnSynced(yjsDoc, file);

        // Start WebSocket connection in background
        const persistenceManager = this;
        webSocketPromise.then(webSocket => {
            if (webSocket && persistenceManager.component) {
                persistenceManager.component.provider = webSocket;

                // ‚úÖ DUPLICATE PREVENTION: onConnect callback handles upgrade, no need for duplicate here
            } else {
                console.warn('‚ö†Ô∏è WebSocket provider was null - likely auth issue or connection blocked');
            }
        }).catch(error => {
            console.warn('‚ö†Ô∏è Background cloud connection failed:', error.message);
            if (persistenceManager.component) {
                persistenceManager.component.connectionStatus = 'offline';
            }
        });

        // Return IndexedDB immediately, WebSocket connects in background
        return { indexedDB, webSocket: null };
    }

    async setupWebSocketWithOnSynced(yjsDoc, file) {
        console.log('üî• CACHE-DEBUG: setupWebSocketWithOnSynced called', {
            isAuthenticated: this.component?.isAuthenticated,
            hasAuthHeaders: !!this.component?.authHeaders,
            username: this.component?.username,
            document: `${file.owner}/${file.permlink}`,
            caller: new Error().stack.split('\n')[2]
        });
        
        // ‚úÖ AUTHENTICATION CHECK: All users require authentication for WebSocket connections
        if (!this.component?.isAuthenticated) {
            console.log('üî• CACHE-DEBUG: WebSocket blocked - no auth', {
                isAuthenticated: this.component?.isAuthenticated,
                isAuthExpired: this.component?.isAuthExpired,
                isReadOnlyMode: this.component?.isReadOnlyMode,
                permissionLevel: file.permissionLevel,
                document: `${file.owner}/${file.permlink}`
            });
            if (this.component) {
                this.component.connectionStatus = 'auth-required';
                this.component.connectionMessage = 'Authentication required for collaborative documents';
            }
            return null;
        }

        // ‚úÖ PRE-FLIGHT PERMISSION CHECK: Verify user has access before attempting WebSocket connection
        const hasPermission = this.component?.checkDocumentPermissionsPreFlight?.(file) ?? false;
        if (!hasPermission) {
            console.warn('üöÄ PRE-FLIGHT: WebSocket connection blocked - user lacks permissions', {
                username: this.component?.username,
                document: `${file.owner}/${file.permlink}`,
                collaborativeDocsCount: this.component?.collaborativeDocs?.length || 0,
                isOwner: this.component?.username === file.owner
            });
            this.component.connectionStatus = 'permission-denied';
            this.component.connectionMessage = 'Access denied - switch to an account with permissions';

            // ‚úÖ GRACEFUL PERMISSION DENIAL: Trigger switch user modal instead of continuing with connection
            console.log('üöÄ PRE-FLIGHT: Triggering switch user modal due to permission mismatch');
            const authBridge = this.component.authBridge;
            if (authBridge) {
                const documentInfo = {
                    name: file.documentName || file.name || 'document',
                    owner: file.owner,
                    permlink: file.permlink,
                    type: 'collaborative'
                };
                authBridge.showAuthPrompt('switch_account', documentInfo);
            }
            return null;
        }

        // ‚úÖ AUTHENTICATED ACCESS: Proceed with WebSocket connection for authenticated users

        // ‚úÖ CONFLICT PREVENTION: Clean up any existing provider first
        if (this.component.provider) {
            console.warn('‚ö†Ô∏è Existing WebSocket provider detected - cleaning up before creating new one');
            try {
                if (this.component.provider.disconnect) {
                    this.component.provider.disconnect();
                }
                if (this.component.provider.destroy) {
                    this.component.provider.destroy();
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Error cleaning up existing provider:', error.message);
            }
            this.component.provider = null;
        }

        // ‚úÖ TIPTAP BEST PRACTICE: Use HocuspocusProvider with official onSynced pattern
        // ‚úÖ CORRECT: Use smart access pattern like other methods
        const tiptapBundle = window.TiptapCollaboration?.Editor
            ? window.TiptapCollaboration
            : window.TiptapCollaboration?.default;
        const HocuspocusProvider = tiptapBundle?.HocuspocusProvider;
        const Y = window.Y;

        if (!HocuspocusProvider || !Y) {
            console.warn('‚ö†Ô∏è Required components not available in bundle');
            console.error('üîç WebSocket bundle access debug:', {
                windowTiptapCollaboration: !!window.TiptapCollaboration,
                hasEditor: !!window.TiptapCollaboration?.Editor,
                hasDefault: !!window.TiptapCollaboration?.default,
                bundleKeys: window.TiptapCollaboration ? Object.keys(window.TiptapCollaboration) : [],
                defaultKeys: window.TiptapCollaboration?.default ? Object.keys(window.TiptapCollaboration.default) : [],
                HocuspocusProvider: !!HocuspocusProvider,
                Y: !!Y
            });
            return null;
        }

        const baseUrl = 'wss://data.dlux.io/collaboration';
        const docPath = `${file.owner}/${file.permlink}`;
        const wsUrl = `${baseUrl}/${docPath}`;
        const persistenceManager = this;

        try {
            // ‚úÖ OFFLINE-FIRST: Allow IndexedDB to work without authentication
            // WebSocket connection is optional - only needed for real-time sync
            if (!this.component.isAuthenticated || !this.component.authHeaders) {
                console.log('üì± OFFLINE-FIRST: No auth headers available, deferring WebSocket connection', {
                    owner: file.owner,
                    permlink: file.permlink,
                    username: this.component.username,
                    isAuthenticated: this.component.isAuthenticated,
                    hasAuthHeaders: !!this.component.authHeaders
                });
                
                // Return null to indicate WebSocket not available
                // IndexedDB will still work for offline editing
                return null;
            }

            // Get auth headers (already validated by AuthStateManager)
            const validatedHeaders = this.component.authHeaders;

            // ‚úÖ AUTH HEADERS INVESTIGATION: Check for potential issues
            const initialValidatedHeaders = validatedHeaders;
            const challengeAge = this.component.authStateManager.getChallengeAge(initialValidatedHeaders);
            const isChallengeTooOldForWebSocket = challengeAge > (24 * 60 * 60); // 24 hours same as API

            // ‚úÖ WEBSOCKET CHALLENGE CHECK: WebSocket uses same 24-hour limit as API
            if (isChallengeTooOldForWebSocket) {
                console.warn('‚ö†Ô∏è CHALLENGE TOO OLD FOR WEBSOCKET:', {
                    challengeAge: challengeAge + 's',
                    limit: '86400s (24 hours)',
                    suggestion: 'Waiting for fresh auth headers before WebSocket connection'
                });

                // ‚úÖ CRITICAL FIX: Wait for fresh auth headers instead of proceeding

                // Use DLUXAuthBridge if available
                const authBridge = this.component.authBridgeInstance;
                if (authBridge) {
                    const documentInfo = {
                        name: file.documentName || file.name || 'document',
                        owner: file.owner,
                        permlink: file.permlink,
                        type: 'collaborative'
                    };
                    authBridge.showAuthPrompt('authenticate', documentInfo);
                } else {
                    // Fallback to legacy emit
                    // Use authBridge for authentication request
                    if (this.component.authBridgeInstance) {
                        this.component.authBridgeInstance.showAuthPrompt('authenticate', {
                            name: 'WebSocket Connection',
                            reason: 'Authentication required for real-time collaboration'
                        });
                    } else {
                        console.error('AuthBridge not available for WebSocket authentication');
                    }
                }

                // ‚úÖ SOLUTION: Return a promise that waits for fresh headers
                return new Promise((resolve, reject) => {
                    let authHeadersHandler = null;
                    let loginModalHandler = null;
                    let wsErrorHandler = null;

                    // Create cleanup function for all event listeners
                    const cleanup = () => {
                        if (authHeadersHandler) {
                            this.component.authStateManager.off('authHeadersChanged', authHeadersHandler);
                            authHeadersHandler = null;
                        }
                        if (loginModalHandler && this.component.eventManager) {
                            this.component.eventManager.removeDOMListener(window, 'loginModalClosed', loginModalHandler);
                            loginModalHandler = null;
                        }
                        if (wsErrorHandler) {
                            this.component.authStateManager.off('websocket-auth-error', wsErrorHandler);
                            wsErrorHandler = null;
                        }
                    };

                    // Set up event listener for fresh auth headers
                    authHeadersHandler = (event) => {
                        const newHeaders = event.detail?.headers;
                        if (newHeaders && this.component.authStateManager.getAuthChallenge(newHeaders)) {
                            const newChallengeAge = this.component.authStateManager.getChallengeAge(newHeaders);

                            // ‚úÖ WEBSOCKET FIX: Accept headers that are valid for WebSocket (< 24 hours)
                            if (newChallengeAge < (24 * 60 * 60)) { // Valid for WebSocket (< 24 hours)
                                cleanup(); // Clean up all listeners

                                // Restart the WebSocket setup with fresh headers
                                this.setupWebSocketWithOnSynced(yjsDoc, file).then(resolve).catch(reject);
                                return;
                            } else {
                                console.warn('‚ö†Ô∏è Received headers are still too old for WebSocket:', {
                                    challengeAge: newChallengeAge + 's',
                                    limit: '86400s (24 hours)',
                                    willContinueWaiting: true
                                });
                                // Continue waiting for better headers
                            }
                        }
                    };

                    // Listen for auth header changes
                    this.component.authStateManager.on('authHeadersChanged', authHeadersHandler);

                    // Handle auth modal close event
                    const handleAuthModalClose = () => {
                        cleanup();
                        console.warn('‚ö†Ô∏è Auth modal closed, proceeding with existing headers');
                        console.warn('üîÑ WebSocket may disconnect if headers are expired, but will reconnect with IndexedDB persistence');
                        resolve();
                    };

                    // Handle login modal close (dispatched from v3-user.js)
                    loginModalHandler = () => {
                        handleAuthModalClose();
                    };
                    
                    // Handle WebSocket auth error
                    wsErrorHandler = () => {
                        cleanup();
                        resolve();
                    };
                    
                    /**
                     * @listens loginModalClosed
                     * @description Listen for login modal closure to retry authentication
                     * Event dispatched by v3-user.js when login modal is closed
                     */
                    if (this.component.eventManager) {
                        this.component.eventManager.addDOMListener(window, 'loginModalClosed', loginModalHandler);
                    } else {
                        window.addEventListener('loginModalClosed', loginModalHandler);
                    }
                    
                    /**
                     * @listens websocket-auth-error
                     * @description Listen for WebSocket authentication failures
                     * @param {Object} event - Contains error details and retry information
                     */
                    if (this.component.authStateManager) {
                        this.component.authStateManager.on('websocket-auth-error', wsErrorHandler);
                    }
                });
            }

            // ‚úÖ PERMISSION DETECTION: Ensure we have a valid permission level
            const detectedPermissionLevel = file.permissionLevel || this.component.getUserPermissionLevel(file);
            const finalPermissionLevel = detectedPermissionLevel !== 'unknown' ? detectedPermissionLevel : this.component.getDefaultPermissionLevel();

            // ‚úÖ ENHANCED AUTH SYNCHRONIZATION: Ensure auth headers match current user before creating WebSocket
            const authAccount = this.component.authStateManager.getAuthAccount(validatedHeaders);
            const currentUser = this.component.username;
            const currentChallengeAge = this.component.authStateManager.getChallengeAge(validatedHeaders);

            const authIssues = {
                userMismatch: authAccount !== currentUser,
                staleChallenge: currentChallengeAge && currentChallengeAge > 82800, // 23 hours (match server validation)
                missingHeaders: !validatedHeaders ||
                    !this.component.authStateManager.hasAllAuthFields(validatedHeaders)
            };

            const hasAuthIssues = authIssues.userMismatch || authIssues.staleChallenge || authIssues.missingHeaders;

            if (hasAuthIssues) {
                console.warn('üîÑ AUTH VALIDATION: WebSocket auth headers have issues - returning null, reactive watcher will retry', {
                    authAccount,
                    currentUser,
                    challengeAge: currentChallengeAge ? `${currentChallengeAge}s` : 'unknown',
                    headers: this.component.authHeaders ? Object.keys(this.component.authHeaders) : [],
                    issues: authIssues,
                    reactiveRetry: true
                });

                // ‚úÖ REACTIVE APPROACH: Return immediately, let existing authHeaders watcher handle retry
                this.component.connectionStatus = 'auth-invalid';
                this.component.connectionMessage = 'Invalid auth headers - will retry when headers are refreshed';

                // Request fresh auth headers proactively (but don't wait)
                const authBridge = this.component.authBridgeInstance;
                if (authBridge) {
                    const documentInfo = {
                        name: file.documentName || file.name || 'document',
                        owner: file.owner,
                        permlink: file.permlink,
                        type: 'collaborative'
                    };
                    authBridge.showAuthPrompt('authenticate', documentInfo);
                } else {
                    // Use authBridge for authentication request
                    if (this.component.authBridgeInstance) {
                        this.component.authBridgeInstance.showAuthPrompt('authenticate', {
                            name: 'WebSocket Connection',
                            reason: 'Authentication required for real-time collaboration'
                        });
                    } else {
                        console.error('AuthBridge not available for WebSocket authentication');
                    }
                }

                // Return null immediately - the existing authHeaders watcher will retry when headers become valid
                return null;
            }

            // ‚úÖ COMPREHENSIVE TOKEN VALIDATION: Validate auth token structure before WebSocket connection
            const tokenValidation = this.validateWebSocketAuthToken(this.component.authHeaders, currentUser, finalPermissionLevel);
            if (!tokenValidation.isValid) {
                console.error('‚ùå WEBSOCKET TOKEN VALIDATION FAILED:', {
                    documentPath: docPath,
                    validationErrors: tokenValidation.errors,
                    authHeaders: this.component.authHeaders ? Object.keys(this.component.authHeaders) : [],
                    currentUser,
                    permissionLevel: finalPermissionLevel
                });

                this.component.connectionStatus = 'auth-invalid';
                this.component.connectionMessage = `Token validation failed: ${tokenValidation.errors.join(', ')}`;

                // Request fresh auth headers
                const authBridge = this.component.authBridgeInstance;
                if (authBridge) {
                    const documentInfo = {
                        name: file.documentName || file.name || 'document',
                        owner: file.owner,
                        permlink: file.permlink,
                        type: 'collaborative'
                    };
                    authBridge.showAuthPrompt('authenticate', documentInfo);
                } else {
                    // Use authBridge for authentication request
                    if (this.component.authBridgeInstance) {
                        this.component.authBridgeInstance.showAuthPrompt('authenticate', {
                            name: 'WebSocket Connection',
                            reason: 'Authentication required for real-time collaboration'
                        });
                    } else {
                        console.error('AuthBridge not available for WebSocket authentication');
                    }
                }
                return null;
            }

            // Create auth token - all users (readonly + editor) use full authentication
            const authTokenObject = {
                account: this.component.authStateManager.getAuthAccount(validatedHeaders),
                signature: this.component.authStateManager.getAuthSignature(validatedHeaders),
                challenge: this.component.authStateManager.getAuthChallenge(validatedHeaders),
                pubkey: this.component.authStateManager.getAuthPubkey(validatedHeaders),
                permission_level: finalPermissionLevel
            };
            const authToken = JSON.stringify(authTokenObject);

            // ‚úÖ ENHANCED DEBUG: Log auth token details at creation time
            console.log('üîê WEBSOCKET AUTH TOKEN CREATION:', {
                documentPath: docPath,
                timestamp: new Date().toISOString(),
                tokenObject: authTokenObject,
                tokenString: authToken,
                tokenLength: authToken.length,

                // Header validation
                headersValid: {
                    hasAccount: !!this.component.authStateManager.getAuthAccount(validatedHeaders),
                    hasSignature: !!this.component.authStateManager.getAuthSignature(validatedHeaders),
                    hasChallenge: !!this.component.authStateManager.getAuthChallenge(validatedHeaders),
                    hasPubkey: !!this.component.authStateManager.getAuthPubkey(validatedHeaders),
                    accountMatchesUser: this.component.authStateManager.getAuthAccount(validatedHeaders) === this.component.username,
                    challengeAge: this.component.authStateManager.getChallengeAge(validatedHeaders)
                },

                // Component state
                componentState: {
                    username: this.component.username,
                    isAuthenticated: this.component.isAuthenticated,
                    isAuthExpired: this.component.isAuthExpired
                }
            });

            // ‚úÖ DEBUG: Log WebSocket auth token details with header comparison

            // ‚úÖ TIPTAP COMPLIANCE: No artificial delays in WebSocket setup
            // HocuspocusProvider handles connection timing automatically

            // ‚úÖ DEBUG: Add Y.js update observer for read-only users
            let yjsUpdateObserver = null;
            if (this.component.isReadOnlyMode) {
                yjsUpdateObserver = (update, origin) => {

                    // Check if editors need to be notified
                    if (update.length > 0) {

                        // ‚úÖ REACTIVE PATTERN: Trust TipTap Collaboration to sync automatically
                        // The extension will trigger editor onUpdate events when content arrives

                        // Remove observer after significant update
                        yjsDoc.off('update', yjsUpdateObserver);
                    }
                };
                yjsDoc.on('update', yjsUpdateObserver);
            }

            // ‚úÖ SERVER INVESTIGATION LOGGING: Comprehensive auth analysis for server debugging
            const investigationChallengeAge = this.component.authStateManager.getChallengeAge(validatedHeaders);
            const serverInvestigation = {
                timestamp: new Date().toISOString(),
                connectionAttempt: {
                    documentPath: docPath,
                    websocketUrl: wsUrl,
                    currentUser: this.component.username,
                    isAuthenticated: this.component.isAuthenticated
                },
                authTokenAnalysis: {
                    tokenLength: authToken ? authToken.length : 0,
                    tokenPreview: authToken ? `${authToken.substring(0, 20)}...${authToken.substring(authToken.length - 10)}` : null,
                    hasAllRequiredHeaders: this.component.authStateManager.hasAllAuthFields(validatedHeaders),
                    headerDetails: {
                        account: this.component.authStateManager.getAuthAccount(validatedHeaders),
                        challenge: this.component.authStateManager.getAuthChallenge(validatedHeaders),
                        pubkeyPrefix: this.component.authStateManager.getAuthPubkey(validatedHeaders)?.substring(0, 12),
                        signaturePrefix: this.component.authStateManager.getAuthSignature(validatedHeaders)?.substring(0, 15)
                    }
                },
                tokenValidation: {
                    challengeTimestamp: this.component.authStateManager.getAuthChallenge(validatedHeaders),
                    challengeAge: investigationChallengeAge,
                    challengeAgeMinutes: investigationChallengeAge ? Math.round(investigationChallengeAge / 60) : null,
                    challengeAgeHours: investigationChallengeAge ? Math.round(investigationChallengeAge / 3600) : null,
                    challengeValid: investigationChallengeAge !== null && investigationChallengeAge < 82800, // 23 hours
                    isChallengeTooOld: investigationChallengeAge > 82800,
                    accountMatchesUser: this.component.authStateManager.getAuthAccount(validatedHeaders) === this.component.username
                },
                permissionContext: {
                    originalPermission: file.permissionLevel,
                    resolvedPermission: finalPermissionLevel,
                    isReadOnlyMode: this.component.isReadOnlyMode,
                    documentOwner: file.owner,
                    currentUserIsOwner: file.owner === this.component.username
                },
                serverExpectations: {
                    expectedAccount: this.component.username,
                    expectedPermissions: [file.permissionLevel, finalPermissionLevel],
                    serverValidationRequired: ['account', 'challenge', 'pubkey', 'signature'],
                    potentialIssues: {
                        userMismatch: this.component.authStateManager.getAuthAccount(validatedHeaders) !== this.component.username,
                        staleChallenge: investigationChallengeAge > 300, // 5 minutes
                        expiredChallenge: investigationChallengeAge > 82800, // 23 hours
                        missingHeaders: !validatedHeaders || Object.keys(validatedHeaders).length < 4
                    }
                }
            };

            console.log('üîç SERVER INVESTIGATION: Pre-connection auth package for server validation:', serverInvestigation);
            
            console.log('üî• CACHE-DEBUG: Creating HocuspocusProvider', {
                hasAuthToken: !!authToken,
                tokenLength: authToken?.length,
                wsUrl,
                docPath,
                username: this.component?.username,
                isAuthenticated: this.component?.isAuthenticated
            });

            // ‚úÖ DEBUG: Add message handler to track WebSocket messages
            let messageCount = 0;
            let lastMessageTime = Date.now();

            const provider = new HocuspocusProvider({
                url: wsUrl,
                name: docPath,
                document: yjsDoc,
                token: authToken,
                connect: true,
                timeout: 30000,
                // ‚úÖ FIX: Force immediate connection
                preserveConnection: true,

                // ‚úÖ TIPTAP COMPLIANCE: Exponential backoff for reconnection
                minReconnectTimeout: 1000,  // Start with 1 second
                maxReconnectTimeout: 30000, // Max 30 seconds
                messageReconnectTimeout: 30000,

                // Additional retry configuration
                maxRetries: 10,
                retryOnError: true,

                // ‚úÖ TIPTAP BEST PRACTICE: Don't set awareness here - HocuspocusProvider creates its own
                // We'll set user info in onConnect callback instead

                // ‚úÖ TIPTAP BEST PRACTICE: Use onSynced callback for collaborative sync completion
                onSynced() {
                    // ‚úÖ CLEANUP SAFETY: Check if we're in cleanup mode
                    if (persistenceManager.component.isCleaningUp) {
                        console.log('‚ö†Ô∏è WebSocket sync ignored - component is cleaning up');
                        return;
                    }
                    
                    // üîµ CACHE-PERSIST: WebSocket sync complete - check database
                    const dbKey = `${persistenceManager.component.username}__${file.owner}/${file.permlink}`;
                    console.log('üîµ CACHE-PERSIST: WebSocket synced - checking database', {
                        indexedDBKey: dbKey,
                        documentHasContent: yjsDoc.share.size > 0,
                        shareSize: yjsDoc.share.size,
                        timestamp: new Date().toISOString()
                    });
                    
                    // Check if database exists after WebSocket sync
                    if (window.indexedDB && window.indexedDB.databases) {
                        window.indexedDB.databases().then(dbs => {
                            const exists = dbs.some(db => db.name === dbKey);
                            console.log('üîµ CACHE-PERSIST: Database check after WebSocket sync', {
                                indexedDBKey: dbKey,
                                databaseExists: exists,
                                allDatabases: dbs.map(db => db.name),
                                timestamp: new Date().toISOString()
                            });
                        });
                    }

                    // ‚úÖ PROVIDER VALIDATION: Removed - provider check was preventing connection

                    // ‚úÖ TIPTAP v3: Clear Y.js syncing flag

                    // Process any queued commands
                    if (persistenceManager.component) {
                        persistenceManager.component.$nextTick(() => {
                            if (persistenceManager.component?.commandQueue && persistenceManager.component.commandQueue.length > 0) {
                                // Process commands here if needed
                            }
                        });
                    }

                    // ‚úÖ CRITICAL FIX: Log Y.js document state after sync for debugging
                    const { documentName, lastModified } = ydocService.getDocumentMetadata();

                    // ‚úÖ FIX: Initialize config map if empty after WebSocket sync
                    // This happens when server returns empty document for new collaborative docs
                    const config = ydocService.getMap('config');
                    if (config && config.size === 0 && !persistenceManager.component.isReadOnlyMode) {
                        ydocService.transactOnMap('config', (configMap) => {
                            configMap.set('created', new Date().toISOString());
                            configMap.set('version', '1.0');
                            configMap.set('documentType', 'collaborative');
                            configMap.set('lastModified', new Date().toISOString());
                            if (file.owner) {
                                configMap.set('owner', file.owner);
                            }
                            // Preserve document name from component state or file
                            const preservedDocumentName = persistenceManager.component.documentName ||
                                persistenceManager.component.currentFile?.documentName ||
                                persistenceManager.component.currentFile?.name ||
                                file.documentName ||
                                file.name;
                            if (preservedDocumentName && !preservedDocumentName.includes('/')) {
                                configMap.set('documentName', preservedDocumentName);
                            }
                        }, 'websocket-sync-init');
                    }

                    // ‚úÖ DEBUG: Check if content is actually in Y.js for read-only users
                    if (persistenceManager.component.isReadOnlyMode) {
                    }

                    // ‚úÖ TIPTAP COMPLIANCE: Use $nextTick for Vue reactivity updates
                    persistenceManager.component.$nextTick(() => {
                        // Update connection status and provider reference for reactive status computation
                        persistenceManager.component.connectionStatus = 'connected';
                        persistenceManager.component.provider = provider;
                        persistenceManager.component.lastSyncTime = new Date();

                        // Provider and status updated after Y.js sync - removed verbose logging
                    });

                    // ‚úÖ UPDATE: Mark Y.js config with sync status (metadata only)
                    // ‚ùå CRITICAL FIX: Skip Y.js updates for read-only users to prevent server rejection
                    if (!persistenceManager.component.isReadOnlyMode) {
                        // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                        ydocService.setCloudSyncStatus(true); // Origin tag to identify this transaction
                    } else {
                    }

                    // ‚úÖ DOCUMENT NAME SYNC: Update currentFile with document name from cloud sync (metadata only)
                    const yjsDocumentName = ydocService.getConfig('documentName');
                    if (yjsDocumentName && persistenceManager.component?.currentFile) {
                        const isUsernameFallback = persistenceManager.component.currentFile.name &&
                            persistenceManager.component.currentFile.name.includes('/');

                        if (isUsernameFallback && yjsDocumentName !== persistenceManager.component.currentFile.name) {

                            persistenceManager.component.currentFile.name = yjsDocumentName;
                            persistenceManager.component.currentFile.documentName = yjsDocumentName;
                            persistenceManager.component.currentFile.title = yjsDocumentName;
                        }
                    }

                    // ‚úÖ TIPTAP COMPLIANCE: Content sync is handled automatically by Collaboration extension
                    // No manual content loading needed - TipTap updates editors automatically when Y.js syncs

                    // ‚úÖ SERVER VERSION: Store server version in Y.js config for offline access
                    // ‚ùå CRITICAL FIX: Skip for read-only users to prevent server rejection
                    if (persistenceManager.component.serverVersion && !persistenceManager.component.isReadOnlyMode) {
                        // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                        ydocService.setServerVersion(persistenceManager.component.serverVersion);
                    }

                    // ‚úÖ CRITICAL FIX: Decouple content loading from tier upgrades
                    // Content should be available in Tier 1 editors via IndexedDB sync

                    // Check if editors already have content from IndexedDB
                    const titleHasContent = (persistenceManager.component.titleInput || '').trim().length > 0;
                    const bodyHasContent = persistenceManager.component.bodyEditor?.getText()?.length > 0;

                    // ‚úÖ TIPTAP BEST PRACTICE: All users with WebSocket should have CollaborationCaret
                    // This provides better collaborative experience with cursor visibility

                    if (persistenceManager.component.bodyEditor) {
                        // ‚úÖ UPGRADE FOR ALL USERS: Both editable and read-only users get Tier 2 with cursors

                        // ‚úÖ PERMISSION REFRESH: Set collaborative activity flag for faster permission checking
                        if (!persistenceManager.component.isActivelyCollaborating) {
                            persistenceManager.component.isActivelyCollaborating = true;

                            // Restart permission refresh with faster rate
                            persistenceManager.component.startPermissionRefresh();
                        }

                        persistenceManager.upgradeToCloudEditors(yjsDoc, provider).catch(error => {
                            console.warn('‚ö†Ô∏è Failed to upgrade to Tier 2 editors:', error.message);
                        });

                        // ‚úÖ REACTIVE PATTERN: Trust TipTap Collaboration to handle content sync
                        // Content will be available through editor update events
                    } else {
                        console.warn('‚ö†Ô∏è Cannot process WebSocket sync - editors not found');
                    }
                },

                onConnect() {
                    // ‚úÖ CLEANUP SAFETY: Check if we're in cleanup mode
                    if (persistenceManager.component.isCleaningUp) {
                        console.log('‚ö†Ô∏è WebSocket connect ignored - component is cleaning up');
                        return;
                    }

                    // ‚úÖ PROVIDER VALIDATION: Removed - provider check was preventing connection

                    persistenceManager.component.connectionStatus = 'connected';
                    persistenceManager.component.connectionMessage = 'Connected to collaboration server';

                    // ‚úÖ FIX: Reset loading flag when WebSocket connects successfully
                    // Document is now fully loaded and user interactions should be tracked
                    persistenceManager.component.isLoadingDocument = false;

                    // ‚úÖ CLEAR AUTH BACKDROP: Clear pending access after successful connection
                    // But only if the user has edit access - read-only users shouldn't clear the modal
                    const authBridge = persistenceManager.component.authBridge;
                    const hasEditAccess = persistenceManager.component.currentPermissionLevel && 
                        (persistenceManager.component.currentPermissionLevel === 'editable' || 
                         persistenceManager.component.currentPermissionLevel === 'postable' || 
                         persistenceManager.component.currentPermissionLevel === 'owner');
                    
                    if (authBridge && hasEditAccess) {
                        authBridge.clearPendingAccess('document-loaded');
                    }

                    // ‚úÖ TIPTAP COMPLIANCE: Set awareness user info after connection
                    if (provider.awareness) {
                        provider.awareness.setLocalStateField('user', {
                            name: persistenceManager.component.username || 'Anonymous',
                            color: (typeof persistenceManager.component.getUserColor === 'function') ? persistenceManager.component.getUserColor() : '#3498db',
                            permissionLevel: file.permissionLevel,
                            isReadOnly: persistenceManager.component.isReadOnlyMode
                        });
                    }

                    // ‚úÖ TIPTAP COMPLIANCE: Track reconnection for exponential backoff
                    if (persistenceManager.component.reconnectAttempts > 0) {
                        persistenceManager.component.reconnectAttempts = 0;
                    }

                    // ‚úÖ FIX: Don't upgrade editors immediately - wait for onSynced
                    // The WebSocket needs to sync Y.js content first

                    // ‚úÖ DEBUG: Check provider sync state

                    // ‚úÖ FIX: For read-only users, check if we need to trigger sync
                    if (persistenceManager.component.isReadOnlyMode) {

                        // ‚úÖ TIPTAP BEST PRACTICE: Read-only awareness is already set in onConnect

                        // üîç DEBUG: Server currently treats this as unauthorized_edit_attempt

                        // ‚úÖ REACTIVE PATTERN: Use provider sync events for read-only users
                        const handleReadOnlySync = async () => {
                            if (provider.synced) {
                                provider.off('synced', handleReadOnlySync);
                            }
                        };

                        // Listen for sync completion
                        provider.on('synced', handleReadOnlySync);

                        // ‚úÖ REACTIVE PATTERN: Use status event for fallback logic
                        const statusHandler = async ({ status }) => {
                            if (status === 'disconnected' && persistenceManager.component.isReadOnlyMode) {

                                // Log provider state for debugging

                                // ‚úÖ FALLBACK: Use HTTP API to fetch document content for read-only users
                                try {
                                    const infoUrl = `https://data.dlux.io/api/collaboration/info/${docPath}`;

                                    const response = await fetch(infoUrl, {
                                        headers: persistenceManager.component.authHeaders || {}
                                    });

                                    if (response.ok) {
                                        const data = await response.json();

                                        if (data.ydocState) {
                                            // Apply the state to our Y.js document
                                            const update = new Uint8Array(data.ydocState);
                                            Y.applyUpdate(yjsDoc, update);

                                            // Trigger sync through provider
                                            if (!provider.synced) {
                                                provider.synced = true;
                                                provider.emit('synced');
                                            }
                                        }
                                    } else {
                                        console.error('‚ùå HTTP fetch failed:', response.status, response.statusText);
                                    }
                                } catch (error) {
                                    console.error('‚ùå HTTP fallback error:', error);
                                }

                                // Remove this handler after handling disconnection
                                provider.off('status', statusHandler);
                            }
                        };

                        provider.on('status', statusHandler);
                    }

                    // ‚úÖ SERVER VERSION: Check version when connecting to ensure compatibility
                    persistenceManager.component.$nextTick(() => {
                        persistenceManager.component.checkServerVersion();
                    });
                },

                onDisconnect() {
                    // ‚úÖ CLEANUP SAFETY: Check if we're in cleanup mode
                    if (persistenceManager.component.isCleaningUp) {
                        console.log('‚ö†Ô∏è WebSocket disconnect ignored - component is cleaning up');
                        return;
                    }

                    // ‚úÖ PROVIDER VALIDATION: Check if this provider is still the active one
                    if (persistenceManager.component.provider !== provider) {
                        console.log('‚ö†Ô∏è WebSocket disconnect ignored - provider is no longer active');
                        return;
                    }

                    // ‚úÖ TIPTAP COMPLIANCE: Use $nextTick for Vue reactivity updates
                    persistenceManager.component.$nextTick(() => {
                        persistenceManager.component.connectionStatus = 'disconnected';
                        persistenceManager.component.connectionMessage = 'Disconnected from server';
                        persistenceManager.component.provider = null;

                        // ‚úÖ TIPTAP COMPLIANCE: Track reconnection attempts for exponential backoff
                        persistenceManager.component.reconnectAttempts++;
                        if (persistenceManager.component.reconnectAttempts > 1) {
                        }

                        // ‚úÖ PERMISSION REFRESH: Reset collaborative activity flag and restart permission refresh at normal rate
                        if (persistenceManager.component.isActivelyCollaborating) {
                            persistenceManager.component.isActivelyCollaborating = false;
                            persistenceManager.component.startPermissionRefresh();
                        }
                    });

                    // ‚úÖ UPDATE: Mark Y.js config with disconnect status
                    // ‚ùå CRITICAL FIX: Skip for read-only users to prevent server rejection
                    if (!persistenceManager.component.isReadOnlyMode) {
                        // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                        ydocService.setCloudSyncStatus(false); // Origin tag to identify this transaction
                    }
                },

                onAuthenticationFailed(data) {
                    // ‚úÖ CLEANUP SAFETY: Check if we're in cleanup mode
                    if (persistenceManager.component.isCleaningUp) {
                        console.log('‚ö†Ô∏è WebSocket auth failure ignored - component is cleaning up');
                        return;
                    }

                    // ‚úÖ PROVIDER VALIDATION: Check if this provider is still the active one
                    if (persistenceManager.component.provider !== provider) {
                        console.log('‚ö†Ô∏è WebSocket auth failure ignored - provider is no longer active');
                        return;
                    }

                    console.error('üîí WebSocket authentication failed', data);

                    // ‚úÖ ENHANCED DEBUG: Comprehensive authentication failure analysis
                    const authFailureDetails = {
                        // Server response
                        serverData: data,
                        reason: data?.reason || 'unknown',
                        timestamp: new Date().toISOString(),

                        // Document context
                        documentPath: docPath,
                        documentOwner: file.owner,
                        documentPermlink: file.permlink,
                        permissionLevel: file.permissionLevel,
                        isReadOnly: persistenceManager.component.isReadOnlyMode,

                        // Authentication state
                        currentUser: persistenceManager.component.username,
                        isAuthenticated: persistenceManager.component.isAuthenticated,
                        isAuthExpired: persistenceManager.component.isAuthExpired,

                        // Auth headers analysis
                        authHeaders: (() => {
                            const validHeaders = persistenceManager.component.isAuthenticated ? persistenceManager.component.authHeaders : null;
                            return {
                                exists: !!validHeaders,
                                account: persistenceManager.component.authStateManager.getAuthAccount(validHeaders),
                                hasSignature: !!persistenceManager.component.authStateManager.getAuthSignature(validHeaders),
                                hasChallenge: !!persistenceManager.component.authStateManager.getAuthChallenge(validHeaders),
                                hasPubkey: !!persistenceManager.component.authStateManager.getAuthPubkey(validHeaders),

                                // Header validation
                                accountMatchesUser: persistenceManager.component.authStateManager.getAuthAccount(validHeaders) === persistenceManager.component.username,
                                challengeAge: persistenceManager.component.authStateManager.getChallengeAge(validHeaders)
                            };
                        })(),

                        // Token analysis (reconstruct what was sent)
                        reconstructedToken: (() => {
                            try {
                                const validHeaders = persistenceManager.component.isAuthenticated ? persistenceManager.component.authHeaders : null;
                                if (validHeaders) {
                                    return JSON.stringify({
                                        account: persistenceManager.component.authStateManager.getAuthAccount(validHeaders),
                                        signature: persistenceManager.component.authStateManager.getAuthSignature(validHeaders),
                                        challenge: persistenceManager.component.authStateManager.getAuthChallenge(validHeaders),
                                        pubkey: persistenceManager.component.authStateManager.getAuthPubkey(validHeaders),
                                        permission_level: file.permissionLevel || 'readonly'
                                    });
                                }
                                return null;
                            } catch (e) {
                                return 'Error reconstructing token: ' + e.message;
                            }
                        })(),

                        // Provider state
                        providerState: {
                            hasProvider: !!persistenceManager.component.provider,
                            providerStatus: persistenceManager.component.provider?.status,
                            isConnected: persistenceManager.component.provider?.isConnected,
                            connectionState: persistenceManager.component.connectionStatus
                        }
                    };

                    console.error('üîç DETAILED AUTH FAILURE ANALYSIS:', authFailureDetails);

                    // ‚úÖ WEBSOCKET TOKEN REFRESH: Attempt to refresh auth and reconnect
                    if (data?.reason === 'permission-denied' && persistenceManager.component.isAuthenticated) {
                        console.log('üîÑ WEBSOCKET TOKEN REFRESH: Permission denied for authenticated user - attempting token refresh');

                        // Check if auth headers are stale
                        const isStale = authFailureDetails.authHeaders.challengeAge > 300; // 5 minutes
                        const accountMismatch = !authFailureDetails.authHeaders.accountMatchesUser;

                        if (isStale || accountMismatch) {
                            console.log('üîÑ WEBSOCKET TOKEN REFRESH: Detected stale/mismatched auth - requesting fresh headers');

                            // Request fresh auth headers
                            const authBridge = persistenceManager.component.authBridgeInstance;
                            if (authBridge) {
                                const documentInfo = {
                                    name: file.documentName || file.name || 'document',
                                    owner: file.owner,
                                    permlink: file.permlink,
                                    type: 'collaborative'
                                };
                                authBridge.showAuthPrompt('authenticate', documentInfo);
                            } else {
                                // Use authBridge for authentication request
                                if (persistenceManager.component.authBridgeInstance) {
                                    persistenceManager.component.authBridgeInstance.showAuthPrompt('authenticate', {
                                        name: 'Document Recovery',
                                        reason: 'Authentication required to recover document'
                                    });
                                } else {
                                    console.error('AuthBridge not available for document recovery authentication');
                                }
                            }

                            // ‚úÖ TIMEOUT HANDLING: Set up retry mechanism with proper timeout handling
                            const setupRetryWatcher = () => {
                                let authHeadersHandler = null;
                                let isCompleted = false;

                                const cleanup = () => {
                                    if (authHeadersHandler) {
                                        persistenceManager.component.authStateManager.off('authHeadersChanged', authHeadersHandler);
                                        authHeadersHandler = null;
                                    }
                                    isCompleted = true;
                                };

                                // ‚úÖ ARCHITECTURE COMPLIANT: Use requestAnimationFrame for timeout instead of setTimeout
                                const startTime = Date.now();
                                const checkAuthTimeout = () => {
                                    if (!isCompleted) {
                                        if (Date.now() - startTime >= 30000) {
                                            console.warn('‚è∞ WEBSOCKET TOKEN REFRESH: Auth refresh timeout (30s) - falling back to offline mode');
                                            cleanup();
                                            persistenceManager.component.connectionStatus = 'offline';
                                        } else {
                                            requestAnimationFrame(checkAuthTimeout);
                                        }
                                    }
                                };
                                requestAnimationFrame(checkAuthTimeout);

                                // Listen for fresh auth headers via event
                                authHeadersHandler = (event) => {
                                    if (isCompleted) return; // Prevent multiple executions

                                    const newHeaders = event.detail?.headers;
                                    if (newHeaders && persistenceManager.component.authStateManager.getAuthAccount(newHeaders) === persistenceManager.component.username) {
                                        console.log('üîÑ WEBSOCKET TOKEN REFRESH: Fresh auth headers received - recreating WebSocket provider');
                                        cleanup();

                                        // ‚úÖ REACTIVE PATTERN: Recreate WebSocket provider immediately (no setTimeout)
                                        (async () => {
                                            try {
                                                // Clean up existing provider
                                                if (persistenceManager.component.provider) {
                                                    persistenceManager.component.provider.disconnect();
                                                    persistenceManager.component.provider.destroy();
                                                    persistenceManager.component.provider = null;
                                                }

                                                // Recreate with fresh headers
                                                const newProvider = await persistenceManager.setupWebSocketWithOnSynced(yjsDoc, file);
                                                if (newProvider) {
                                                    persistenceManager.component.provider = newProvider;
                                                    console.log('‚úÖ WEBSOCKET TOKEN REFRESH: Successfully recreated WebSocket provider with fresh auth');
                                                } else {
                                                    console.warn('‚ö†Ô∏è WEBSOCKET TOKEN REFRESH: Failed to recreate WebSocket provider - staying offline');
                                                    persistenceManager.component.connectionStatus = 'offline';
                                                }
                                            } catch (error) {
                                                console.error('‚ùå WEBSOCKET TOKEN REFRESH: Error recreating WebSocket provider:', error);
                                                persistenceManager.component.connectionStatus = 'error';
                                            }
                                        })();
                                    }
                                };

                                // Subscribe to auth header changes
                                persistenceManager.component.authStateManager.on('authHeadersChanged', authHeadersHandler);
                            };

                            setupRetryWatcher();
                        } else {
                            console.log('üîÑ WEBSOCKET TOKEN REFRESH: Auth headers appear fresh - no refresh needed');
                        }
                    }

                    // ‚úÖ DEBUG: Enhanced logging for WebSocket authentication failures
                    const validHeaders = persistenceManager.component.isAuthenticated ? persistenceManager.component.authHeaders : null;

                    // ‚úÖ READ-ONLY USERS SHOULD CONNECT: They need WebSocket for awareness and broadcasts
                    if (data.reason === 'permission-denied') {
                        console.error('üö® WEBSOCKET PERMISSION DENIED - This should not happen for valid users!');
                        console.error('üìã Read-only users need WebSocket for:');
                        console.error('   - Real-time permission broadcasts');
                        console.error('   - User awareness and live cursors');
                        console.error('   - Collaborative content updates');
                        console.error('üîß Investigation needed: Why is server rejecting WebSocket auth?');

                        // Log auth details for debugging
                        if (persistenceManager.component.authHeaders) {
                        }
                    }

                    // Regular error handling for non-read-only users
                    persistenceManager.component.connectionStatus = 'error';
                    persistenceManager.component.connectionMessage = 'Authentication failed';

                    // Try to refresh authentication for editable users
                    if (!persistenceManager.component.isReadOnlyMode && persistenceManager.component.loadCollaborationAuthHeaders) {
                        persistenceManager.component.loadCollaborationAuthHeaders(true).then(() => {
                        }).catch(error => {
                            console.error('‚ùå Failed to refresh authentication headers:', error);
                        });
                    }
                },

                onError(error) {
                    // ‚úÖ CLEANUP SAFETY: Check if we're in cleanup mode
                    if (persistenceManager.component.isCleaningUp) {
                        console.log('‚ö†Ô∏è WebSocket error ignored - component is cleaning up');
                        return;
                    }

                    // ‚úÖ PROVIDER VALIDATION: Check if this provider is still the active one
                    if (persistenceManager.component.provider !== provider) {
                        console.log('‚ö†Ô∏è WebSocket error ignored - provider is no longer active');
                        return;
                    }

                    console.error('‚ùå WebSocket error:', error);

                    // ‚úÖ DEBUG: Log full error details

                    // Handle specific protocol errors
                    if (error.message && error.message.includes('unknown type: 7')) {
                        console.warn('‚ö†Ô∏è Protocol mismatch detected - CLOSE message type not handled properly');
                        // This error typically means the server sent a close message
                        // Don't disconnect immediately - let the server close the connection
                        persistenceManager.component.connectionStatus = 'disconnected';
                        persistenceManager.component.connectionMessage = 'Server closed connection';

                        // Clean up the provider reference
                        persistenceManager.component.$nextTick(() => {
                            persistenceManager.component.provider = null;
                        });
                        return;
                    }

                    // Handle WebSocket closed before connection
                    if (error.message && error.message.includes('WebSocket is closed before the connection is established')) {
                        console.warn('‚ö†Ô∏è WebSocket closed before connection - server may have rejected the connection');
                        persistenceManager.component.connectionStatus = 'error';
                        persistenceManager.component.connectionMessage = 'Server rejected connection';
                        return;
                    }

                    persistenceManager.component.connectionStatus = 'error';
                    persistenceManager.component.connectionMessage = `Connection error: ${error.message}`;
                },

                // Add debugging for provider events (but don't interfere with message handling)
                onOpen() {
                },

                onStatus(event) {
                },

                // ‚úÖ DEBUG: Track message flow and handle permission broadcasts
                onMessage(data) {
                    messageCount++;
                    const timeSinceLastMessage = Date.now() - lastMessageTime;
                    lastMessageTime = Date.now();

                    // ‚úÖ DEBUG: Track heartbeat/keepalive messages
                    if (data && (data.type === 'pong' || data.type === 'ping' || data.type === 'heartbeat')) {
                        return; // Skip further processing for heartbeat messages
                    }

                    // ‚úÖ PERMISSION BROADCAST DEBUG: Try to detect permission-related messages
                    let hasPermissionData = false;
                    let messageInfo = 'unknown';

                    try {
                        // Check if this is a text message that might contain permission data
                        if (typeof data === 'string') {
                            const lowerData = data.toLowerCase();
                            if (lowerData.includes('permission') || lowerData.includes('access') || lowerData.includes('grant') || lowerData.includes('revoke')) {
                                hasPermissionData = true;
                                messageInfo = 'potential-permission-broadcast';
                            }
                        }

                        // Check if this is a binary message with Uint8Array content that might be Y.js update with permission info
                        if (data instanceof Uint8Array || data?.byteLength) {
                            // For debugging: Try to decode if it contains permission info in the update
                            try {
                                const decoded = new TextDecoder().decode(data);
                                if (decoded.includes('permission') || decoded.includes('access')) {
                                    hasPermissionData = true;
                                    messageInfo = 'yjs-update-with-permission-data';
                                }
                            } catch (e) {
                                // Expected for binary Y.js updates
                            }
                        }
                    } catch (e) {
                        console.warn('‚ö†Ô∏è Error analyzing message for permission data:', e);
                    }

                    // First message is typically the sync response
                    if (messageCount === 1) {
                    }

                    // Check if sync completed after message
                    if (provider.synced && messageCount <= 3) {
                    }
                },

                // ‚úÖ DEBUG: Add more event handlers to understand sync issue
                onStateless(payload) {

                    // ‚úÖ ENHANCED PERMISSION BROADCAST DETECTION: Handle multiple formats
                    const isPermissionBroadcast = payload && (
                        payload.type === 'permission-update' ||
                        payload.type === 'permission-change' ||
                        payload.type === 'permission-grant' ||
                        payload.type === 'permission-revoke' ||
                        payload.type === 'access-update' ||
                        payload.event === 'permission-update' ||
                        payload.action === 'permission-update' ||
                        (payload.targetAccount && payload.permissionType) ||
                        (payload.account && payload.permission) ||
                        (payload.user && payload.access)
                    );

                    if (isPermissionBroadcast) {

                        // Normalize the payload to the expected format
                        const normalizedPayload = {
                            type: payload.type || 'permission-update',
                            targetAccount: payload.targetAccount || payload.account || payload.user,
                            permissionType: payload.permissionType || payload.permission || payload.access,
                            grantedBy: payload.grantedBy || payload.by || payload.from,
                            owner: payload.owner,
                            permlink: payload.permlink
                        };

                        // Check if this permission update is for the current user
                        if (normalizedPayload.targetAccount === persistenceManager.component.username) {

                            // Use Vue's nextTick to ensure reactive updates
                            persistenceManager.component.$nextTick(() => {
                                persistenceManager.component.handleRemotePermissionUpdate(normalizedPayload);
                            });
                        } else {
                        }
                    }

                    // ‚úÖ LEGACY FORMAT: Handle original permission-update type
                    if (payload && payload.type === 'permission-update') {

                        // Check if this permission update is for the current user
                        if (payload.targetAccount === persistenceManager.component.username) {

                            // Use Vue's nextTick to ensure reactive updates
                            persistenceManager.component.$nextTick(() => {
                                persistenceManager.component.handleRemotePermissionUpdate(payload);
                            });
                        } else {
                        }
                    }

                    // ‚úÖ REACTIVE PERMISSIONS: Handle permission revocation broadcasts
                    if (payload && payload.type === 'permission-revoke') {

                        // Check if this revocation is for the current user
                        if (payload.targetAccount === persistenceManager.component.username) {

                            // Handle as no-access permission update
                            const revokePayload = {
                                ...payload,
                                permissionType: 'no-access'
                            };

                            persistenceManager.component.$nextTick(() => {
                                persistenceManager.component.handleRemotePermissionUpdate(revokePayload);
                            });
                        }
                    }
                },

                // ‚úÖ SERVER UPDATE: Server now handles read-only awareness updates
                // No need to block broadcasts - server will filter appropriately
                beforeBroadcastStateless(payload) {
                    // Debug: Log all broadcast attempts with more detail
                    const payloadStr = payload ? JSON.stringify(payload).substring(0, 100) : 'null';

                    // Allow all broadcasts - server handles permissions
                    return payload;
                },

                // Allow regular broadcasts - server handles permissions
                beforeBroadcast(data) {

                    // Allow all broadcasts - server handles permissions
                    return true;
                }
            });

            // ‚úÖ Y.JS COMPLIANCE: Implement proper awareness heartbeat
            // Y.js awareness timeout is 30 seconds - send updates every 15 seconds
            // ‚úÖ ARCHITECTURE RULE 6: Replace setInterval with requestAnimationFrame
            let lastHeartbeatTime = Date.now();
            const heartbeatInterval = 15000; // 15 seconds - half of Y.js 30s timeout
            
            const awarenessHeartbeat = () => {
                const now = Date.now();
                if (now - lastHeartbeatTime >= heartbeatInterval) {
                    if (provider.awareness && !provider.isDestroyed) {
                        // Send lightweight awareness update to maintain Y.js 30s timeout
                        provider.awareness.setLocalStateField('lastActivity', Date.now());
                    }
                    lastHeartbeatTime = now;
                }
                
                if (!provider.isDestroyed) {
                    this.component.awarenessHeartbeat = requestAnimationFrame(awarenessHeartbeat);
                }
            };
            
            // Start the heartbeat
            this.component.awarenessHeartbeat = requestAnimationFrame(awarenessHeartbeat);

            // Clean up heartbeat when provider is destroyed
            provider.on('destroy', () => {
                if (this.component.awarenessHeartbeat) {
                    cancelAnimationFrame(this.component.awarenessHeartbeat);
                    this.component.awarenessHeartbeat = null;
                }
            });

            // ‚úÖ TIPTAP BEST PRACTICE: Awareness state is properly set in onConnect
            // No need to clear it here - CollaborationCaret will work correctly

            // ‚úÖ FIX: Remove manual connection - provider should connect automatically with connect: true

            /**
             * @listens status
             * @description Monitor WebSocket connection status changes
             * @param {Object} event - Status event
             * @param {string} event.status - Connection status: 'connecting'|'connected'|'disconnected'
             */
            provider.on('status', ({ status }) => {

                // ‚úÖ REACTIVE PATTERN: Handle sync completion through events
                if (status === 'connected' && !provider.synced) {
                } else if (status === 'connected' && provider.synced) {
                }
            });

            // ‚úÖ REACTIVE PATTERN: Handle connection errors reactively
            provider.on('connection-error', ({ error }) => {
                console.error('üîå WebSocket connection error:', {
                    message: error.message,
                    documentPath: docPath
                });

                // ‚úÖ ZOMBIE DOCUMENT CLEANUP: Handle deleted documents (404 responses)
                if (error.message && (
                    error.message.includes('404') || 
                    error.message.includes('Not found') ||
                    error.message.includes('not found') ||
                    error.message.includes('Document does not exist')
                )) {
                    console.warn('üóëÔ∏è Document deleted on server, cleaning up local cache', {
                        owner: file.owner,
                        permlink: file.permlink,
                        cacheKey: `${persistenceManager.component.username}__${file.owner}/${file.permlink}`
                    });
                    
                    // Notify user
                    const message = file.owner === persistenceManager.component.username 
                        ? 'This document no longer exists on the server.'
                        : 'This document has been deleted by the owner.';
                    
                    // Clean up local cache
                    const cacheKey = `${persistenceManager.component.username}__${file.owner}/${file.permlink}`;
                    indexedDB.deleteDatabase(cacheKey).then(() => {
                        console.log('‚úÖ Deleted local cache for removed document:', cacheKey);
                    }).catch(err => {
                        console.error('‚ùå Failed to delete cache:', err);
                    });
                    
                    // Remove from offline caches list
                    if (persistenceManager.component.offlineCaches) {
                        persistenceManager.component.offlineCaches = 
                            persistenceManager.component.offlineCaches.filter(
                                doc => !(doc.owner === file.owner && doc.permlink === file.permlink)
                            );
                    }
                    
                    // Remove from collaborative docs list
                    if (persistenceManager.component.collaborativeDocs) {
                        persistenceManager.component.collaborativeDocs = 
                            persistenceManager.component.collaborativeDocs.filter(
                                doc => !(doc.owner === file.owner && doc.permlink === file.permlink)
                            );
                    }
                    
                    // Navigate away if currently viewing this document
                    if (persistenceManager.component.currentFile && 
                        persistenceManager.component.currentFile.owner === file.owner && 
                        persistenceManager.component.currentFile.permlink === file.permlink) {
                        
                        alert(message);
                        
                        // Navigate to new document
                        persistenceManager.component.$nextTick(() => {
                            persistenceManager.component.newDocument();
                        });
                    }
                    
                    return; // Don't process further
                }

                // Check if manual intervention needed
                if (provider.ws && provider.ws.readyState === WebSocket.CLOSED) {
                }
            });

            return provider;

        } catch (error) {
            console.error('‚ùå Failed to create WebSocket provider:', error);
            this.component.connectionStatus = 'error';
            this.component.connectionMessage = `Setup failed: ${error.message}`;
            return null;
        }
    }

    async recreateReadOnlyEditors(yjsDoc) {
        // ‚úÖ RECOVERY METHOD: Recreate read-only editors when content sync fails

        try {
            // Destroy existing editors
            // titleEditor removed - using simple input field
            if (this.component.bodyEditor) {
                this.component.bodyEditor.destroy();
                this.component.bodyEditor = null;
            }
            // permlinkEditor removed - using simple input field

            // Wait for DOM cleanup
            await this.component.$nextTick();

            // Recreate editors with synced Y.js document
            const tier = TierDecisionManager.TierType.LOCAL; // Read-only uses Tier 1
            const editors = await this.component.documentManager.editorFactory.createEditors(yjsDoc, tier, null);

            this.component.bodyEditor = markRaw(editors.bodyEditor);

            // Re-setup sync listeners
            this.component.syncManager.setupSyncListeners(editors, yjsDoc);

            // ‚úÖ COMPLIANCE: Debug code removed - no content access in timeouts

        } catch (error) {
            console.error('‚ùå Failed to recreate read-only editors:', error);
            throw error;
        }
    }

    async upgradeToCloudEditors(yjsDoc, webSocketProvider) {
        // ‚úÖ TIMING GUARD: Skip upgrade if still loading document or user switching
        if (this.component.isLoadingDocument || this.component.isLoadingFromURL || this.component._processingUserChange) {
            // Store pending upgrade for reactive processing
            this.component._pendingUpgrade = { yjsDoc, webSocketProvider };
            return;
        }

        // ‚úÖ CONCURRENCY PROTECTION: Prevent operations during unmounting or cleanup
        if (this.component.creatingEditors || this.component.isInitializingEditors || this.component.isUnmounting || this.component.isCleaningUp) {
            return;
        }

        // ‚úÖ PREREQUISITE CHECK: Ensure editors exist before upgrading
        if (!this.component.bodyEditor) {
            return;
        }

        // ‚úÖ DUPLICATE PREVENTION: Check if editor already has cursors (Tier 2)
        if (this.component.bodyEditor?.extensionManager?.extensions?.find(ext => ext.name === 'collaborationCaret')) {
            return;
        }

        // ‚úÖ MUTUAL EXCLUSION: Set flag to prevent concurrent upgrades
        this.component.creatingEditors = true;

        try {
            // ‚úÖ TIPTAP BEST PRACTICE: Preserve Y.js document state during tier upgrade

            // Store current editor state for verification (following TipTap best practices)
            const beforeUpgrade = {
                title: this.component.titleInput || '',
                body: this.component.bodyEditor?.getText() || '',
                ...ydocService.getDocumentMetadata()
            };

            // ‚úÖ CRITICAL: Create new editors BEFORE destroying old ones
            // This ensures Y.js document content continuity during transition

            // ‚úÖ TIMING FIX: Ensure DOM is ready before creating new editors
            await this.component.$nextTick();

            const newEditors = await this.component.documentManager.editorFactory.createTier2Editors(yjsDoc, webSocketProvider);

            // ‚úÖ TIPTAP COMPLIANCE: Trust automatic Y.js sync via Collaboration extension
            // No manual timing - TipTap handles initialization automatically

            // ‚úÖ VERIFICATION: Check that new editor has Y.js content
            const bodyContent = newEditors.bodyEditor?.getText() || '';
            const titleContent = this.component.titleInput || '';

            // ‚úÖ DEBUG: Log editor upgrade for read-only documents

            // ‚úÖ TIPTAP BEST PRACTICE: Safe destruction with verification
            await this.component.documentManager.lifecycleManager.destroyEditors();

            // Replace editor references
            this.component.bodyEditor = markRaw(newEditors.bodyEditor);

            // ‚úÖ TIPTAP COMPLIANCE FIX: Setup sync listeners but preserve auto-naming state
            // The Tier 2 editors need onUpdate handlers, but must respect existing auto-naming flags

            this.component.documentManager.syncManager.setupSyncListeners(newEditors, yjsDoc);

            // Update component state to reflect cloud mode
            // isCollaborativeMode is now a computed property
            this.component.fileType = 'collaborative';
            this.component.connectionStatus = 'connected';

            // ‚úÖ VUE REACTIVITY: Ensure DOM updates are processed after editor transitions
            await this.component.$nextTick();

            // ‚úÖ VERIFICATION: Confirm editor state preserved (following TipTap best practices)
            const afterUpgrade = {
                title: this.component.titleInput || '',
                body: this.component.bodyEditor?.getText() || '',
                documentName: ydocService.getConfig('documentName')
            };

            const statePreserved = beforeUpgrade.title === afterUpgrade.title &&
                beforeUpgrade.body === afterUpgrade.body &&
                beforeUpgrade.documentName === afterUpgrade.documentName;

            if (statePreserved) {
            } else {
                // Downgraded from warning - Y.js CRDT ensures consistency
            }

            // ‚úÖ UPDATE: Mark Y.js config with tier upgrade info
            // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
            ydocService.setTierUpgrade(true);
            ydocService.updateConfig('hasCollaborationCaret', true);

        } catch (error) {
            console.error('‚ùå Failed to upgrade to cloud editors:', error);

            // ‚úÖ FAILSAFE: Ensure component state is consistent even if upgrade fails
            this.component.connectionStatus = 'error';
        } finally {
            // ‚úÖ CLEANUP: Always clear the flag to allow future operations
            this.component.creatingEditors = false;
        }
    }

    setupTempPersistence(yjsDoc) {
        // ‚úÖ TIPTAP BEST PRACTICE: Deferred IndexedDB for temp documents
        this.setupDeferredIndexedDB(yjsDoc);
    }

    setupDeferredIndexedDB(yjsDoc) {
        // ‚úÖ REDIRECTED: Use the unified component-level persistence method instead
        // This ensures only one persistence system runs and avoids race conditions

        // The component-level system already handles debounced creation via debouncedCreateIndexedDBForTempDocument()
        // No additional setup needed here - editor onUpdate handlers will trigger persistence automatically
    }

    debounce(func, wait) {
        let lastCallTime = 0;
        let animationFrame = null;
        
        return function executedFunction(...args) {
            lastCallTime = Date.now();
            const thisCallTime = lastCallTime;
            
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            
            const checkTime = () => {
                const elapsed = Date.now() - thisCallTime;
                
                if (elapsed >= wait && thisCallTime === lastCallTime) {
                    func(...args);
                } else {
                    animationFrame = requestAnimationFrame(checkTime);
                }
            };
            
            animationFrame = requestAnimationFrame(checkTime);
        };
    }

    hasContentToSave() {
        // ‚úÖ CORRECT: Check editor and title input for content detection
        if (!this.component.bodyEditor) {
            return false;
        }

        const titleText = this.component.titleInput?.trim() || '';
        const bodyText = this.component.bodyEditor.getText().trim();

        return titleText || bodyText;
    }

    updateLocalFileTimestamp(fileId, timestamp) {
        if (!fileId) return;

        try {
            // Update localStorage metadata
            const files = this.component.documentStorageService.getAllDocuments();
            const fileIndex = files.findIndex(f => f.id === fileId);

            if (fileIndex >= 0) {
                files[fileIndex].lastModified = timestamp;
                files[fileIndex].modified = timestamp;
                this.component.documentStorageService.saveAllDocuments(files);

            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Failed to update local file timestamp:', error.message);
        }
    }

    /**
     * ‚úÖ COMPREHENSIVE TOKEN VALIDATION: Validate WebSocket auth token structure and content
     * @param {Object} authHeaders - Auth headers object
     * @param {string} expectedUser - Expected username 
     * @param {string} permissionLevel - Expected permission level
     * @returns {Object} Validation result with isValid flag and errors array
     */
    validateWebSocketAuthToken(authHeaders, expectedUser, permissionLevel) {
        const DEBUG = this.component.DEBUG || false;

        // Use centralized auth header validation
        const baseValidation = this.component.authStateManager.validateAuthHeaders(authHeaders, expectedUser);
        if (!baseValidation.isValid) {
            return baseValidation;
        }

        const errors = [];

        // All basic validation is handled by authStateManager.validateAuthHeaders
        // Only need to add WebSocket-specific validations here

        // Permission level validation
        // Note: This validation excludes 'no-access' as it's not a valid permission for granting
        const validPermissionLevels = this.component.getValidPermissionLevels();
        const validGrantPermissions = validPermissionLevels.filter(level => level !== 'no-access');
        if (!validGrantPermissions.includes(permissionLevel)) {
            errors.push(`Invalid permission level: ${permissionLevel}`);
        }

        // Token size validation (WebSocket header limit)
        const tokenObject = {
            account: this.component.authStateManager.getAuthAccount(authHeaders),
            signature: this.component.authStateManager.getAuthSignature(authHeaders),
            challenge: this.component.authStateManager.getAuthChallenge(authHeaders),
            pubkey: this.component.authStateManager.getAuthPubkey(authHeaders),
            permission_level: permissionLevel
        };
        const tokenString = JSON.stringify(tokenObject);
        if (tokenString.length > 2048) {
            errors.push(`Token too large: ${tokenString.length} bytes (max 2048)`);
        }

        if (DEBUG && errors.length === 0) {
            console.log('‚úÖ WEBSOCKET TOKEN VALIDATION PASSED:', {
                account: this.component.authStateManager.getAuthAccount(authHeaders),
                challengeAge: baseValidation.challengeAge,
                permissionLevel,
                tokenSize: tokenString.length
            });
        }

        return {
            isValid: errors.length === 0 && baseValidation.isValid,
            errors: [...baseValidation.errors, ...errors],
            tokenSize: tokenString.length,
            challengeAge: baseValidation.challengeAge
        };
    }
}

/**
 * 4. EDITOR FACTORY
 * Create editors following TipTap patterns - NO manual content setting
 * 
 * üö® CRITICAL ENFORCEMENT RULES:
 * ‚ùå NEVER use setContent(), setHTML(), or insertContent() 
 * ‚ùå NEVER manipulate Y.js XML fragments directly
 * ‚ùå NEVER add Y.js observers on content fragments  
 * ‚úÖ ONLY use TipTap Collaboration extension for content sync
 * ‚úÖ ONLY use onUpdate for flags (hasUnsavedChanges, debouncedCreateIndexedDBForTempDocument)
 */
class EditorFactory {
    constructor(component) {
        this.component = component;
    }

    async createEditors(yjsDoc, tier, webSocketProvider = null) {
        // ‚úÖ CONCURRENCY PROTECTION: Prevent operations during unmounting or cleanup
        if (this.component.creatingEditors || this.component.isInitializingEditors || this.component.isUnmounting || this.component.isCleaningUp) {
            return null;
        }

        // ‚úÖ DUPLICATE PREVENTION: Check if editor already exists (single editor solution)
        if (this.component.bodyEditor) {
            return {
                bodyEditor: this.component.bodyEditor
            };
        }

        this.component.creatingEditors = true;

        try {
            if (tier === TierDecisionManager.TierType.CLOUD) {
                // ‚úÖ OFFLINE-FIRST: Always create Tier 2 editors for collaborative documents
                // WebSocket can be null when offline/disconnected - editors still need collaborative features
                // The Collaboration extension works with Y.js even without active WebSocket connection
                return await this.createTier2Editors(yjsDoc, webSocketProvider);
            } else {
                return await this.createTier1Editors(yjsDoc, webSocketProvider);
            }
        } finally {
            this.component.creatingEditors = false;
        }
    }

    async createTier1Editors(yjsDoc, webSocketProvider = null) {
        // ‚úÖ TIPTAP BEST PRACTICE: Use window bundle instead of ES6 imports
        const bundle = window.TiptapCollaboration;
        if (!bundle) {
            throw new Error('TipTap collaboration bundle not available');
        }

        // Ensure Y.js document is ready
        if (!yjsDoc) {
            throw new Error('Y.js document is required for editor creation');
        }

        // ‚úÖ VERIFY: Check Y.js document state before creating editor

        // ‚úÖ GRACEFUL HANDLING: Check if document is in a bad state
        if (yjsDoc.isDestroyed) {
            // For authentication flows, handle gracefully
            if (this.isLoadingFromURL) {
                console.warn('‚ö†Ô∏è Y.js document destroyed during authentication flow - this is expected');
                throw new Error('Y.js document is destroyed during authentication - will retry after login');
            }
            // ‚úÖ ENHANCED AUTH PROTECTION: Check if we're in any authentication or recovery scenario
            else if (this.connectionStatus === 'connecting' ||
                this.connectionStatus === 'auth-required' ||
                this.connectionStatus === 'auth-invalid' ||
                this.connectionStatus === 'initializing' ||
                this.connectionStatus === 'error' ||
                this.connectionStatus === 'disconnected') {

                console.warn('‚ö†Ô∏è Y.js document destroyed during auth/connection flow - creating new document', {
                    connectionStatus: this.connectionStatus,
                    hasFailedPermissionAttempts: this.failedPermissionAttempts?.size > 0,
                    isConnectingToDocument: this.isConnectingToDocument
                });

                // Create a new Y.js document for the retry using YDocService
                const newYjsDoc = ydocService.createDocument(`retry-${Date.now()}`);

                // Update the component reference
                this.ydoc = newYjsDoc;
                // Use the new document for editor creation
                yjsDoc = newYjsDoc;
                console.log('‚úÖ Created new Y.js document for auth/connection retry:', {
                    guid: newYjsDoc.guid,
                    clientID: newYjsDoc.clientID,
                    connectionStatus: this.connectionStatus
                });
            } else {
                console.error('‚ùå Y.js document destroyed in unexpected state:', {
                    connectionStatus: this.connectionStatus,
                    isLoadingFromURL: this.isLoadingFromURL,
                    currentFile: this.currentFile?.name,
                    hasProvider: !!this.provider
                });
                throw new Error('Y.js document is destroyed - cannot create editor');
            }
        }

        // ‚úÖ ULTIMATE FIX: Comprehensive bundle access debugging and resolution

        // ‚úÖ BYPASS BUNDLE VARIABLE - Access directly from window with fallback patterns
        if (!window.TiptapCollaboration) {
            throw new Error('window.TiptapCollaboration not available');
        }

        // ‚úÖ SMART ACCESS: Try direct access first, then default export
        const tiptapBundle = window.TiptapCollaboration.Editor ? window.TiptapCollaboration : window.TiptapCollaboration.default;

        if (!tiptapBundle) {
            throw new Error('TipTap components not found in window.TiptapCollaboration or window.TiptapCollaboration.default');
        }

        const Editor = tiptapBundle.Editor;
        const StarterKit = tiptapBundle.StarterKit;
        const Collaboration = tiptapBundle.Collaboration;
        const CollaborationCaret = tiptapBundle.CollaborationCaret;
        const Placeholder = tiptapBundle.Placeholder;
        const BubbleMenu = tiptapBundle.BubbleMenu;
        const FloatingMenu = tiptapBundle.FloatingMenu;
        const CustomTextAlign = tiptapBundle.CustomTextAlign;
        const IPFSVideo = tiptapBundle.IPFSVideo;
        const CustomImage = tiptapBundle.CustomImage; // Use CustomImage from bundle
        const Mention = tiptapBundle.Mention;
        const TableKit = tiptapBundle.TableKit;
        const CustomTableCell = tiptapBundle.CustomTableCell;
        const DragHandle = tiptapBundle.DragHandle;
        const CustomDropcursor = tiptapBundle.CustomDropcursor;
        const CustomHorizontalRule = tiptapBundle.CustomHorizontalRule;
        const Heading = tiptapBundle.Heading; // This is actually CustomHeading from bundle
        const CustomBlockquote = tiptapBundle.CustomBlockquote;
        const BlockquoteNestingFilter = tiptapBundle.BlockquoteNestingFilter;
        const BlockquoteAlignmentFilter = tiptapBundle.BlockquoteAlignmentFilter;
        const BulletList = tiptapBundle.BulletList;
        const OrderedList = tiptapBundle.OrderedList;
        const ListItem = tiptapBundle.ListItem;
        const Link = tiptapBundle.Link;
        const TextSelection = tiptapBundle.TextSelection;
        const Extension = tiptapBundle.Extension;
        const tippy = tiptapBundle.tippy;
        const renderToMarkdown = tiptapBundle.renderToMarkdown;
        const Plugin = tiptapBundle.Plugin;
        const PluginKey = tiptapBundle.PluginKey;
        const Subscript = tiptapBundle.Subscript;
        const Superscript = tiptapBundle.Superscript;

        if (!Editor || !StarterKit || !Collaboration || !Placeholder) {
            throw new Error('Required TipTap components missing from bundle and window');
        }

        // ‚úÖ BEST PRACTICE: Wait for Vue components to be ready
        await this.component.$nextTick();

        // ‚úÖ DEBUG: Log Y.js document state before creating editors

        // ‚úÖ TIPTAP BEST PRACTICE: Include CollaborationCaret when WebSocket is available
        // This follows TipTap's recommendation for read-only users with cursor visibility
        const isEditable = !this.component.isReadOnlyMode;

        // Build body extensions array - single editor only
        const bodyExtensions = [
            // Filtering extension - must be early to catch transactions
            BlockquoteNestingFilter,
            BlockquoteAlignmentFilter,
            StarterKit.configure({
                undoRedo: false,     // ‚úÖ v3: Disable UndoRedo (included in StarterKit) when using Collaboration
                dropcursor: false,   // ‚úÖ Disable default dropcursor to use CustomDropcursor
                horizontalRule: false, // ‚úÖ Disable built-in HR to use custom draggable version
                heading: false,      // ‚úÖ Disable built-in heading to use CustomHeading with blockquote-aware input rules
                blockquote: false    // ‚úÖ Disable built-in blockquote to use CustomBlockquote with alignment restrictions
            }),
            Collaboration.configure({
                document: yjsDoc,
                field: 'body'
            }),
            Placeholder.configure({
                placeholder: 'Start writing your content...'
            }),
            CustomTextAlign.configure({
                types: ['heading', 'paragraph', 'tableCell', 'tableHeader'],
                alignments: ['left', 'center', 'right', 'justify'],
            }),
            IPFSVideo,
            CustomImage.configure({
                inline: false,  // Block-level images for proper markdown
                HTMLAttributes: {
                    class: 'content-image'
                    // Removed draggable: false to allow dragging in table cells
                },
                onImageClick: (pos, attrs) => {
                    // TipTap best practice: Use callback passed to extension
                    this.component.editImage(pos, attrs);
                }
            }),
            Mention.configure({
                HTMLAttributes: {
                    class: 'mention',
                    target: '_blank',
                },
                renderHTML({ node }) {
                    return ['a', {
                        href: `/@${node.attrs.id}`,
                        class: 'mention',
                        target: '_blank'
                    }, `@${node.attrs.label ?? node.attrs.id}`];
                },
                suggestion: createMentionSuggestion()
            }),
            TableKit && TableKit.configure({
                // Disable tableCell since we're providing our own custom version
                tableCell: false,
                // tableHeader uses the default from TableKit
                // Configure the table extension within the kit
                table: {
                    resizable: false,              // No column resizing
                    handleWidth: 0,               // No resize handles
                    allowTableNodeSelection: false // Simple selection only
                }
            }),
            // ‚úÖ TIPTAP BEST PRACTICE: Add CustomTableCell with nested table prevention
            CustomTableCell && CustomTableCell,
            // ‚úÖ Add CustomDropcursor that controls visibility when dragging tables
            CustomDropcursor && CustomDropcursor.configure({
                color: '#5C94FE',
                width: 2,
                class: 'custom-dropcursor'
            }),
            // ‚úÖ Add CustomHorizontalRule with draggable functionality
            CustomHorizontalRule && CustomHorizontalRule,
            // ‚úÖ Add CustomHeading that prevents input rules inside blockquotes
            Heading && Heading,
            // ‚úÖ Add CustomBlockquote with alignment restrictions and input rule handling
            CustomBlockquote && CustomBlockquote,
            // ‚úÖ Add Subscript and Superscript extensions
            Subscript && Subscript,
            Superscript && Superscript,
            DragHandle && DragHandle.configure({
                render: () => {
                    const element = document.createElement('div');
                    element.classList.add('ProseMirror-drag-handle');
                    element.setAttribute('draggable', 'true');
                    element.setAttribute('data-drag-handle', '');
                    return element;
                },
                onNodeChange: ({ node }) => {
                    // Track which node the drag handle is hovering over
                    // Store in both locations for compatibility with CustomDropcursor
                    this.component.dragHandleHoveredNode = node;
                    if (window.dluxEditor) {
                        window.dluxEditor.dragHandleHoveredNode = node;
                    }
                },
                tippyOptions: {
                    duration: 0,
                    placement: 'left',
                    hideOnClick: false,
                    theme: 'drag-handle'
                }
            }),
        ];

        // ‚úÖ BUBBLE MENU: Add after DOM ref check to ensure element exists
        if (this.component.$refs.bubbleMenu) {
            bodyExtensions.push(
                BubbleMenu.configure({
                    element: this.component.$refs.bubbleMenu,
                    shouldShow: ({ editor, from, to }) => {
                        // Check if editor is destroyed or component is unmounting
                        if (!editor || editor.isDestroyed || this.component.isUnmounting) {
                            return false;
                        }
                        // Only show when text is selected and not in readonly mode
                        return !this.component.isReadOnlyMode && from !== to
                    },
                    updateDelay: 250,  // Increased delay to reduce positioning calls
                    tippyOptions: {
                        onHide: () => {
                            // Cleanup when bubble menu hides
                            return true;
                        },
                        onDestroy: () => {
                            // Ensure positioning calculations are cancelled
                            return true;
                        }
                    }
                })
            );
        } else {
            console.warn('‚ö†Ô∏è BubbleMenu DOM ref not available, skipping bubble menu');
        }

        // ‚úÖ FLOATING MENU: Add extension with element configuration
        if (FloatingMenu && this.component.$refs.floatingMenu) {
            bodyExtensions.push(FloatingMenu.configure({
                element: this.component.$refs.floatingMenu,
                tippyOptions: {
                    placement: 'top-start',
                    duration: 100,
                },
                shouldShow: ({ editor, view, state, oldState }) => {
                    // Don't show until editor has been focused at least once
                    if (!this.component.editorHasBeenFocused) return false;

                    // Don't show in readonly mode
                    if (this.component.isReadOnlyMode) return false;

                    // Only show on empty paragraphs
                    const { $from } = state.selection;
                    const node = $from.parent;

                    // Check if it's an empty paragraph
                    if (node.type.name !== 'paragraph' || node.content.size !== 0) {
                        return false;
                    }

                    // Check if paragraph is inside a list or blockquote
                    for (let d = $from.depth; d > 0; d--) {
                        const parentNode = $from.node(d);
                        if (['bulletList', 'orderedList', 'blockquote'].includes(parentNode.type.name)) {
                            return false;
                        }
                    }

                    return true;
                }
            }));
        }

        // ‚úÖ DEBUG: Log Y.js document state before creating editor

        // ‚úÖ TIPTAP BEST PRACTICE: Add CollaborationCaret for all users (server will handle read-only awareness)
        if (webSocketProvider && CollaborationCaret) {
            const cursorConfig = {
                provider: webSocketProvider,
                user: {
                    name: this.component.username || 'Anonymous',
                    color: (typeof this.component.getUserColor === 'function') ? this.component.getUserColor() : '#3498db'
                }
            };

            bodyExtensions.push(CollaborationCaret.configure(cursorConfig));
        }

        // ‚úÖ SPK DRIVE DROP HANDLER: Add extension for drag and drop from SPK Drive
        if (Extension) {
            const editorFactory = this;
            bodyExtensions.push(Extension.create({
                name: 'spkDriveDrop',
                addProseMirrorPlugins() {
                    return [editorFactory.createSpkDriveDropPlugin(this.editor)];
                }
            }));
        }

        // ‚úÖ CRITICAL: Wait for Vue components to be ready
        // ‚úÖ COMPLIANCE: Use proper Vue lifecycle
        await this.component.$nextTick();

        let bodyEditor;
        try {
            // Filter out any null/undefined extensions
            const validExtensions = bodyExtensions.filter(ext => ext != null);

            bodyEditor = new Editor({
                element: this.component.$refs.bodyEditor,
                extensions: validExtensions,
                editable: isEditable,
                autofocus: false, // Prevent TextSelection warning on initialization
                // ‚úÖ v3 REMOVED: immediatelyRender is not a valid TipTap v3 option
                // ‚úÖ v3 PERFORMANCE: Enable shouldRerenderOnTransaction for better collaborative performance
                shouldRerenderOnTransaction: false,
                // ‚úÖ v3 ERROR HANDLING: Enable parseOptions for better error recovery
                parseOptions: {
                    preserveWhitespace: 'full'
                },
                onCreate: ({ editor }) => {
                    // ‚úÖ FIX: Track editor creation time to prevent initialization triggers
                    this.component.editorCreatedAt = Date.now();

                    // ‚úÖ DEBUG: Check editor state immediately after creation

                    // ‚úÖ DRAG HANDLE: Now handled via CSS :hover rules in tiptap-editor.css
                    // The drag handle is hidden by default and shown on editor hover

                    /* Removed complex JavaScript management - using CSS instead
                    const setupDragHandleVisibility = () => {
                        if (DEBUG) console.log('üîç Setting up drag handle visibility management');
                        
                        // Check for existing drag handles immediately
                        const initialHandles = document.querySelectorAll('.ProseMirror-drag-handle');
                        if (DEBUG) console.log('üîç Initial drag handles found:', initialHandles.length);
                        
                        // Function to activate drag handles
                        const activateDragHandles = () => {
                            const dragHandles = document.querySelectorAll('.ProseMirror-drag-handle');
                            if (DEBUG) console.log('üîç Activating drag handles, found:', dragHandles.length);
                            
                            dragHandles.forEach((handle, index) => {
                                // Add class to handle
                                handle.classList.add('drag-handle-activated');
                                
                                // Also try setting inline styles as backup
                                handle.style.opacity = '1';
                                handle.style.visibility = 'visible';
                                
                                // Also add to parent element if it exists
                                if (handle.parentElement) {
                                    handle.parentElement.classList.add('drag-handle-activated');
                                }
                                
                                if (DEBUG) console.log(`üîç Activated drag handle ${index + 1}:`, {
                                    classes: handle.className,
                                    parentClasses: handle.parentElement?.className,
                                    computedOpacity: window.getComputedStyle(handle).opacity,
                                    computedVisibility: window.getComputedStyle(handle).visibility
                                });
                            });
                            
                            return dragHandles.length > 0;
                        };
                        
                        // Hide handles immediately on initialization
                        hideDragHandles();
                        
                        // Function to hide drag handles initially
                        const hideDragHandles = () => {
                            const dragHandles = document.querySelectorAll('.ProseMirror-drag-handle');
                            dragHandles.forEach((handle) => {
                                // Force hide with inline styles
                                handle.style.opacity = '0';
                                handle.style.visibility = 'hidden';
                                // Remove activated class if present
                                handle.classList.remove('drag-handle-activated');
                                if (handle.parentElement) {
                                    handle.parentElement.classList.remove('drag-handle-activated');
                                }
                            });
                            return dragHandles.length;
                        };
                        
                        // Set up MutationObserver to catch dynamically added drag handles
                        const observer = new MutationObserver((mutations) => {
                            for (const mutation of mutations) {
                                for (const node of mutation.addedNodes) {
                                    if (node.nodeType === 1 && 
                                        (node.classList?.contains('ProseMirror-drag-handle') ||
                                         node.querySelector?.('.ProseMirror-drag-handle'))) {
                                        if (DEBUG) console.log('üîç New drag handle detected via MutationObserver');
                                        // Hide it immediately using microtask for DOM updates
                                        Promise.resolve().then(() => {
                                            const hidden = hideDragHandles();
                                            if (DEBUG) console.log('üîç Hid', hidden, 'drag handles on creation');
                                        });
                                        return;
                                    }
                                }
                            }
                        });
                        
                        // Start observing
                        observer.observe(editor.view.dom.parentElement || document.body, {
                            childList: true,
                            subtree: true
                        });
                        
                        // Track if we've shown handles
                        let handlesShown = false;
                        
                        // Set up hover listener
                        const handleFirstHover = () => {
                            if (DEBUG) console.log('üîç Editor hover detected');
                            if (!handlesShown) {
                                const activated = activateDragHandles();
                                if (activated) {
                                    handlesShown = true;
                                    if (DEBUG) console.log('üîç Drag handles shown on first hover');
                                }
                            }
                        };
                        
                        editor.view.dom.addEventListener('mouseenter', handleFirstHover);
                        
                        // Clean up observer on editor destroy
                        editor.on('destroy', () => {
                            observer.disconnect();
                        });
                    };
                    
                    // Execute setup
                    setupDragHandleVisibility();
                    */

                    // ‚úÖ FIX: Set editorInitialized flag using nextTick to ensure proper Vue lifecycle
                    // This ensures that initialization-triggered updates don't cause persistence
                    this.component.$nextTick(() => {
                        this.component.editorInitialized = true;

                        /**
                         * @event tiptap-editor-ready
                         * @description Notify external components that the TipTap editor is fully initialized
                         */
                        window.dispatchEvent(new CustomEvent('tiptap-editor-ready'));
                    });

                    // ‚úÖ STATE MONITORING: Track ProseMirror state for debugging
                    if (this.component.enableStateMonitoring) {
                    }

                    // ‚úÖ TIPTAP v3 COMPLIANCE: No setContent needed - TipTap starts empty by default
                    // Y.js will handle all content synchronization automatically

                    // Mark content as loaded for ContentStateManager
                    if (this.component.contentStateManager) {
                        this.component.contentStateManager.markContentLoaded('body');
                    }

                    // ‚úÖ REMOVED: Fragment checking code that interferes with TipTap
                    // The Collaboration extension will create and manage the body fragment
                    // Checking for fragments before TipTap initializes can cause conflicts

                },
                onUpdate: ({ editor, transaction }) => {
                    // ‚úÖ TIPTAP COMPLIANCE: Only UI state flags in onUpdate, no content access

                    // ‚úÖ STATE MONITORING: Log transaction details for debugging
                    if (this.component.enableStateMonitoring && transaction) {
                    }

                    // ‚úÖ CRITICAL FIX: Check both editor.isEditable AND component readonly mode
                    // This prevents any edit attempts during Y.js sync for read-only users
                    if (!editor.isEditable || this.component.isReadOnlyMode) {
                        // Read-only mode - do nothing on updates
                        return;
                    }

                    // ‚úÖ Skip if this is a remote transaction from Y.js
                    if (transaction.getMeta('y-sync')) {
                        return;
                    }

                    // ‚úÖ TipTap v3: Skip transactions from metadata updates
                    const origin = transaction.getMeta('y-origin');
                    if (origin === 'title-update' || origin === 'metadata-update' || origin === 'auto-naming' || origin === 'schema-init') {
                        return;
                    }

                    // ‚úÖ PREVENT UPDATE CONFLICTS: Skip updates while executing commands
                    if (this.component.isExecutingCommand) {
                        return;
                    }

                    // ‚úÖ FIX: Skip persistence triggers during editor initialization
                    // Check if this is an initialization update (no actual content changes)
                    if (!transaction.docChanged || transaction.steps.length === 0) {
                        return;
                    }

                    // ‚úÖ FIX: Additional check - skip if editor was just created (within 500ms)
                    const timeSinceCreation = Date.now() - (this.component.editorCreatedAt || 0);
                    if (timeSinceCreation < 500) {
                        // Check if this is just initialization content
                        const bodyText = editor.getText().trim();
                        if (!bodyText || bodyText.length === 0) {
                            return;
                        }
                    }

                    // ‚úÖ Track content changes for editor stabilization
                    this.component.lastContentChange = Date.now();

                    // ‚úÖ TIPTAP v3: Updates handled automatically by Collaboration extension

                    // ‚úÖ TIPTAP COMPLIANCE: Only process updates for editable documents
                    // ‚úÖ READ-ONLY PROTECTION: Block all save operations for read-only users
                    if (!this.component.isReadOnlyMode) {
                        // ‚úÖ FIX: Don't set intent flags for temporary documents until we verify content
                        if (!this.component.isTemporaryDocument || this.component.indexeddbProvider) {
                            // For persistent documents, always track changes
                            console.log('üîç BODY UPDATE - Setting hasUnsavedChanges:', {
                                isTemporary: this.component.isTemporaryDocument,
                                hasIndexedDB: !!this.component.indexeddbProvider,
                                isLoading: this.component.isLoadingDocument,
                                editorInitialized: this.component.editorInitialized
                            });
                            this.component.hasUnsavedChanges = true;
                            this.component.hasUserIntent = true;
                            // Call updateSaveStatus directly to ensure message shows
                            this.component.$nextTick(() => {
                                this.component.updateSaveStatus();
                            });
                        } else {
                            // For temporary documents, defer intent detection to content check
                            this.component.hasUnsavedChanges = true; // Track that something changed
                            // Don't set hasUserIntent yet - let content check determine this
                        }

                        // ‚úÖ FIX: Only trigger auto-save after editor is fully initialized
                        // This prevents false triggers during page load and document initialization
                        if (this.component.editorInitialized && !this.component.isLoadingDocument) {
                            this.component.debouncedUpdateContent();
                        } else {
                        }
                    }

                    // ‚úÖ TIPTAP BEST PRACTICE: Create IndexedDB persistence lazily when user shows REAL intent
                    if (this.component.isTemporaryDocument && !this.component.indexeddbProvider && !this.component.isCreatingPersistence) {
                        // ‚úÖ USER INTENT DETECTION: Use debounced real content check outside onUpdate
                        this.component.debouncedCheckUserIntentAndCreatePersistence();
                    }
                    // ‚ùå REMOVED: Body editor should NOT trigger title auto-save
                    // This was causing mismatched transaction errors

                    // ‚úÖ TEMP DOCUMENTS: No debounce needed (not yet persistent)
                },
                onFocus: ({ editor }) => {
                    // Track that editor has been focused
                    if (!this.component.editorHasBeenFocused) {
                        this.component.editorHasBeenFocused = true;
                        this.component.editorInteractionCount++;

                    }
                },
                onBeforeCreate: ({ editor }) => {
                    // ‚úÖ STATE MONITORING: Track editor lifecycle
                    if (this.component.enableStateMonitoring) {
                    }
                },
                onSelectionUpdate: ({ editor }) => {
                    // ‚úÖ TABLE STATE TRACKING: Update reactive property for CSS-based toolbar
                    const wasInTable = this.component.isInTable;
                    this.component.isInTable = editor.isActive('table');

                    // Increment counter to trigger computed property updates
                    this.component.selectionUpdateCounter++;

                    // Update toolbar position when entering a table or navigating within tables
                    if (this.component.isInTable) {
                        // Use double nextTick to ensure DOM is fully updated after table insertion
                        this.component.$nextTick(() => {
                            this.component.$nextTick(() => {
                                this.component.updateTableToolbarPosition();
                            });
                        });
                    }

                    // Log state changes for debugging
                    if (wasInTable !== this.component.isInTable) {
                    }

                    // ‚úÖ STATE MONITORING: Track selection changes
                    if (this.component.enableStateMonitoring) {
                        const selection = editor.state.selection;
                    }
                },
                onTransaction: ({ editor, transaction }) => {
                    // ‚úÖ STATE MONITORING: Detailed transaction tracking
                    if (this.component.enableStateMonitoring && transaction.docChanged) {
                    }
                }
            });
        } catch (error) {
            console.error('‚ùå Failed to create body editor:', error);
            // ‚úÖ ENHANCED ERROR TRACKING: Capture state at error time
            if (this.component.enableStateMonitoring) {
                console.error('üî¥ Editor creation error state:', {
                    yjsDocExists: !!yjsDoc,
                    yjsShareSize: Object.keys(yjsDoc?.share || {}).length,
                    domRefExists: !!this.component.$refs.bodyEditor,
                    errorType: error.constructor.name,
                    errorMessage: error.message,
                    errorStack: error.stack
                });
            }
            throw new Error(`Editor creation failed: ${error.message}`);
        }

        // ‚úÖ COMPLIANCE: Debug timeout removed - no content access in setTimeout

        // ‚úÖ Let TipTap handle all initialization internally
        // No need to wait or check for fragments

        // ‚úÖ CRITICAL: Use Vue's nextTick to coordinate with TipTap initialization
        // This ensures editor is properly integrated with Vue's reactivity system
        await this.component.$nextTick();

        // ‚úÖ TIPTAP v3 BEST PRACTICE: DO NOT check Y.js fragments directly
        // The Collaboration extension manages all Y.js synchronization internally
        // Checking fragments can interfere with TipTap's initialization and cause "mismatched transaction" errors

        return { bodyEditor };
    }

    async createTier2Editors(yjsDoc, webSocketProvider) {
        // ‚úÖ TIPTAP BEST PRACTICE: Full collaborative editors with cursors

        // ‚úÖ BYPASS BUNDLE VARIABLE - Access directly from window for Tier 2
        if (!window.TiptapCollaboration) {
            throw new Error('window.TiptapCollaboration not available for Tier 2');
        }

        // ‚úÖ SMART ACCESS: Try direct access first, then default export (Tier 2)
        const tiptapBundle = window.TiptapCollaboration.Editor ? window.TiptapCollaboration : window.TiptapCollaboration.default;

        if (!tiptapBundle) {
            throw new Error('TipTap components not found for Tier 2');
        }

        const Editor = tiptapBundle.Editor;
        const StarterKit = tiptapBundle.StarterKit;
        const Collaboration = tiptapBundle.Collaboration;
        const CollaborationCaret = tiptapBundle.CollaborationCaret;
        const Placeholder = tiptapBundle.Placeholder;
        const BubbleMenu = tiptapBundle.BubbleMenu;
        const FloatingMenu = tiptapBundle.FloatingMenu;
        const CustomTextAlign = tiptapBundle.CustomTextAlign;
        const IPFSVideo = tiptapBundle.IPFSVideo;
        const CustomImage = tiptapBundle.CustomImage; // Use CustomImage from bundle
        const Mention = tiptapBundle.Mention;
        const TableKit = tiptapBundle.TableKit;
        const CustomTableCell = tiptapBundle.CustomTableCell;
        const DragHandle = tiptapBundle.DragHandle;
        const CustomDropcursor = tiptapBundle.CustomDropcursor;
        const CustomHorizontalRule = tiptapBundle.CustomHorizontalRule;
        const Heading = tiptapBundle.Heading; // This is actually CustomHeading from bundle
        const CustomBlockquote = tiptapBundle.CustomBlockquote;
        const BlockquoteNestingFilter = tiptapBundle.BlockquoteNestingFilter;
        const BlockquoteAlignmentFilter = tiptapBundle.BlockquoteAlignmentFilter;
        const BulletList = tiptapBundle.BulletList;
        const OrderedList = tiptapBundle.OrderedList;
        const ListItem = tiptapBundle.ListItem;
        const Link = tiptapBundle.Link;
        const TextSelection = tiptapBundle.TextSelection;
        const Extension = tiptapBundle.Extension;
        const tippy = tiptapBundle.tippy;
        const Subscript = tiptapBundle.Subscript;
        const Superscript = tiptapBundle.Superscript;

        if (!Editor || !StarterKit || !Collaboration) {
            throw new Error('Required TipTap components missing from bundle and window');
        }

        // ‚úÖ CRITICAL: Wait for Vue components to be ready
        await this.component.$nextTick();

        // Build body extensions array - single editor only (like Tier 1)
        const bodyExtensions = [
            // Filtering extension - must be early to catch transactions
            BlockquoteNestingFilter,
            BlockquoteAlignmentFilter,
            StarterKit.configure({
                undoRedo: false,     // ‚úÖ v3: Disable UndoRedo (included in StarterKit) when using Collaboration
                dropcursor: false,   // ‚úÖ Disable default dropcursor to use CustomDropcursor
                horizontalRule: false, // ‚úÖ Disable built-in HR to use custom draggable version
                heading: false,      // ‚úÖ Disable built-in heading to use CustomHeading with blockquote-aware input rules
                blockquote: false    // ‚úÖ Disable built-in blockquote to use CustomBlockquote with alignment restrictions
            }),
            Collaboration.configure({
                document: yjsDoc,
                field: 'body'
            }),
            Placeholder.configure({
                placeholder: 'Start writing your content...'
            }),
            CustomTextAlign.configure({
                types: ['heading', 'paragraph', 'tableCell', 'tableHeader'],
                alignments: ['left', 'center', 'right', 'justify'],
            }),
            IPFSVideo,
            CustomImage.configure({
                inline: false,  // Block-level images for proper markdown
                HTMLAttributes: {
                    class: 'content-image'
                    // Removed draggable: false to allow dragging in table cells
                },
                onImageClick: (pos, attrs) => {
                    // TipTap best practice: Use callback passed to extension
                    this.component.editImage(pos, attrs);
                }
            }),
            Mention.configure({
                HTMLAttributes: {
                    class: 'mention',
                    target: '_blank',
                },
                renderHTML({ node }) {
                    return ['a', {
                        href: `/@${node.attrs.id}`,
                        class: 'mention',
                        target: '_blank'
                    }, `@${node.attrs.label ?? node.attrs.id}`];
                },
                suggestion: createMentionSuggestion()
            }),
            TableKit && TableKit.configure({
                // Disable tableCell since we're providing our own custom version
                tableCell: false,
                // tableHeader uses the default from TableKit
                // Configure the table extension within the kit
                table: {
                    resizable: false,              // No column resizing
                    handleWidth: 0,               // No resize handles
                    allowTableNodeSelection: false // Simple selection only
                }
            }),
            // ‚úÖ TIPTAP BEST PRACTICE: Add CustomTableCell with nested table prevention
            CustomTableCell && CustomTableCell,
            // ‚úÖ Add CustomDropcursor that controls visibility when dragging tables
            CustomDropcursor && CustomDropcursor.configure({
                color: '#5C94FE',
                width: 2,
                class: 'custom-dropcursor'
            }),
            // ‚úÖ Add CustomHorizontalRule with draggable functionality
            CustomHorizontalRule && CustomHorizontalRule,
            // ‚úÖ Add CustomHeading that prevents input rules inside blockquotes
            Heading && Heading,
            // ‚úÖ Add CustomBlockquote with alignment restrictions and input rule handling
            CustomBlockquote && CustomBlockquote,
            // ‚úÖ Add Subscript and Superscript extensions
            Subscript && Subscript,
            Superscript && Superscript,
            DragHandle && DragHandle.configure({
                render: () => {
                    const element = document.createElement('div');
                    element.classList.add('ProseMirror-drag-handle');
                    element.setAttribute('draggable', 'true');
                    element.setAttribute('data-drag-handle', '');
                    return element;
                },
                onNodeChange: ({ node }) => {
                    // Track which node the drag handle is hovering over
                    // Store in both locations for compatibility with CustomDropcursor
                    this.component.dragHandleHoveredNode = node;
                    if (window.dluxEditor) {
                        window.dluxEditor.dragHandleHoveredNode = node;
                    }
                },
                tippyOptions: {
                    duration: 0,
                    placement: 'left',
                    offset: [0, -10], // Negative distance moves handle further left from content
                    hideOnClick: false,
                    theme: 'drag-handle'
                }
            }),
        ];

        // ‚úÖ BUBBLE MENU: Add after DOM ref check to ensure element exists
        if (this.component.$refs.bubbleMenu) {
            bodyExtensions.push(
                BubbleMenu.configure({
                    element: this.component.$refs.bubbleMenu,
                    shouldShow: ({ editor, from, to }) => {
                        // Check if editor is destroyed or component is unmounting
                        if (!editor || editor.isDestroyed || this.component.isUnmounting) {
                            return false;
                        }
                        // Only show when text is selected and not in readonly mode
                        return !this.component.isReadOnlyMode && from !== to
                    },
                    updateDelay: 250,  // Increased delay to reduce positioning calls
                    tippyOptions: {
                        onHide: () => {
                            // Cleanup when bubble menu hides
                            return true;
                        },
                        onDestroy: () => {
                            // Ensure positioning calculations are cancelled
                            return true;
                        }
                    }
                })
            );
        } else {
            console.warn('‚ö†Ô∏è BubbleMenu DOM ref not available, skipping bubble menu');
        }

        // ‚úÖ FLOATING MENU: Add extension with element configuration
        if (FloatingMenu && this.component.$refs.floatingMenu) {
            bodyExtensions.push(FloatingMenu.configure({
                element: this.component.$refs.floatingMenu,
                tippyOptions: {
                    placement: 'top-start',
                    duration: 100,
                },
                shouldShow: ({ editor, view, state, oldState }) => {
                    // Don't show until editor has been focused at least once
                    if (!this.component.editorHasBeenFocused) return false;

                    // Don't show in readonly mode
                    if (this.component.isReadOnlyMode) return false;

                    // Only show on empty paragraphs
                    const { $from } = state.selection;
                    const node = $from.parent;

                    // Check if it's an empty paragraph
                    if (node.type.name !== 'paragraph' || node.content.size !== 0) {
                        return false;
                    }

                    // Check if paragraph is inside a list or blockquote
                    for (let d = $from.depth; d > 0; d--) {
                        const parentNode = $from.node(d);
                        if (['bulletList', 'orderedList', 'blockquote'].includes(parentNode.type.name)) {
                            return false;
                        }
                    }

                    return true;
                }
            }));
        }

        // ‚úÖ TIPTAP BEST PRACTICE: Add CollaborationCaret for all users (server will handle read-only awareness)
        if (webSocketProvider && CollaborationCaret) {
            const cursorConfig = {
                provider: webSocketProvider,
                user: {
                    name: this.component.username || 'Anonymous',
                    color: (typeof this.component.getUserColor === 'function') ? this.component.getUserColor() : '#3498db'
                }
            };

            bodyExtensions.push(CollaborationCaret.configure(cursorConfig));
        }

        // ‚úÖ SPK DRIVE DROP HANDLER: Add extension for drag and drop from SPK Drive
        if (Extension) {
            const editorFactory = this;
            bodyExtensions.push(Extension.create({
                name: 'spkDriveDrop',
                addProseMirrorPlugins() {
                    return [editorFactory.createSpkDriveDropPlugin(this.editor)];
                }
            }));
        }

        // ‚úÖ CRITICAL FIX: Calculate editable state based on current permissions
        const isEditable = !this.component.isReadOnlyMode;

        // ‚úÖ COMPLIANCE: Use proper Vue lifecycle - DOM should be ready  
        await this.component.$nextTick();

        // Filter out any null/undefined extensions
        const validExtensions = bodyExtensions.filter(ext => ext != null);

        const bodyEditor = new Editor({
            element: this.component.$refs.bodyEditor,
            extensions: validExtensions,
            editable: isEditable,
            autofocus: false, // Prevent TextSelection warning on initialization
            // ‚úÖ REMOVED: content parameter - let Y.js handle content via Collaboration extension
            // ‚úÖ v3 REMOVED: immediatelyRender is not a valid TipTap v3 option
            // ‚úÖ v3 PERFORMANCE: Enable shouldRerenderOnTransaction for better collaborative performance
            shouldRerenderOnTransaction: false,
            // ‚úÖ v3 ERROR HANDLING: Enable parseOptions for better error recovery
            parseOptions: {
                preserveWhitespace: 'full'
            },
            onCreate: ({ editor }) => {
                // ‚úÖ FIX: Track editor creation time to prevent initialization triggers
                this.component.editorCreatedAt = Date.now();

                // ‚úÖ DRAG HANDLE: Now handled via CSS :hover rules in tiptap-editor.css
                // The drag handle is hidden by default and shown on editor hover

                // ‚úÖ FIX: Set editorInitialized flag using nextTick to ensure proper Vue lifecycle
                this.component.$nextTick(() => {
                    this.component.editorInitialized = true;

                    /**
                     * @event tiptap-editor-ready
                     * @description Notify external components that the TipTap editor is fully initialized
                     */
                    window.dispatchEvent(new CustomEvent('tiptap-editor-ready'));
                });

                /* Removed complex JavaScript management - using CSS instead
                const setupDragHandleVisibility = () => {
                    if (DEBUG) console.log('üîç [Tier 2] Setting up drag handle visibility management');
                    
                    // Check for existing drag handles immediately
                    const initialHandles = document.querySelectorAll('.ProseMirror-drag-handle');
                    if (DEBUG) console.log('üîç [Tier 2] Initial drag handles found:', initialHandles.length);
                    
                    // Function to hide drag handles initially
                    const hideDragHandles = () => {
                        const dragHandles = document.querySelectorAll('.ProseMirror-drag-handle');
                        dragHandles.forEach((handle) => {
                            // Force hide with inline styles
                            handle.style.opacity = '0';
                            handle.style.visibility = 'hidden';
                            // Remove activated class if present
                            handle.classList.remove('drag-handle-activated');
                            if (handle.parentElement) {
                                handle.parentElement.classList.remove('drag-handle-activated');
                            }
                        });
                        return dragHandles.length;
                    };
                    
                    // Function to activate drag handles
                    const activateDragHandles = () => {
                        const dragHandles = document.querySelectorAll('.ProseMirror-drag-handle');
                        if (DEBUG) console.log('üîç [Tier 2] Activating drag handles, found:', dragHandles.length);
                        
                        dragHandles.forEach((handle, index) => {
                            // Add class to handle
                            handle.classList.add('drag-handle-activated');
                            
                            // Also try setting inline styles as backup
                            handle.style.opacity = '1';
                            handle.style.visibility = 'visible';
                            
                            // Also add to parent element if it exists
                            if (handle.parentElement) {
                                handle.parentElement.classList.add('drag-handle-activated');
                            }
                            
                            if (DEBUG) console.log(`üîç [Tier 2] Activated drag handle ${index + 1}:`, {
                                classes: handle.className,
                                parentClasses: handle.parentElement?.className,
                                computedOpacity: window.getComputedStyle(handle).opacity,
                                computedVisibility: window.getComputedStyle(handle).visibility
                            });
                        });
                        
                        return dragHandles.length > 0;
                    };
                    
                    // Hide handles immediately on initialization
                    hideDragHandles();
                    
                    // Set up MutationObserver to catch dynamically added drag handles
                    const observer = new MutationObserver((mutations) => {
                        for (const mutation of mutations) {
                            for (const node of mutation.addedNodes) {
                                if (node.nodeType === 1 && 
                                    (node.classList?.contains('ProseMirror-drag-handle') ||
                                     node.querySelector?.('.ProseMirror-drag-handle'))) {
                                    if (DEBUG) console.log('üîç [Tier 2] New drag handle detected via MutationObserver');
                                    // Hide it immediately using microtask for DOM updates
                                    Promise.resolve().then(() => {
                                        const hidden = hideDragHandles();
                                        if (DEBUG) console.log('üîç [Tier 2] Hid', hidden, 'drag handles on creation');
                                    });
                                    return;
                                }
                            }
                        }
                    });
                    
                    // Start observing
                    observer.observe(editor.view.dom.parentElement || document.body, {
                        childList: true,
                        subtree: true
                    });
                    
                    // Track if we've shown handles
                    let handlesShown = false;
                    
                    // Set up hover listener
                    const handleFirstHover = () => {
                        if (DEBUG) console.log('üîç [Tier 2] Editor hover detected');
                        if (!handlesShown) {
                            const activated = activateDragHandles();
                            if (activated) {
                                handlesShown = true;
                                if (DEBUG) console.log('üîç [Tier 2] Drag handles shown on first hover');
                            }
                        }
                    };
                    
                    editor.view.dom.addEventListener('mouseenter', handleFirstHover);
                    
                    // Clean up observer on editor destroy
                    editor.on('destroy', () => {
                        observer.disconnect();
                    });
                };
                
                // Execute setup
                setupDragHandleVisibility();
                */
            },
            onFocus: ({ editor }) => {
                // Track that editor has been focused
                if (!this.component.editorHasBeenFocused) {
                    this.component.editorHasBeenFocused = true;
                    this.component.editorInteractionCount++;

                }
            },
            onUpdate: () => {
                // ‚úÖ TIPTAP COMPLIANCE: Only UI state flags in onUpdate, no content access

                // ‚úÖ TIPTAP COMPLIANCE: Use synchronous permission check
                if (!this.component.isReadOnlyMode) {
                    this.component.hasUnsavedChanges = true;
                    this.component.hasUserIntent = true;

                    // ‚úÖ FIX: Show save indicator immediately (same as Tier 1)
                    this.component.$nextTick(() => {
                        this.component.updateSaveStatus();
                    });

                    this.component.debouncedUpdateContent();

                    // ‚úÖ PERFORMANCE: Tier 2 editors are always for stable documents
                    this.component.clearUnsavedAfterSync();
                }
            },
            onSelectionUpdate: ({ editor }) => {
                // ‚úÖ TABLE STATE TRACKING: Update reactive property for CSS-based toolbar
                const wasInTable = this.component.isInTable;
                this.component.isInTable = editor.isActive('table');

                // Increment counter to trigger computed property updates
                this.component.selectionUpdateCounter++;

                // Update toolbar position whenever table state changes or we're in a table
                if (this.component.isInTable && (!wasInTable || this.component.isInTable)) {
                    // Always update position when in a table to handle table-to-table navigation
                    this.component.$nextTick(() => {
                        this.component.updateTableToolbarPosition();
                    });
                }

                // Log state changes for debugging
                if (wasInTable !== this.component.isInTable) {
                }
            }
        });

        // ‚úÖ CRITICAL: Use Vue's nextTick to coordinate with TipTap initialization
        // This ensures editor is properly integrated with Vue's reactivity system
        await this.component.$nextTick();

        // ‚úÖ CRITICAL: Wait for TipTap Collaboration extension to create Y.js fragments
        // This is essential for TipTap v3 to prevent "mismatched transaction" errors
        // ‚úÖ TIPTAP v3 COMPLIANCE: TipTap Collaboration extension creates fragments automatically
        // No need to check for fragment existence - trust TipTap to handle this

        return { bodyEditor };
    }

    /**
     * Create SPK Drive drop handler plugin
     * Handles drag and drop of files from SPK Drive into the editor
     */
    createSpkDriveDropPlugin(editor) {
        const Plugin = window.TiptapCollaboration?.Plugin || window.TiptapCollaboration?.default?.Plugin;
        const PluginKey = window.TiptapCollaboration?.PluginKey || window.TiptapCollaboration?.default?.PluginKey;

        if (!Plugin || !PluginKey) {
            console.warn('‚ö†Ô∏è Plugin or PluginKey not available from TipTap bundle');
            return null;
        }

        return new Plugin({
            key: new PluginKey('spkDriveDrop'),
            props: {
                handleDrop: (view, event) => {
                    // Check if this is an SPK Drive file drop
                    const contractId = event.dataTransfer.getData("contractid");
                    if (!contractId) return false;

                    // Check for single file (backward compatibility)
                    const singleFileId = event.dataTransfer.getData("fileid");

                    // Check for multiple files
                    const itemIdsJson = event.dataTransfer.getData("itemids");

                    if (!singleFileId && !itemIdsJson) return false;

                    event.preventDefault();

                    // Get drop position
                    const coords = { left: event.clientX, top: event.clientY };
                    const pos = view.posAtCoords(coords);
                    if (!pos) return false;

                    // Handle single file drop
                    if (singleFileId) {
                        this.handleSpkFileInsert(editor, pos.pos, singleFileId, contractId);
                        return true;
                    }

                    // Handle multiple files drop
                    if (itemIdsJson) {
                        try {
                            const itemIds = JSON.parse(itemIdsJson);
                            // Filter out folders (items starting with "folder-")
                            const fileIds = itemIds.filter(id => !id.startsWith('folder-'));

                            if (fileIds.length === 0) return false;

                            // Insert files at drop position
                            let currentPos = pos.pos;
                            fileIds.forEach((fileId) => {
                                this.handleSpkFileInsert(editor, currentPos, fileId, contractId);
                                // For subsequent files, append at the end
                                currentPos = editor.state.doc.content.size;
                            });

                            return true;
                        } catch (error) {
                            console.error('Error parsing itemids:', error);
                            return false;
                        }
                    }

                    return false;
                }
            }
        });
    }

    /**
     * Handle SPK file insertion at drop position
     */
    handleSpkFileInsert(editor, pos, fileId, contractId) {
        try {
            // Get SPK Drive component reference
            const spkDrive = window.spkDriveComponent;
            if (!spkDrive || !spkDrive.newMeta) {
                console.warn('‚ö†Ô∏è SPK Drive component not available');
                return;
            }

            // Get file metadata
            const fileData = spkDrive.newMeta[contractId]?.[fileId];
            if (!fileData) {
                console.warn('‚ö†Ô∏è File metadata not found:', { contractId, fileId });
                return;
            }

            const fileName = fileData.name || fileId;
            const fileType = fileData.type || '';
            const url = `https://ipfs.dlux.io/ipfs/${fileId}`;

            // SPK Drive appends folder depth (.0 for root, .1 for subfolder, etc.)
            // Extract the actual file type without the folder depth suffix
            const cleanFileType = fileType.split('.')[0];

            // Determine if it's a video or image
            const isVideo = fileName.match(/\.(mp4|webm|ogg|m3u8|mov|avi|mkv|m4v|3gp|3g2)$/i) ||
                fileType.match(/^video\//i) ||
                cleanFileType === 'm3u8' ||
                ['mp4', 'webm', 'ogg', 'm3u8', 'mov', 'avi', 'mkv', 'm4v', '3gp', '3g2'].includes(cleanFileType);
            const isImage = fileName.match(/\.(jpg|jpeg|png|gif|webp|svg|bmp|ico|tiff|tif|avif|jfif|heic|heif)$/i) ||
                fileType.match(/^image\//i) ||
                ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'bmp', 'ico', 'tiff', 'tif', 'avif', 'jfif', 'heic', 'heif'].includes(cleanFileType);

            if (isVideo) {
                // Build video attributes
                const videoAttrs = {
                    src: url,
                    controls: true,
                    width: '100%',
                    height: 'auto',
                    crossorigin: 'anonymous'
                };

                // Only set type attributes for m3u8 which requires it
                if (fileName.endsWith('.m3u8') || cleanFileType === 'm3u8') {
                    videoAttrs.type = 'application/x-mpegURL';
                    videoAttrs['data-type'] = 'm3u8';
                    videoAttrs['data-mime-type'] = 'application/x-mpegURL';
                }

                // Insert video at drop position
                editor.chain()
                    .focus()
                    .insertContentAt(pos, {
                        type: 'ipfsvideo',
                        attrs: videoAttrs
                    })
                    .run();

            } else if (isImage) {
                // Insert image
                editor.chain()
                    .focus()
                    .insertContentAt(pos, {
                        type: 'image',
                        attrs: {
                            src: url,
                            alt: fileName,
                            title: fileName
                        }
                    })
                    .run();

            } else {
                console.warn('‚ö†Ô∏è Unsupported file type for drop:', fileName);
            }
        } catch (error) {
            console.error('‚ùå Error handling SPK file drop:', error);
        }
    }
}

/**
 * 5. SYNC MANAGER
 * Handle sync between TipTap ‚Üî Vue (NOT TipTap ‚Üî Y.js - that's automatic)
 * 
 * üö® CRITICAL ENFORCEMENT RULES:
 * ‚ùå NEVER sync content in onUpdate (no editor.getText() or getHTML())
 * ‚ùå NEVER manipulate Y.js XML fragments
 * ‚úÖ ONLY use onUpdate for flags and temp document promotion
 * ‚úÖ ONLY use editor.getText() in export/display methods
 * ‚úÖ Let TipTap Collaboration extension handle ALL Y.js ‚Üî TipTap sync
 */
class SyncManager {
    constructor(component) {
        this.component = component;
    }

    setupSyncListeners(editors, yjsDoc) {
        // ‚úÖ TIPTAP BEST PRACTICE: TipTap ‚Üí Y.js handled automatically by Collaboration extension
        // ‚úÖ TIPTAP BEST PRACTICE: Y.js ‚Üí TipTap handled automatically by Collaboration extension

        // ONLY handle: TipTap ‚Üí Vue reactive state (for UI)
        this.setupTipTapToVueSync(editors);

        // ‚úÖ NEW: Y.js config observers for document name changes (real-time collaboration)
        this.setupYjsConfigObservers(yjsDoc);

        // ONLY handle: Vue ‚Üí Parent component (for external integrations)
        this.setupVueToParentSync();
    }

    setupTipTapToVueSync(editors) {
        // ‚úÖ TIPTAP BEST PRACTICE: Use TipTap editor events, not Y.js manipulation
        // ‚ùå VIOLATION REMOVED: No content syncing in onUpdate (violates TipTap best practices)

        // titleEditor removed - using simple input field with debounced sync

        editors.bodyEditor.on('update', ({ editor }) => {
            // ‚úÖ READ-ONLY PROTECTION: Block all write operations for read-only users
            if (!this.component.isReadOnlyMode) {
                // ‚úÖ ONLY FLAGS: Update UI flags, never sync content
                this.component.hasUnsavedChanges = true;

            }

            // ‚úÖ TIPTAP COMPLIANCE: Memory monitoring works for all users (read-only safe)
            const textLength = editor.getText().length;
            if (textLength > 50000 && !this.component.memoryMonitorInterval) {
                this.component.startMemoryMonitoring();
            } else if (textLength < 30000 && this.component.memoryMonitorInterval) {
                this.component.stopMemoryMonitoring();
            }
        });

        // ‚ùå REMOVED: Direct Y.js XML fragment manipulation
        // ‚ùå REMOVED: Content syncing (this.component.content.title = editor.getText())
        // ‚úÖ CORRECT: TipTap Collaboration extension handles Y.js sync automatically
    }


    setupYjsConfigObservers(yjsDoc) {
        // ‚úÖ TIPTAP BEST PRACTICE: Robust Y.js observer lifecycle with proper cleanup
        try {
            // ‚úÖ BEST PRACTICE: Store observer reference for cleanup
            this.configObserver = (event) => {
                try {
                    // ‚úÖ PERFORMANCE: Use $nextTick for DOM-dependent updates only
                    if (!event || !event.changes || !event.changes.keys) return;

                    event.changes.keys.forEach((change, key) => {
                        // ‚úÖ Handle documentName changes (existing functionality)
                        if (key === 'documentName' && (change.action === 'update' || change.action === 'add')) {
                            const newDocumentName = ydocService.getConfig('documentName');

                            // ‚úÖ REACTIVITY: Update Vue reactive state first
                            if (this.component?.currentFile && newDocumentName) {
                                // ‚úÖ BEST PRACTICE: Batch reactive updates for performance
                                this.component.$nextTick(() => {
                                    try {
                                        this.component.currentFile.name = newDocumentName;
                                        this.component.currentFile.documentName = newDocumentName;
                                        this.component.currentFile.title = newDocumentName;

                                        // ‚úÖ PERFORMANCE: Update document metadata - caching handled internally
                                        if (this.component.currentFile.owner && this.component.currentFile.permlink) {
                                            documentService.updateDocumentName(
                                                this.component.currentFile,
                                                newDocumentName
                                            );
                                        }

                                        // ‚úÖ REACTIVITY: Update reactive property with proper timing
                                        if (typeof this.component.updateReactiveDocumentName === 'function') {
                                            this.component.updateReactiveDocumentName(newDocumentName);
                                        } else {
                                            console.warn('‚ö†Ô∏è updateReactiveDocumentName method not available on component');
                                            // ‚úÖ FALLBACK: Update reactive property directly
                                            this.component.reactiveDocumentName = newDocumentName;
                                        }

                                        // Already logged above, remove duplicate
                                    } catch (innerError) {
                                        console.error('‚ùå Error in Y.js config observer $nextTick callback:', innerError);
                                    }
                                });
                            }
                        }

                        // Title moved to metadata map

                        // ‚úÖ RECURSION FIX: Permlink now handled by metadata observer, not config
                        // Config observer should NOT handle permlink anymore
                    });
                } catch (error) {
                    console.error('‚ùå Error in Y.js config observer:', error);
                }
            };

            // ‚úÖ BEST PRACTICE: Attach observer with reference for cleanup
            this.configUnsubscribe = ydocService.observeConfig(this.configObserver);

            // ‚úÖ METADATA OBSERVER: Sync metadata changes for UI reactivity
            this.metadataObserver = (event) => {
                if (!this.component || !this.component.content) return;

                // Update content object for computed properties that still rely on it
                const tags = ydocService.getMetadata('tags') || [];
                const beneficiaries = ydocService.getMetadata('beneficiaries') || [];
                const permlink = ydocService.getMetadata('permlink') || '';

                // Update Vue reactive content object
                this.component.content.tags = tags;
                this.component.content.beneficiaries = [...beneficiaries]; // Create new array for content object
                this.component.content.permlink = permlink;

                // ‚úÖ RECURSION FIX: Do NOT update permlinkInput from metadata
                // permlinkInput is user input field - only sync reactive properties
                // This prevents the recursion loop entirely

                // ‚úÖ PROPER REACTIVITY: Update reactive properties for Vue to track
                this.component.reactiveTags = tags;

                // ‚úÖ VUE 3 BEST PRACTICE: Clear array first, then push new items
                // This ensures Vue 3 detects the change properly
                if (event.keysChanged.has('beneficiaries')) {

                    // Clear the array first
                    this.component.reactiveBeneficiaries.length = 0;

                    // Then push new items
                    beneficiaries.forEach(ben => {
                        this.component.reactiveBeneficiaries.push(ben);
                    });

                    // Use nextTick to log after DOM update
                    this.component.$nextTick(() => {
                    });
                } else {
                    // For other fields, use spread operator
                    this.component.reactiveBeneficiaries = [...beneficiaries];
                }
                // ‚úÖ REMOVED: reactivePermlink - not used, actualPermlink() computed handles display

                // Sync custom JSON to reactive property
                const customJson = ydocService.getMetadata('customJson') || {};
                this.component.reactiveCustomJson = { ...customJson }; // Create new object for Vue reactivity

                // Also sync custom JSON string for the editor
                if (event.keysChanged.has('customJson')) {
                    this.component.customJsonString = JSON.stringify(customJson, null, 2);
                    this.component.content.custom_json = customJson; // Sync for backward compatibility

                    // ‚úÖ Vue reactivity handles UI updates automatically

                    // ‚úÖ IFRAME INTEGRATION: Broadcast custom JSON changes to registered iframes
                    if (this.component.customJsonMessageHandler) {
                        this.component.customJsonMessageHandler.broadcastCustomJsonUpdate(customJson);
                    }
                }

                // ‚úÖ REACTIVE PATTERN: Sync comment options to reactive property
                const commentOptionsFromYjs = {
                    allowVotes: ydocService.getMetadata('allowVotes'),
                    allowCurationRewards: ydocService.getMetadata('allowCurationRewards'),
                    maxAcceptedPayout: ydocService.getMetadata('maxAcceptedPayout'),
                    percentHbd: ydocService.getMetadata('percentHbd')
                };
                
                console.log('üìù COMMENT OPTIONS: Loading from Y.js metadata', {
                    fromYjs: commentOptionsFromYjs,
                    keysChanged: Array.from(event.keysChanged),
                    hasCommentOptionsChanges: event.keysChanged.has('allowVotes') || 
                                            event.keysChanged.has('allowCurationRewards') || 
                                            event.keysChanged.has('maxAcceptedPayout') || 
                                            event.keysChanged.has('percentHbd')
                });
                
                this.component.reactiveCommentOptions = {
                    allowVotes: commentOptionsFromYjs.allowVotes !== false,
                    allowCurationRewards: commentOptionsFromYjs.allowCurationRewards !== false,
                    maxAcceptedPayout: commentOptionsFromYjs.maxAcceptedPayout === true,
                    percentHbd: commentOptionsFromYjs.percentHbd === true
                };
                
                console.log('üìù COMMENT OPTIONS: Set reactive properties', {
                    reactive: this.component.reactiveCommentOptions,
                    timestamp: Date.now()
                });

                // Also sync to non-reactive commentOptions for external API compatibility
                if (event.keysChanged.has('allowVotes')) {
                    this.component.commentOptions.allowVotes = ydocService.getMetadata('allowVotes') !== false;
                }
                if (event.keysChanged.has('allowCurationRewards')) {
                    this.component.commentOptions.allowCurationRewards = ydocService.getMetadata('allowCurationRewards') !== false;
                }
                if (event.keysChanged.has('maxAcceptedPayout')) {
                    this.component.commentOptions.maxAcceptedPayout = ydocService.getMetadata('maxAcceptedPayout') === true;
                }
                if (event.keysChanged.has('percentHbd')) {
                    this.component.commentOptions.percentHbd = ydocService.getMetadata('percentHbd') === true;
                }

                // ‚úÖ FIX: Handle permlink changes from remote users
                if (event.keysChanged.has('permlink')) {
                    const newPermlink = ydocService.getMetadata('permlink') || '';
                    // Only update if not currently updating from local user input
                    if (!this.component._isUpdatingPermlink) {
                        if (newPermlink === this.component.generatedPermlink) {
                            // Auto-generated permlink - clear input to show generated
                            this.component.permlinkInput = '';
                        } else if (newPermlink && newPermlink !== this.component.generatedPermlink) {
                            // Custom permlink - set input to show custom value
                            this.component.permlinkInput = newPermlink;
                        }
                    }
                }

                // ‚úÖ NEW: Handle title changes (moved from config to metadata)
                if (event.keysChanged.has('title')) {
                    const newTitle = ydocService.getMetadata('title') || '';
                    this.component.$nextTick(() => {
                        // ‚úÖ FIX: Only update title if we have a new value OR if the document is being loaded
                        // This prevents empty values from overwriting existing titles
                        if (newTitle !== undefined) {
                            console.log('üîç TITLE UPDATE:', {
                                from: this.component.titleInput,
                                to: newTitle,
                                isLoadingDocument: this.component.isLoadingDocument
                            });
                            this.component.titleInput = newTitle;
                        }

                        // ‚úÖ REMOVED: Don't set hasUserIntent here - let the general handler do it
                        // This ensures title behaves the same as other metadata fields
                    });
                }

                // ‚úÖ FIX: Set unsaved changes flags when metadata changes
                if (event.keysChanged.size > 0) {
                    // Only log significant changes, not every metadata field
                    const significantChanges = Array.from(event.keysChanged).filter(key => {
                        const keyChange = event.changes.keys.get(key);
                        return ['tags', 'beneficiaries', 'customJson'].includes(key) &&
                            keyChange && keyChange.action === 'add';
                    });

                    if (significantChanges.length > 0) {
                    }

                    // Only set flags if document is not temporary or already has persistence
                    // AND we're not in the middle of loading a document
                    // AND the editor has been fully initialized
                    if ((!this.component.isTemporaryDocument || this.component.indexeddbProvider) &&
                        !this.component.isLoadingDocument &&
                        this.component.editorInitialized) {
                        this.component.hasUnsavedChanges = true;
                        this.component.hasUserIntent = true;

                        // Trigger autosave
                        this.component.autoSave();
                    }
                }
            };

            this.metadataUnsubscribe = ydocService.observeMetadata(this.metadataObserver);

            // ‚úÖ PERMISSION BROADCAST OBSERVER: Listen for real-time permission changes
            this.permissionObserver = (event) => {
                try {
                    if (!event || !event.changes || !event.changes.keys) return;
                    if (!this.component) return;

                    event.changes.keys.forEach((change, key) => {
                        if (key.startsWith('update_') && change.action === 'add') {
                            const permissionUpdate = ydocService.getPermission(key);
                            if (permissionUpdate && permissionUpdate.broadcastType) {

                                // Check if this affects the current user
                                const currentUsername = this.component.username;
                                if (permissionUpdate.account === currentUsername) {
                                    this.handlePermissionBroadcast(permissionUpdate);
                                }
                            }
                        }
                    });
                } catch (error) {
                    console.error('‚ùå Error in Y.js permission observer:', error);
                }
            };

            this.permissionUnsubscribe = ydocService.observePermissions(this.permissionObserver);

            // ‚úÖ RECURSION FIX: Don't load initial permlink into permlinkInput
            // permlinkInput is user input only - metadata provides separate reactive value
            // Initial permlink display is handled by actualPermlink() computed property

            // Remove verbose setup logging

        } catch (error) {
            console.warn('‚ö†Ô∏è Failed to set up Y.js config observers:', error);
        }
    }

    cleanupYjsObservers(yjsDoc) {
        // ‚úÖ BEST PRACTICE: Proper observer cleanup to prevent memory leaks
        try {
            if (this.configUnsubscribe) {
                this.configUnsubscribe();
                this.configUnsubscribe = null;
                this.configObserver = null;
            }

            if (this.metadataUnsubscribe) {
                this.metadataUnsubscribe();
                this.metadataUnsubscribe = null;
                this.metadataObserver = null;
            }

            if (this.permissionUnsubscribe) {
                this.permissionUnsubscribe();
                this.permissionUnsubscribe = null;
                this.permissionObserver = null;
            }

        } catch (error) {
            console.warn('‚ö†Ô∏è Error cleaning up Y.js observers:', error);
        }
    }

    /**
     * ‚úÖ PERMISSION BROADCAST HANDLER: Process real-time permission changes
     * Called when permission updates are received via Y.js WebSocket broadcast
     */
    handlePermissionBroadcast(permissionUpdate) {
        try {
            const { account, permissionType, grantedBy, timestamp, broadcastType } = permissionUpdate;

            // ‚úÖ REAL-TIME PERMISSION UPDATE: Refresh permissions immediately
            this.component.$nextTick(async () => {
                try {
                    // Force refresh permissions from server
                    await this.component.checkPermissions();

                    // Show user notification about permission change
                    let message = '';
                    if (broadcastType === 'permission_granted') {
                        message = `@${grantedBy} granted you ${permissionType} access to this document`;
                    } else if (broadcastType === 'permission_revoked') {
                        message = `@${grantedBy} revoked your access to this document`;
                    }

                    if (message) {
                        // Show notification if notification system is available
                        if (this.component.showNotification) {
                            this.component.showNotification(message, broadcastType === 'permission_granted' ? 'success' : 'warning');
                        } else {
                        }
                    }

                    // ‚úÖ PERMISSION LEVEL CHANGE: Handle editor reconnection if needed
                    const newPermissionLevel = this.component.getUserPermissionLevel(this.component.currentFile);
                    const oldReadOnlyMode = this.component.isReadOnlyMode;

                    // If permission was revoked, handle immediate effects
                    if (broadcastType === 'permission_revoked') {
                        // Update permission level to trigger computed property recalculation
                        this.component.updateFilePermission(this.component.currentFile, this.component.getDefaultPermissionLevel());

                        // Permission caching is handled internally by getMasterPermissionForDocument
                        // Vue reactivity automatically handled by AuthStateManager's reactive state

                        // Disable editors immediately (isReadOnlyMode watcher will also handle this)
                        if (this.component.bodyEditor && !this.component.bodyEditor.isDestroyed) {
                            this.component.bodyEditor.setEditable(false);
                        }
                    }

                    // If permission was granted and user was previously read-only, enable editing
                    if (broadcastType === 'permission_granted' && oldReadOnlyMode) {
                        const canEdit = this.component.permissionService.canEditWithPermission(newPermissionLevel);
                        if (canEdit) {
                            // Update permission level to trigger computed property recalculation
                            this.component.updateFilePermission(this.component.currentFile, newPermissionLevel);

                            // Permission caching is handled internally by getMasterPermissionForDocument
                            // Vue reactivity automatically handled by AuthStateManager's reactive state

                            // Enable editors (isReadOnlyMode watcher will also handle this)
                            if (this.component.bodyEditor && !this.component.bodyEditor.isDestroyed) {
                                this.component.bodyEditor.setEditable(true);
                            }

                            // ‚úÖ WEBSOCKET RECONNECTION: Reconnect with new permission level for server validation
                            if (this.component.provider && this.component.lifecycleManager) {
                                await this.component.lifecycleManager.reconnectWebSocketForPermissionUpgrade();
                            }
                        }
                    }

                } catch (error) {
                    console.error('‚ùå Error processing permission broadcast:', error);
                }
            });

        } catch (error) {
            console.error('‚ùå Error in handlePermissionBroadcast:', error);
        }
    }

    debounce(func, wait) {
        let lastCallTime = 0;
        let animationFrame = null;
        
        return function executedFunction(...args) {
            lastCallTime = Date.now();
            const thisCallTime = lastCallTime;
            
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            
            const checkTime = () => {
                const elapsed = Date.now() - thisCallTime;
                
                if (elapsed >= wait && thisCallTime === lastCallTime) {
                    func(...args);
                } else {
                    animationFrame = requestAnimationFrame(checkTime);
                }
            };
            
            animationFrame = requestAnimationFrame(checkTime);
        };
    }

    setupVueToParentSync() {
        // Emit changes to parent component (for external integrations)
        this.component.debouncedUpdateContent(); // Emit reactive content to parent
    }

}

/**
 * 6. CUSTOM JSON MESSAGE HANDLER
 * Handle custom JSON updates from iframe-based enhanced post components
 * Provides performant, collaborative synchronization for any type of component
 */
class CustomJsonMessageHandler {
    constructor(component) {
        this.component = component;
        this.iframeRegistry = new Map(); // Track active iframes
        this.updateQueue = [];
        this.updateDebounceTimer = null; // DEPRECATED - using timestamp approach
        this.lastUpdateRequest = 0; // Timestamp of last update request
        this.isProcessing = false;

        // Performance monitoring
        this.metrics = {
            totalUpdates: 0,
            batchedUpdates: 0,
            largestPayload: 0,
            averageLatency: 0
        };

        // Listen for custom JSON updates from any iframe
        this.messageHandler = this.handleMessage.bind(this);
        // Use component's eventManager if available, otherwise fallback to direct registration
        if (this.component.eventManager) {
            this.component.eventManager.addDOMListener(window, 'message', this.messageHandler);
        } else {
            window.addEventListener('message', this.messageHandler);
        }

    }

    /**
     * Handle incoming messages from iframe components
     */
    handleMessage(event) {
        // Skip non-iframe messages
        if (!event.data || typeof event.data !== 'object') return;

        // First check if this is an SPK file selection message
        if (event.data.type === 'spkFileSelected' && this.component.handleSPKFileSelection) {
            this.component.handleSPKFileSelection(event);
            return;
        }

        const { type, payload, iframeId } = event.data;

        // Only process our custom JSON messages
        if (!type || !type.startsWith('CUSTOM_JSON_')) return;

        // Security: Validate origin if needed (can be configured)
        if (!this.isValidOrigin(event.origin)) {
            console.warn('‚ö†Ô∏è Rejected message from untrusted origin:', event.origin);
            return;
        }

        switch (type) {
            case 'CUSTOM_JSON_UPDATE':
                this.queueCustomJsonUpdate(payload, iframeId, event.source);
                break;

            case 'CUSTOM_JSON_REQUEST':
                this.sendCurrentCustomJson(event.source, iframeId);
                break;

            case 'CUSTOM_JSON_REGISTER':
                this.registerIframe(event.source, iframeId, payload);
                break;

            case 'CUSTOM_JSON_UNREGISTER':
                this.unregisterIframe(iframeId);
                break;
        }
    }

    /**
     * Security check for message origins
     */
    isValidOrigin(origin) {
        // Allow same origin always
        if (origin === window.location.origin) return true;

        // Allow local development
        if (origin === 'http://localhost' || origin.startsWith('http://localhost:')) return true;

        // Allow file:// protocol for local development
        if (origin === 'file://') return true;

        // Allow null origin (some iframes)
        if (origin === 'null') return true;

        // Could add whitelist of allowed domains here
        // For now, allow all origins since iframes may have various sources
        return true;
    }

    /**
     * Register an iframe component
     */
    registerIframe(source, iframeId, metadata = {}) {
        this.iframeRegistry.set(iframeId, {
            source,
            metadata,
            registeredAt: Date.now(),
            lastUpdate: null
        });

        // Send current custom JSON state to newly registered iframe
        this.sendCurrentCustomJson(source, iframeId);
    }

    /**
     * Unregister an iframe component
     */
    unregisterIframe(iframeId) {
        if (this.iframeRegistry.has(iframeId)) {
            this.iframeRegistry.delete(iframeId);
        }
    }

    /**
     * Queue custom JSON updates for debounced batch processing
     */
    queueCustomJsonUpdate(updates, iframeId, source) {
        // Validate updates
        if (!updates || typeof updates !== 'object') {
            console.warn('‚ö†Ô∏è Invalid custom JSON update:', updates);
            return;
        }

        // Track metrics
        const updateSize = JSON.stringify(updates).length;
        this.metrics.totalUpdates++;
        this.metrics.largestPayload = Math.max(this.metrics.largestPayload, updateSize);

        // Add to queue
        this.updateQueue.push({
            updates,
            iframeId,
            timestamp: Date.now(),
            size: updateSize
        });

        // Update iframe registry
        if (this.iframeRegistry.has(iframeId)) {
            const iframe = this.iframeRegistry.get(iframeId);
            iframe.lastUpdate = Date.now();
            iframe.source = source; // Update source in case it changed
        }

        // ‚úÖ ARCHITECTURE COMPLIANT: Use requestAnimationFrame for debouncing instead of setTimeout
        if (this.updateDebounceTimer) {
            // Cancel pending update
            this.updateDebounceTimer = null;
        }
        
        // Use timestamp-based debouncing
        const now = Date.now();
        this.lastUpdateRequest = now;
        
        // Process after a delay using requestAnimationFrame
        const processAfterDelay = () => {
            if (this.lastUpdateRequest === now && Date.now() - now >= 200) {
                this.processBatchedUpdates();
            } else if (this.lastUpdateRequest === now) {
                requestAnimationFrame(processAfterDelay);
            }
        };
        requestAnimationFrame(processAfterDelay);
    }

    /**
     * Process all queued updates in a single Y.js transaction
     */
    async processBatchedUpdates() {
        if (this.updateQueue.length === 0 || this.isProcessing) return;

        this.isProcessing = true;
        const startTime = Date.now();
        const queueSnapshot = [...this.updateQueue];
        this.updateQueue = [];

        try {
            // Check if we have Y.js document
            if (!this.component.ydoc) {
                console.warn('‚ö†Ô∏è No Y.js document available for custom JSON updates');
                return;
            }

            // Merge all queued updates
            const mergedUpdates = {};
            let totalSize = 0;

            for (const { updates, iframeId, size } of queueSnapshot) {
                // Option 1: Namespace by iframe ID (prevents conflicts)
                // mergedUpdates[iframeId] = updates;

                // Option 2: Merge at root level (allows shared data)
                Object.assign(mergedUpdates, updates);

                totalSize += size;
            }

            // ‚úÖ GOLDEN RULE #2: Use YDocService for Y.js operations
            const currentJson = ydocService.getMetadata('customJson') || {};
            const newJson = { ...currentJson, ...mergedUpdates };

            // Size check and warning
            const jsonSize = JSON.stringify(newJson).length;
            if (jsonSize > 50000) { // 50KB warning threshold
                console.warn('‚ö†Ô∏è Large custom JSON size:', {
                    size: jsonSize,
                    sizeKB: Math.round(jsonSize / 1024) + 'KB',
                    recommendation: 'Consider optimizing data structure'
                });
            }

            // Single Y.js transaction for all updates
            ydocService.batchUpdate(
                {
                    lastModified: new Date().toISOString(),
                    lastCustomJsonUpdate: new Date().toISOString()
                },
                {
                    customJson: newJson
                },
                'iframe-customjson-batch'
            );

            // Update metrics
            const latency = Date.now() - startTime;
            this.metrics.batchedUpdates++;
            this.metrics.averageLatency = (this.metrics.averageLatency + latency) / 2;

            // Notify all registered iframes of the update
            this.broadcastCustomJsonUpdate(mergedUpdates);

        } catch (error) {
            console.error('‚ùå Error processing custom JSON updates:', error);

            // Re-queue failed updates for retry
            this.updateQueue.unshift(...queueSnapshot);

        } finally {
            this.isProcessing = false;
        }
    }

    /**
     * Send current custom JSON state to an iframe
     */
    sendCurrentCustomJson(target, iframeId) {
        try {
            if (!this.component.ydoc) {
                console.warn('‚ö†Ô∏è No Y.js document available for custom JSON request');
                return;
            }

            // ‚úÖ GOLDEN RULE #2: Use YDocService for Y.js operations
            const customJson = ydocService.getMetadata('customJson') || {};

            const message = {
                type: 'CUSTOM_JSON_STATE',
                iframeId,
                payload: customJson,
                timestamp: Date.now()
            };

            target.postMessage(message, '*');

        } catch (error) {
            console.error('‚ùå Error sending custom JSON to iframe:', error);
        }
    }

    /**
     * Broadcast custom JSON updates to all registered iframes
     */
    broadcastCustomJsonUpdate(updates) {
        if (this.iframeRegistry.size === 0) return;

        const message = {
            type: 'CUSTOM_JSON_UPDATE_BROADCAST',
            payload: updates,
            timestamp: Date.now()
        };

        for (const [iframeId, { source }] of this.iframeRegistry) {
            try {
                source.postMessage(message, '*');
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to broadcast to iframe:', iframeId, error.message);
                // Clean up dead iframes
                this.unregisterIframe(iframeId);
            }
        }

    }

    /**
     * Get performance metrics
     */
    getMetrics() {
        return {
            ...this.metrics,
            activeIframes: this.iframeRegistry.size,
            queueLength: this.updateQueue.length
        };
    }

    /**
     * Cleanup handler
     */
    destroy() {
        // Remove message listener (EventManager will handle cleanup if used)
        if (!this.component.eventManager) {
            window.removeEventListener('message', this.messageHandler);
        }

        // Clear timers (DEPRECATED - using timestamp approach)
        this.lastUpdateRequest = 0;

        // Clear registries
        this.iframeRegistry.clear();
        this.updateQueue = [];

    }
}

/**
 * 7. LIFECYCLE MANAGER
 * Proper TipTap cleanup patterns
 */
class LifecycleManager {
    constructor(component) {
        this.component = component;
    }

    async cleanupDocument() {
        // ‚úÖ TIPTAP BEST PRACTICE: Destroy editors in proper order
        
        console.log('üîç DOCUMENT CLEANUP:', {
            hadTitle: !!this.component.titleInput,
            title: this.component.titleInput
        });

        this.component.isCleaningUp = true;

        try {
            // 0. Clean up video observers FIRST to prevent "element not in DOM" warnings
            if (window.IPFSHLSPlayer?.observer) {
                console.log('üé• Cleaning up video observer before document cleanup');
                window.IPFSHLSPlayer.observer.disconnect();
                window.IPFSHLSPlayer.observer = null;
            }
            
            // 1. Destroy TipTap editors first
            await this.destroyEditors();

            // 2. Cleanup WebSocket provider
            await this.cleanupWebSocketProvider();

            // 3. Cleanup custom JSON message handler
            if (this.component.customJsonMessageHandler) {
                this.component.customJsonMessageHandler.destroy();
                this.component.customJsonMessageHandler = null;
            }

            // 4. Cleanup Y.js document
            await this.cleanupYjsDocument();

            // 5. Reset component state
            this.resetComponentState();

        } finally {
            this.component.isCleaningUp = false;
        }
    }

    async partialCleanupForAuth() {
        // ‚úÖ AUTHENTICATION FLOW CLEANUP: Preserve Y.js document but clean up editors/providers

        this.component.isCleaningUp = true;

        try {
            console.log('üîë PARTIAL CLEANUP: Starting authentication-safe cleanup');
            
            // 0. Clean up video observers FIRST to prevent "element not in DOM" warnings during auth
            if (window.IPFSHLSPlayer?.observer) {
                console.log('üé• Cleaning up video observer before auth cleanup');
                window.IPFSHLSPlayer.observer.disconnect();
                window.IPFSHLSPlayer.observer = null;
            }

            // 1. Destroy TipTap editors (but preserve Y.js document)
            await this.destroyEditors();

            // 2. Cleanup WebSocket provider (will reconnect after auth)
            await this.cleanupWebSocketProvider();

            // 3. Cleanup custom JSON message handler
            if (this.component.customJsonMessageHandler) {
                this.component.customJsonMessageHandler.destroy();
                this.component.customJsonMessageHandler = null;
            }

            // 4. SKIP Y.js document cleanup - preserve for reconnection after auth
            console.log('üîë PARTIAL CLEANUP: Preserving Y.js document for post-authentication reconnection');

            // 5. Reset only safe component state (preserve document references)
            this.resetComponentStatePartial();

            console.log('üîë PARTIAL CLEANUP: Authentication-safe cleanup completed');

        } finally {
            this.component.isCleaningUp = false;
        }
    }

    async destroyEditors() {
        // ‚úÖ TIPTAP BEST PRACTICE: Proper editor destruction with error handling and verification

        const editors = [
            { name: 'bodyEditor', instance: this.component.bodyEditor }
        ];

        for (const { name, instance } of editors) {
            if (instance) {
                try {
                    // ‚úÖ VERIFICATION: Check if editor is already destroyed
                    if (instance.isDestroyed) {
                        this.component[name] = null;
                        continue;
                    }

                    // ‚úÖ PROPER DESTRUCTION: Call destroy and wait for completion
                    await new Promise(resolve => {
                        // TipTap destroy might be async - wait for next tick to ensure completion
                        instance.destroy();
                        this.component.$nextTick(() => {
                            resolve();
                        });
                    });

                    // ‚úÖ VERIFICATION: Confirm destruction succeeded
                    if (instance.isDestroyed) {

                        // ‚úÖ Emit event when body editor is destroyed
                        if (name === 'bodyEditor') {
                            /**
                             * @event tiptap-editor-destroyed
                             * @description Notify external components that the editor has been destroyed
                             */
                            window.dispatchEvent(new CustomEvent('tiptap-editor-destroyed'));
                        }
                    } else {
                        console.warn(`‚ö†Ô∏è Editor ${name} destroy() called but not confirmed destroyed`);
                        // ‚úÖ TIPTAP COMPLIANCE: Wait for destroy confirmation with proper timeout
                        await new Promise((resolve) => {
                            const maxWaitTime = 200;
                            const startTime = Date.now();
                            
                            const checkDestruction = () => {
                                const elapsed = Date.now() - startTime;
                                if (instance.isDestroyed || elapsed >= maxWaitTime) {
                                    if (elapsed >= maxWaitTime && !instance.isDestroyed) {
                                        console.warn(`‚ö†Ô∏è Editor ${name} destroy timeout after ${maxWaitTime}ms`);
                                    }
                                    resolve();
                                } else {
                                    requestAnimationFrame(checkDestruction);
                                }
                            };
                            requestAnimationFrame(checkDestruction);
                        });
                    }

                } catch (error) {
                    console.error(`‚ùå Error destroying ${name}:`, error.message);
                } finally {
                    // ‚úÖ CLEANUP: Always clear reference regardless of destroy success
                    this.component[name] = null;
                }
            }
        }
    }

    async cleanupWebSocketProvider() {
        // ‚úÖ Y.JS COMPLIANCE: Clean up awareness heartbeat
        if (this.component.awarenessHeartbeat) {
            clearInterval(this.component.awarenessHeartbeat);
            this.component.awarenessHeartbeat = null;
        }

        if (this.component.provider) {
            try {
                // Store reference to avoid null access during async operations
                const provider = this.component.provider;
                
                // ‚úÖ AWARENESS CLEANUP: Clear user presence first
                if (provider.awareness) {
                    console.log('üßπ Clearing awareness state before provider cleanup');
                    provider.awareness.setLocalState(null);
                    provider.awareness.destroy();
                }

                // ‚úÖ DISCONNECT: Gracefully disconnect WebSocket
                if (provider.disconnect) {
                    provider.disconnect();
                    
                    // Wait for disconnect to complete
                    await new Promise(resolve => {
                        if (!provider || provider.status === 'disconnected') {
                            resolve();
                        } else {
                            const statusHandler = ({ status }) => {
                                if (status === 'disconnected') {
                                    provider.off('status', statusHandler);
                                    resolve();
                                }
                            };
                            provider.on('status', statusHandler);
                            // Timeout using requestAnimationFrame (Rule 6 compliant)
                            let frameCount = 0;
                            const maxFrames = 60; // ~1 second at 60fps
                            const frameTimeout = () => {
                                if (++frameCount >= maxFrames) {
                                    provider.off('status', statusHandler);
                                    resolve();
                                } else {
                                    requestAnimationFrame(frameTimeout);
                                }
                            };
                            requestAnimationFrame(frameTimeout);
                        }
                    });
                }

                // ‚úÖ DESTROY: Clean up provider instance
                if (provider && provider.destroy) {
                    provider.destroy();
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Error during WebSocket provider cleanup:', error?.message || error);
            }

            this.component.provider = null;
        }

        // Reset connection status
        this.component.connectionStatus = 'disconnected';
        this.component.connectionMessage = '';
    }

    /**
     * ‚úÖ PERMISSION UPGRADE: Reconnect WebSocket with new permission level
     * Required when user is upgraded from readonly to editable for server to accept changes
     */
    async reconnectWebSocketForPermissionUpgrade() {
        if (!this.component.currentFile || this.component.currentFile.type !== 'collaborative') {
            throw new Error('Cannot reconnect - not in collaborative document');
        }

        if (!this.component.yjsDoc) {
            throw new Error('Cannot reconnect - no Y.js document available');
        }

        const oldPermissionLevel = this.component.getUserPermissionLevel(this.component.currentFile);

        const validatedHeaders = this.component.isAuthenticated ? this.component.authHeaders : null;

        try {
            // ‚úÖ AUTH VALIDATION: Ensure auth headers match current username before reconnecting
            if (validatedHeaders && this.component.username) {
                const authAccount = this.component.authStateManager.getAuthAccount(validatedHeaders);
                const currentUser = this.component.username;

                if (authAccount !== currentUser) {
                    console.warn('üîÑ AUTH MISMATCH DETECTED: Delaying WebSocket reconnection until auth headers sync', {
                        authAccount,
                        currentUser,
                        willWaitForSync: true
                    });

                    // ‚úÖ PURE EVENT-DRIVEN: Wait for auth headers to sync without timeout
                    return new Promise((resolve, reject) => {
                        let handler = null;
                        let errorHandler = null;
                        let logoutHandler = null;

                        // Cleanup function for all event listeners
                        const cleanup = () => {
                            if (handler) {
                                this.component.authStateManager.off('authHeadersChanged', handler);
                                handler = null;
                            }
                            if (errorHandler) {
                                this.component.authStateManager.off('authError', errorHandler);
                                errorHandler = null;
                            }
                            if (logoutHandler) {
                                this.component.authStateManager.off('userChanged', logoutHandler);
                                logoutHandler = null;
                            }
                        };

                        // Listen for auth header changes
                        handler = (event) => {
                            const updatedHeaders = event.detail.headers;
                            const updatedAuthAccount = this.component.authStateManager.getAuthAccount(updatedHeaders);

                            if (updatedAuthAccount === currentUser) {
                                cleanup();
                                // Retry the reconnection with synced headers
                                this.reconnectWebSocketForPermissionUpgrade().then(resolve).catch(reject);
                            }
                        };

                        // Listen for auth errors (user might fail to authenticate)
                        errorHandler = (event) => {
                            cleanup();
                            console.warn('‚ö†Ô∏è Auth error occurred while waiting for sync:', event.detail);
                            reject(new Error('Authentication failed during WebSocket reconnection'));
                        };

                        // Listen for logout (user cancelled auth)
                        logoutHandler = (event) => {
                            // ‚úÖ FIX: Access event data from detail property (CustomEvent structure)
                            const data = event.detail || {};
                            if (!data.newUser) {
                                cleanup();
                                console.warn('‚ö†Ô∏è User logged out while waiting for auth sync');
                                reject(new Error('User logged out during WebSocket reconnection'));
                            }
                        };

                        // Attach all event listeners
                        this.component.authStateManager.on('authHeadersChanged', handler);
                        this.component.authStateManager.on('authError', errorHandler);
                        this.component.authStateManager.on('userChanged', logoutHandler);

                        // Check once immediately in case headers are already synced
                        const currentHeaders = this.component.isAuthenticated ? this.component.authHeaders : null;
                        const currentAuthAccount = this.component.authStateManager.getAuthAccount(currentHeaders);
                        if (currentAuthAccount === currentUser) {
                            cleanup();
                            this.reconnectWebSocketForPermissionUpgrade().then(resolve).catch(reject);
                        } else {
                            // ‚úÖ EVENT-DRIVEN: If not synced, emit event to request auth refresh
                            // The auth system will handle the sync and emit authHeadersChanged when ready
                        }
                    });
                }
            }

            // 1. Clean up existing WebSocket provider 
            await this.cleanupWebSocketProvider();

            // 2. Set up new WebSocket provider with updated permissions
            const result = await this.continueReconnectionWithCurrentHeaders();

            // 3. Verify new provider was created
            if (!this.component.provider) {
                throw new Error('Failed to create new WebSocket provider');
            }

            // Provider will automatically trigger onSynced and upgrade editors

        } catch (error) {
            console.error('‚ùå PERMISSION UPGRADE: WebSocket reconnection failed:', error.message);
            throw error;
        }
    }

    /**
     * ‚úÖ AUTH SYNCHRONIZATION: Continue WebSocket reconnection with current auth headers
     * Separated method to avoid infinite recursion in auth sync logic
     */
    async continueReconnectionWithCurrentHeaders() {
        const validatedHeaders = this.component.isAuthenticated ? this.component.authHeaders : null;

        // Clean up existing WebSocket provider 
        await this.cleanupWebSocketProvider();

        // Set up new WebSocket provider with current auth headers
        const result = await this.setupCloudPersistence(this.component.yjsDoc, this.component.currentFile);

        // Verify new provider was created
        if (!this.component.provider) {
            throw new Error('Failed to create new WebSocket provider during auth sync');
        }

        return result;
    }

    async cleanupYjsDocument() {
        if (this.component.ydoc) {
            try {

                // ‚úÖ BEST PRACTICE: Clean up Y.js observers before destroying document
                if (this.component.syncManager) {
                    this.component.syncManager.cleanupYjsObservers(this.component.ydoc);
                }

                // ‚úÖ GOLDEN RULE #2: Clean up YDocService before destroying document
                if (ydocService.isReady()) {
                    ydocService.destroyDocument();
                }

                // ‚úÖ VERIFICATION: Check if document is already destroyed
                if (this.component.ydoc.isDestroyed) {
                } else {
                    this.component.ydoc.destroy();
                }

            } catch (error) {
                console.error('‚ùå Error destroying Y.js document:', error.message);
            } finally {
                // ‚úÖ ALWAYS CLEAR: Clear reference regardless of destroy success
                this.component.ydoc = null;
            }
        }

        if (this.component.indexeddbProvider) {
            try {

                // ‚úÖ IMPORTANT: Only clear data for collaborative documents to prevent cross-user contamination
                // For local documents, we want to preserve the data in IndexedDB
                if (this.component.fileType === 'collaborative' &&
                    this.component.indexeddbProvider.clearData &&
                    typeof this.component.indexeddbProvider.clearData === 'function') {
                    await this.component.indexeddbProvider.clearData();

                    // ‚úÖ ADDITIONAL LOGGING: Log which user-specific key was cleared
                    if (this.component.currentFile) {
                        const userIdentifier = this.component.username;
                        const clearedKey = `${userIdentifier}__${this.component.currentFile.owner}/${this.component.currentFile.permlink}`;
                    }
                } else if (this.component.fileType === 'local') {
                }

                // Then destroy the provider
                this.component.indexeddbProvider.destroy();

            } catch (error) {
                console.error('‚ùå Error during IndexedDB cleanup:', error.message);
            } finally {
                this.component.indexeddbProvider = null;
                this.component.hasIndexedDBPersistence = false;
            }
        }
    }

    resetComponentState() {
        this.component.currentFile = null;

        // ‚úÖ AUTH STATE MANAGER: Clear current document
        if (this.component.authStateManager) {
            console.log('üîê AuthStateManager: Clearing current document');
            this.component.authStateManager.setCurrentDocument(null);
        }

        this.component.fileType = 'local';
        // isCollaborativeMode is now a computed property
        this.component.connectionStatus = 'disconnected';
        this.component.hasUnsavedChanges = false;
        this.component.hasUserIntent = false;
        this.component.isTemporaryDocument = false;
        this.component.hasIndexedDBPersistence = false;
        this.component.isCreatingPersistence = false; // Reset user intent flag

        // ‚úÖ FIXED: Reset reactive state properties
        // ‚úÖ TIPTAP COMPLIANCE: Removed reactive content properties

        // ‚úÖ PROPER REACTIVITY: Reset reactive properties
        this.component.reactiveTags = [];
        this.component.reactiveBeneficiaries = [];
        // ‚úÖ REMOVED: reactivePermlink reset - not needed
        this.component.reactiveCustomJson = {};
        this.component.reactiveCommentOptions = {
            allowVotes: true,
            allowCurationRewards: true,
            maxAcceptedPayout: false,
            percentHbd: false
        };

        // ‚úÖ REACTIVITY FIX: Reset reactive document name
        this.component.reactiveDocumentName = null;

        // ‚úÖ RECURSION PROTECTION: Clear recursion protection flags
        this.component._isUpdatingPermlink = false;

        // ‚úÖ FIX: Reset editor initialization flags
        this.component.editorInitialized = false;
        this.component.isLoadingDocument = false;

        // ‚úÖ DEBOUNCE CLEANUP: Clear all timers to prevent memory leaks and unwanted persistence
        // DEPRECATED: autoNameTimeout removed, using reactive pattern

        // ‚úÖ FIX: Clear content update timer to prevent File > New persistence issue
        if (this.component.contentUpdateFrame) {
            cancelAnimationFrame(this.component.contentUpdateFrame);
            this.component.contentUpdateFrame = null;
        }

        // ‚úÖ FIX: Clear persistence creation timer
        if (this.component.createPersistenceDebounceTimer) {
            cancelAnimationFrame(this.component.createPersistenceDebounceTimer);
            this.component.createPersistenceDebounceTimer = null;
        }

        // ‚úÖ FIX: Clear title auto-save frame
        if (this.component.titleAutoSaveFrame) {
            cancelAnimationFrame(this.component.titleAutoSaveFrame);
            this.component.titleAutoSaveFrame = null;
        }

        // ‚úÖ FIX: Clear temp persistence timer (used by checkUserIntent)
        if (this.component.tempPersistenceTimeout) {
            clearTimeout(this.component.tempPersistenceTimeout);
            this.component.tempPersistenceTimeout = null;
        }

        // DEPRECATED: autoNameTimeout removed, using reactive pattern

        // ‚úÖ FIX: Reset editor creation timestamp to ensure proper initialization detection
        this.component.editorCreatedAt = null;

        // ‚úÖ FIX: Reset editor focus state to hide UI elements for new documents
        this.component.editorHasBeenFocused = false;
        this.component.editorInteractionCount = 0;

        // ‚úÖ SECURITY: Clear access denial and permission state
        // Permissions cleared via cache - computed property will return empty array

        // ‚úÖ ADVANCED SETTINGS: Clear all advanced settings inputs and UI state
        this.clearAdvancedSettings();

        // ‚úÖ FIX: Clear remix application state if present
        // This ensures File > New closes any open remix apps and clears the URL
        // Emit event instead of calling parent method directly
        if (typeof window !== 'undefined') {
            window.dispatchEvent(new CustomEvent('closeRemixApp'));
        }
    }

    resetComponentStatePartial() {
        // ‚úÖ AUTHENTICATION FLOW RESET: Only reset safe state, preserve document references

        // Clear editor flags but preserve Y.js document and file references
        this.component.connectionStatus = 'disconnected';
        this.component.hasUnsavedChanges = false;
        this.component.editorInitialized = false;
        this.component.isLoadingDocument = false;

        // Clear timers to prevent conflicts
        // DEPRECATED: autoNameTimeout removed, using reactive pattern

        if (this.component.contentUpdateFrame) {
            cancelAnimationFrame(this.component.contentUpdateFrame);
            this.component.contentUpdateFrame = null;
        }

        // Reset interaction state
        this.component.editorHasBeenFocused = false;
        this.component.editorInteractionCount = 0;

        // PRESERVE: currentFile, ydoc, permissions, and document context for reconnection
        console.log('üîë PARTIAL RESET: Preserved currentFile and Y.js document for post-authentication reconnection');
    }

    clearAdvancedSettings() {
        // ‚úÖ Clear input fields
        this.component.tagInput = '';
        this.component.beneficiaryInput = {
            account: '',
            percent: '1'
        };
        this.component.customJsonString = '';
        this.component.customJsonError = '';

        // ‚úÖ CRITICAL FIX: Reset all input fields for clean slate
        this.component.titleInput = '';
        this.component.permlinkInput = ''; // Reset permlink input for File > New

        // ‚úÖ Reset UI state
        this.component.showAdvancedOptions = false;
        this.component.showPermlinkEditor = false;
        this.component.isEditingDocumentName = false;
        this.component.documentNameInput = '';

        // ‚úÖ Clear content object (for legacy code compatibility)
        this.component.content = {
            tags: [],
            custom_json: {},
            permlink: '',
            beneficiaries: []
        };

        // ‚úÖ CRITICAL: Also reset comment options to defaults
        this.component.commentOptions = {
            allowVotes: true,
            allowCurationRewards: true,
            maxAcceptedPayout: false,
            percentHbd: false
        };
    }
}

/**
 * 7. DOCUMENT MANAGER
 * Orchestrate loading following TipTap patterns
 * 
 * üö® CRITICAL FILE OPERATION VIOLATIONS TO PREVENT:
 * ‚ùå NEVER: Manual content extraction from editors during save/load
 * ‚ùå NEVER: setContent() when loading existing documents
 * ‚ùå NEVER: Storing title/body content in file objects  
 * ‚ùå NEVER: Extracting document name from title content
 * ‚ùå NEVER: Manual content injection during file operations
 * ‚ùå NEVER: Reusing editors between different documents
 * ‚ùå NEVER: Creating editors before Y.js document exists
 * ‚ùå NEVER: Skipping editor destruction during file transitions
 * 
 * ‚úÖ ONLY ALLOWED FILE PATTERNS:
 * ‚úÖ Always destroy editors before loading new documents
 * ‚úÖ Create Y.js document first, then editors
 * ‚úÖ Wait for onSynced before considering document loaded
 * ‚úÖ Store only metadata in file objects (id, name, owner, etc.)
 * ‚úÖ Let TipTap automatically populate content from Y.js
 * ‚úÖ Use config.documentName for file naming, not title content
 * ‚úÖ Use temp document strategy for new documents
 * ‚úÖ Follow tier decision pattern (LOCAL vs CLOUD)
 */
class DocumentManager {
    constructor(component) {
        this.component = component;
        this.tierDecision = new TierDecisionManager();
        this.yjsManager = new YjsDocumentManager(component);
        this.persistenceManager = new PersistenceManager(component);
        this.editorFactory = new EditorFactory(component);
        this.syncManager = new SyncManager(component);
        this.lifecycleManager = new LifecycleManager(component);
    }

    async loadDocument(file) {
        // ‚úÖ TIPTAP BEST PRACTICE: Follow official loading patterns
        const loadStartTime = Date.now();

        // üèÅ RACE: Enhanced race condition tracking with timing
        const raceDebugData = {
            loadStartTime: loadStartTime,
            timestamp: Date.now(),
            hasAuthHeaders: !!this.component.authHeaders,
            authHeaderAge: this.component.authStateManager?.getChallengeAge(this.component.authHeaders),
            isAuthenticated: this.component.isAuthenticated,
            username: this.component.username,
            authHeadersAccount: this.component.authHeaders?.['x-account'],
            authBridgeState: this.component.authBridgeInstance?.getState(),
            hasAuthStateManager: !!this.component.authStateManager,
            currentPermissionLevel: this.component.currentPermissionLevel
        };

        console.log('üèÅ RACE: loadDocument starting', raceDebugData);

        // ‚è±Ô∏è TIMING: Create timing tracker for this load
        const timingTracker = {
            start: loadStartTime,
            steps: []
        };

        const logTiming = (step) => {
            const elapsed = Date.now() - loadStartTime;
            timingTracker.steps.push({ step, elapsed });
            console.log(`‚è±Ô∏è TIMING: ${step} - ${elapsed}ms from start`);
        };

        // Load document - removed diagnostic logging for performance

        // STEP 1: Cleanup existing state
        logTiming('Starting cleanup');
        await this.lifecycleManager.cleanupDocument();
        logTiming('Cleanup completed');

        // STEP 2: Determine tier (immutable decision)
        logTiming('Determining tier');
        const tier = this.tierDecision.determineTier(file, this.component);
        logTiming(`Tier determined: ${tier}`);

        // STEP 3: Create Y.js document + setup persistence
        logTiming('Creating Y.js document');
        const yjsDoc = await this.yjsManager.createDocument(file, tier);
        this.component.ydoc = yjsDoc;
        logTiming('Y.js document created');

        // ‚úÖ TIPTAP COMPLIANCE: Validate Y.js document integrity
        if (this.component.recoveryManager) {
            const isValid = await this.component.recoveryManager.validateYjsDocumentIntegrity(yjsDoc);
            if (!isValid) {
                console.warn('‚ö†Ô∏è Y.js document validation failed, attempting recovery');
                try {
                    const documentId = file?.id || (file?.owner && file?.permlink ? `${file.owner}/${file.permlink}` : null);
                    const recoveredDoc = await this.component.recoveryManager.recoverCorruptedDocument(documentId, yjsDoc);
                    if (recoveredDoc && recoveredDoc !== yjsDoc) {
                        // Replace with recovered document
                        yjsDoc.destroy();
                        this.component.ydoc = recoveredDoc;
                    }
                } catch (error) {
                    console.error('‚ùå Document recovery failed:', error);
                    // Continue with potentially corrupted document
                }
            }
        }

        // STEP 4: Setup persistence and create editors in correct sequence for collaborative documents
        let webSocketProvider = null;

        // ‚úÖ FIX: Get document ID from either file.id or owner/permlink combination
        const documentId = file?.id || (file?.owner && file?.permlink ? `${file.owner}/${file.permlink}` : null);

        if (documentId) {
            if (tier === TierDecisionManager.TierType.CLOUD) {
                // ‚úÖ OFFLINE-FIRST: IndexedDB loads immediately for instant editing
                console.log('üîê CACHE-CREATE: Entering CLOUD tier branch', {
                    documentId,
                    username: this.component.username,
                    isAuthenticated: this.component.isAuthenticated,
                    hasAuthHeaders: !!this.component.authHeaders
                });
                logTiming('Setting up cloud persistence (IndexedDB + WebSocket)');
                const { indexedDB, webSocket } = await this.persistenceManager.setupCloudPersistence(yjsDoc, file);
                this.component.indexeddbProvider = indexedDB;
                this.component.hasIndexedDBPersistence = true;
                // Note: webSocket is null initially (connects in background)
                this.component.provider = webSocket;
                webSocketProvider = webSocket;
                logTiming(`Cloud persistence setup complete - WebSocket: ${webSocket ? 'created' : 'pending'}`);

            } else {
                // For local documents, don't use user isolation
                this.component.indexeddbProvider = await this.yjsManager.setupIndexedDBWithOnSynced(yjsDoc, documentId, false);
                this.component.hasIndexedDBPersistence = true; // ‚úÖ CRITICAL: Set flag for status indicator
            }
        } else {
            console.warn('‚ö†Ô∏è DIAGNOSTIC: No document ID available - missing both file.id and owner/permlink', {
                hasFileId: !!file?.id,
                hasOwner: !!file?.owner,
                hasPermlink: !!file?.permlink,
                fileKeys: file ? Object.keys(file) : 'no-file'
            });
        }

        // STEP 5: Create appropriate editors immediately (offline-first pattern)
        // ‚úÖ OFFLINE-FIRST: Create editors immediately with whatever content is available
        // IndexedDB has already synced (if content exists), WebSocket will sync in background
        const editors = await this.editorFactory.createEditors(yjsDoc, tier, webSocketProvider);

        // ‚úÖ SAFETY CHECK: Ensure component is available before setting editors
        if (!this.component) {
            console.error('‚ùå Component not available during editor initialization');
            throw new Error('Component not initialized - cannot set up editors');
        }

        this.component.bodyEditor = markRaw(editors.bodyEditor);

        // ‚úÖ REACTIVE PATTERN: Use editor's onUpdate event for content verification
        // Set up one-time content check when editor first updates with content
        if (this.component.bodyEditor) {
            const checkContentOnce = () => {
                const titleContent = this.component.titleInput || '';
                const bodyContent = this.component.bodyEditor?.getText() || '';

                if (titleContent.length > 0 || bodyContent.length > 0) {

                    // Remove the temporary update handler
                    if (this.component.contentCheckHandler) {
                        this.component.bodyEditor.off('update', this.component.contentCheckHandler);
                        this.component.contentCheckHandler = null;
                    }
                }
            };

            // Store handler reference for cleanup
            this.component.contentCheckHandler = checkContentOnce;
            this.component.bodyEditor.on('update', checkContentOnce);

            // ‚úÖ REACTIVE: Also check if Y.js already has content after IndexedDB sync
            this.component.$nextTick(() => {
                const titleContent = this.component.titleInput || '';
                const bodyContent = this.component.bodyEditor?.getText() || '';

            });
        }

        // ‚úÖ CRITICAL: NO manual content setting
        // TipTap automatically loads content from Y.js after sync

        // STEP 6: Setup sync listeners (Vue reactive state only)
        this.syncManager.setupSyncListeners(editors, yjsDoc);

        // ‚úÖ BEST PRACTICE: Store sync manager reference for cleanup
        this.component.syncManager = this.syncManager;

        // ‚úÖ TIPTAP v3 COMPLIANT: Load existing metadata from Y.js to Vue reactive data
        // This ensures advanced settings are properly displayed when loading a document
        this.component.loadMetadataFromYjs();

        // STEP 7: Minimal wait for TipTap initialization (offline-first)
        // ‚úÖ TIPTAP OFFLINE-FIRST: Trust IndexedDB sync + TipTap automatic content loading

        // Only wait for Vue to process editor initialization
        await this.component.$nextTick();

        // ‚úÖ OFFLINE-FIRST: Skip content verification delays for collaborative documents
        // IndexedDB content loads via onSynced callback automatically
        // WebSocket sync happens in background without blocking UI

        if (tier === TierDecisionManager.TierType.CLOUD) {
        } else {
            // For local documents, do a quick content check (no delays)
            if (this.component.bodyEditor) {
                // Content verification performed for local documents
            }
        }

        // ‚úÖ PERFORMANCE FIX: Let Vue's reactivity handle updates automatically

        // ‚úÖ TIPTAP COMPLIANCE: No manual content loading for collaborative documents
        // TipTap Collaboration extension handles ALL content sync automatically via onSynced callbacks
        // WebSocket provider syncs content in background without blocking UI

        // STEP 8: Update component state
        // ‚úÖ INSTANT DISPLAY FIX: Use cached metadata to prevent "untitled doc" flash
        let finalFile = file;

        // Check for cached document metadata first (prevents flash)
        const documentKey = file?.owner && file?.permlink ? `${file.owner}/${file.permlink}` : null;
        const cachedMetadata = documentKey ? await documentService.getDocumentMetadata(documentKey) : null;

        if (cachedMetadata && cachedMetadata.documentName && !cachedMetadata.documentName.includes('/')) {

            finalFile = {
                ...file,
                name: cachedMetadata.documentName,
                documentName: cachedMetadata.documentName,
                title: cachedMetadata.documentName
            };

            // Also set it in Y.js config for consistency
            if (this.component.ydoc) {
                // ‚úÖ GOLDEN RULE #2: Use YDocService for Y.js operations
                ydocService.batchUpdate(
                    {
                        documentName: cachedMetadata.documentName,
                        lastCacheLoad: new Date().toISOString()
                    },
                    {},
                    'cache-load'
                );

                // ‚úÖ REACTIVITY FIX: Update reactive property for Vue
                if (this.component && typeof this.component.updateReactiveDocumentName === 'function') {
                    this.component.updateReactiveDocumentName(cachedMetadata.documentName);
                } else {
                    console.warn('‚ö†Ô∏è updateReactiveDocumentName method not available, setting reactiveDocumentName directly');
                    if (this.component) {
                        this.component.reactiveDocumentName = cachedMetadata.documentName;
                    }
                }
            }
        } else {
            // Fallback: Check Y.js config if it was updated during sync
            const yjsDocumentName = ydocService.getConfig('documentName');
            if (yjsDocumentName && yjsDocumentName !== file.name && !yjsDocumentName.includes('/')) {

                finalFile = {
                    ...file,
                    name: yjsDocumentName,
                    documentName: yjsDocumentName,
                    title: yjsDocumentName
                };

            }
        }

        // ‚úÖ CRITICAL FIX: Ensure documents maintain their correct type and flags
        if (tier === TierDecisionManager.TierType.CLOUD) {
            finalFile = {
                ...finalFile,
                type: 'collaborative',
                isCollaborative: true
            };
        } else if (tier === TierDecisionManager.TierType.LOCAL) {
            finalFile = {
                ...finalFile,
                type: 'local',
                isCollaborative: false
            };
        }

        logTiming('Setting currentFile');
        this.component.currentFile = finalFile;

        // ‚úÖ AUTH STATE MANAGER: Sync current document
        if (this.component.authStateManager) {
            logTiming('Syncing document to AuthStateManager');
            console.log('üîê AuthStateManager: Syncing current document', {
                id: finalFile.id,
                type: finalFile.type
            });
            this.component.authStateManager.setCurrentDocument(finalFile);
            logTiming('AuthStateManager sync complete');
        }

        // ‚úÖ REACTIVITY FIX: Update reactive document name for Vue display
        this.component.reactiveDocumentName = finalFile.name || finalFile.documentName || 'Untitled';

        this.component.fileType = tier === TierDecisionManager.TierType.CLOUD ? 'collaborative' : 'local';
        // isCollaborativeMode is now a computed property based on currentFile.type

        // ‚úÖ PERFORMANCE: Update local document metadata - caching handled internally
        if (tier === TierDecisionManager.TierType.LOCAL && finalFile.id && finalFile.name) {
            documentService.updateDocumentMetadata(finalFile.id, {
                documentName: finalFile.name,
                timestamp: Date.now(),
                documentId: finalFile.id,
                type: 'local'
            });
        }

        // ‚úÖ TIPTAP v3 COMPLIANT: Set persistence state for loaded documents
        this.component.isTemporaryDocument = false;
        this.component.hasIndexedDBPersistence = true;
        this.component.isPersistenceReady = true;

        // ‚úÖ Set initial connection status based on tier
        if (tier === TierDecisionManager.TierType.LOCAL) {
            this.component.connectionStatus = 'offline';
            this.component.connectionMessage = 'Working offline with local storage';
        } else if (tier === TierDecisionManager.TierType.CLOUD) {
            // For cloud tier, status will be updated by WebSocket callbacks
            // Set initial status to 'connecting' if not already connected
            if (!this.component.websocketProvider || !this.component.websocketProvider.isConnected) {
                this.component.connectionStatus = 'connecting';
                this.component.connectionMessage = 'Connecting to collaboration server...';
            }
        }

        // ‚úÖ Force status update after state changes
        this.component.$nextTick(() => {
        });

        // ‚è±Ô∏è TIMING: Final timing summary
        logTiming('loadDocument completed');
        const totalTime = Date.now() - loadStartTime;
        console.log('‚è±Ô∏è TIMING: LoadDocument Complete Summary', {
            totalTime: `${totalTime}ms`,
            documentType: file?.type,
            tier: tier,
            steps: timingTracker.steps,
            authState: {
                hasAuthHeaders: !!this.component.authHeaders,
                isAuthenticated: this.component.isAuthenticated,
                authBridgeModalShowing: this.component.authBridgeInstance?.isPromptVisible()
            }
        });
    }

    async newDocument(initialContent = null) {
        // ‚úÖ FIX: Prevent duplicate newDocument calls that cause infinite loop
        if (this.component.isCreatingNewDocument) {
            console.warn('‚ö†Ô∏è newDocument already in progress, skipping duplicate call');
            return;
        }

        this.component.isCreatingNewDocument = true;

        try {
            // ‚úÖ TIPTAP BEST PRACTICE: Always start as Tier 1 (offline-first)
            const tier = TierDecisionManager.TierType.LOCAL;

            // Reset loading flag for new documents
            this.component.isLoadingDocument = false;
            // Reset editor initialized flag for new documents
            this.component.editorInitialized = false;

            // STEP 1: Cleanup existing state
            await this.lifecycleManager.cleanupDocument();

            // STEP 2: Create temp Y.js document
            const yjsDoc = await this.yjsManager.createTempDocument();
            this.component.ydoc = yjsDoc;

            // STEP 2.5: ‚úÖ TRUE TEMP STRATEGY: Keep Y.js in memory only until user intent
            // IndexedDB persistence will be created later when user shows intent
            const documentId = `temp_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;
            this.component.tempDocumentId = documentId;
            this.component.isTemporaryDocument = true;

            // ‚úÖ NO IndexedDB persistence yet - true temporary document
            this.component.indexeddbProvider = null;
            this.component.hasIndexedDBPersistence = false;

            // STEP 3: Ensure DOM is ready before creating editors
            await this.component.$nextTick();

            // STEP 4: Create Tier 1 editors
            const editors = await this.editorFactory.createEditors(yjsDoc, tier);
            this.component.bodyEditor = markRaw(editors.bodyEditor);

            // STEP 5: NO INITIAL CONTENT SETTING - TipTap Collaboration handles content automatically
            if (initialContent) {
                // ‚ùå VIOLATION REMOVED: Manual setContent() calls violate TipTap best practices
                // ‚úÖ CORRECT: Store initial content in Y.js metadata if needed for reference
                // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                ydocService.setInitialContentLoaded(true, initialContent); // Origin tag to identify this transaction
            }

            // STEP 6: Setup sync listeners
            this.syncManager.setupSyncListeners(editors, yjsDoc);

            // STEP 7: ‚úÖ BEST PRACTICE: Keep URL clean for new documents
            // Do NOT show temp URLs - only update URL after user shows intent and persistence is created
            // This prevents URL clutter and follows the temp document strategy pattern
            this.component.clearAllURLParams();

            // STEP 8: Create file metadata and update component state
            const now = new Date().toISOString();
            const initialName = `Untitled - ${new Date().toLocaleDateString()}`;

            // ‚úÖ TRUE TEMP STRATEGY: No file entry creation, no localStorage persistence
            // Document stays in memory only until user shows intent

            // Update component state for temp document
            this.component.currentFile = {
                id: documentId,
                name: initialName,
                documentName: initialName,
                title: initialName,
                type: 'temp', // Mark as temporary type
                created: now,
                lastModified: now,
                modified: now,
                hasIndexedDBPersistence: false, // No persistence yet
                owner: this.component.username || 'anonymous'
            };

            // ‚úÖ AUTH STATE MANAGER: Sync temp document
            if (this.component.authStateManager) {
                console.log('üîê AuthStateManager: Syncing temp document');
                this.component.authStateManager.setCurrentDocument(this.component.currentFile);
            }

            this.component.fileType = 'temp'; // Temporary file type
            // isCollaborativeMode is now a computed property
            // Keep isTemporaryDocument = true (already set above)

            // ‚úÖ REACTIVITY FIX: Initialize reactive document name for Vue display
            this.component.reactiveDocumentName = initialName;

        } finally {
            // Always reset the flag, even if there was an error
            this.component.isCreatingNewDocument = false;
        }
    }

    // ===== DRAFTS LIST MANAGEMENT =====
    async loadLocalFiles() {
        try {

            // Load from localStorage metadata
            const files = this.component.documentStorageService.getAllDocuments();

            // ‚úÖ SECURITY FIX: Only show files owned by the current authenticated user
            const userFiles = files.filter(file => {
                // If user is logged in, only show their files
                if (this.component.username) {
                    return file.owner === this.component.username;
                }
                // If not logged in, only show anonymous files
                return !file.owner || file.owner === 'anonymous';
            });

            // üìö PHANTOM DEBUG: Log all local files being loaded with stack trace
            console.log('üìö PHANTOM DEBUG: Local files being loaded', {
                totalFiles: userFiles.length,
                files: userFiles.map(f => ({
                    id: f.id,
                    name: f.name || f.documentName,
                    type: f.type,
                    owner: f.owner,
                    isCollaborative: f.isCollaborative,
                    permlink: f.permlink
                })),
                stackTrace: new Error().stack
            });

            this.component.localFiles = userFiles.map(file => {
                // üìö PHANTOM DEBUG: Check for problematic files during loading
                const wasCollaborative = file.type === 'collaborative' || file.isCollaborative;
                if (wasCollaborative) {
                    console.log('üìö PHANTOM DEBUG: Found stale collaborative file in localStorage', {
                        owner: file.owner,
                        permlink: file.permlink,
                        type: file.type,
                        isCollaborative: file.isCollaborative,
                        id: file.id,
                        name: file.name || file.documentName,
                        currentUser: this.component.username,
                        action: 'Converting to local type'
                    });
                }
                
                return {
                    ...file,
                    type: 'local',  // Force type to local since these are from localStorage
                    // Clear collaborative flags for stale converted documents
                    isCollaborative: false,  // Clear this flag for localStorage files
                    hasLocalVersion: true,
                    isOfflineFirst: true, // All our files use Y.js + IndexedDB
                    // ‚úÖ FIX: Include collaborative metadata for linking
                    collaborativeOwner: file.collaborativeOwner,
                    collaborativePermlink: file.collaborativePermlink,
                    convertedToCollaborative: file.convertedToCollaborative,
                    collaborativeConvertedAt: file.collaborativeConvertedAt
                };
            });

            // ‚úÖ PERFORMANCE OPTIMIZATION: Skip IndexedDB scan on initial load for faster startup
            // Only scan IndexedDB when user actually opens the file browser or load modal
            // This eliminates the 87-database scan that was causing the "still slow" issue

        } catch (error) {
            console.error('‚ùå Failed to load local files:', error);
            this.component.localFiles = [];
        }
    }

    async scanIndexedDBDocuments() {
        console.log('üì± OFFLINE-FIRST: scanIndexedDBDocuments starting', {
            username: this.component.username,
            hasIndexedDB: !!indexedDB,
            hasDatabasesAPI: !!(indexedDB?.databases),
            offlineCachesBeforeScan: this.component.offlineCaches?.length || 0
        });
        
        try {

            if (!indexedDB.databases) {
                console.warn('‚ö†Ô∏è OFFLINE-FIRST: IndexedDB.databases API not available');
                return [];
            }

            const databases = await indexedDB.databases();
            
            // üì± OFFLINE-FIRST: Enhanced database logging
            console.log('üì± OFFLINE-FIRST: Found databases', {
                totalDatabases: databases.length,
                allDatabaseNames: databases.map(db => db.name),
                collaborativeCaches: databases.filter(db => db.name.includes('__') && db.name.includes('/')).map(db => db.name),
                localDatabases: databases.filter(db => db.name.startsWith('local_')).map(db => db.name),
                tempDatabases: databases.filter(db => db.name.startsWith('temp_')).map(db => db.name),
                username: this.component.username
            });

            // Track found documents to avoid duplicates
            const foundDocs = new Set();

            // Clear and populate indexedDBDocuments map
            this.component.indexedDBDocuments.clear();

            for (const dbInfo of databases) {
                const dbName = dbInfo.name;

                // Check if this is one of our document databases
                // Include collaborative documents (with /) and local/temp documents
                if (dbName && (dbName.startsWith('temp_') ||
                    dbName.startsWith('local_') ||
                    dbName.includes('/'))) {
                    foundDocs.add(dbName);

                    // Add to indexedDBDocuments map for status checking
                    this.component.indexedDBDocuments.set(dbName, {
                        name: dbName,
                        size: dbInfo.size || 0,
                        version: dbInfo.version || 1
                    });

                    // Check if we already have this in localStorage
                    const existsInLocalStorage = this.component.localFiles.some(f => f.id === dbName);

                    // Identify collaborative caches vs local documents
                    if (dbName.includes('__') && dbName.includes('/')) {
                        // It's a collaborative cache: username__owner/permlink
                        const [userPrefix, ownerPermlink] = dbName.split('__');
                        const [owner, permlink] = ownerPermlink?.split('/') || [];
                        
                        console.log('üì± OFFLINE-FIRST: Checking collaborative cache', {
                            dbName,
                            userPrefix,
                            currentUsername: this.component.username,
                            isUserMatch: userPrefix === this.component.username,
                            owner,
                            permlink
                        });
                        
                        // Check if this is the current user's cache
                        if (userPrefix === this.component.username) {
                            // Extract document name from Y.js
                            const documentName = await this.extractDocumentNameFromIndexedDB(dbName);
                            
                            // Add as collaborative cache, not local
                            const cachedDoc = {
                                id: dbName,
                                type: 'collaborative',
                                owner: owner,
                                permlink: permlink,
                                name: documentName || `${owner}/${permlink}`,
                                isOfflineCache: true,
                                hasLocalVersion: true,
                                created: new Date().toISOString(),
                                modified: new Date().toISOString()
                            };
                            
                            // Store in offlineCaches for deduplication
                            if (!this.component.offlineCaches) {
                                console.log('üì± OFFLINE-FIRST: Initializing offlineCaches array');
                                this.component.offlineCaches = [];
                            }
                            this.component.offlineCaches.push(cachedDoc);
                            
                            console.log('üì± OFFLINE-FIRST: Added collaborative cache to offlineCaches', {
                                dbName,
                                owner,
                                permlink,
                                documentName,
                                userPrefix,
                                currentUser: this.component.username,
                                totalOfflineCaches: this.component.offlineCaches.length
                            });
                        } else {
                            console.log('üì± OFFLINE-FIRST: Skipping cache - wrong user', {
                                dbName,
                                cacheUser: userPrefix,
                                currentUser: this.component.username
                            });
                        }
                    } else if (!existsInLocalStorage && (dbName.startsWith('temp_') || dbName.startsWith('local_'))) {
                        // It's a local/temp document
                        // ‚úÖ TIPTAP BEST PRACTICE: Extract real document name from Y.js config
                        const documentName = await this.extractDocumentNameFromIndexedDB(dbName);

                        // ‚úÖ SECURITY FIX: Only add orphaned IndexedDB documents if user is authenticated
                        if (this.component.username) {
                            // üìö PHANTOM DEBUG: Log orphaned IndexedDB document being added
                            console.log('üìö PHANTOM DEBUG: FOUND ORPHANED IndexedDB document', {
                                dbName,
                                documentName,
                                currentUser: this.component.username,
                                existsInLocalStorage: false,
                                localFilesIds: this.component.localFiles.map(f => f.id),
                                source: 'IndexedDB scan',
                                action: 'WILL ADD TO LOCAL FILES'
                            });
                            
                            this.component.localFiles.push({
                                id: dbName,
                                name: documentName || `Document ${dbName.substring(0, 8)}...`,
                                type: 'local',
                                created: new Date().toISOString(),
                                modified: new Date().toISOString(),
                                isOfflineFirst: true,
                                hasLocalVersion: true,
                                owner: this.component.username
                            });
                        }
                    }
                }
            }

            // Return the additional documents for merging
            const additionalDocs = this.component.localFiles.filter(f =>
                f.id && (f.id.startsWith('temp_') || f.id.startsWith('local_'))
            );
            
            console.log('üì± OFFLINE-FIRST: scanIndexedDBDocuments complete', {
                offlineCachesFound: this.component.offlineCaches?.length || 0,
                offlineCaches: this.component.offlineCaches?.map(c => ({
                    id: c.id,
                    owner: c.owner,
                    permlink: c.permlink
                })),
                additionalLocalDocs: additionalDocs.length,
                username: this.component.username
            });
            
            return additionalDocs;

        } catch (error) {
            console.error('‚ùå OFFLINE-FIRST: Error scanning IndexedDB:', error);
            return [];
        }
    }

    // ‚úÖ TIPTAP BEST PRACTICE: Extract document name from Y.js config in IndexedDB
    async extractDocumentNameFromIndexedDB(documentId) {
        try {

            // ‚úÖ CORRECT: Use same import pattern as other methods
            const tiptapBundle = window.TiptapCollaboration?.Editor
                ? window.TiptapCollaboration
                : window.TiptapCollaboration?.default;
            const Y = tiptapBundle?.Y;
            const IndexeddbPersistence = tiptapBundle?.IndexeddbPersistence;

            if (!Y || !IndexeddbPersistence) {
                console.warn('‚ö†Ô∏è Y.js or IndexedDB persistence not available for name extraction');
                return null;
            }

            // Temporarily create Y.js document and IndexedDB provider to read config
            const tempYdoc = new Y.Doc();
            const tempProvider = new IndexeddbPersistence(documentId, tempYdoc);

            // Wait for sync to load existing document with proper error handling
            await new Promise((resolve, reject) => {
                let isResolved = false;
                const startTime = Date.now();

                const checkTimeout = () => {
                    if (!isResolved && Date.now() - startTime > 500) {
                        isResolved = true;
                        console.warn('‚ö†Ô∏è IndexedDB sync timeout for document name extraction');
                        resolve(); // Don't reject, just proceed without document name
                    } else if (!isResolved) {
                        requestAnimationFrame(checkTimeout);
                    }
                };
                requestAnimationFrame(checkTimeout);

                tempProvider.once('synced', () => {
                    if (!isResolved) {
                        isResolved = true;
                        resolve();
                    }
                });

                // Check if already synced immediately
                if (tempProvider.synced) {
                    if (!isResolved) {
                        isResolved = true;
                        clearTimeout(timeoutId);
                        resolve();
                    }
                }
            });

            // ‚úÖ CORRECT: Extract document name from Y.js config (not editor content)
            const documentName = ydocService.getConfig('documentName');

            // Clean up temporary Y.js document and provider
            tempProvider.destroy();
            tempYdoc.destroy();

            if (documentName && documentName.trim() !== '') {

                return documentName;
            } else {

                return null;
            }

        } catch (error) {
            console.warn('‚ö†Ô∏è Could not extract document name from IndexedDB:', error.message);
            return null;
        }
    }

    async ensureLocalFileEntry() {
        if (!this.component.currentFile || !this.component.ydoc) {

            return;
        }

        // ‚úÖ SECURITY: Require authentication for saving documents
        if (!this.component.username) {
            console.warn('‚ö†Ô∏è Cannot save document: User not authenticated');
            return;
        }

        try {

            // ‚úÖ TIPTAP BEST PRACTICE: Get document name from Y.js config first
            // Access the computed property directly since we're inside DocumentManager class
            const configDocumentName = this.component.getDocumentNameFromConfig;
            const documentName = configDocumentName || this.component.currentFile?.name || `Untitled - ${new Date().toLocaleDateString()}`;

            // Create file metadata entry
            const fileEntry = {
                id: this.component.currentFile.id,
                name: documentName,
                type: 'local',
                created: this.component.currentFile.created || new Date().toISOString(),
                modified: new Date().toISOString(),
                isOfflineFirst: true,
                owner: this.component.username,
                lastModified: new Date().toISOString()
            };

            // Update localStorage metadata
            const files = this.component.documentStorageService.getAllDocuments();
            const existingIndex = files.findIndex(f => f.id === fileEntry.id);

            if (existingIndex >= 0) {
                files[existingIndex] = fileEntry;
            } else {
                files.push(fileEntry);
            }

            this.component.documentStorageService.saveAllDocuments(files);

            // Update component state
            this.component.currentFile = {
                ...this.component.currentFile,
                ...fileEntry
            };
            this.component.fileType = 'local';

            // ‚úÖ PERFORMANCE: Skip loadLocalFiles() on first save - only update localStorage
            // The file will appear in drafts when user opens load modal (lazy loading)

        } catch (error) {
            console.error('‚ùå Failed to ensure local file entry:', error);
        }
    }

    // ‚úÖ RULE 6 COMPLIANCE: Clean component state for fresh Y.js document creation
    async cleanupComponent() {

        try {
            // STEP 1: Destroy editors first using proper TipTap best practices
            await this.component.documentManager.lifecycleManager.destroyEditors();

            // STEP 2: Destroy WebSocket provider
            if (this.component.provider) {
                this.component.provider.disconnect();
                this.component.provider.destroy();
                this.component.provider = null;
            }

            // STEP 3: Destroy IndexedDB provider
            if (this.component.indexeddbProvider) {
                // ‚úÖ CRITICAL: Only clear data for collaborative documents
                // Local documents should preserve their IndexedDB data
                if (this.component.fileType === 'collaborative' &&
                    this.component.indexeddbProvider.clearData &&
                    typeof this.component.indexeddbProvider.clearData === 'function') {
                    await this.component.indexeddbProvider.clearData();
                } else if (this.component.fileType === 'local') {
                }
                this.component.indexeddbProvider.destroy();
                this.component.indexeddbProvider = null;
            }

            // STEP 4: Destroy Y.js document (critical for Rule 6 compliance)
            if (this.component.ydoc) {
                this.component.ydoc.destroy();
                this.component.ydoc = null;
            }

            // STEP 5: Reset component state
            this.component.connectionStatus = 'disconnected';
            this.component.connectedUsers = [];
            this.component.hasUnsavedChanges = false;
            this.component.hasUserIntent = false;
            this.component.hasIndexedDBPersistence = false;

            // STEP 6: Clear any pending timers
            if (this.component.tempPersistenceTimeout) {
                clearTimeout(this.component.tempPersistenceTimeout);
                this.component.tempPersistenceTimeout = null;
            }

        } catch (error) {
            console.error('‚ùå Component cleanup failed:', error);
            // Continue anyway - this is best effort cleanup
        }
    }
}

/**
 * 8. RECOVERY MANAGER
 * Y.js document corruption recovery and integrity validation
 */
class RecoveryManager {
    constructor(component) {
        this.component = component;
    }

    /**
     * ‚úÖ TIPTAP COMPLIANCE: Validate Y.js document integrity
     */
    async validateYjsDocumentIntegrity(ydoc) {
        if (!ydoc) return false;

        try {
            // Check if document can be encoded - use proper bundle access pattern
            const tiptapBundle = window.TiptapCollaboration?.Editor
                ? window.TiptapCollaboration
                : window.TiptapCollaboration?.default;
            const Y = tiptapBundle?.Y;
            if (!Y) {
                console.warn('‚ö†Ô∏è Y.js not available in TipTap bundle');
                return false;
            }

            const state = Y.encodeStateAsUpdate(ydoc);
            // Note: A new Y.js document might have a small state, that's OK
            if (!state) {
                console.warn('‚ö†Ô∏è Y.js document cannot be encoded');
                return false;
            }

            // Check required maps exist
            const isValid = ydocService.validateDocumentStructure(ydoc);
            
            // YDocService.validateDocumentStructure already checks for required maps
            return isValid;
        } catch (error) {
            console.error('‚ùå Y.js document validation failed:', error);
            return false;
        }
    }

    /**
     * ‚úÖ TIPTAP COMPLIANCE: Recover corrupted Y.js document
     */
    async recoverCorruptedDocument(documentId) {

        try {
            // Step 1: Try to restore from IndexedDB
            const recovered = await this.restoreFromIndexedDB(documentId);
            if (recovered) {
                return recovered;
            }

            // Step 2: Try to restore from server
            if (this.component.currentFile?.type === 'collaborative') {
                const serverDoc = await this.restoreFromServer(documentId);
                if (serverDoc) {
                    return serverDoc;
                }
            }

            // Step 3: Create fresh document as last resort
            console.warn('‚ö†Ô∏è Creating fresh Y.js document (data loss possible)');
            // Get Y.js from bundle
            const bundle = window.TiptapCollaboration;
            const Y = bundle?.Y;
            if (!Y) {
                throw new Error('Y.js not available in TipTap bundle');
            }

            // Create fresh document using YDocService for proper schema initialization
            const freshDoc = ydocService.createDocument(`recovery-${documentId}-${Date.now()}`);

            return freshDoc;

        } catch (error) {
            console.error('‚ùå Document recovery failed:', error);
            throw new Error('Unable to recover document: ' + error.message);
        }
    }

    /**
     * ‚úÖ TIPTAP COMPLIANCE: Restore from IndexedDB
     */
    async restoreFromIndexedDB(documentId) {
        try {
            // ‚úÖ CORRECT: Use smart access pattern like editor components
            const tiptapBundle = window.TiptapCollaboration?.Editor
                ? window.TiptapCollaboration
                : window.TiptapCollaboration?.default;
            const IndexeddbPersistence = tiptapBundle?.IndexeddbPersistence;

            if (!IndexeddbPersistence) {
                console.warn('‚ö†Ô∏è IndexeddbPersistence not available in TipTap bundle');
                return null;
            }

            // Get Y.js from bundle - use same pattern as above
            const Y = tiptapBundle?.Y;
            if (!Y) {
                console.warn('‚ö†Ô∏è Y.js not available in TipTap bundle');
                return null;
            }

            // Create temporary Y.js doc for recovery
            const tempDoc = new Y.Doc();
            const tempProvider = new IndexeddbPersistence(documentId, tempDoc);

            // Wait for sync using reactive pattern
            await new Promise((resolve) => {
                // Check if already synced
                if (tempProvider.synced) {
                    resolve();
                    return;
                }

                tempProvider.once('synced', () => {
                    resolve();
                });
            });

            // Validate recovered document
            if (await this.validateYjsDocumentIntegrity(tempDoc)) {
                return tempDoc;
            }

            tempProvider.destroy();
            tempDoc.destroy();
            return null;

        } catch (error) {
            console.warn('‚ö†Ô∏è IndexedDB recovery failed:', error);
            return null;
        }
    }

    /**
     * ‚úÖ TIPTAP COMPLIANCE: Restore from server
     */
    async restoreFromServer(documentId) {
        if (!this.component.isAuthenticated || !this.component.currentFile) {
            return null;
        }

        try {
            const { owner, permlink } = this.component.currentFile;
            const infoUrl = `https://data.dlux.io/api/collaboration/info/${owner}/${permlink}`;

            const response = await fetch(infoUrl, {
                headers: this.component.authHeaders
            });

            if (response.ok) {
                const data = await response.json();
                if (data.ydocState) {
                    // Create new doc from server state
                    const bundle = window.TiptapCollaboration;
                    const Y = bundle?.Y;
                    if (!Y) {
                        console.warn('‚ö†Ô∏è Y.js not available in TipTap bundle');
                        return null;
                    }

                    const serverDoc = new Y.Doc();
                    Y.applyUpdate(serverDoc, new Uint8Array(data.ydocState));

                    if (await this.validateYjsDocumentIntegrity(serverDoc)) {
                        return serverDoc;
                    }

                    serverDoc.destroy();
                }
            }

            return null;
        } catch (error) {
            console.warn('‚ö†Ô∏è Server recovery failed:', error);
            return null;
        }
    }

}

/**
 * 8. CONTENT STATE MANAGER
 * Manages content state without direct Y.js access (TipTap v3 compliance)
 */
class ContentStateManager {
    constructor(component) {
        this.component = component;
        this.contentLoaded = {
            title: false,
            body: false,
            permlink: false
        };
        this.lastKnownStats = {
            titleLength: 0,
            bodyLength: 0,
            isEmpty: true
        };
    }

    /**
     * Check if any content exists
     * @returns {boolean} True if any content exists
     */
    hasContent() {
        if (!this.component.bodyEditor) {
            return false;
        }

        const titleHasContent = (this.component.titleInput?.trim() || '').length > 0;
        const bodyHasContent = this.component.bodyEditor.getText().trim().length > 0;
        return titleHasContent || bodyHasContent;
    }

    /**
     * Get content statistics from editors
     * @returns {Object} Content statistics
     */
    getContentStats() {
        const stats = {
            titleLength: (this.component.titleInput || '').length,
            bodyLength: this.component.bodyEditor?.getText()?.length || 0,
            permlinkLength: (this.component.permlinkInput || '').length,
            isEmpty: true,
            hasTitle: false,
            hasBody: false,
            totalLength: 0
        };

        stats.hasTitle = stats.titleLength > 0;
        stats.hasBody = stats.bodyLength > 0;
        stats.isEmpty = !stats.hasTitle && !stats.hasBody;
        stats.totalLength = stats.titleLength + stats.bodyLength;

        // Cache the stats for use when editors aren't available
        this.lastKnownStats = { ...stats };

        return stats;
    }

    /**
     * Mark content as loaded for an editor
     * @param {string} editorType - 'title', 'body', or 'permlink'
     */
    markContentLoaded(editorType) {
        if (this.contentLoaded.hasOwnProperty(editorType)) {
            this.contentLoaded[editorType] = true;
        }
    }

    /**
     * Check if all content is loaded
     * @returns {boolean} True if all editors have loaded content
     */
    isAllContentLoaded() {
        return this.contentLoaded.title && this.contentLoaded.body;
    }

    /**
     * Reset content loaded state
     */
    resetContentLoadedState() {
        this.contentLoaded = {
            title: false,
            body: false,
            permlink: false
        };
    }

    /**
     * Get debug info without Y.js access
     * @returns {Object} Debug information
     */
    getDebugInfo() {
        const stats = this.getContentStats();
        return {
            editors: {
                bodyExists: !!this.component.bodyEditor,
                titleIsInput: true,
                permlinkIsInput: true
            },
            content: stats,
            loaded: this.contentLoaded,
            state: {
                isTemporary: this.component.isTemporaryDocument || false,
                isReadOnly: this.component.isReadOnlyMode || false,
                hasUnsavedChanges: this.component.hasUnsavedChanges || false
            }
        };
    }
}

// ==================== MAIN COMPONENT ====================

export default {
    name: 'TipTapEditorModular',

    emits: [
        'content-changed',
        'content-available',
        'publishPost',
        'publish-to-hive',
        'requestAuthHeaders',
        'request-auth-headers',
        'tosign',
        'update:fileToAdd',
        'document-converted',
        'collaborative-data-changed'
    ],

    props: {
        // ‚úÖ REMOVED authHeaders prop - using authStateManager as single source of truth
        authLoading: {
            type: Boolean,
            default: false
        },
        // ‚úÖ AUTH BRIDGE PROP: Accept auth bridge from parent component for modular auth
        authBridge: {
            type: Object,
            default: null
        },
        // ‚úÖ USERNAME PROP: Accept username from parent component (handles login/logout)
        usernameProp: {
            type: String,
            default: null
        },
        initialContent: Object,
        fileToAdd: String,
        dluxAssets: {
            type: Array,
            default: () => []
        }
    },

    // ‚úÖ REMOVED inject - using imported authStateManager singleton instead
    // This prevents dual-source conflicts and recursion

    data() {
        return {
            // ===== INSTANCE MANAGEMENT =====
            componentId: `tiptap_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`,
            isInitializing: false,
            creatingEditors: false,
            isCleaningUp: false,
            isExecutingCommand: false, // Prevent conflicts during command execution
            isYjsSyncing: false, // Track Y.js sync state
            // Content and storage timestamps
            contentTimestamps: {
                lastChange: null,           // Last content modification
                lastIndexedDBCreation: null // IndexedDB creation time
            },
            editorStabilizationDelay: 500, // ms to wait after changes before allowing commands
            editorCreatedAt: null, // Track when editor was created to prevent init triggers

            // ===== MANAGERS =====
            documentManager: null,
            eventManager: null, // Centralized event listener management,

            // ===== AUTHENTICATION =====
            // serverAuthFailed removed - handled through DLUXAuthBridge
            // Auth timestamp tracked in authTimestamps
            authModalActive: false, // ‚úÖ GOLDEN RULE #7: Track if auth modal is showing to prevent duplicates

            // ‚è±Ô∏è AUTH SEQUENCE: Track authentication flow timing
            authSequence: null,
            hasAnnouncedPresence: false, // Track if read-only user has sent initial presence
            failedPermissionAttempts: new Map(), // Track failed permission attempts per user/document to prevent infinite loops
            isConnectingToDocument: false, // Prevent multiple simultaneous connection attempts
            // Coordination flags removed - using event-driven architecture

            // ===== FILE MANAGEMENT =====
            currentFile: null,
            hasUnsavedChanges: false,
            saveError: false, // Track save errors for separate status indicators
            fileType: 'local', // 'local' or 'collaborative'
            isLoadingDocument: false, // ‚úÖ SECURITY: Prevent user intent detection during document loading
            editorInitialized: false, // ‚úÖ FIX: Prevent false triggers during editor initialization
            pendingDocumentLoad: null, // ‚úÖ COORDINATION: Prevent concurrent document loads from different flows
            isUnmounting: false, // ‚úÖ FIX: Prevent BubbleMenu positioning errors during unmount
            isCreatingNewDocument: false, // ‚úÖ FIX: Prevent duplicate newDocument() calls causing infinite loop
            isInitialMount: true, // ‚úÖ FIX: Prevent race conditions during component initialization

            // ===== DRAG TRACKING =====
            dragHandleHoveredNode: null, // Track which node the drag handle is hovering over

            // ===== SAVE STATUS DISPLAY =====
            saveMessageVisible: false,
            saveMessageText: '',
            saveMessagePersistent: false,
            saveMessageTimeout: null,
            showSavePopover: false,

            // ===== TIPTAP EDITORS =====
            // from interfering with ProseMirror's internal state management
            // ARCHITECTURE: Single editor approach - title is stored in titleInput, not a separate editor
            bodyEditor: null, // TipTap editor instance (the only editor)

            // ===== COLLABORATION =====
            ydoc: null,
            provider: null,
            indexeddbProvider: null,
            tempPersistenceTimeout: null,
            titleAutoSaveTimer: null,
            titleAutoSaveFrame: null,
            titleAutoSaveTimestamp: 0,
            contentUpdateFrame: null,
            contentUpdateTimestamp: 0,
            connectionStatus: 'disconnected',
            connectionMessage: 'Not connected',
            reconnectAttempts: 0, // ‚úÖ TIPTAP COMPLIANCE: Track reconnection for exponential backoff
            connectedUsers: [],
            isOfflineMode: false, // ‚úÖ OFFLINE-FIRST: Track when loading from cache without auth
            offlineModeReason: null, // ‚úÖ OFFLINE-FIRST: Reason for offline mode (not-authenticated, network-error, etc.)

            // ===== DOCUMENT ACCESS STATE =====
            // Note: Pending document access is now managed by DLUXAuthBridge

            // ===== CONTENT =====
            content: {
                tags: [],
                custom_json: {},
                beneficiaries: []
            },

            // ===== UI INPUTS FOR MAP FIELDS =====
            titleInput: '',
            permlinkInput: '',

            // ===== UI STATE =====
            showLoadModal: false,
            showSaveModal: false,
            showShareModal: false,
            showPublishModal: false,
            showAdvancedOptions: false,
            showStatusDetails: false,
            showImageEditModal: false,
            imageEditData: {
                pos: null,
                src: '',
                alt: '',
                title: ''
            },
            // Modular media edit system
            showMediaEditModal: false,
            mediaEditData: {
                pos: null,
                type: 'image', // 'image', 'video', 'audio', etc.
                src: '',
                alt: '',
                title: '',
                // Additional fields for different media types
                width: '',
                height: '',
                controls: true,
                autoplay: false,
                loop: false,
                muted: false
            },

            // ===== DOCUMENT NAME EDITING =====
            isEditingDocumentName: false,
            documentNameInput: '',
            cancelingEdit: false, // Flag to prevent blur save when canceling

            // ===== PERMLINK EDITING =====
            showPermlinkEditor: false,
            permlinkInputTemp: '', // Temporary value while editing
            originalPermlinkValue: '', // Store original value for cancel
            _isUpdatingPermlink: false, // Flag to prevent recursion during updates

            // ===== TAG MANAGEMENT =====
            tagInput: '',

            // ===== BENEFICIARIES =====
            beneficiaryInput: {
                account: '',
                percent: '1'
            },

            // ===== CUSTOM JSON =====
            customJsonString: '',
            customJsonError: '',

            // ===== COMMENT OPTIONS =====
            commentOptions: {
                allowVotes: true,
                allowCurationRewards: true,
                maxAcceptedPayout: false,
                percentHbd: false
            },

            // ===== FILE OPERATIONS =====
            saving: false,
            loading: false,
            deleting: false,
            publishing: false,

            // ===== DOCUMENTS =====
            localFiles: [],
            collaborativeDocs: [],
            offlineCaches: [], // Stores collaborative document caches found in IndexedDB
            loadingDocs: false,
            loadCollaborativeDocsController: null, // AbortController for request cancellation
            autoRefreshTimer: null,
            userSwitchTimestamp: null, // Cache-busting timestamp for connection pool reset
            loadCollaborativeDocsRetryCount: 0, // Track retry attempts for connection errors
            _handlingUserChange: false, // Flag to prevent duplicate user change handling

            // ===== TABLE SORTING =====
            sortColumn: 'lastModified', // default sort by last modified
            sortDirection: 'desc', // 'asc' or 'desc'

            // ===== FORMS =====
            saveForm: {
                filename: '',
                storageType: 'local',
                description: '',
                isNewDocument: false
            },

            shareForm: {
                username: '',
                permission: 'readonly'
            },

            publishForm: {
                tags: [],
                beneficiaries: [],
                customJson: {},
                votingWeight: 100
            },

            // ===== REACTIVE TRIGGERS =====
            collaborativeDataVersion: 0,

            // ===== FLAGS =====
            isLoadingPublishOptions: false,
            isUpdatingPublishOptions: false,
            isTemporaryDocument: false,
            tempDocumentId: null,
            isInitializingEditors: false,
            isUpdatingPermissions: false,
            hasIndexedDBPersistence: false,
            isPersistenceReady: false, // Track if document persistence is fully ready
            hasUnsavedChanges: false,
            hasUserIntent: false, // ‚úÖ TIPTAP COMPLIANCE: Track user intent without content access
            isCreatingPersistence: false, // Prevent multiple user intent triggers
            _collabDocLoadAttempted: false, // ‚úÖ AUTH TIMING: Prevent duplicate collab doc loads
            // ‚úÖ REACTIVE PATTERNS: Removed timeout variables - using immediate reactive patterns

            // ===== UI CONTROLS =====
            dropdownOpen: {},

            // ===== COLLABORATIVE USER WIDGET =====
            connectedUsers: [],
            showColorPicker: false,
            userColor: null,
            userColors: ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e'],

            // ===== HISTORY =====
            documentHistory: [],
            selectedVersions: [],

            // ===== MEMORY PROFILING =====
            memoryMonitorInterval: null,
            // Debug timestamps
            debugTimestamps: {
                lastMemoryProfile: null,
                lastStateValidation: null
            },

            // ===== PERFORMANCE =====
            debouncedAutoSave: null,
            autoSaveTimer: null,

            // ===== TEMP DOCUMENT STRATEGY =====
            creatingEditors: false,

            // ===== CONTENT RESTORATION =====
            pendingContentRestore: null,

            // ===== MODAL DATA =====
            saveAsLocal: true,
            publishAsDraft: false,

            // ===== DOCUMENT LISTS =====
            localFiles: [],
            indexedDBDocuments: new Map(), // Track IndexedDB cached documents
            loadingDocs: false,
            autoRefreshTimer: null,
            isLoadingCollaborativeDocs: false, // ‚úÖ PERMISSION FIX: Track when collaborative docs are being loaded

            // ===== PERFORMANCE OPTIMIZATION =====
            isRefreshingDocuments: false,
            // indexedDBScanCache: null, // REMOVED: Use documentService.getIndexedDBScanCache()
            // indexedDBScanCacheTime: 0, // REMOVED: Managed by documentService
            permissionLoadTimeout: null,

            // ===== AUTHENTICATION TIMING =====
            hasInitialAuthCheck: false,

            // ===== AUTHENTICATION CONTINUATION STATE =====
            pendingConversion: null,
            conversionInProgress: false,

            // ===== WEBGL LIFECYCLE FLAGS =====
            isUnmounting: false,

            // ===== DOCUMENT PERMISSIONS (MISSING REACTIVE PROPERTIES) =====
            loadingPermissions: false,

            // ===== TIPTAP SECURITY: Debounced permission validation =====
            permissionValidationTimeout: null,
            // Consolidated permission timing
            permissionTimestamps: {
                lastCheck: 0,          // Last permission check
                lastRefresh: 0,        // Last permission refresh
                lastBroadcast: 0,      // Last broadcast processed
                lastSkippedLog: 0      // Last skipped log message
            },
            lastUserSwitch: 0,

            // ‚úÖ REMOVED: reactivePermissionState - now using AuthStateManager's reactive state as single source of truth

            // ‚úÖ REMOVED: permissionUpdateTimeout - no longer needed with reactive AuthStateManager

            // ===== WEBSOCKET COMMAND QUEUE =====
            commandQueue: [], // Queue for commands to execute after WebSocket sync
            permissionLoadThrottle: null,

            // ===== PERMISSION CACHE: Removed - using AuthStateManager as single source =====
            // permissionCache: {}, // REMOVED: Use this.authStateManager.getCachedFilePermission()
            // documentMetadataCache: {}, // REMOVED: Use documentService for metadata

            // ===== REACTIVE Y.JS DOCUMENT NAME: Force Vue reactivity for Y.js config changes =====
            reactiveDocumentName: null,

            // Loading state for permissions - simplified to single key
            permissionLoadingKey: null,

            // ===== API THROTTLING: Prevent excessive API calls =====
            // API timestamps
            apiTimestamps: {
                lastCollabDocsLoad: 0
            },
            pendingPermissionRequests: new Map(), // ‚úÖ PERFORMANCE: Request deduplication

            // ===== ANALYTICS CACHES: Removed - using CollaborationService =====
            // analyticsCaches: {}, // REMOVED: Use collaborationService for analytics

            // ===== COLLABORATION ANALYTICS: Stats and activity tracking =====
            // REMOVED: Use collaborationService for all analytics data
            loadingInfo: false,
            loadingStats: false,
            loadingActivity: false,

            // ===== OFFLINE-FIRST PERMISSION SYSTEM: Real-time updates via WebSocket =====
            // Permission timestamps consolidated above
            permissionRefreshRate: 60000, // 1 minute - temporary until WebSocket broadcasts work
            fastPermissionRefreshRate: 30000, // 30 seconds when actively collaborating - temporary fast rate
            realtimePermissionUpdates: true, // Enable real-time permission updates
            isActivelyCollaborating: false, // Track if user is in active collaborative session
            // Permission timestamps consolidated above

            // ===== TIPTAP TIMING FIX: Deferred auto-connect for authentication race conditions =====
            pendingAutoConnect: null,
            authLoadTimeout: null,
            deferredCollabConnection: null,  // Store collab params when auth is loading
            deferredLocalConnection: null,   // Store local params when auth is loading

            // ===== AUTO-SAVE TIMEOUT =====
            autoSaveTimeout: null, // DEPRECATED - remove after full migration
            autoSaveFrame: null,
            autoSaveTimestamp: 0,

            // ===== URL LOADING: Track if we're loading from URL parameters =====
            isLoadingFromURL: false,

            // ===== SERVER VERSION CHECKING =====
            serverVersionCheckInterval: 3600000, // Check every hour
            isCheckingServerVersion: false,
            expectedServerVersion: '1.0.0', // Configure expected version
            serverVersionCheckTimer: null, // For periodic checks

            // ‚úÖ TIPTAP COMPLIANCE: Removed reactive content properties - use methods instead

            // ===== REACTIVE VERSION TRACKING =====
            // Force Vue reactivity for Y.js metadata changes
            // Reactive properties for Y.js metadata (proper Vue reactivity)
            reactiveTags: [],
            reactiveBeneficiaries: [],
            reactiveCommentOptions: {
                allowVotes: true,
                allowCurationRewards: true,
                maxAcceptedPayout: false,
                percentHbd: false
            },
            reactiveCustomJson: {},
            // ‚úÖ REMOVED: reactivePermlink - not used, replaced by actualPermlink() computed

            // ===== JSON PREVIEW REACTIVE DATA =====
            jsonPreview: {
                comment: {},          // Main comment operation
                commentOptions: null, // Comment options operation (null if defaults)
                metadata: {},         // Generation metadata
                complete: []          // Complete operations array
            },
            jsonPreviewModal: {
                show: false,
                tab: 'complete',
                validation: {
                    valid: true,
                    errors: [],
                    warnings: []
                }
            },

            // ===== STATE MONITORING =====
            enableStateMonitoring: false, // Enable detailed ProseMirror state logging
            stateValidationErrors: [],
            // Debug timestamps consolidated above

            // ===== LOADING MESSAGES =====
            showLoadingMessage: '', // Display loading messages during auth loading

            // ===== COMPREHENSIVE LOADING & ERROR STATES =====
            loadingStates: {
                auth: false,
                document: false,
                permissions: false
            },

            errorStates: {
                auth: null,
                document: null,
                permissions: null
            },

            // ===== TABLE TOOLBAR STATE =====
            // Track table state for CSS-based toolbar
            isInTable: false,
            selectionUpdateCounter: 0,  // Triggers computed property updates on selection change

            // ===== EDITOR INTERACTION TRACKING =====
            // Track editor focus and interaction for UI elements
            editorHasBeenFocused: false,  // Track if editor has received focus at least once
            editorInteractionCount: 0,     // Track number of interactions

        };
    },

    computed: {

        // Centralized auth bridge access
        authBridgeInstance() {
            // ‚úÖ CLEAN ARCHITECTURE: Auth bridge comes only from props
            return this.authBridge || null;
        },
        
        // ‚úÖ HEADLESS AUTH: Reactive access to auth bridge state
        authBridgeState() {
            return this.authBridgeInstance?.authState || null;
        },
        
        isAuthProcessing() {
            return this.authBridgeState?.isProcessing || false;
        },
        
        authError() {
            return this.authBridgeState?.error || null;
        },

        // ‚úÖ AUTH STATE MANAGER: Use imported singleton to avoid dual-source conflicts
        authStateManager() {
            return authStateManagerService; // Return the renamed import
        },

        // Centralized document storage service access
        documentStorageService() {
            return documentStorageService;
        },

        // Centralized cache service access
        cacheService() {
            return cacheService;
        },
        
        // ‚úÖ DOCUMENT SERVICE: Single source for document data
        documentService() {
            return documentService;
        },
        
        // ‚úÖ COLLABORATION SERVICE: Single source for analytics data
        collaborationService() {
            return collaborationService;
        },
        
        // ‚úÖ SERVER VERSION: Consolidate to CacheService as single source of truth
        serverVersion() {
            const cached = this.cacheService.getServerVersion();
            return cached?.version || null;
        },
        
        serverVersionCheckTime() {
            const cached = this.cacheService.getServerVersion();
            return cached?.checkTime || 0;
        },
        
        serverVersionMismatch() {
            const version = this.serverVersion;
            if (!version) return false;
            return version !== this.expectedServerVersion;
        },

        // Current text format for dropdown display
        currentTextFormat() {
            // Reference the counter to make Vue track selection changes
            this.selectionUpdateCounter;

            if (!this.bodyEditor || this.bodyEditor.isDestroyed) return 'Format';

            // Check heading levels
            if (this.isActive('heading', { level: 1 })) return 'Heading 1';
            if (this.isActive('heading', { level: 2 })) return 'Heading 2';
            if (this.isActive('heading', { level: 3 })) return 'Heading 3';
            if (this.isActive('heading', { level: 4 })) return 'Heading 4';
            if (this.isActive('heading', { level: 5 })) return 'Heading 5';
            if (this.isActive('heading', { level: 6 })) return 'Heading 6';

            // Check paragraph
            if (this.isActive('paragraph')) return 'Paragraph';

            // Default
            return 'Format';
        },

        // Check if text alignment is allowed at current position
        canUseTextAlign() {
            // Reference the counter to make Vue track selection changes
            this.selectionUpdateCounter;

            if (!this.bodyEditor || this.bodyEditor.isDestroyed) return false;

            // Check if we're in any node that shouldn't have text alignment
            const inBlockquote = this.isActive('blockquote');
            const inBulletList = this.isActive('bulletList');
            const inOrderedList = this.isActive('orderedList');
            const inTaskList = this.isActive('taskList');
            const inCodeBlock = this.isActive('codeBlock');

            // Debug logging to see what's happening
            if (inBlockquote) {
                console.log('üö´ canUseTextAlign: In blockquote, disabling alignment buttons');
            }

            if (inBlockquote) return false;
            if (inBulletList) return false;
            if (inOrderedList) return false;
            if (inTaskList) return false;
            if (inCodeBlock) return false;
            // Removed: if (this.isInTable) return false; - Now allowing text alignment in tables

            return true;
        },

        // Check if horizontal rule can be inserted at current position
        canInsertHorizontalRule() {
            // Reference the counter to make Vue track selection changes
            this.selectionUpdateCounter;

            if (!this.bodyEditor || this.bodyEditor.isDestroyed) return false;

            // Check if we're in any node that blocks horizontal rules
            if (this.isInTable) return false; // No HRs in tables
            if (this.isActive('blockquote')) return false; // No HRs in blockquotes
            if (this.isActive('codeBlock')) return false; // No HRs in code blocks

            return true;
        },

        // ‚úÖ SINGLE SOURCE OF TRUTH: Username from AuthStateManager
        username() {
            console.log('üìä TipTap username computed recalculating:', {
                usernameProp: this.usernameProp,
                authStateUser: this.authStateManager?.state?.user,
                timestamp: new Date().toISOString()
            });
            
            // ‚úÖ GOLDEN RULE #3: Single Source of Truth
            // AuthStateManager is THE authority on authenticated user identity
            const authUser = this.authStateManager?.state?.user;
            
            // ‚úÖ GOLDEN RULE #7: Single Responsibility
            // This computed property ONLY returns the username, no side effects
            if (authUser && authUser !== 'GUEST') {
                return authUser;
            }
            
            // Fallback for non-authenticated scenarios (initial page load)
            return this.usernameProp || null;
        },
        // ‚úÖ TIPTAP.DEV UNIFIED ARCHITECTURE: Single document model with unified status indicators
        allDocuments() {

            // Create a map to merge local and cloud versions of the same document
            const documentMap = new Map();

            // ‚úÖ OFFLINE-FIRST: Process offline caches first (collaborative docs cached in IndexedDB)
            // These are added when online docs aren't available
            const hasOfflineCaches = !!(this.offlineCaches && this.offlineCaches.length > 0);
            const offlineCachesArray = this.offlineCaches || [];
            console.log('üì± OFFLINE-FIRST: allDocuments computed - checking offline caches');
            console.log('  this.offlineCaches:', JSON.stringify(this.offlineCaches?.slice(0, 2)));
            console.log('  isArray:', Array.isArray(this.offlineCaches));
            console.log('  hasOfflineCaches:', hasOfflineCaches);
            console.log('  offlineCachesCount:', offlineCachesArray.length);
            console.log('  collaborativeDocsCount:', this.collaborativeDocs?.length || 0);
            if (hasOfflineCaches) {
                console.log('  offlineCaches content:');
                offlineCachesArray.forEach((c, i) => {
                    console.log(`    [${i}]: ${c.id} (${c.owner}/${c.permlink})`);
                });
            }
            
            if (this.offlineCaches && this.offlineCaches.length > 0) {
                console.log('üîç OFFLINE-DEBUG: Processing offlineCaches in allDocuments', JSON.stringify({
                    cacheCount: this.offlineCaches.length,
                    isAuthenticated: this.isAuthenticated,
                    username: this.username
                }, null, 2));
                
                this.offlineCaches.forEach(cachedDoc => {
                    const key = `${cachedDoc.owner}/${cachedDoc.permlink}`;
                    
                    // ‚úÖ OFFLINE-FIRST FIX: When not authenticated, collaborativeDocs will be empty
                    // so we should add all offline caches. When authenticated, check for duplicates.
                    let shouldAddCache = false;
                    
                    if (!this.isAuthenticated) {
                        // Not authenticated - add all offline caches
                        shouldAddCache = true;
                        console.log('üîç OFFLINE-DEBUG: Adding offline cache (not authenticated)', JSON.stringify({
                            key,
                            owner: cachedDoc.owner,
                            permlink: cachedDoc.permlink,
                            isOfflineCache: cachedDoc.isOfflineCache,
                            cachedDocId: cachedDoc.id
                        }, null, 2));
                    } else {
                        // Authenticated - only add if not in collaborativeDocs
                        const existsInCollaborativeDocs = this.collaborativeDocs.some(
                            doc => doc.owner === cachedDoc.owner && doc.permlink === cachedDoc.permlink
                        );
                        shouldAddCache = !existsInCollaborativeDocs;
                        
                        if (shouldAddCache) {
                            console.log('üîç OFFLINE-DEBUG: Adding offline cache (not in API results)', JSON.stringify({
                                key,
                                owner: cachedDoc.owner,
                                permlink: cachedDoc.permlink,
                                isOfflineCache: cachedDoc.isOfflineCache,
                                cachedDocId: cachedDoc.id
                            }, null, 2));
                        }
                    }
                    
                    if (shouldAddCache) {
                        const finalDoc = {
                            ...cachedDoc,
                            localStatus: 'cached',
                            cloudStatus: 'offline',
                            syncStatus: 'offline-cache'
                        };
                        documentMap.set(key, finalDoc);
                        console.log('üîç OFFLINE-DEBUG: Added doc to documentMap', JSON.stringify({
                            key,
                            isOfflineCache: finalDoc.isOfflineCache,
                            id: finalDoc.id,
                            type: finalDoc.type
                        }, null, 2));
                    }
                });
            }

            // ‚úÖ TIPTAP.DEV BEST PRACTICE: Process local documents first
            this.localFiles.forEach(localFile => {
                const key = this.getDocumentKey(localFile);

                // ‚úÖ UNIFIED ARCHITECTURE: Local documents that have been converted to collaborative
                // should be treated as collaborative documents with local cache
                // ‚úÖ FIX: Check for actual collaborative flag/type, not just owner/permlink
                const isConvertedCollaborative = (localFile.type === 'collaborative' || localFile.isCollaborative) && localFile.owner && localFile.permlink;
                
                // üìö PHANTOM DEBUG: Log suspicious local files
                if (isConvertedCollaborative) {
                    console.log('üìö PHANTOM DEBUG: Found converted collaborative in localFiles', {
                        owner: localFile.owner,
                        permlink: localFile.permlink,
                        type: localFile.type,
                        isCollaborative: localFile.isCollaborative,
                        key: key,
                        hasAccessType: !!localFile.accessType,
                        accessType: localFile.accessType
                    });
                }

                // ‚úÖ FIXED: Cloud indicator should show for ALL collaborative documents
                const hasCloudCapability = isConvertedCollaborative || ((localFile.isCollaborative || localFile.type === 'collaborative') && localFile.owner && localFile.permlink);

                // ‚úÖ DEBUG: Calculate status values with fallbacks
                const localStatus = this.getLocalStatus(localFile) || 'saved'; // Default to 'saved' for local files
                const cloudStatus = hasCloudCapability ? (this.getCloudStatus(localFile) || 'available') : 'none';
                const syncStatus = hasCloudCapability ? (this.getSyncStatus(localFile, localFile) || 'local-only') : 'local-only';

                // Local file status calculation - removed verbose logging for performance

                // ‚úÖ FIX: Check if this local file has been linked to a cloud document
                const isLinkedToCloud = localFile.collaborativeOwner && localFile.collaborativePermlink;

                // ‚úÖ FIX: Use cloud key if linked to prevent duplicates in the list
                const finalKey = isLinkedToCloud ? `${localFile.collaborativeOwner}/${localFile.collaborativePermlink}` : key;

                // ‚úÖ FIX: Skip adding if this will be a duplicate (cloud version will handle it)
                if (isLinkedToCloud && documentMap.has(finalKey)) {

                    return;
                }

                // ‚úÖ RESILIENCE: Schedule background validation for linked documents
                if (isLinkedToCloud) {
                    this.scheduleDocumentLinkValidation(localFile);
                }

                documentMap.set(finalKey, {
                    ...localFile,
                    // ‚úÖ FIX: Ensure type property is set for permission system
                    type: (hasCloudCapability || isLinkedToCloud) ? 'collaborative' : 'local',
                    // ‚úÖ FIX: Add cloud properties if linked
                    owner: isLinkedToCloud ? localFile.collaborativeOwner : localFile.owner,
                    permlink: isLinkedToCloud ? localFile.collaborativePermlink : localFile.permlink,
                    // UNIFIED MODEL: Single document with dual indicators
                    hasLocalVersion: true,
                    hasCloudVersion: hasCloudCapability || isLinkedToCloud,
                    localFile: localFile,
                    cloudFile: (hasCloudCapability || isLinkedToCloud) ? localFile : null,
                    // Prefer collaborative if it has cloud capability or is linked, otherwise local
                    preferredType: (hasCloudCapability || isLinkedToCloud) ? 'collaborative' : 'local',
                    // Status indicators with debug logging
                    localStatus: localStatus,
                    cloudStatus: isLinkedToCloud ? 'synced' : cloudStatus,
                    syncStatus: isLinkedToCloud ? 'synced' : syncStatus
                });
            });

            // ‚úÖ TIPTAP.DEV BEST PRACTICE: Process collaborative documents and merge intelligently
            if (this.showCollaborativeFeatures) {
                // üìö PHANTOM DEBUG: Log collaborative docs processing
                console.log('üìö PHANTOM DEBUG: Processing collaborative docs in allDocuments', {
                    showCollaborativeFeatures: this.showCollaborativeFeatures,
                    collaborativeDocsCount: this.collaborativeDocs.length,
                    collaborativeDocs: this.collaborativeDocs.slice(0, 3).map(d => ({
                        owner: d.owner,
                        permlink: d.permlink,
                        type: d.type,
                        accessType: d.accessType
                    })),
                    timestamp: Date.now()
                });
                
                // ‚úÖ SECURITY FIX: Filter collaborative documents to only show documents user has access to
                const accessibleCloudFiles = this.collaborativeDocs.filter(doc => {
                    // ‚úÖ UNIFIED PERMISSION SYSTEM: Use canAccessDocument for consistent access checks
                    return this.canAccessDocument(doc);
                });

                accessibleCloudFiles.forEach(cloudFile => {
                    // ‚úÖ FIX: Ensure collaborative documents have the required properties
                    cloudFile.type = 'collaborative';
                    cloudFile.isCollaborative = true;

                    const key = this.getDocumentKey(cloudFile);
                    const existing = documentMap.get(key);

                    if (existing) {
                        // ‚úÖ MERGE: Existing local version found (could be linked local file)

                        // ‚úÖ DEBUG: Calculate merged status values with fallbacks
                        const mergedLocalStatus = existing.localStatus || 'saved';
                        const mergedCloudStatus = this.getCloudStatus(cloudFile) || 'available';
                        const mergedSyncStatus = this.getSyncStatus(existing.localFile, cloudFile) || 'synced';

                        // Merged file status calculation - removed verbose logging for performance

                        documentMap.set(key, {
                            ...existing,
                            ...cloudFile, // Cloud file data takes precedence for metadata
                            // ‚úÖ FIX: Preserve local file name if it's more meaningful
                            name: existing.name || cloudFile.documentName || cloudFile.permlink,
                            // ‚úÖ FIX: Ensure type property is set for permission system
                            type: 'collaborative',
                            // Keep local file reference for actions
                            localFile: existing.localFile,
                            // Add cloud file reference
                            cloudFile: cloudFile,
                            // Update status flags
                            hasLocalVersion: existing.hasLocalVersion,
                            hasCloudVersion: true,
                            // TIPTAP BEST PRACTICE: Prefer cloud version for collaborative documents
                            preferredType: 'collaborative',
                            // Status indicators with debug logging and fallbacks
                            localStatus: mergedLocalStatus,
                            cloudStatus: mergedCloudStatus,
                            syncStatus: mergedSyncStatus
                        });
                    } else {
                        // ‚úÖ CLOUD-ONLY: Check if it has IndexedDB cache (offline-first pattern)
                        const cloudOnlyLocalStatus = this.getLocalStatus(cloudFile) || 'none';

                        // Collaborative document processing - removed verbose logging for performance

                        const cloudOnlyCloudStatus = this.getCloudStatus(cloudFile) || 'available';
                        // Cloud status result - removed verbose logging for performance

                        const cloudOnlySyncStatus = 'cloud-only'; // Available for sync but not cached

                        documentMap.set(key, {
                            ...cloudFile,
                            // ‚úÖ FIX: Ensure type property is set for permission system
                            type: 'collaborative',
                            hasLocalVersion: cloudOnlyLocalStatus !== 'none', // Dynamic based on IndexedDB check
                            hasCloudVersion: true,
                            localFile: null,
                            cloudFile: cloudFile,
                            preferredType: 'collaborative',
                            // Status indicators with debug logging and fallbacks
                            localStatus: cloudOnlyLocalStatus,
                            cloudStatus: cloudOnlyCloudStatus,
                            syncStatus: cloudOnlySyncStatus
                        });
                    }
                });
            }

            // ‚úÖ TIPTAP.DEV COMPLIANCE: IndexedDB is a CACHE, not a separate document source
            // We don't create separate entries for IndexedDB-only documents
            // They are cached versions of cloud documents or orphaned cache entries

            // Convert map to array and sort by most recent activity
            const allFiles = Array.from(documentMap.values());
            
            // Debug log the final documents
            console.log('üîç OFFLINE-DEBUG: allDocuments final output', JSON.stringify({
                count: allFiles.length,
                documents: allFiles.map(f => ({
                    id: f.id,
                    isOfflineCache: f.isOfflineCache,
                    type: f.type,
                    owner: f.owner,
                    permlink: f.permlink
                }))
            }, null, 2));

            return allFiles.sort((a, b) => {
                const aDate = new Date(a.updatedAt || a.lastModified || 0);
                const bDate = new Date(b.updatedAt || b.lastModified || 0);
                return bDate - aDate;
            });
        },

        // ‚úÖ SECURITY: Filtered document list - only shows documents user can access
        accessibleDocuments() {
            console.log('üîç OFFLINE-DEBUG: accessibleDocuments called, processing', this.allDocuments.length, 'documents');
            
            // Filter allDocuments to only show files the user can access
            const filteredDocs = this.allDocuments.filter(file => {
                const permissionLevel = this.getUserPermissionLevel(file);

                // ‚úÖ RULE #8: Apply access control to all documents
                // Trust that collaborativeDocs only contains validated documents
                const hasAccess = this.permissionService.hasAccess(permissionLevel);

                if (!hasAccess) {
                    // Log filtered out documents with debug tag
                    console.log('üîç OFFLINE-DEBUG: Document filtered out in accessibleDocuments', JSON.stringify({
                        id: file.id,
                        owner: file.owner,
                        permlink: file.permlink,
                        type: file.type,
                        isOfflineCache: file.isOfflineCache,
                        permissionLevel: permissionLevel,
                        hasAccess: hasAccess,
                        currentUser: this.username
                    }, null, 2));
                }

                return hasAccess;
            });
            
            // Log filtering results and actual documents
            console.log('üîç OFFLINE-DEBUG: accessibleDocuments result', JSON.stringify({
                totalDocs: this.allDocuments.length,
                accessibleDocs: filteredDocs.length,
                filteredOut: this.allDocuments.length - filteredDocs.length,
                timestamp: Date.now(),
                filteredDocuments: filteredDocs.map(d => ({
                    id: d.id,
                    name: d.name || d.documentName,
                    type: d.type,
                    owner: d.owner,
                    permlink: d.permlink,
                    isOfflineCache: d.isOfflineCache,
                    isCollaborative: d.isCollaborative,
                    convertedToCollaborative: d.convertedToCollaborative
                }))
            }, null, 2));

            // Apply sorting
            if (!filteredDocs || !Array.isArray(filteredDocs)) {
                return [];
            }

            // Sort documents based on current sort column and direction
            const sorted = [...filteredDocs].sort((a, b) => {
                let aValue, bValue;

                switch (this.sortColumn) {
                    case 'name':
                        aValue = (a.name || a.documentName || a.permlink || '').toLowerCase();
                        bValue = (b.name || b.documentName || b.permlink || '').toLowerCase();
                        break;
                    case 'type':
                        aValue = a.hasCloudVersion ? 'cloud' : 'local';
                        bValue = b.hasCloudVersion ? 'cloud' : 'local';
                        break;
                    case 'owner':
                        aValue = (a.owner || '').toLowerCase();
                        bValue = (b.owner || '').toLowerCase();
                        break;
                    case 'access':
                        aValue = this.getUserPermissionLevel(a);
                        bValue = this.getUserPermissionLevel(b);
                        break;
                    case 'lastModified':
                    default:
                        aValue = new Date(a.updatedAt || a.lastModified || 0).getTime();
                        bValue = new Date(b.updatedAt || b.lastModified || 0).getTime();
                        break;
                }

                if (this.sortDirection === 'asc') {
                    return aValue < bValue ? -1 : aValue > bValue ? 1 : 0;
                } else {
                    return bValue < aValue ? -1 : bValue > aValue ? 1 : 0;
                }
            });

            return sorted;
        },

        // ‚úÖ CLOUD BUTTON BACKGROUND: Background colors for cloud connection button
        cloudButtonStyle() {
            const state = this.cloudConnectionStatus.state;

            switch (state) {
                case 'non-collaborative':
                    return 'background-color: rgba(108, 117, 125, 0.2); border-left: 4px solid #6c757d;'; // Grey
                case 'connected':
                    return 'background-color: rgba(25, 135, 84, 0.2); border-left: 4px solid #198754;'; // Green
                case 'connecting':
                    return 'background-color: rgba(255, 193, 7, 0.2); border-left: 4px solid #ffc107;'; // Orange
                case 'offline':
                default:
                    return 'background-color: rgba(13, 202, 240, 0.2); border-left: 4px solid #0dcaf0;'; // Blue
            }
        },

        // ===== STATUS & CONNECTION =====
        unifiedStatusInfo() {
            // Implementation from current file - status logic for collaborative/offline states
            const status = {
                state: 'unknown',
                icon: '‚ùì',
                message: 'Unknown Status',
                details: '',
                actions: [],
                class: 'status-unknown'
            };

            const hasYjsDocument = !!this.ydoc;
            const isConnectedToServer = this.connectionStatus === 'connected';
            const hasWebSocketProvider = !!this.provider;

            // ‚úÖ STATUS DETECTION: Check current document state

            // ‚úÖ ENHANCED: Check for collaborative documents even without Y.js (loading state)
            // Only consider documents collaborative if explicitly marked as such
            // Local documents may have owner/permlink for URL routing but should remain local
            const isCollaborativeDocument = this.currentFile &&
                (this.currentFile.type === 'collaborative' ||
                    this.currentFile.isCollaborative === true);

            // ‚úÖ PRIORITY 0: COLLABORATIVE DOCUMENTS WITHOUT Y.js (early loading state)
            if (isCollaborativeDocument && !hasYjsDocument) {
                return {
                    state: 'loading-collaborative',
                    icon: '‚òÅÔ∏è',
                    message: 'Loading collaborative document...',
                    details: 'Initializing collaborative document system',
                    actions: [],
                    class: 'status-loading'
                };
            }

            if (hasYjsDocument) {
                // ‚úÖ PRIORITY 1: TEMP DOCUMENTS FIRST (highest priority - prevents contamination)
                if (this.isTemporaryDocument) {
                    if (this.hasUnsavedChanges) {
                        return {
                            state: 'saving-local',
                            icon: 'üíæ',
                            message: 'Saving locally...',
                            details: 'Creating draft document - changes will be saved to browser storage',
                            actions: [],
                            class: 'status-saving'
                        };
                    }

                    return {
                        state: 'temp-ready',
                        icon: 'üìù',
                        message: 'Ready to edit',
                        details: 'Temporary document - will become a draft when you make changes',
                        actions: [],
                        class: 'status-temp'
                    };
                }

                // ‚úÖ PRIORITY 2: CHECK FOR COLLABORATIVE DOCUMENTS FIRST
                // isCollaborativeDocument already defined above

                // ‚úÖ PRIORITY 2A: COLLABORATIVE DOCUMENTS (even if offline/read-only)
                if (isCollaborativeDocument) {
                    // Continue to collaborative status checks below
                }
                // ‚úÖ PRIORITY 2B: LOCAL DOCUMENT WITH INDEXEDDB PERSISTENCE (non-collaborative only)
                else if (this.hasIndexedDBPersistence && !isCollaborativeDocument) {
                    if (this.hasUnsavedChanges) {
                        return {
                            state: 'saving-local',
                            icon: 'üíæ',
                            message: 'Saving locally...',
                            details: 'Local document with Y.js persistence - changes saved to browser storage',
                            actions: [],
                            class: 'status-saving'
                        };
                    }

                    return {
                        state: 'saved-local',
                        icon: '‚úÖ',
                        message: 'Saved locally',
                        details: 'Local document with Y.js persistence - stored in browser storage',
                        actions: [],
                        class: 'status-saved'
                    };
                }

                // ‚úÖ VERSION CHECK: Show warning if server version mismatch detected
                if (this.serverVersionMismatch && isConnectedToServer) {
                    return {
                        state: 'version-mismatch',
                        icon: '‚ö†Ô∏è',
                        message: 'Server version mismatch',
                        details: `Server: ${this.serverVersion}, Expected: ${this.expectedServerVersion}`,
                        actions: [],
                        class: 'status-warning'
                    };
                }

                // ‚úÖ PRIORITY 3: COLLABORATIVE DOCUMENT WITH CLOUD CONNECTION
                if (isCollaborativeDocument && hasWebSocketProvider && isConnectedToServer) {
                    if (this.hasUnsavedChanges) {
                        return {
                            state: 'syncing',
                            icon: 'üîÑ',
                            message: 'Syncing changes...',
                            details: 'Real-time collaboration active - changes syncing to cloud',
                            actions: [],
                            class: 'status-syncing'
                        };
                    }

                    return {
                        state: 'synced',
                        icon: '‚òÅÔ∏è',
                        message: 'All changes synced',
                        details: 'Connected to collaboration server - offline-first enabled',
                        actions: [],
                        class: 'status-synced'
                    };
                }

                // ‚úÖ PRIORITY 4: COLLABORATIVE DOCUMENT WITH WEBSOCKET PROVIDER (True Collaborative Mode)
                if (isCollaborativeDocument && hasWebSocketProvider && this.hasIndexedDBPersistence) {
                    if (this.hasUnsavedChanges) {
                        return {
                            state: 'syncing',
                            icon: 'üîÑ',
                            message: 'Saving changes...',
                            details: 'Cloud collaboration - connecting in background, changes saved locally',
                            actions: [],
                            class: 'status-syncing'
                        };
                    }

                    return {
                        state: 'synced',
                        icon: '‚òÅÔ∏è',
                        message: 'Ready for collaboration',
                        details: 'Collaborative document loaded - connecting to cloud in background',
                        actions: [],
                        class: 'status-synced'
                    };
                }

                // ‚úÖ PRIORITY 4.5: COLLABORATIVE DOCUMENT WITHOUT WEBSOCKET (offline/loading state)
                if (isCollaborativeDocument && this.hasIndexedDBPersistence) {
                    // Check if we're explicitly disconnected
                    if (this.connectionStatus === 'disconnected' || this.connectionStatus === 'offline' || this.connectionStatus === 'error') {
                        if (this.hasUnsavedChanges) {
                            return {
                                state: 'cloud-disconnected-saving',
                                icon: 'üîÑ',
                                message: 'Saving changes locally...',
                                details: 'Cloud disconnected - changes saved locally, will sync when reconnected',
                                actions: [],
                                class: 'status-disconnected'
                            };
                        }

                        return {
                            state: 'cloud-disconnected',
                            icon: '‚òÅÔ∏è',
                            message: 'Cloud disconnected',
                            details: 'Working offline - changes saved locally',
                            actions: [],
                            class: 'status-disconnected'
                        };
                    }

                    if (this.hasUnsavedChanges) {
                        return {
                            state: 'syncing',
                            icon: 'üîÑ',
                            message: 'Saving changes...',
                            details: 'Collaborative document - changes saved locally, cloud sync pending',
                            actions: [],
                            class: 'status-syncing'
                        };
                    }

                    return {
                        state: 'cloud-offline',
                        icon: '‚òÅÔ∏è',
                        message: 'Collaborative document',
                        details: 'Document loaded locally - cloud connection establishing',
                        actions: [],
                        class: 'status-cloud-offline'
                    };
                }

                // ‚úÖ PRIORITY 4.6: COLLABORATIVE DOCUMENT FALLBACK (minimal state)
                if (isCollaborativeDocument) {
                    return {
                        state: 'collaborative',
                        icon: '‚òÅÔ∏è',
                        message: 'Collaborative document',
                        details: 'Loading collaborative document...',
                        actions: [],
                        class: 'status-collaborative'
                    };
                }

                // ‚úÖ PRIORITY 5: FALLBACK FOR INDEXEDDB PERSISTENCE (local documents only)
                if (this.hasIndexedDBPersistence) {
                    if (this.hasUnsavedChanges) {
                        return {
                            state: 'saving-local',
                            icon: 'üíæ',
                            message: 'Saving locally...',
                            details: 'Local document with Y.js persistence - changes saved to browser storage',
                            actions: [],
                            class: 'status-saving'
                        };
                    }

                    return {
                        state: 'saved-local',
                        icon: '‚úÖ',
                        message: 'Saved locally',
                        details: 'Local document with Y.js persistence - stored in browser storage',
                        actions: [],
                        class: 'status-saved'
                    };
                }

                if (this.hasUnsavedChanges) {
                    return {
                        state: 'saving-local',
                        icon: 'üíæ',
                        message: 'Saving locally...',
                        details: 'Local document with Y.js persistence - changes saved to browser storage',
                        actions: [],
                        class: 'status-saving'
                    };
                }

                return {
                    state: 'saved-local',
                    icon: '‚úÖ',
                    message: 'Saved locally',
                    details: 'Local document with Y.js persistence - stored in browser storage',
                    actions: [],
                    class: 'status-saved'
                };
            }

            // ‚úÖ FINAL FALLBACK: Collaborative documents without Y.js or editors
            if (isCollaborativeDocument) {
                return {
                    state: 'collaborative-loading',
                    icon: '‚òÅÔ∏è',
                    message: 'Collaborative document',
                    details: 'Loading collaborative document system...',
                    actions: [],
                    class: 'status-loading'
                };
            }

            if (!this.bodyEditor) {
                return {
                    state: 'no-document',
                    icon: 'üìÑ',
                    message: 'No document loaded',
                    details: 'Create a new document or open an existing one to start editing',
                    actions: [],
                    class: 'status-temp'
                };
            }

            return status;
        },

        // ‚úÖ CLOUD CONNECTION STATUS: Pure cloud collaboration connection state
        cloudConnectionStatus() {
            const isCollaborativeDocument = this.currentFile &&
                (this.currentFile.type === 'collaborative' ||
                    this.currentFile.isCollaborative === true);

            if (!isCollaborativeDocument) {
                return {
                    state: 'non-collaborative',
                    icon: 'fas fa-cloud text-muted opacity-25',
                    message: 'Local document',
                    class: 'status-grey'
                };
            }

            // Collaborative document - check connection status
            switch (this.connectionStatus) {
                case 'connected':
                    return {
                        state: 'connected',
                        icon: 'fas fa-cloud text-success',
                        message: 'Connected',
                        class: 'status-green'
                    };

                case 'connecting':
                    return {
                        state: 'connecting',
                        icon: 'fas fa-cloud text-warning',
                        message: 'Connecting...',
                        class: 'status-orange'
                    };

                case 'disconnected':
                case 'offline':
                case 'error':
                default:
                    return {
                        state: 'offline',
                        icon: 'fas fa-cloud text-info',
                        message: 'Offline',
                        class: 'status-blue'
                    };
            }
        },

        // ‚úÖ SAVE STATUS: Pure document persistence state
        saveStatus() {
            // Show indicator when:
            // 1. Document has persistence, OR
            // 2. Document has unsaved changes (even if creating persistence)
            const visible = (!this.isTemporaryDocument || this.hasIndexedDBPersistence || this.hasUnsavedChanges);

            // Check if save failed first
            if (this.saveError) {
                return {
                    state: 'error',
                    icon: 'fas fa-exclamation-triangle text-warning',
                    message: 'Save failed',
                    class: 'status-error text-warning',
                    visible: visible,
                    persistent: true // Errors should not fade
                };
            }

            // For collaborative docs that are offline
            const isCollaborativeOffline = this.currentFile &&
                (this.currentFile.type === 'collaborative' || this.currentFile.isCollaborative === true) &&
                this.connectionStatus !== 'connected';

            if (this.hasUnsavedChanges) {
                return {
                    state: 'saving',
                    icon: 'fas fa-circle-notch fa-spin text-muted',
                    message: this.getSaveMessage('saving'),
                    class: 'status-saving text-muted',
                    visible: visible,
                    persistent: false // Can fade after save completes
                };
            }

            // Changes saved
            return {
                state: 'saved',
                icon: 'fas fa-check text-muted',
                message: this.getSaveMessage('saved'),
                class: 'status-saved text-muted',
                visible: visible,
                persistent: isCollaborativeOffline // Persist if offline
            };
        },

        isConnected() {
            return this.connectionStatus === 'connected';
        },

        isAuthenticated() {
            // ‚úÖ SINGLE SOURCE OF TRUTH: Proxy to AuthStateManager
            const result = this.authStateManager.isAuthenticated();
            
            // Log only on state changes to reduce noise
            if (this._lastAuthState !== result) {
                console.log('üî¥ AUTH-FLOW: isAuthenticated computed property changed', {
                    isAuthenticated: result,
                    authState: this.authStateManager._stateWrapper?.authState,
                    hasHeaders: !!this.authStateManager.state?.authHeaders,
                    user: this.authStateManager.state?.user
                });
                this._lastAuthState = result;
            }
            
            return result;
        },

        // ‚úÖ SINGLE SOURCE OF TRUTH: Auth headers from AuthStateManager
        authHeaders() {
            // Proxy to AuthStateManager - the single source of truth
            return this.authStateManager.getAuthHeaders();
        },

        // ‚úÖ ACCESS CONTROL: Determine access capabilities based on auth state
        canAccessLocalDocuments() {
            // Local documents can be accessed by anyone (authenticated or not)
            // Only blocked during active auth loading
            return !this.authLoading;
        },

        canAccessCollaborativeDocuments() {
            // Collaborative documents require full authentication
            const result = this.isAuthenticated;
            
            console.log('üîµ OFFLINE-CACHE-DEBUG: canAccessCollaborativeDocuments evaluated', {
                result,
                isAuthenticated: this.isAuthenticated,
                username: this.username,
                hasAuthHeaders: !!this.authHeaders,
                currentFile: this.currentFile ? `${this.currentFile.owner}/${this.currentFile.permlink}` : null
            });
            
            return result;
        },

        isAuthExpired() {
            // ‚úÖ UNIFIED: Use validated auth headers from AuthStateManager
            const validatedHeaders = this.isAuthenticated ? this.authHeaders : null;
            if (!validatedHeaders) return true;

            try {
                const challenge = JSON.parse(this.authStateManager.getAuthChallenge(validatedHeaders));
                const expiry = challenge.expire;
                return Date.now() > expiry;
            } catch (error) {
                console.error('Error parsing challenge:', error);
                return true;
            }
        },

        // ===== LOADING & ERROR STATES =====

        // ‚úÖ COMPREHENSIVE LOADING STATE: Check if anything is loading
        isAnyLoading() {
            return Object.values(this.loadingStates).some(v => v) || this.authLoading;
        },

        // ‚úÖ CURRENT ERROR: Get the most relevant error
        currentError() {
            return Object.values(this.errorStates).find(v => v) || null;
        },

        // ===== PERMISSIONS =====

        // ‚úÖ PERMISSION LOADING STATE: Track if permissions are being loaded
        isPermissionLoading() {
            if (!this.currentFile) return false;
            const key = this.getDocumentKey(this.currentFile);
            return this.permissionLoadingKey === key;
        },

        // ‚úÖ SINGLE SOURCE: Get document permissions from CacheService
        documentPermissions() {
            if (!this.currentFile || this.currentFile.type !== 'collaborative') return [];
            
            // Get document key
            const documentKey = `${this.currentFile.owner}/${this.currentFile.permlink}`;
            
            // Get cached permissions from CacheService
            const cachedData = this.cacheService.getCachedDocumentPermissions(
                documentKey,
                this.username
            );
            
            // Return cached permissions or empty array
            return cachedData || [];
        },

        // ‚úÖ DERIVED STATE: Computed list of shared users (excludes owner)
        sharedUsers() {
            if (!this.currentFile || !this.documentPermissions.length) return [];
            
            // Filter out the owner from permissions list
            return this.documentPermissions.filter(permission => 
                permission.account !== this.currentFile.owner
            );
        },

        canEdit() {
            // ‚úÖ ENHANCED: Proper integration with 3-endpoint permission system
            if (!this.bodyEditor) {
                return false; // No editor available
            }

            // ‚úÖ PERFORMANCE: Use cached read-only mode calculation
            if (this.isReadOnlyMode) {
                return false; // Document is in read-only mode
            }

            // ‚úÖ ENHANCED: Additional permission validation for collaborative documents
            if (this.currentFile && this.currentFile.type === 'collaborative') {
                const permissionLevel = this.getUserPermissionLevel(this.currentFile);
                // ‚úÖ 4-TIER PERMISSION MODEL: Allow editing for all levels except readonly and no-access
                // - owner: Can edit
                // - postable: Can edit
                // - editable: Can edit
                // - readonly: Cannot edit
                // - no-access: Cannot edit
                return !this.isReadOnlyOrWorse(permissionLevel);
            }

            // ‚úÖ DEFAULT: Local documents and temp documents are editable
            return true;
        },

        canDelete() {
            if (!this.currentFile || this.deleting) {
                return false;
            }

            // ‚úÖ UNIFIED PERMISSION SYSTEM: Use getUserPermissionLevel for delete permission
            const permissionLevel = this.getUserPermissionLevel(this.currentFile);

            // Only owners can delete documents
            return this.isOwnerPermission(permissionLevel);
        },

        // ===== COLLABORATIVE FEATURES =====
        showCollaborativeFeatures() {
            return this.isAuthenticated && !this.isAuthExpired;
        },

        // ‚úÖ MISSING COMPUTED PROPERTY: Determine if current document is in collaborative mode
        isCollaborativeMode() {
            // Check if current document is collaborative
            if (!this.currentFile) return false;

            // Only use explicit collaborative indicators
            // Do NOT rely on owner/permlink alone as local documents can have these
            return this.currentFile.type === 'collaborative' ||
                this.currentFile.isCollaborative === true;
        },

        // Get collaborative documents owned by current user
        ownedCloudFiles() {
            // ‚úÖ UNIFIED: Use username directly since we're checking ownership
            if (!this.showCollaborativeFeatures || !this.isAuthenticated || !this.username) {
                return [];
            }
            return this.collaborativeDocs.filter(doc => doc.owner === this.username);
        },

        // ===== DISPLAY HELPERS =====

        shareableDocumentURL() {
            return this.generateShareableURL();
        },

        // ===== EDITOR CAPABILITIES =====

        // ===== COLLABORATIVE USER WIDGET =====
        avatarUrl() {
            if (!this.username) return '';
            return `https://images.hive.blog/u/${this.username}/avatar/small`;
        },

        getUserColor() {
            if (this.userColor) return this.userColor;

            // Generate a consistent color based on username
            if (this.username) {
                const hash = this.username.split('').reduce((a, b) => {
                    a = ((a << 5) - a) + b.charCodeAt(0);
                    return a & a;
                }, 0);
                const index = Math.abs(hash) % this.userColors.length;
                return this.userColors[index];
            }

            return this.userColors[0]; // Default color
        },

        // ===== MISSING COMPUTED PROPERTIES =====

        displayTags() {
            // ‚úÖ PROPER REACTIVITY: Return reactive Vue property that's synced from Y.js
            return this.reactiveTags;
        },

        displayBeneficiaries() {
            // ‚úÖ PROPER REACTIVITY: Return reactive Vue property that's synced from Y.js
            return this.reactiveBeneficiaries;
        },

        displayCommentOptions() {
            // ‚úÖ REACTIVE PATTERN: Return reactive comment options
            return this.reactiveCommentOptions;
        },

        displayCustomJson() {
            // ‚úÖ REACTIVE PATTERN: Return reactive custom JSON
            return this.reactiveCustomJson;
        },

        // ‚úÖ REMOVED: displayPermlink - use actualPermlink() instead

        documentTitleIndicator() {
            // Check document type first - collaborative vs local
            if (!this.isCollaborativeMode) {
                // Local document - always show dotted cloud
                return `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-muted" style="opacity: 0.6;">
                        <path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z" stroke-dasharray="2,2"/>
                    </svg>
                `;
            }

            // Collaborative document - check connection status
            if (this.connectionStatus === 'connecting') {
                // Spinner cloud (connecting)
                return `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-primary">
                        <path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"/>
                        <circle cx="12" cy="12" r="3" fill="none" stroke="currentColor" stroke-width="1">
                            <animateTransform attributeName="transform" type="rotate" values="0 12 12;360 12 12" dur="1s" repeatCount="indefinite"/>
                        </circle>
                    </svg>
                `;
            }

            if (this.connectionStatus === 'connected') {
                // Solid cloud (connected)
                //const color = this.hasUnsavedChanges ? 'text-warning' : 'text-success';
                return `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" class="text-success">
                        <path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"/>
                    </svg>
                `;
            }

            // Disconnected/offline collaborative document - solid yellow cloud with slash
            return `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-warning">
                    <path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"/>
                    <line x1="3" y1="3" x2="21" y2="21" stroke="currentColor" stroke-width="2"/>
                </svg>
            `;
        },

        // ===== TEMPLATE DISPLAY HELPERS =====
        // ‚úÖ CORRECT: Computed properties for template display (not reactive content sync)

        // ===== DOCUMENT NAME UTILITIES =====
        // ‚úÖ CORRECT: Get document name from Y.js config (for file lists, UI display)
        getDocumentNameFromConfig() {
            // ‚úÖ REACTIVITY FIX: Use reactive property instead of direct Y.js access
            // This ensures Vue knows when the document name changes
            return this.reactiveDocumentName;
        },

        // ‚úÖ CORRECT: Display document name (NOT title content) - COMPUTED PROPERTY
        displayDocumentName() {
            // Priority: Y.js config > currentFile object > safe fallback (NO username/permlink)
            const yjsDocumentName = this.getDocumentNameFromConfig;

            // Computing display name

            if (yjsDocumentName && yjsDocumentName.trim() !== '') {
                return yjsDocumentName;
            }

            // For collaborative documents, use only documentName field
            if (this.currentFile?.type === 'collaborative' || this.currentFile?.isCollaborative) {
                const documentName = this.currentFile?.documentName;
                if (documentName && documentName.trim() !== '') {
                    return documentName;
                }
            } else {
                // For local files, use name field
                const fileName = this.currentFile?.name;
                if (fileName && fileName.trim() !== '' && !fileName.includes('/')) {
                    return fileName;
                }
            }

            // ‚úÖ SAFE FALLBACK: Never return username/permlink format
            return `Untitled - ${new Date().toLocaleDateString()}`;
        },

        // ‚úÖ CORRECT: Set document name in Y.js config

        // ‚úÖ CORRECT: Update UI from Y.js config changes (for real-time collaboration)
        updateDocumentNameFromConfig() {
            const configDocumentName = this.getDocumentNameFromConfig;
            if (configDocumentName && this.currentFile) {
                this.currentFile.name = configDocumentName;
                this.currentFile.documentName = configDocumentName;
                this.currentFile.title = configDocumentName; // For UI display

                // Note: cacheDocumentMetadata is now a method, not accessible from computed
                // This will be handled in the methods section when needed

                // ‚úÖ SYNC: Update localStorage metadata to match Y.js config
                if (this.currentFile.id && this.currentFile.type === 'local') {
                    this.documentStorageService.updateDocumentMetadata(this.currentFile.id, { name: configDocumentName });
                }

            }
        },

        // ===== DOCUMENT NAME DEBUGGING =====
        debugDocumentName() {
            // Document name debugging - removed verbose logging for performance
        },

        // ===== READONLY MODE COMPUTATION =====
        // ‚úÖ PERFORMANCE: Enhanced read-only mode with proper new document handling
        isReadOnlyMode() {
            // ‚úÖ TEMP DOCUMENT OVERRIDE: Temp documents are ALWAYS editable (highest priority)
            if (this.isTemporaryDocument) {
                return false;
            }

            // ‚úÖ PERSISTENCE CREATION OVERRIDE: During IndexedDB creation, keep editable
            if (this.isCreatingPersistence) {
                return false;
            }

            // ‚úÖ AUTH LOADING: If auth is still loading, use safe defaults
            if (this.authLoading) {
                // For local documents, remain editable during auth loading
                if (this.currentFile && this.currentFile.type === 'local') {
                    return false;
                }
                // For collaborative documents, check cached permissions first
                if (this.currentFile && this.currentFile.type === 'collaborative') {
                    // Check if we have cached permissions that indicate edit access
                    const cachedPermission = this.authStateManager?.getCachedPermission(this.currentFile.owner, this.currentFile.permlink);
                    if (cachedPermission) {
                        // If cached permission shows edit access, remain editable
                        // ‚úÖ UNIFIED: Use helper for permission check
                        if (this.canEditWithPermission(cachedPermission)) {
                            return false;
                        }
                    }

                    // Default to readonly if no cached permissions
                    return true;
                }
                // For new documents (no currentFile), remain editable
                return false;
            }

            // ‚úÖ SECURITY: Default collaborative documents to readonly until proven otherwise
            // Check if we're loading a collaborative document from URL
            const urlParams = new URLSearchParams(window.location.search);
            const isLoadingCollaborativeFromURL = urlParams.has('collab_owner') && urlParams.has('collab_permlink');

            // ‚úÖ LOCAL DOCUMENT OVERRIDE: Local documents are ALWAYS editable (by design)
            if (!this.currentFile) {
                // If no currentFile but loading collaborative doc, default to readonly
                if (isLoadingCollaborativeFromURL) {
                    return true; // Default collaborative to readonly
                }
                return false; // No document = new document = editable
            }

            // ‚úÖ FAST PATH: Check document type first (most reliable)
            if (this.currentFile.type === 'local') {
                return false; // Local documents are always editable
            }

            // ‚úÖ FAST PATH: Check for local IDs (backup check)
            if (this.currentFile.id && (
                this.currentFile.id.startsWith('temp_') ||
                this.currentFile.id.startsWith('local_')
            )) {
                return false; // Local/temp documents are always editable
            }

            // ‚úÖ CONVERSION STATE OVERRIDE: Keep documents editable during cloud conversion
            if (this.conversionInProgress && this.currentFile?.type === 'local') {
                return false;
            }

            // ‚úÖ PENDING CONVERSION OVERRIDE: Keep documents editable when auth is pending
            if (this.pendingConversion && this.pendingConversion.type === 'cloud-conversion' &&
                this.currentFile?.type === 'local') {
                return false;
            }

            // ‚úÖ COLLABORATIVE DOCUMENTS: Only check permissions for collaborative docs
            if (this.currentFile?.type === 'collaborative') {
                // ‚úÖ TIPTAP BEST PRACTICE: Use getUserPermissionLevel for consistent 4-tier permission handling
                const userPermission = this.getUserPermissionLevel(this.currentFile);

                // ‚úÖ 4-TIER PERMISSION MODEL COMPLIANCE:
                // - owner: Full control (edit + share + delete)
                // - postable: Can edit and publish to blockchain
                // - editable: Can edit but not publish
                // - readonly: Can only view
                // - no-access: Cannot access document

                // Return true (read-only mode) for readonly and no-access
                return this.isReadOnlyOrWorse(userPermission);
            }

            // ‚úÖ DEFAULT: All non-collaborative documents are editable
            return false;
        },

        // ‚úÖ COMMENT OPTIONS: Check if rewards are declined
        areRewardsDeclined() {
            // When maxAcceptedPayout checkbox is true, rewards are declined
            return this.reactiveCommentOptions.maxAcceptedPayout === true;
        },

        // ===== DROPDOWN MENU SUPPORT =====
        canShare() {
            // Only document owners can share
            if (!this.isAuthenticated || !this.currentFile || this.currentFile.type !== 'collaborative') {
                return false;
            }

            // ‚úÖ UNIFIED PERMISSION SYSTEM: Use isOwner computed property
            return this.isOwner;
        },

        canDuplicate() {
            // Can only duplicate documents that have persistence
            if (!this.currentFile) {
                return false;
            }

            // Collaborative documents are always duplicable (already persisted on server)
            if (this.currentFile.type === 'collaborative') {
                return true;
            }

            // Local documents: only duplicable if they have IndexedDB persistence
            // (i.e., user has shown intent and autosave created persistence)
            return !this.isTemporaryDocument || this.hasIndexedDBPersistence;
        },

        // ===== COLLABORATION ANALYTICS COMPUTED PROPERTIES =====

        showCollaborationAnalytics() {
            // Show analytics for collaborative documents with info or stats
            return this.currentFile &&
                this.currentFile.type === 'collaborative' &&
                (this.collaborationInfo || this.collaborationStats) &&
                this.isAuthenticated;
        },

        collaborationMetadata() {
            if (!this.collaborationInfo) return null;

            const info = this.collaborationInfo;
            return {
                documentName: info.documentName,
                documentPath: info.documentPath,
                hasContent: info.hasContent,
                contentSize: this.formatFileSize(info.contentSize || 0),
                accessType: info.accessType,
                websocketUrl: info.websocketUrl,
                createdAt: info.createdAt ? this.formatTime(new Date(info.createdAt)) : 'Unknown',
                updatedAt: info.updatedAt ? this.formatTime(new Date(info.updatedAt)) : 'Unknown',
                lastActivity: info.lastActivity ? this.formatTime(new Date(info.lastActivity)) : 'Never'
            };
        },

        collaborationSummary() {
            if (!this.collaborationStats) return null;

            const stats = this.collaborationStats;
            return {
                totalUsers: stats.total_users || 0,
                activeUsers: stats.active_users || 0,
                totalEdits: stats.total_edits || 0,
                documentSize: this.formatFileSize(stats.document_size || 0),
                lastActivity: stats.last_activity ? this.formatTime(new Date(stats.last_activity)) : 'Never',
                inactivityDays: stats.inactivity_days || 0,
                isRecentlyActive: (stats.inactivity_days || 0) < 7
            };
        },

        recentCollaborationActivity() {
            return this.collaborationActivity.slice(0, 10).map(activity => ({
                account: activity.account,
                type: activity.activity_type,
                timestamp: this.formatTime(new Date(activity.created_at)),
                data: activity.activity_data,
                isRecent: (Date.now() - new Date(activity.created_at).getTime()) < (24 * 60 * 60 * 1000) // 24 hours
            }));
        },

        collaborationInsights() {
            if (!this.collaborationStats && !this.collaborationInfo) return null;

            const stats = this.collaborationStats || {};
            const info = this.collaborationInfo || {};
            const permissions = stats.permissions_summary || {};

            return {
                // Document metadata insights
                documentMetrics: {
                    hasContent: info.hasContent,
                    contentSize: info.contentSize || stats.document_size || 0,
                    accessType: info.accessType,
                    documentAge: this.getDocumentAge(info.createdAt),
                    lastModified: this.getTimeSince(info.updatedAt || info.lastActivity)
                },

                // User engagement insights
                userEngagement: {
                    total: permissions.total_users || 0,
                    readonly: permissions.readonly_users || 0,
                    editors: permissions.editable_users || 0,
                    publishers: permissions.postable_users || 0
                },

                // Activity insights
                activityLevel: this.getActivityLevel(stats.inactivity_days),
                editFrequency: this.getEditFrequency(stats.total_edits, stats.last_activity || info.lastActivity),
                collaborationHealth: this.getCollaborationHealth(stats, info)
            };
        },

        // ‚úÖ TIPTAP SECURITY: Hide content immediately when user boundary violations detected
        shouldHideContent() {
            // ‚úÖ TEMP DOCUMENT OVERRIDE: Temp documents are ALWAYS visible
            if (this.isTemporaryDocument) {
                return false;
            }

            // ‚úÖ PERSISTENCE CREATION OVERRIDE: During IndexedDB creation, keep visible
            if (this.isCreatingPersistence) {
                return false;
            }

            // ‚úÖ PERFORMANCE: Fast path for new documents (always visible)
            if (!this.currentFile) {
                return false;
            }

            // ‚úÖ LOCAL DOCUMENTS: Check ownership boundaries
            if (this.currentFile.type === 'local') {
                const fileOwner = this.currentFile.owner;
                if (fileOwner && this.username && fileOwner !== this.username) {
                    return true; // Hide immediately - user boundary violation
                }
                return false; // Local documents owned by current user are visible
            }

            // ‚úÖ FAST PATH: Check for local IDs (backup check)
            if (this.currentFile.id && (
                this.currentFile.id.startsWith('temp_') ||
                this.currentFile.id.startsWith('local_')
            )) {
                return false; // Local/temp documents are always visible
            }

            // ‚úÖ COLLABORATIVE DOCUMENTS: Only check permissions for collaborative docs
            if (this.currentFile.type === 'collaborative') {
                // Use cached permission result if available and recent
                const now = Date.now();
                if (this.lastPermissionCheck && (now - this.lastPermissionCheck) < 500) {
                    return this.lastReadOnlyResult && this.getUserPermissionLevel(this.currentFile) === 'no-access';
                }

                const localPermission = this.getUserPermissionLevel(this.currentFile);
                return this.permissionService.hasNoAccess(localPermission);
            }

            // ‚úÖ DEFAULT: All non-collaborative documents are visible
            return false;
        },

        // ‚úÖ PERMLINK GENERATION: Generate URL-safe permlink from title
        generatedPermlink() {
            // Generate slug from title input
            const titleText = this.titleInput ? this.titleInput.trim() : '';
            if (!titleText) return '';

            return titleText
                .toLowerCase()
                .replace(/[^a-z0-9\s-]/g, '') // Remove invalid characters
                .replace(/\s+/g, '-') // Convert spaces to hyphens
                .replace(/-+/g, '-') // Collapse multiple hyphens
                .trim()
                .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
                .substring(0, 100); // Limit to 100 characters for Hive compatibility
        },

        // ‚úÖ SIMPLIFIED: Get the actual permlink that will be used (custom or generated)
        actualPermlink() {
            // For validation and display, use the effective permlink
            // Custom permlink (sanitized) takes priority, then generated
            if (this.permlinkInput && this.permlinkInput.trim()) {
                return this.sanitizedCustomPermlink;
            }
            return this.generatedPermlink;
        },

        // ‚úÖ NEW: Get sanitized version of custom permlink for saving
        sanitizedCustomPermlink() {
            if (!this.permlinkInput || !this.permlinkInput.trim()) return '';

            const input = this.permlinkInput.trim();
            return input
                .toLowerCase()
                .replace(/[^a-z0-9\s-]/g, '') // Remove invalid characters
                .replace(/\s+/g, '-') // Convert spaces to hyphens
                .replace(/-+/g, '-') // Collapse multiple hyphens
                .trim()
                .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
                .substring(0, 100); // Limit to 100 characters for Hive compatibility
        },

        // ===== JSON PREVIEW COMPUTED PROPERTIES =====

        // Parent permlink for Hive posts
        parentPermlink() {
            // Default parent for new posts
            return 'hive-161511'; // DLUX community
        },

        // Convert beneficiaries from reactive array to Hive format
        beneficiariesArray() {
            if (!this.reactiveBeneficiaries || this.reactiveBeneficiaries.length === 0) {
                return [];
            }

            // Convert to Hive format and sort by account name (required by Hive)
            return this.reactiveBeneficiaries
                .filter(b => b.account && b.weight > 0)
                .map(b => ({
                    account: b.account.toLowerCase().trim(),
                    weight: parseInt(b.weight) // Weight in basis points (100 = 1%)
                }))
                .sort((a, b) => a.account.localeCompare(b.account));
        },

        // Parse custom JSON from reactive object
        customJsonObject() {
            // Return the reactive custom JSON object
            return this.reactiveCustomJson || {};
        },

        // Check if we have non-default comment options
        hasNonDefaultCommentOptions() {
            return !this.reactiveCommentOptions.allowVotes ||
                !this.reactiveCommentOptions.allowCurationRewards ||
                this.reactiveCommentOptions.maxAcceptedPayout !== false ||
                this.reactiveCommentOptions.percentHbd !== false ||
                this.beneficiariesArray.length > 0;
        },

        // Generate JSON metadata for the post
        jsonMetadata() {
            const metadata = {
                app: 'dlux/1.0',
                format: 'markdown',
                tags: this.reactiveTags || [],
                custom: this.customJsonObject
            };

            // Add document metadata if available
            if (this.currentFile) {
                metadata.document = {
                    id: this.currentFile.id,
                    type: this.currentFile.type,
                    created: this.currentFile.created,
                    modified: new Date().toISOString()
                };
            }

            // Add collaboration metadata if applicable
            if (this.isCollaborativeMode && this.currentFile) {
                metadata.collaboration = {
                    owner: this.currentFile.owner,
                    permlink: this.currentFile.permlink,
                    users: this.connectedUsers.length
                };
            }

            return metadata;
        },

        // Generate comment operation from current state
        commentOperation() {
            return {
                "comment": {
                    "parent_author": "",
                    "parent_permlink": this.parentPermlink,
                    "author": this.username || 'anonymous',
                    "permlink": this.actualPermlink,
                    "title": this.titleInput || 'Untitled',
                    "body": this.getBodyContent ? this.getBodyContent() : '',
                    "json_metadata": JSON.stringify(this.jsonMetadata)
                }
            };
        },

        // Generate comment_options operation if needed
        commentOptionsOperation() {
            // Only generate if we have non-default values
            if (!this.hasNonDefaultCommentOptions) return null;

            const options = {
                "comment_options": {
                    "author": this.username || 'anonymous',
                    "permlink": this.actualPermlink,
                    "max_accepted_payout": this.reactiveCommentOptions.maxAcceptedPayout ?
                        "0.000 HBD" : "1000000.000 HBD",
                    "percent_hbd": this.reactiveCommentOptions.percentHbd ? 10000 : 0,
                    "allow_votes": this.reactiveCommentOptions.allowVotes,
                    "allow_curation_rewards": this.reactiveCommentOptions.allowCurationRewards,
                    "extensions": []
                }
            };

            // Add beneficiaries if any
            if (this.beneficiariesArray.length > 0) {
                options.comment_options.extensions.push([0, {
                    "beneficiaries": this.beneficiariesArray
                }]);
            }

            return options;
        },

        // Complete operations array for Hive broadcast
        completeOperations() {
            const ops = [["comment", this.commentOperation.comment]];

            if (this.commentOptionsOperation) {
                ops.push(["comment_options", this.commentOptionsOperation.comment_options]);
            }

            return ops;
        },

        // ===== PERMISSION LEVEL COMPUTED PROPERTIES =====

        /**
         * Check if permissions are currently loading
         */
        isPermissionLoading() {
            if (!this.currentFile || this.currentFile.type !== 'collaborative') return false;
            
            // Check if collaborative docs are still loading
            if (this.authStateManager?.state?.collaborativeDocsLoading) {
                return true;
            }
            
            // Could add more loading checks here if needed
            return false;
        },

        /**
         * Current user's permission level for the active document
         */
        currentPermissionLevel() {
            if (!this.currentFile || !this.username) return 'no-access';

            // For local documents - user always has full control
            if (this.currentFile.type === 'local') return 'owner';

            // For collaborative docs:
            // ‚úÖ SINGLE SOURCE OF TRUTH: Use AuthStateManager's reactive cache
            const cachedPermission = this.authStateManager.getCachedPermission(
                this.currentFile.owner,
                this.currentFile.permlink
            );
            
            if (cachedPermission) {
                return cachedPermission;
            }

            // If no cached permission, check documentPermissions array
            if (this.documentPermissions && this.username) {
                const userPerm = this.documentPermissions.find(p => p.account === this.username);
                if (userPerm) {
                    // Permission caching is handled internally by getMasterPermissionForDocument
                    return userPerm.permissionType;
                }
            }

            // Default to readonly for collaborative docs without permission data
            return this.getDefaultPermissionLevel();
        },

        /**
         * Permission level checks for UI reactivity
         */
        isOwner() {
            // ‚úÖ UNIFIED PERMISSION SYSTEM: Use getUserPermissionLevel for all ownership checks
            if (!this.currentFile) return false;
            return this.isOwnerPermission(this.getUserPermissionLevel(this.currentFile));
        },

        isPostable() {
            return this.canPublishWithPermission(this.currentPermissionLevel);
        },

        isEditable() {
            return this.canEditWithPermission(this.currentPermissionLevel);
        },

        isReadonly() {
            return this.currentPermissionLevel === this.getDefaultPermissionLevel();
        },

        hasNoAccess() {
            return this.currentPermissionLevel === this.getNoAccessPermissionLevel();
        },

        canPublish() {
            // ‚úÖ TIPTAP COMPLIANCE: Use computed properties instead of methods
            const titleText = this.titleInput ? this.titleInput.trim() : '';
            const bodyText = this.bodyEditor ? this.bodyEditor.getText().trim() : '';

            // Basic content validation
            if (!titleText || !bodyText) return false;

            // Check tags from reactive state (source of truth for UI)
            const hasTags = this.reactiveTags.length > 0;

            if (!hasTags) return false;

            // ‚úÖ ENHANCED: Permission-based publish validation
            if (this.currentFile?.type === 'collaborative') {
                // Collaborative documents require authentication AND publish permission

                // Use simplified currentPermissionLevel instead of getUserPermissionLevel
                return this.isPostable; // This checks for 'postable' or 'owner'
            } else {
                // Local documents and temp documents can be published without authentication
                // (publishing will prompt for auth when needed)
                return true;
            }
        }
    },

    watch: {
        // ‚úÖ OFFLINE-FIRST: Watch offlineCaches for debugging
        offlineCaches: {
            handler(newVal, oldVal) {
                console.log('üì± OFFLINE-FIRST: offlineCaches watcher triggered');
                console.log('  oldLength:', oldVal?.length || 0);
                console.log('  newLength:', newVal?.length || 0);
                if (newVal && newVal.length > 0) {
                    console.log('  New offline caches:');
                    newVal.forEach((c, i) => {
                        console.log(`    [${i}]: ${c.id}`);
                    });
                }
            },
            deep: true,
            immediate: true
        },
        
        // ‚úÖ PENDING UPGRADE: Process deferred WebSocket upgrades
        isLoadingDocument: {
            handler(newValue, oldValue) {
                // Process pending upgrade when loading completes
                if (oldValue === true && newValue === false && this._pendingUpgrade) {
                    const { yjsDoc, webSocketProvider } = this._pendingUpgrade;
                    this._pendingUpgrade = null;
                    console.log('üîÑ Processing deferred WebSocket upgrade');
                    this.documentManager?.persistenceManager?.upgradeToCloudEditors(yjsDoc, webSocketProvider);
                }
            }
        },
        
        // üîê AUTH STATE: Track authentication changes
        isAuthenticated: {
            handler(newValue, oldValue) {
                // Skip initial mount
                if (oldValue === undefined) return;
                
                console.log('üîê isAuthenticated changed:', {
                    from: oldValue,
                    to: newValue,
                    timestamp: new Date().toISOString()
                });
                
                // Call the existing handler
                this.handleAuthenticationStateChange(newValue, oldValue);
            }
        },
        
        // üîê AUTH TIMING: Track username changes
        username: {
            handler(newValue, oldValue) {
                console.log('üîê AUTH TIMING: Username watcher triggered', {
                    oldValue: oldValue,
                    newValue: newValue,
                    isGuestUser: !newValue || newValue === 'GUEST',
                    wasGuestUser: !oldValue || oldValue === 'GUEST',
                    changeType: !oldValue ? 'initial' :
                        oldValue === 'GUEST' && newValue !== 'GUEST' ? 'login' :
                            oldValue !== 'GUEST' && newValue === 'GUEST' ? 'logout' :
                                oldValue !== newValue ? 'switch' : 'no-change',
                    timestamp: new Date().toISOString()
                });
            },
            immediate: true
        },

        // üîê AUTH TIMING: Track username prop changes
        usernameProp: {
            handler(newValue, oldValue) {
                console.log('üîê AUTH TIMING: usernameProp changed', {
                    oldValue: oldValue,
                    newValue: newValue,
                    timestamp: new Date().toISOString()
                });
            },
            immediate: true
        },

        // ‚úÖ PERMISSION WATCHER: Update editor state when permissions change
        currentPermissionLevel: {
            handler(newValue, oldValue) {
                // Skip initial mount
                if (oldValue === undefined) return;
                
                // Skip if component is being destroyed or no editor
                if (this._isDestroyed || !this.bodyEditor || !this.currentFile) return;
                
                console.log('üîí Permission level changed:', {
                    from: oldValue,
                    to: newValue,
                    username: this.username,
                    timestamp: new Date().toISOString()
                });
                
                // Update editor state based on new permission level
                this.updateEditorMode();
                
                // Also update WebSocket connection if needed
                if (ydocService.isReady() && this.selectedFile) {
                    // If permission upgraded from readonly/no-access to editable/postable/owner
                    const wasReadOnly = ['readonly', 'no-access'].includes(oldValue);
                    const canEditNow = ['editable', 'postable', 'owner'].includes(newValue);
                    
                    if (wasReadOnly && canEditNow && this.collaborationStatus === 'connected') {
                        console.log('üîÑ Permission upgraded - reconnecting WebSocket for edit access');
                        // Force reconnection to apply new permissions
                        this.handleWebSocketReconnection();
                    }
                }
            }
        },

        // ‚úÖ SAVE STATUS WATCHERS: Update save indicator when state changes
        hasUnsavedChanges: {
            handler(newValue, oldValue) {
                if (newValue !== oldValue) {
                    this.$nextTick(() => {
                        this.updateSaveStatus();
                    });
                }
            },
            immediate: true
        },

        saveError: {
            handler(newValue, oldValue) {
                if (newValue !== oldValue) {
                    this.updateSaveStatus();
                }
            }
        },


        hasIndexedDBPersistence: {
            handler(newValue, oldValue) {
                if (newValue !== oldValue) {
                    this.updateSaveStatus();
                }
            }
        },

        connectionStatus: {
            handler(newValue, oldValue) {
                if (newValue !== oldValue) {
                    // Update save message when connection changes
                    this.updateSaveStatus();
                }
            }
        },

        // ‚úÖ REPLACED BY setupAuthHeadersListener: This watcher is now handled in handleAuthHeadersChange
        /*
        authHeaders: {
            immediate: true, // Run on mount to check initial state
            handler(newHeaders, oldHeaders) {
                // Logic moved to handleAuthHeadersChange method
            }
        },
        */


        // ‚úÖ FIXED: Watch permlink input and sync to Y.js metadata (ultra-defensive)
        permlinkInput: {
            handler(newPermlink, oldPermlink) {
                // ‚úÖ RECURSION PROTECTION: Multiple defensive guards
                if (this._isUpdatingPermlink) {
                    return;
                }

                if (newPermlink === oldPermlink) {
                    return;
                }

                if (typeof newPermlink !== 'string') {
                    return;
                }

                // ‚úÖ DEFENSIVE: Only sync actual user changes
                this.debouncedSetPermlinkInMetadata();
            },
            immediate: false // Don't trigger on initial value
        },

        // ‚úÖ AUTHENTICATION LOADING: Handle auth loading completion
        authLoading: {
            immediate: true,
            handler(newValue, oldValue) {

                // ‚úÖ FIX: Skip during initial mount to prevent race conditions
                if (this.isInitialMount) {
                    return;
                }

                // Only proceed when auth loading completes (true -> false)
                if (newValue) return;

                // Also check for initial false value
                if (oldValue === undefined && newValue === false) {
                }

                // Check for deferred collaborative connection
                if (this.deferredCollabConnection && this.isAuthenticated) {
                    const { owner, permlink } = this.deferredCollabConnection;
                    this.deferredCollabConnection = null;
                    this.showLoadingMessage = '';
                    this.loadingStates.auth = false;
                    this.isLoadingFromURL = true;
                    this.autoConnectToCollaborativeDocument(owner, permlink).catch(error => {
                        console.error('‚ùå Deferred collaborative connection failed:', error);
                        this.isLoadingFromURL = false;

                        // ‚úÖ FIX: Don't create temp document on connection failure
                        // Set error state and preserve URL for retry
                        this.connectionStatus = 'error';
                        this.connectionMessage = 'Failed to connect to collaborative document. Check your authentication and try again.';
                    });
                    return;
                }

                // Check if we're now authenticated and have a collaborative URL
                if (this.isAuthenticated) {
                    const urlParams = new URLSearchParams(window.location.search);
                    const collabOwner = urlParams.get('collab_owner');
                    const collabPermlink = urlParams.get('collab_permlink');

                    if (collabOwner && collabPermlink && !this.isLoadingFromURL) {
                        this.isLoadingFromURL = true;
                        this.autoConnectToCollaborativeDocument(collabOwner, collabPermlink).catch(error => {
                            console.error('‚ùå Failed to auto-connect to collaborative document:', error);
                            this.isLoadingFromURL = false;
                            this.isLoadingDocument = false; // Reset loading flag on error

                            // Check if it's a temporary error
                            const isTemporaryError = error.message.includes('fetch') ||
                                error.message.includes('network') ||
                                error.message.includes('timeout');

                            if (!isTemporaryError) {
                                console.warn('üîó Clearing URL due to permanent error after auth');
                                this.clearCollabURLParams();

                                // Only create new document for permanent errors where URL is cleared
                                if (!this.currentFile) {
                                    this.documentManager.newDocument();
                                }
                            } else {
                                // ‚úÖ FIX: For temporary errors, preserve URL and set error state
                                this.connectionStatus = 'error';
                                this.connectionMessage = 'Temporary error loading document after authentication. Please retry.';
                            }
                        });
                    }
                } else if (!this.currentFile) {
                    // No document loaded yet
                    const urlParams = new URLSearchParams(window.location.search);
                    const collabOwner = urlParams.get('collab_owner');
                    const collabPermlink = urlParams.get('collab_permlink');

                    if (collabOwner && collabPermlink) {
                        // ‚úÖ FIX: No document loaded yet, but we have URL params - load the collaborative document
                        this.isLoadingFromURL = true;
                        this.autoConnectToCollaborativeDocument(collabOwner, collabPermlink).catch(error => {
                            console.error('‚ùå Failed to auto-connect to collaborative document:', error);
                            this.isLoadingFromURL = false;
                            this.isLoadingDocument = false; // Reset loading flag on error

                            if (!this.currentFile) {
                                this.documentManager.newDocument();
                            }
                        });
                    } else {
                        // No URL params and no document - create new
                        this.documentManager.newDocument();
                    }
                }
            }
        },

        // ‚úÖ REPLACED BY EVENT-DRIVEN APPROACH: This watcher has been replaced by handleUserChange method
        // which is triggered by DLUXAuthBridge userChanged events for better control
        /*
        username: {
            async handler(newUsername, oldUsername) {
                console.log('üë§ DEBUG: Username watcher - HANDLER CALLED', {
                    oldUsername,
                    newUsername,
                    usernameChanged: oldUsername !== newUsername,
                    hasCurrentFile: !!this.currentFile,
                    authBridgeExists: !!this.authBridgeInstance,
                    componentDestroyed: this._isDestroyed,
                    timestamp: new Date().toISOString()
                });
                
                // ‚úÖ ENHANCED DEBUG: Detailed watcher information
                console.log('üë§ DEBUG: Username watcher detailed state:', {
                    computedPropertySources: {
                        authLoading: this.authLoading,
                        authAccount: this.authStateManager.getAuthAccount(this.isAuthenticated ? this.authHeaders : null),
                        usernameProp: this.usernameProp,
                        authStateManager: this.authStateManager?.getUser()
                    },
                    watcherInfo: {
                        triggerTimestamp: new Date().toISOString(),
                        usernameComputedCalled: 'Check computed logs above',
                        immediateMode: false,
                        deepMode: false
                    }
                });
                
                // Skip initial mount
                if (!oldUsername && !this.currentFile) {
                    console.log('üë§ DEBUG: Skipping username watcher - initial mount without current file');
                    return;
                }
                
                // Skip if username hasn't actually changed
                if (newUsername === oldUsername) {
                    console.log('üë§ DEBUG: Skipping username watcher - username unchanged');
                    return;
                }
                
                console.log('üîê DEBUG: Username changed - processing user switch:', {
                    from: oldUsername,
                    to: newUsername,
                    hasCurrentFile: !!this.currentFile,
                    currentFile: this.currentFile,
                    authBridge: !!this.authBridgeInstance,
                    pendingAccess: this.authBridgeInstance?.authState?.pendingDocumentAccess
                });

                // ‚úÖ AUTH STATE MANAGER: Update user state if available
                if (this.authStateManager) {
                    console.log('üîê AuthStateManager: Updating user state', { oldUsername, newUsername });
                    this.authStateManager.setUser(newUsername);
                    // Note: Not using syncAuthStateFromBridge() here as we only need to update user
                    
                    // For logout - auth manager handles document clearing
                    if (!newUsername) {
                        console.log('üîê AuthStateManager: User logout detected');
                        // AuthStateManager will emit clearDocument event
                        // which is handled by our listener
                        return;
                    }
                }
                
                // ‚úÖ CONNECTION CLEANUP: Cancel all pending HTTP requests from old user
                this.cancelAllPendingRequests('user-switch');
                
                // ‚úÖ CACHE BUSTING: Clear connection state for new user
                this.resetConnectionPoolForUserSwitch(oldUsername, newUsername);
                
                // Clear all permission caches
                this.clearAllPermissionCaches();
                
                // ‚úÖ CLEAR STALE PERMISSIONS: Clear cached permissions when switching users
                if (oldUsername !== newUsername) {
                    console.log('üîÑ DEBUG: Username changed - clearing stale permission cache:', {
                        oldUsername,
                        newUsername,
                        oldPermissionLevel: this.currentPermissionLevel,
                        wasAuthenticated: this.isAuthenticated
                    });
                    
                    // Permission level will automatically update via computed property
                    console.log('üîÑ DEBUG: User switched - permission level will recalculate');
                }
                
                // ‚úÖ AUTH BRIDGE INTEGRATION: Update auth bridge with new account state
                const authBridge = this.authBridgeInstance;
                if (authBridge) {
                    console.log('üîë DEBUG: Updating auth bridge with new username:', {
                        oldUsername,
                        newUsername,
                        hasPendingAccess: !!authBridge.authState.pendingDocumentAccess,
                        pendingAccess: authBridge.authState.pendingDocumentAccess
                    });
                    authBridge.setAccount(newUsername || null);
                    
                    // ‚úÖ COMPREHENSIVE USER SWITCH VALIDATION
                    console.log('üîç DEBUG: Starting account validation for user switch:', {
                        newUsername,
                        hasPendingAccess: !!authBridge.authState.pendingDocumentAccess,
                        pendingAccess: authBridge.authState.pendingDocumentAccess,
                        hasCurrentFile: !!this.currentFile,
                        currentFile: this.currentFile,
                        currentFileOwner: this.currentFile?.owner,
                        currentFilePermlink: this.currentFile?.permlink
                    });
                    
                    // ‚úÖ PRIMARY PATH: Pending document access from auth modal
                    if (authBridge.authState.pendingDocumentAccess && newUsername) {
                        console.log('‚úÖ DEBUG: PRIMARY PATH - Account changed with pending document access - validating new account');
                        console.log('‚úÖ DEBUG: Pending access details:', authBridge.authState.pendingDocumentAccess);
                        
                        // Use nextTick to ensure username change has propagated
                        this.$nextTick(() => {
                            console.log('‚úÖ DEBUG: Executing validateAccountForPendingDocument with pending access');
                            this.validateAccountForPendingDocument(authBridge.authState.pendingDocumentAccess);
                        });
                        
                    // ‚úÖ FALLBACK PATH: Use current file if no pending access
                    } else if (newUsername && this.currentFile && (this.currentFile.owner || this.currentFile.permlink)) {
                        console.log('üîÑ DEBUG: FALLBACK PATH - Account changed with current file context - using fallback validation');
                        
                        const fallbackDocumentInfo = {
                            name: this.currentFile.name || this.currentFile.documentName || `${this.currentFile.owner}/${this.currentFile.permlink}`,
                            owner: this.currentFile.owner,
                            permlink: this.currentFile.permlink,
                            id: this.currentFile.id,
                            type: this.currentFile.type || (this.currentFile.permlink ? 'collaborative' : 'local')
                        };
                        
                        console.log('üîÑ DEBUG: Fallback document info:', fallbackDocumentInfo);
                        
                        this.$nextTick(() => {
                            console.log('üîÑ DEBUG: Executing validateAccountForPendingDocument with fallback info');
                            this.validateAccountForPendingDocument(fallbackDocumentInfo);
                        });
                        
                    // ‚ùå NO VALIDATION PATH: Missing context
                    } else {
                        console.log('‚ùå DEBUG: NO VALIDATION PATH - Account changed but validation cannot proceed:', {
                            hasNewUsername: !!newUsername,
                            hasPendingAccess: !!authBridge.authState.pendingDocumentAccess,
                            hasCurrentFile: !!this.currentFile,
                            currentFileHasOwner: !!(this.currentFile?.owner),
                            currentFileHasPermlink: !!(this.currentFile?.permlink),
                            authBridgePendingAccess: authBridge.authState.pendingDocumentAccess,
                            reason: !newUsername ? 'no-username' : 
                                   !authBridge.authState.pendingDocumentAccess && !this.currentFile ? 'no-context' :
                                   !authBridge.authState.pendingDocumentAccess && this.currentFile && !this.currentFile.owner && !this.currentFile.permlink ? 'invalid-current-file' :
                                   'unknown'
                        });
                        
                        // üÜò EMERGENCY RECOVERY: Try to find any usable document context
                        if (newUsername) {
                            console.log('üÜò DEBUG: EMERGENCY RECOVERY - Attempting to find usable document context');
                            
                            // Check if we have any stored document context from URL parameters
                            const urlParams = new URLSearchParams(window.location.search);
                            const urlOwner = urlParams.get('owner');
                            const urlPermlink = urlParams.get('permlink');
                            
                            if (urlOwner && urlPermlink) {
                                console.log('üÜò DEBUG: Found URL context for emergency validation');
                                const emergencyContext = {
                                    name: `${urlOwner}/${urlPermlink}`,
                                    owner: urlOwner,
                                    permlink: urlPermlink,
                                    type: 'collaborative'
                                };
                                
                                this.$nextTick(() => {
                                    console.log('üÜò DEBUG: Executing emergency validation with URL context');
                                    this.validateAccountForPendingDocument(emergencyContext);
                                });
                            } else {
                                console.log('‚ùå DEBUG: No recovery possible - no document context available');
                            }
                        }
                    }
                } else {
                    console.log('üîë DEBUG: No auth bridge available to update with username change');
                }
                
                // ‚úÖ SECURITY: Clear local files immediately to prevent showing other users' files
                this.localFiles = [];
                
                // ‚úÖ VUE BEST PRACTICE: Use $nextTick to ensure username has propagated through reactivity
                this.$nextTick(() => {
                    // Refresh document lists to apply new user filter
                    this.loadLocalFiles().catch(error => {
                        console.warn('‚ö†Ô∏è Failed to refresh local files after user change:', error);
                    });
                });
                
                // ‚úÖ SECURITY FIX: Re-validate permissions for ANY open document
                if (this.currentFile) {
                    // Handle logout scenario (username becomes null/empty)
                    if (!newUsername) {
                        if (DEBUG) console.log('üö´ User logged out - clearing document');
                        
                        // ‚úÖ SECURITY BOUNDARY: Clear document before showing auth modal
                        this.setCurrentFile(null);
                        
                        // Then handle access denial (shows auth modal)
                        this.handleDocumentAccessDenied();
                        return;
                    }
                    
                    if (this.currentFile.type === 'collaborative') {
                        if (DEBUG) console.log('üîê Re-validating permissions for current collaborative document');
                        
                        // ‚úÖ COORDINATION CHECK: Only handle if authHeaders watcher isn't already handling it
                        if (this.isHandlingCollaborativeDocumentSwitch) {
                            if (DEBUG) console.log('üîÑ Username watcher: Collaborative document switch already being handled by authHeaders watcher, skipping');
                            return;
                        }
                        
                        // Force immediate permission check
                        this.validateCurrentDocumentPermissions();
                    } else if (this.currentFile.type === 'local' || !this.currentFile.type) {
                        if (DEBUG) console.log('üîê STREAMLINED: Immediate local document ownership check');
                        
                        // ‚úÖ COORDINATION CHECK: Only handle if authHeaders watcher isn't already handling it
                        if (this.isHandlingLocalDocumentSwitch) {
                            if (DEBUG) console.log('üîÑ Username watcher: Local document switch already being handled by authHeaders watcher, skipping');
                            return;
                        }
                        
                        // ‚úÖ IMMEDIATE LOCAL DOCUMENT ENFORCEMENT: Simple ownership check
                        const documentOwner = this.getLocalDocumentOwner();
                        
                        if (DEBUG) console.log('üîç Username watcher: Local document ownership check', {
                            documentOwner,
                            oldUsername,
                            newUsername,
                            willClearDocument: documentOwner && documentOwner !== newUsername
                        });
                        
                        // Clear document if new user is not the owner
                        if (documentOwner && documentOwner !== newUsername) {
                            if (DEBUG) console.log('üö´ Username watcher: Local document access boundary crossed', {
                                documentOwner,
                                oldUser: oldUsername,
                                newUser: newUsername,
                                isOwnerSwitchingAway: documentOwner === oldUsername,
                                action: 'clearing-document'
                            });
                            
                            // ‚úÖ DEDICATED METHOD: Use new dedicated user switch method
                            await this.clearLocalDocumentForUserSwitch(documentOwner, newUsername, 'username-watcher');
                            return; // Exit early - no complex validation needed
                        } else if (DEBUG) {
                            console.log('‚úÖ Username watcher: Local document access allowed', {
                                reason: !documentOwner ? 'no-owner' : 'user-is-owner'
                            });
                        }
                    }
                }
            }
        },
        immediate: false, // Don't fire on initial mount
        deep: false // Username is a primitive value, no need for deep watching
    },
    */

        // ‚úÖ BACKUP MECHANISM: Watch usernameProp directly as backup for username watcher
        // ‚úÖ REMOVED: usernameProp watcher - the username computed property watcher handles everything

        // ===== AUTHENTICATION AND DOCUMENT LOADING WATCHERS =====

        // ‚úÖ AUTO-REFRESH: Automatically refresh document list when load modal opens
        showLoadModal: {
            handler(newValue, oldValue) {
                if (newValue && !oldValue) {
                    // ‚úÖ TIPTAP BEST PRACTICE: Non-blocking modal refresh
                    this.refreshDocumentLists().catch(error => {
                        console.warn('‚ö†Ô∏è Background document list refresh failed:', error);
                    });
                } else if (!newValue && oldValue) {
                    // Modal just closed

                }
            },
            immediate: false
        },

        // ‚úÖ TIPTAP BEST PRACTICE: Watch for readonly mode changes to update editor state
        isReadOnlyMode: {
            handler(newReadOnlyMode, oldReadOnlyMode) {
                if (newReadOnlyMode !== oldReadOnlyMode) {

                    // ‚úÖ TIPTAP BEST PRACTICE: Use nextTick to ensure Vue reactivity has completed
                    this.$nextTick(() => {
                        // Check if component is still valid before updating
                        if (!this._isDestroyed && this.bodyEditor && !this.bodyEditor.isDestroyed && this.currentFile) {
                            this.updateEditorMode();
                        }
                    });
                }
            },
            immediate: false
        },

        // ‚úÖ COLLABORATIVE USER WIDGET: Watch for provider changes to set up awareness
        provider: {
            handler(newProvider, oldProvider) {
                // Clean up old provider awareness listeners
                if (oldProvider && oldProvider.awareness) {
                    oldProvider.awareness.off('change', this.updateConnectedUsers);
                }

                // Set up new provider awareness listeners
                if (newProvider && newProvider.awareness) {
                    // ‚úÖ TIPTAP BEST PRACTICE: Awareness user info is set in onConnect callback
                    // This ensures the provider is fully initialized before setting user data

                    // Listen for awareness changes
                    newProvider.awareness.on('change', this.updateConnectedUsers);

                    // Initial update
                    this.updateConnectedUsers();
                }
            },
            immediate: false
        },

        // ‚úÖ REPLACED BY EVENT-DRIVEN APPROACH: This watcher has been replaced by setupAuthHeadersListener
        // which uses polling to detect auth header changes for better control and timing
        /*
        authHeaders: {
            handler(newHeaders, oldHeaders) {
                console.log('üì° AUTH HEADERS WATCHER DEBUG:', {
                    hasNewHeaders: !!newHeaders,
                    newHeadersAccount: newHeaders?.['x-account'],
                    newHeadersChallenge: newHeaders?.['x-challenge'],
                    hasOldHeaders: !!oldHeaders,
                    oldHeadersAccount: oldHeaders?.['x-account'],
                    isFirstHeaders: !oldHeaders && !!newHeaders,
                    hasDeferredCollab: !!this.deferredCollabConnection,
                    hasDeferredLocal: !!this.deferredLocalConnection,
                    username: this.username,
                    account: this.account
                });
                
                if (DEBUG) console.log('üì° authHeaders watcher triggered:', {
                    hasNewHeaders: !!newHeaders,
                    account: this.authStateManager.getAuthAccount(newHeaders),
                    hasDeferredCollab: !!this.deferredCollabConnection,
                    hasDeferredLocal: !!this.deferredLocalConnection
                });

                // ‚úÖ AUTH STATE MANAGER: Sync auth headers
                if (this.authStateManager) {
                    console.log('üîê AuthStateManager: Syncing auth headers');
                    this.authStateManager.setAuthHeaders(newHeaders);
                }
                
                // Process any deferred connections now that auth is ready (if component managers are ready)
                if (this.deferredCollabConnection) {
                        const { owner, permlink, needsAuth, documentContext } = this.deferredCollabConnection;
                        
                        // Check if component managers are ready before processing
                        const managersReady = this.documentManager && this.recoveryManager && this.contentStateManager;
                        
                        console.log('üîÑ DEBUG: AuthHeaders watcher found deferred connection:', {
                            owner,
                            permlink,
                            isAuthenticated: this.isAuthenticated,
                            authLoading: this.authLoading,
                            managersReady,
                            documentManager: !!this.documentManager,
                            recoveryManager: !!this.recoveryManager,
                            contentStateManager: !!this.contentStateManager
                        });
                        
                        if (managersReady) {
                            console.log('üîÑ DEBUG: AuthHeaders watcher processing deferred connection - managers ready');
                            this.deferredCollabConnection = null;
                            this.showLoadingMessage = '';
                            this.loadingStates.auth = false;
                            this.$nextTick(async () => {
                                // ‚úÖ INTEGRATED AUTH FLOW: Check if auth modal should be triggered first
                                if (needsAuth && !this.isAuthenticated && documentContext) {
                                    console.log('üîó DEBUG: AuthHeaders watcher - deferred connection needs auth, triggering auth modal');
                                    await this.handleDocumentAccessDenied(documentContext);
                                    return;
                                }
                                
                                this.autoConnectToCollaborativeDocument(owner, permlink).catch(error => {
                                    console.error('‚ùå Deferred collaborative connection failed:', error);
                                    this.isLoadingFromURL = false;

                                    // Create a temp document if we don't have one
                                    if (!this.currentFile) {
                                        this.documentManager.newDocument();
                                    }
                                });
                            });
                        } else {
                            console.log('üîÑ DEBUG: AuthHeaders watcher - component managers not ready, keeping deferred connection');
                        }
                    }

                    if (this.deferredLocalConnection) {
                        const { owner, permlink } = this.deferredLocalConnection;
                        if (DEBUG) console.log('üîÑ Processing deferred local connection after auth headers:', { owner, permlink });
                        this.deferredLocalConnection = null;
                        this.$nextTick(() => {
                            this.autoConnectToLocalDocument(owner, permlink).catch(error => {
                                console.error('‚ùå Deferred local connection failed:', error);
                            });
                        });
                    }
                }

                // ‚úÖ LOCAL DOCUMENT COORDINATION: Use coordination flag to prevent race conditions
                if (this.currentFile && this.currentFile.type === 'local') {
                    const currentAuthUser = newHeaders ? this.authStateManager.getAuthAccount(newHeaders) : null;
                    const documentOwner = this.getLocalDocumentOwner();
                    
                    if (documentOwner && documentOwner !== currentAuthUser) {
                        if (DEBUG) console.log('üîÑ AuthHeaders watcher: Local document ownership issue detected', {
                            documentOwner,
                            currentAuthUser,
                            action: 'using-dedicated-user-switch-method'
                        });
                        
                        // ‚úÖ DEDICATED METHOD: Use new dedicated user switch method
                        this.clearLocalDocumentForUserSwitch(documentOwner, currentAuthUser, 'authHeaders-watcher');
                    }
                }
                
                // ‚úÖ COLLABORATIVE DOCUMENT COORDINATION: Handle permission validation for user switches
                if (this.currentFile && this.currentFile.type === 'collaborative') {
                    const currentAuthUser = newHeaders ? this.authStateManager.getAuthAccount(newHeaders) : null;
                    const oldAuthUser = oldHeaders ? this.authStateManager.getAuthAccount(oldHeaders) : null;
                    
                    // Check if this is a user switch for collaborative documents
                    if (oldAuthUser && currentAuthUser && oldAuthUser !== currentAuthUser) {
                        if (DEBUG) console.log('üîÑ AuthHeaders watcher: User switch detected for collaborative document', {
                            from: oldAuthUser,
                            to: currentAuthUser,
                            document: `${this.currentFile.owner}/${this.currentFile.permlink}`,
                            action: 'validating-permission-for-new-user'
                        });
                        
                        // Clear cached permissions for this document via AuthStateManager
                        if (this.authStateManager) {
                            this.authStateManager.clearFilePermissionCache();
                        }
                        
                        // Reload permission for this document with new user
                        this.loadPermissionForDocument(this.currentFile).catch(error => {
                            console.warn('‚ö†Ô∏è Failed to reload permission after user switch:', error);
                        });
                    }
                }
            },
            immediate: false
        },
        */

        // ‚úÖ TIPTAP LIFECYCLE: Watch for collaborative metadata changes to trigger auto-save
        collaborationMetadata: {
            handler(newMetadata, oldMetadata) {

                // Only auto-save if we have a current file and it's not temporary
                if (this.currentFile && !this.isTemporaryDocument) {
                    // Set unsaved changes flag
                    this.hasUnsavedChanges = true;
                    this.hasUserIntent = true;

                    // ‚úÖ FIX: Show save indicator immediately
                    this.$nextTick(() => {
                        this.updateSaveStatus();
                    });

                    // ‚úÖ FIX: Trigger save after metadata change
                    this.autoSave();
                }
            }
        }
    },

    created() {
        console.log('üöÄ TIPTAP-EDITOR-MODULAR: created() called', {
            timestamp: new Date().toISOString(),
            username: this.username,
            usernameProp: this.usernameProp,
            authBridge: !!this.authBridge,
            urlParams: window.location.search
        });

        // Set up AuthStateManager event listeners early
        if (this.authStateManager) {
            this.setupAuthStateListeners();
            console.log('üîê AuthStateManager listeners configured in created hook');
        }
    },

    async mounted() {
        console.log('üöÄ TIPTAP-EDITOR-MODULAR: mounted() called', {
            timestamp: new Date().toISOString(),
            username: this.username,
            authHeaders: !!this.authHeaders,
            authBridge: !!this.authBridgeInstance,
            urlParams: window.location.search
        });
        
        // ‚úÖ CACHE MIGRATION: Clean up legacy cache keys on mount
        this.migrateLegacyCacheKeys();
        
        // üîê AUTH TIMING: Track component mount
        console.log('üîê AUTH TIMING: TipTap editor component mounted', {
            username: this.username,
            usernameProp: this.usernameProp,
            isGuestUser: !this.username || this.username === 'GUEST',
            authLoading: this.authLoading,
            timestamp: new Date().toISOString()
        });

        // ‚úÖ CENTRALIZED EVENT MANAGEMENT: Initialize event manager for automatic cleanup
        this.eventManager = new EventManager(this);
        console.log('üéß EventManager initialized with automatic Vue lifecycle integration');

        // ‚úÖ GLOBAL EVENT BUS: Initialize event bus for Vue 3 compatible communication
        if (!window.editorEventBus) {
            window.editorEventBus = new EventTarget();
            console.log('üì¢ Global editor event bus initialized for Vue 3 compatibility');
        }

        // ‚úÖ CENTRALIZED PERMISSION SERVICE: Use singleton permission service for unified access control
        this.permissionService = permissionService;
        console.log('üîê Using singleton PermissionService for centralized permission management');

        // ‚úÖ OFFLINE-FIRST: Scan for cached collaborative documents on mount
        // This populates offlineCaches array for immediate display
        console.log('üì± OFFLINE-FIRST: mounted() checking for cached docs');
        console.log('  username:', this.username);
        console.log('  usernameProp:', this.usernameProp);
        console.log('  authStateManagerUser:', this.authStateManager?.state?.user);
        console.log('  isAuthenticated:', this.isAuthenticated);
        console.log('  hasAuthHeaders:', !!this.authHeaders);
        console.log('  willScan:', !!this.username);
        
        // üî¥ AUTH-RESTORE: Check for stored headers on mount
        const currentUser = this.username || this.authStateManager?.state?.user;
        console.log('üî¥ AUTH-RESTORE: Component mounted, checking for stored headers', {
            currentUser: currentUser,
            sessionStorageKey: currentUser ? `collaborationAuthHeaders_${currentUser}` : 'no-user',
            sessionStorageHeaders: (typeof sessionStorage !== 'undefined' && currentUser) ? 
                sessionStorage.getItem(`collaborationAuthHeaders_${currentUser}`) : 'N/A',
            authBridgeHeaders: this.authBridgeInstance?.getAuthHeaders?.(),
            authStateHeaders: this.authStateManager?.getAuthHeaders?.(),
            timestamp: Date.now()
        });
        
        if (this.username) {
            console.log('üì± OFFLINE-FIRST: Starting IndexedDB scan on mount');
            this.scanIndexedDBDocuments().then(additionalDocs => {
                console.log('üì± OFFLINE-FIRST: IndexedDB scan complete');
                console.log('  username:', this.username);
                console.log('  offlineCachesFound:', this.offlineCaches?.length || 0);
                if (this.offlineCaches && this.offlineCaches.length > 0) {
                    console.log('  offlineCacheDetails:');
                    this.offlineCaches.forEach((c, i) => {
                        console.log(`    [${i}]:`, {
                            id: c.id,
                            owner: c.owner,
                            permlink: c.permlink,
                            name: c.name
                        });
                    });
                }
                console.log('  additionalLocalDocs:', additionalDocs?.length || 0);
                console.log('  allDocumentsCount:', this.allDocuments?.length || 0);
            }).catch(error => {
                console.error('‚ùå OFFLINE-FIRST: IndexedDB scan failed on mount:', error);
                console.error('  Error details:', error.message, error.stack);
            });
        } else {
            console.warn('‚ö†Ô∏è OFFLINE-FIRST: No username available, skipping IndexedDB scan', {
                username: this.username,
                usernameProp: this.usernameProp,
                authStateManagerUser: this.authStateManager?.state?.user
            });
        }

        // ‚úÖ AUTH STATE SYNC: Sync any existing auth state from bridge to manager
        // This handles the case where v3-user restored auth before this component mounted
        this.syncAuthStateFromBridge();

        // ‚úÖ AUTH BRIDGE EVENT LISTENER: Listen for auth updates from bridge
        if (this.authBridgeInstance && this.authStateManager) {
            console.log('üîê Setting up authBridge event listener for auth updates');
            
            // Listen for auth header updates from the bridge
            this.authBridgeInstance.on('authHeadersUpdated', (data) => {
                // ‚úÖ ENHANCED LOGGING: Track the entire auth headers update flow
                console.log('üîê authHeadersUpdated EVENT START', {
                    timestamp: new Date().toISOString(),
                    eventData: data,
                    currentAuthState: {
                        username: this.username,
                        authStateManagerUser: this.authStateManager?.state?.user,
                        authState: this.authStateManager?._authState,
                        isAuthenticated: this.isAuthenticated,
                        hasAuthHeaders: !!this.authHeaders
                    }
                });

                // ‚úÖ BACKUP EXTRACTION: Extract account from headers if not in event data
                const accountFromHeaders = data.headers?.['x-account'];
                if (!data.account && accountFromHeaders) {
                    console.log('üîê AUTH BRIDGE EVENT: Extracting account from headers as backup', {
                        originalAccount: data.account,
                        extractedAccount: accountFromHeaders
                    });
                    data.account = accountFromHeaders;
                }
                
                console.log('üîê AUTH BRIDGE EVENT: Auth headers updated', {
                    account: data.account,
                    isAuthenticated: data.isAuthenticated,
                    isExpired: data.isExpired,
                    hasHeaders: !!data.headers,
                    dataKeys: Object.keys(data),
                    headersAccount: data.headers?.['x-account'],
                    thisUsername: this.username,
                    authStateUser: this.authStateManager?.state?.user,
                    // ‚úÖ ENHANCED: Log actual data content for debugging
                    eventDataSummary: {
                        account: data.account || 'undefined',
                        hasValidHeaders: !!data.headers && !!data.headers['x-account'],
                        currentUsername: this.username
                    }
                });
                
                // ‚úÖ DEBUG: Log what we're about to do
                console.log('üîê authHeadersUpdated: Processing updates', {
                    willSetUser: data.account !== undefined && data.account !== null,
                    userToSet: data.account,
                    willSetHeaders: !!data.headers,
                    currentState: this.authStateManager?._authState
                });

                // Update AuthStateManager with new auth state
                // Always update the user state from auth bridge events
                if (data.account !== undefined && data.account !== null) {
                    console.log('üîê Updating AuthStateManager user from auth bridge event', {
                        oldUser: this.authStateManager.getUser(),
                        newUser: data.account
                    });
                    this.authStateManager.setUser(data.account);
                } else if (data.account === null) {
                    console.warn('üîê WARNING: Received null account in auth bridge event, not updating AuthStateManager', {
                        eventData: data,
                        currentUser: this.authStateManager.getUser()
                    });
                }
                
                if (data.headers) {
                    console.log('üîê authHeadersUpdated: Calling setAuthHeaders', {
                        hasHeaders: true,
                        headerKeys: Object.keys(data.headers),
                        account: data.headers['x-account']
                    });
                    this.authStateManager.setAuthHeaders(data.headers);
                }

                // ‚úÖ FINAL STATE LOG
                console.log('üîê authHeadersUpdated EVENT END', {
                    timestamp: new Date().toISOString(),
                    finalState: {
                        username: this.username,
                        authStateManagerUser: this.authStateManager?.state?.user,
                        authState: this.authStateManager?._authState,
                        isAuthenticated: this.isAuthenticated,
                        hasAuthHeaders: !!this.authHeaders
                    }
                });
            });
        }
        
        // ‚úÖ GOLDEN RULE #1: Listen to AuthStateManager user changes
        // This ensures usernameProp stays in sync with auth state
        if (this.authStateManager) {
            console.log('üîê Setting up AuthStateManager event listener for user changes');
            
            this.authStateManager.on('userChanged', (event) => {
                // ‚úÖ FIX: Access event data from detail property (CustomEvent structure)
                const { oldUser, newUser, changeType } = event.detail || {};
                
                console.log('üìù TipTap: AuthStateManager user changed', {
                    oldUser,
                    newUser,
                    changeType,
                    currentUsernameProp: this.usernameProp,
                    timestamp: new Date().toISOString()
                });
                
                // ‚úÖ GOLDEN RULE #3: AuthStateManager is source of truth
                // Call our unified user change handler to process the change
                const type = changeType || (!oldUser ? 'login' : !newUser ? 'logout' : 'switch');
                this.handleUserChange(oldUser, newUser, type);
                
                // Optional: Emit event to parent if it needs to sync
                if (this.usernameProp !== newUser) {
                    console.log('üìù Username mismatch detected, parent may need to sync', {
                        propValue: this.usernameProp,
                        authStateValue: newUser
                    });
                    // Uncomment if parent needs to be notified:
                    // this.$emit('username-sync-needed', newUser);
                }
            });
            
            // Also listen for auth header changes to ensure synchronization
            this.authStateManager.on('authHeadersCleared', ({ reason, oldUser, newUser }) => {
                console.log('üîí TipTap: Auth headers cleared notification', {
                    reason,
                    oldUser,
                    newUser,
                    willClearModal: this.authModalActive
                });
                
                // Clear any active auth modal when headers are cleared
                if (this.authModalActive && reason === 'username-change') {
                    this.authModalActive = false;
                }
            });
        }

        // ‚úÖ PROTOCOL ERROR HANDLER: Handle WebSocket protocol mismatches globally
        this.setupGlobalErrorHandler();

        // ‚úÖ API LOGGING: All collaboration endpoints have JSON response logging enabled

        // ‚úÖ COMPLIANCE: Debug collaboration endpoints code removed

        // Make methodsCommon available globally for video nodeViews
        window.methodsCommon = methodsCommon;

        // ‚úÖ Log TipTap component availability
        if (DEBUG && window.TiptapCollaboration) {
            console.log('‚úÖ TipTap collaboration bundle loaded');
        }

        // Handle initial auth headers based on auth state
        if (this.authBridgeInstance) {
            // If we already have auth headers from the bridge, log it
            if (this.authBridgeInstance.authState.authHeaders) {

                // Process any deferred local connections
                if (this.deferredLocalConnection) {
                    const { owner, permlink } = this.deferredLocalConnection;
                    this.deferredLocalConnection = null;
                    this.$nextTick(() => {
                        this.autoConnectToLocalDocument(owner, permlink).catch(error => {
                            console.error('‚ùå Deferred local connection failed:', error);
                        });
                    });
                }
            } else if (!this.authBridgeInstance.authState.authHeaders) {
                // No auth headers yet
            }
        }

        // ‚úÖ EVENT-DRIVEN USER CHANGES: Subscribe to modular auth bridge user change events
        this.setupAuthBridgeUserChangeListener();

        // ‚úÖ LOGOUT HANDLER: Listen for logout events from parent
        this.setupLogoutListener();

        // ‚úÖ AUTH HEADERS CHANGES: Monitor for auth header changes to validate permissions
        this.setupAuthHeadersListener();

        // ‚úÖ EVENT-DRIVEN USERNAME MONITORING: Use proper Vue watchers instead of polling
        // Watch for username changes to trigger validation
        this.setupUsernameWatcher();

        // Expose component for drag tracking
        window.dluxEditor = this;

        try {
            // ‚úÖ DEBUG: Track component manager initialization

            // Initialize managers
            this.documentManager = new DocumentManager(this);
            this.recoveryManager = new RecoveryManager(this);
            this.contentStateManager = new ContentStateManager(this);
            this.customJsonMessageHandler = new CustomJsonMessageHandler(this);

            // ‚úÖ COMPONENT READY: Process any deferred connections now that managers are initialized
            if (this.deferredCollabConnection) {
                const { owner, permlink, needsAuth, documentContext } = this.deferredCollabConnection;
                console.log('üîÑ Processing deferred collaborative connection - component managers ready:', {
                    owner,
                    permlink,
                    needsAuth,
                    managersReady: true,
                    hasDocumentContext: !!documentContext
                });
                this.deferredCollabConnection = null;
                this.showLoadingMessage = '';
                this.loadingStates.auth = false;

                // Process the deferred connection in next tick to ensure everything is fully ready
                this.$nextTick(async () => {
                    // ‚úÖ INTEGRATED AUTH FLOW: Check if auth modal should be triggered first
                    if (needsAuth && !this.isAuthenticated && documentContext) {
                        await this.handleDocumentAccessDenied(documentContext);
                        return;
                    }

                    this.isLoadingFromURL = true;
                    this.autoConnectToCollaborativeDocument(owner, permlink).then(result => {
                    }).catch(error => {
                        console.error('‚ùå Failed to auto-connect to deferred collaborative document:', error);
                        this.isLoadingFromURL = false;
                        // Create a temp document if we don't have one
                        if (!this.currentFile) {
                            this.documentManager.newDocument();
                        }
                    });
                });
            }

            // ‚úÖ COMPLIANCE: Auth header caching is handled by the parent component
            // The sessionStorage cache is used for API calls when headers expire mid-session
            // We don't auto-restore here to prevent triggering keychain on every mount

            // ‚úÖ TIPTAP BEST PRACTICE: Check URL parameters FIRST before any other initialization
            const urlParams = new URLSearchParams(window.location.search);
            const collabOwner = urlParams.get('collab_owner');
            const collabPermlink = urlParams.get('collab_permlink');
            const localOwner = urlParams.get('local_owner');
            const localPermlink = urlParams.get('local_permlink');

            console.log('üîç TIPTAP: URL Parameters detected (checking first):', {
                collabOwner, collabPermlink, localOwner, localPermlink,
                hasCollabParams: !!(collabOwner && collabPermlink),
                hasLocalParams: !!(localOwner && localPermlink)
            });

            // ‚úÖ OFFLINE-FIRST: Preload all cached data for instant display
            this.loadCachedCollaborativeDocs();
            // ‚úÖ REMOVED: loadPersistedPermissions() - AuthStateManager handles permission persistence

            // ‚úÖ PERFORMANCE: Pre-load permissions and metadata for collaborative documents
            if (collabOwner && collabPermlink) {
                // ‚úÖ AuthStateManager handles permission caching automatically
                const cachedMetadata = await documentService.getDocumentMetadata(`${collabOwner}/${collabPermlink}`);
                if (cachedMetadata && cachedMetadata.documentName) {
                    this.reactiveDocumentName = cachedMetadata.documentName;
                }
            }

            // ‚úÖ EVENT-DRIVEN AUTH: Check collaborative documents based on auth restoration state
            if (collabOwner && collabPermlink) {
                console.log('üîê AUTH TIMING: Checking collaborative document access', {
                    username: this.username,
                    usernameProp: this.usernameProp,
                    authLoading: this.authLoading,
                    authHeaders: !!this.authHeaders,
                    collabOwner: collabOwner,
                    collabPermlink: collabPermlink,
                    timestamp: new Date().toISOString()
                });

                // ‚úÖ AUTHENTICATION CHECK: Check if we have auth headers for logged-in users
                const needsAuthHeaders = this.username && this.username !== 'GUEST';
                const hasAuth = this.isAuthenticated;

                console.log('üîê AUTH TIMING: Auth header check for collaborative document', {
                    username: this.username,
                    needsAuthHeaders,
                    hasAuth,
                    authLoading: this.authLoading,
                    willDeferLoad: needsAuthHeaders && !hasAuth
                });

                // If user needs auth headers but doesn't have them yet, check offline cache first
                if (needsAuthHeaders && !hasAuth) {
                    console.log('üî¥ CACHE-TEST: User logged in but not authenticated - checking offline cache first', {
                        reason: 'User logged in but auth headers not restored yet',
                        username: this.username,
                        authHeadersExpected: true,
                        authBridge: !!this.authBridgeInstance,
                        authBridgeHeaders: this.authBridgeInstance?.authState?.authHeaders ? 'present' : 'missing'
                    });
                    console.log('üîê OFFLINE-LOAD: User logged in but not authenticated - checking offline cache first', {
                        reason: 'User logged in but auth headers not restored yet',
                        username: this.username,
                        authHeadersExpected: true,
                        authBridge: !!this.authBridgeInstance,
                        authBridgeHeaders: this.authBridgeInstance?.authState?.authHeaders ? 'present' : 'missing'
                    });
                    
                    // ‚úÖ OFFLINE-FIRST: Check offline cache before showing auth modal
                    // loadDocumentFromURL will check the cache via authStateManager.checkDocumentAccess
                    // If document is not cached, authStateManager will emit accessDenied event which triggers auth modal
                    console.log('üî¥ CACHE-TEST: Attempting to load collaborative document from cache for logged-in user', {
                        owner: collabOwner,
                        permlink: collabPermlink,
                        user: this.username
                    });
                    console.log('üîê OFFLINE-LOAD: Attempting to load collaborative document from cache for logged-in user', {
                        owner: collabOwner,
                        permlink: collabPermlink,
                        user: this.username
                    });
                    
                    // Mark that we're attempting to load to prevent duplicate from watcher
                    this._collabDocLoadAttempted = true;
                    this.isLoadingFromURL = true;
                    this.autoConnectToCollaborativeDocument(collabOwner, collabPermlink).catch(error => {
                        console.error('‚ùå OFFLINE-LOAD: Failed to load collaborative document:', error);
                        this.isLoadingFromURL = false;
                    });
                } else {
                    // For guest users or users with auth headers, proceed immediately
                    console.log('üîê AUTH TIMING: Proceeding with collaborative document load', {
                        reason: !needsAuthHeaders ? 'Guest user' : 'Auth headers available',
                        username: this.username,
                        hasAuth
                    });

                    // Mark that we're attempting to load to prevent duplicate from watcher
                    this._collabDocLoadAttempted = true;
                    this.isLoadingFromURL = true;
                    this.autoConnectToCollaborativeDocument(collabOwner, collabPermlink).catch(error => {
                        console.error('‚ùå Failed to auto-connect to collaborative document:', error);

                        // ‚úÖ SMART ERROR HANDLING: Only clear URL for permanent errors
                        const isTemporaryError = error.message.includes('fetch') ||
                            error.message.includes('network') ||
                            error.message.includes('timeout') ||
                            error.message.includes('authentication') ||
                            error.message.includes('permission') ||
                            error.message.includes('updateReactiveDocumentName is not a function') ||
                            error.message.includes('not a function');

                        if (!isTemporaryError) {
                            // Clear bad URL parameters and fall back to temp document for permanent errors
                            console.warn('üîó MOUNTED: Clearing URL due to permanent error:', error.message);
                            this.clearCollabURLParams();
                            this.documentManager.newDocument();
                            // Reset flag for permanent errors
                            this._collabDocLoadAttempted = false;
                        } else {
                            // Keep URL for temporary errors - show error but allow retry

                            // ‚úÖ FIX: Don't create temp document for temporary errors
                            // Set error state and let user retry authentication
                            this.connectionStatus = 'error';
                            this.connectionMessage = 'Temporary error loading document. You can retry authentication or refresh the page.';

                            // ‚úÖ FIX: Reset loading flag to allow retry
                            this.isLoadingFromURL = false;
                            // Keep _collabDocLoadAttempted true for temporary errors to prevent auto-retry
                        }
                    });
                }
            } else if (localOwner && localPermlink) {
                // ‚úÖ TIPTAP BEST PRACTICE: Non-blocking local document loading
                this.isLoadingFromURL = true;
                this.autoConnectToLocalDocument(localOwner, localPermlink).catch(error => {
                    console.error('‚ùå Failed to auto-connect to local document:', error);
                    // ‚úÖ FIX: Don't clear URL on failed document load - preserve for retry
                    // User may need to log in or document may be temporarily unavailable
                    console.warn('‚ö†Ô∏è Document load failed - preserving URL for potential retry');
                    this.documentManager.newDocument();
                });

            } else {
                // ‚úÖ TIPTAP BEST PRACTICE: Non-blocking initialization

                // Load document lists in background (non-blocking)
                this.refreshDocumentLists().catch(error => {
                    console.warn('‚ö†Ô∏è Background document list loading failed:', error);
                });

                // Create new temp document immediately (non-blocking)
                this.documentManager.newDocument().catch(error => {
                    console.error('‚ùå Failed to create new document:', error);
                });
            }

        } catch (error) {
            console.error('‚ùå Failed to initialize TipTap modular editor:', error);

            // Check if TipTap collaboration bundle is missing
            const bundle = window.TiptapCollaboration;
            if (!bundle) {
                console.error('‚ùå TipTap collaboration bundle not found. Please ensure TipTap dependencies are loaded.');
            }
            throw error;
        }

        // ‚úÖ REMOVED: loadPersistedPermissions() - AuthStateManager handles permission persistence

        // ‚úÖ COLLABORATIVE USER WIDGET: Initialize user color and awareness
        this.initializeUserColor();

        // ‚úÖ REACTIVE PATTERNS: All debounced methods are now defined as reactive methods below
        // No legacy timeout-based method creation during component initialization

        // ‚úÖ OFFLINE-FIRST: Start permission refresh system when authenticated
        this.$nextTick(() => {
            // Only start permission refresh if already authenticated
            // This won't trigger keychain because it only runs if auth is valid
            if (this.isAuthenticated && !this.isAuthExpired) {
                this.startPermissionRefresh();
            }

            // üîç DEBUG: Check drag handle status periodically

            // ‚úÖ SERVER VERSION: Check server version on startup (non-blocking)
            this.checkServerVersion().catch(error => {
                console.warn('‚ö†Ô∏è Background server version check failed:', error);
            });
        });

        // ‚úÖ STATE MONITORING: Add keyboard shortcuts for debug commands
        this.setupDebugKeyboardShortcuts();

        // ‚úÖ DEFERRED AUTH CHECK: Check for collaborative document after component is fully mounted
        // Get URL params again for deferred loading check (they were defined in try block scope)
        const urlParamsDeferred = new URLSearchParams(window.location.search);
        const deferredCollabOwner = urlParamsDeferred.get('collab_owner');
        const deferredCollabPermlink = urlParamsDeferred.get('collab_permlink');

        this.$nextTick(() => {
            // If we have collaborative URL params but haven't started loading yet
            if (deferredCollabOwner && deferredCollabPermlink && !this.isLoadingFromURL && !this.currentFile) {

                // Attempt to load the document immediately
                // The existing reactive patterns will handle auth sync if needed
                this.isLoadingFromURL = true;
                this.autoConnectToCollaborativeDocument(deferredCollabOwner, deferredCollabPermlink).catch(error => {
                    console.error('‚ùå Failed to auto-connect to collaborative document:', error);
                    this.isLoadingFromURL = false;

                    const isTemporaryError = error.message.includes('fetch') ||
                        error.message.includes('network') ||
                        error.message.includes('timeout');

                    const isAuthenticationError = error.message.includes('Y.js document is destroyed') ||
                        error.message.includes('will retry after login') ||
                        error.message.includes('during authentication') ||
                        error.message.includes('permission') ||
                        error.message.includes('access denied') ||
                        error.message.includes('Forbidden') ||
                        error.message.includes('403') ||
                        error.message.includes('auth');

                    if (!isTemporaryError && !isAuthenticationError) {
                        console.warn('üîó Clearing URL due to permanent error');
                        this.clearCollabURLParams();
                    } else {
                        const reason = isAuthenticationError ? 'authentication-related error' : 'temporary error';
                        console.log(`üîó Preserving URL - ${reason}, authentication flow can proceed`);
                    }

                    // Create a temp document if we don't have one
                    if (!this.currentFile) {
                        this.documentManager.newDocument();
                    }
                });
            }
        });

        // ‚úÖ MESSAGE HANDLER: Listen for SPK file selections from parent
        // ARCHITECTURE NOTE: To prevent duplicate window message listeners, we use a
        // centralized approach where CustomJsonMessageHandler is the ONLY listener
        // for window message events. It forwards SPK file selection messages to this
        // handler, eliminating the duplicate listener warning from EventManager.
        this.handleSPKFileSelection = (event) => {
            if (!event.data || typeof event.data !== 'object') return;

            const { type, file, url, metadata } = event.data;

            // Handle SPK file selection for video
            if (type === 'spkFileSelected' && event.data.target === 'editor') {

                // Check if it's a video file
                const videoExtensions = ['.mp4', '.mov', '.avi', '.mkv', '.webm', '.m3u8', '.flv', '.wmv', '.mpg', '.mpeg', '.3gp', '.ogv'];
                const isVideo = file && videoExtensions.some(ext => file.toLowerCase().endsWith(ext));

                if (isVideo && url) {
                    // Pass metadata to insertVideoEmbed for proper type detection
                    this.insertVideoEmbed(url, metadata);
                }
            }
        };

        // Initialize video support for HLS playback

        if (methodsCommon && methodsCommon.initIpfsVideoSupport) {
            this.videoObserver = methodsCommon.initIpfsVideoSupport();

            // Force check existing videos after DOM settles
            this.$nextTick(() => {
                const videos = document.querySelectorAll('video');

                // Check what's in the TipTap document
                if (this.bodyEditor) {
                    this.bodyEditor.state.doc.descendants((node, pos) => {
                        if (node.type.name === 'video') {
                        }
                    });
                }

                videos.forEach((video, index) => {

                });
            });
        } else {
            console.error('üé• methodsCommon.initIpfsVideoSupport not found!');
        }

        // ‚úÖ FIX: Mark initial mount as complete to enable watchers
        this.isInitialMount = false;
    },

    async beforeUnmount() {
        this.isUnmounting = true;

        // ‚úÖ BUBBLE MENU CLEANUP: Force hide bubble menu to cancel any pending positioning
        if (this.$refs.bubbleMenu) {
            // Hide the bubble menu element to stop any pending Floating UI calculations
            this.$refs.bubbleMenu.style.display = 'none';
            this.$refs.bubbleMenu.style.visibility = 'hidden';
        }

        // ‚úÖ CENTRALIZED CLEANUP: EventManager will automatically clean up all registered listeners
        // - SPK file selection message listener
        // - Debug keydown listener  
        // - Auth bridge event listeners (userChanged, authRetryReady)
        // - Intervals and timeouts
        if (this.eventManager) {
            console.log('üéß EventManager cleanup handled automatically by Vue lifecycle integration');
        }
        
        // ‚úÖ Clear handler references to ensure they're recreated if component remounts
        this.handleSPKFileSelection = null;
        this.debugKeydownHandler = null;

        // AuthStateManager event cleanup
        if (this._authStateCleanup) {
            this._authStateCleanup();
        }
        if (this._authStateUserChangedHandler && this.authStateManager) {
            this.authStateManager.off('userChanged', this._authStateUserChangedHandler);
        }
        if (this._authHeadersHandler && this.authStateManager) {
            this.authStateManager.off('authHeadersChanged', this._authHeadersHandler);
        }
        if (this._usernameChangeHandler && this.authStateManager) {
            this.authStateManager.off('userChanged', this._usernameChangeHandler);
        }

        // Clean up video observer
        if (this.videoObserver) {
            this.videoObserver.disconnect();
            this.videoObserver = null;
        }

        // ‚úÖ TIPTAP v3: Clear command queue
        this.commandQueue = [];
        this.isYjsSyncing = false;

        // ‚úÖ CLEANUP: Username validation interval handled by EventManager
        
        // ‚úÖ CLEANUP: Stop memory monitoring if active
        if (this.memoryMonitorInterval) {
            this.stopMemoryMonitoring();
        }

        // Clear any pending timeouts (Vue reactivity cleanup)
        if (this.syncTimeout) {
            clearTimeout(this.syncTimeout);
            this.syncTimeout = null;
        }
        if (this.tempPersistenceTimeout) {
            clearTimeout(this.tempPersistenceTimeout);
            this.tempPersistenceTimeout = null;
        }
        if (this.updateContentTimeout) {
            clearTimeout(this.updateContentTimeout);
            this.updateContentTimeout = null;
        }
        if (this.titleSyncTimeout) {
            clearTimeout(this.titleSyncTimeout);
            this.titleSyncTimeout = null;
        }
        if (this.permlinkSyncTimeout) {
            clearTimeout(this.permlinkSyncTimeout);
            this.permlinkSyncTimeout = null;
        }
        if (this.titleAutoSaveFrame) {
            cancelAnimationFrame(this.titleAutoSaveFrame);
            this.titleAutoSaveFrame = null;
        }
        if (this.contentUpdateTimeout) {
            clearTimeout(this.contentUpdateTimeout);
            this.contentUpdateTimeout = null;
        }
        if (this.titleUpdateTimeout) {
            clearTimeout(this.titleUpdateTimeout);
            this.titleUpdateTimeout = null;
        }

        // Clear permission-related timeouts
        if (this.permissionLoadTimeout) {
            cancelAnimationFrame(this.permissionLoadTimeout);
            this.permissionLoadTimeout = null;
        }
        // Permission timestamps handled by permissionTimestamps object
        this.permissionTimestamps.lastBroadcast = null;

        // Clear async timeouts
        if (this.permissionValidationTimeout) {
            cancelAnimationFrame(this.permissionValidationTimeout);
            this.permissionValidationTimeout = null;
        }

        if (this.authLoadTimeout) {
            cancelAnimationFrame(this.authLoadTimeout);
            this.authLoadTimeout = null;
        }
        this.pendingAutoConnect = null;

        // this.indexedDBScanCache = null; // REMOVED: Using documentService
        // this.indexedDBScanCacheTime = null; // REMOVED: Using documentService

        // Clear conversion related timeouts
        if (this.pendingConversion) {
            this.pendingConversion = null;
        }
        this.conversionInProgress = false;

        // Clear server version check timeout
        if (this.serverVersionCheckTimer) {
            clearTimeout(this.serverVersionCheckTimer);
            this.serverVersionCheckTimer = null;
        }

        // ‚úÖ TIPTAP v3: Clean up Y.js observers first (before destroying editors)
        if (this.configObserver) {
            this.configObserver();
            this.configObserver = null;
        }
        if (this.metadataObserver) {
            this.metadataObserver();
            this.metadataObserver = null;
        }
        if (this.permissionObserver) {
            this.permissionObserver();
            this.permissionObserver = null;
        }

        // ‚úÖ AUTH STATE MANAGER: Clean up event listeners
        if (this._authStateCleanup) {
            console.log('üîê AuthStateManager: Cleaning up event listeners');
            this._authStateCleanup();
            this._authStateCleanup = null;
        }

        // ‚úÖ REMOVED: _userChangeHandler cleanup - no longer needed
        // We exclusively use authStateManager's userChanged event

        // Clean up editors and providers
        if (this.documentManager) {
            try {
                await this.documentManager.cleanupComponent();
            } catch (error) {
                console.error('‚ùå Error during component cleanup:', error);
            }
        }
    },

    // ==================== HTML TEMPLATE ====================
    methods: {
        ...methodsCommon,
        
        // ===== TEST METHODS =====
        /**
         * Clear auth headers for testing offline cache loading
         * Only clears headers without logging out
         */
        clearAuthHeadersForTesting() {
            console.log('üß™ TEST: Clearing auth headers without logout');
            
            // Get current username for sessionStorage key
            const username = this.username || this.authStateManager?.state?.user;
            
            // Clear from AuthStateManager
            if (this.authStateManager) {
                this.authStateManager.setAuthHeaders(null);
                console.log('üß™ TEST: Cleared auth headers from AuthStateManager');
            }
            
            // Clear from sessionStorage with correct username-specific key
            if (window.sessionStorage && username) {
                const correctKey = `collaborationAuthHeaders_${username}`;
                sessionStorage.removeItem(correctKey);
                console.log('üß™ TEST: Cleared auth headers from sessionStorage', {
                    key: correctKey,
                    username: username
                });
                
                // Also clear any legacy keys just in case
                sessionStorage.removeItem('dlux_auth_headers');
                sessionStorage.removeItem('authHeaders');
            }
            
            // Clear from authBridge if exists  
            // ‚úÖ GOLDEN RULE 10: Use service method instead of direct mutation
            if (window.authBridge) {
                if (window.authBridge.setAuthHeaders) {
                    window.authBridge.setAuthHeaders(null, username);
                } else {
                    // Fallback if method doesn't exist
                    window.authBridge.authState.authHeaders = null;
                }
                console.log('üß™ TEST: Cleared auth headers from authBridge');
            }
            
            // Also clear from authBridgeInstance if available
            if (this.authBridgeInstance) {
                this.authBridgeInstance.setAuthHeaders(null, username);
                console.log('üß™ TEST: Cleared auth headers from authBridgeInstance');
            }
            
            alert('Auth headers cleared! You can now refresh to test offline cache loading.');
        },
        
        // ===== UTILITY METHODS =====
        /**
         * Wait for IndexedDB provider to sync with timeout fallback
         * @param {Object} provider - IndexedDB persistence provider
         * @param {number} timeoutMs - Timeout in milliseconds
         * @param {boolean} rejectOnTimeout - If true, reject on timeout instead of resolve
         * @returns {Promise} Resolves when synced or timeout reached
         */
        async waitForProviderSync(provider, timeoutMs = 1000, rejectOnTimeout = false) {
            return Promise.race([
                new Promise(resolve => provider.once('synced', resolve)),
                new Promise((resolve, reject) => {
                    // Use requestAnimationFrame for timeout (Rule 6 compliant)
                    const frames = Math.ceil(timeoutMs / 16); // Convert ms to frames at 60fps
                    let frameCount = 0;
                    const frameTimeout = () => {
                        if (++frameCount >= frames) {
                            if (rejectOnTimeout) {
                                reject(new Error(`Provider sync timeout after ${timeoutMs}ms`));
                            } else {
                                resolve();
                            }
                        } else {
                            requestAnimationFrame(frameTimeout);
                        }
                    };
                    requestAnimationFrame(frameTimeout);
                })
            ]);
        },
        
        // ===== STATE MANAGEMENT WRAPPER METHODS =====
        // These methods ensure all state changes go through controlled APIs
        // following our 8 architecture rules
        
        /**
         * Update file permission level (replaces direct .permissionLevel assignments)
         * @param {Object} file - File object to update
         * @param {string} level - New permission level
         */
        updateFilePermission(file, level) {
            if (!file || !level) return;
            
            if (!VALID_PERMISSION_LEVELS.includes(level)) {
                console.warn('‚ö†Ô∏è Invalid permission level:', level);
                return;
            }
            
            const oldLevel = file.permissionLevel;
            
            // Store the permission in the file object for reactivity
            // This is acceptable as we're modifying our own component's data
            // The PermissionService determines permissions but doesn't store them
            file.permissionLevel = level;
            
            // Clear permission cache in auth state manager when permission changes
            if (window.authStateManager && file.owner && file.permlink) {
                window.authStateManager.clearDocumentPermission(file.owner, file.permlink);
            }
        },
        
        /**
         * Update access type (replaces direct .accessType assignments)
         * @param {Object} doc - Document object to update
         * @param {string} accessType - New access type
         */
        updateDocumentAccessType(doc, accessType) {
            if (!doc || !accessType) return;
            
            const oldType = doc.accessType;
            doc.accessType = accessType;
            
        },
        
        /**
         * Set collaborative documents array (replaces direct assignments)
         * @param {Array} docs - New collaborative documents array
         */
        setCollaborativeDocs(docs) {
            const oldCount = this.collaborativeDocs?.length || 0;
            
            // üìö PHANTOM DEBUG: Log collaborative docs being set
            console.log('üìö PHANTOM DEBUG: Setting collaborative docs', {
                source: 'setCollaborativeDocs',
                oldCount: oldCount,
                newCount: docs?.length || 0,
                docs: docs?.slice(0, 3).map(d => ({
                    owner: d.owner,
                    permlink: d.permlink,
                    accessType: d.accessType,
                    type: d.type
                })),
                timestamp: Date.now(),
                callStack: new Error().stack.split('\n').slice(2, 5).join(' -> ')
            });
            
            this.collaborativeDocs = Array.isArray(docs) ? docs : [];
            
            // Sync with auth state manager if available
            if (this.authStateManager) {
                this.authStateManager.setCollaborativeDocs(this.collaborativeDocs);
            }
        },
        
        /**
         * Clear collaborative documents
         */
        clearCollaborativeDocs() {
            this.setCollaborativeDocs([]);
        },
        
        /**
         * Update current file (replaces direct assignments)
         * @param {Object|null} file - New current file or null
         */
        setCurrentFile(file) {
            const oldFile = this.currentFile;
            this.currentFile = file;
            
        },
        
        /**
         * Update Y.js config map (replaces direct yjsDoc.transact calls)
         * @param {string} key - Config key to update
         * @param {*} value - New value
         * @param {string} origin - Transaction origin for debugging
         */
        updateYjsConfig(key, value, origin = 'component-update') {
            if (!this.ydoc || !key) return;
            
            // ‚úÖ GOLDEN RULE #2: Use YDocService for Y.js operations
            ydocService.updateConfig(key, value, origin);
        },
        
        /**
         * Update Y.js metadata map
         * @param {string} key - Metadata key to update
         * @param {*} value - New value
         * @param {string} origin - Transaction origin for debugging
         */
        updateYjsMetadata(key, value, origin = 'component-update') {
            if (!this.ydoc || !key) return;
            
            // ‚úÖ GOLDEN RULE #2: Use YDocService for Y.js operations
            ydocService.updateMetadata(key, value, origin);
        },
        
        /**
         * Batch update Y.js config
         * @param {Object} updates - Object with key-value pairs to update
         * @param {string} origin - Transaction origin for debugging
         */
        batchUpdateYjsConfig(updates, origin = 'component-batch-update') {
            if (!this.ydoc || !updates) return;
            
            // ‚úÖ GOLDEN RULE #2: Use YDocService for Y.js operations
            ydocService.batchUpdate(updates, {}, origin);
        },
        
        // ===== EVENT-DRIVEN USER CHANGES =====

        /**
         * Setup event listener for auth bridge user changes (modular authentication)
         */
        setupAuthBridgeUserChangeListener() {
            const authBridge = this.authBridgeInstance;
            
            if (!authBridge) {
                console.warn('‚ö†Ô∏è Auth bridge not available during mount - user change events will not be received');
                return;
            }

            console.log('üîÑ MODULAR AUTH: Setting up user change event listener');

            // ‚úÖ REMOVED: _userChangeHandler definition - no longer needed
            // We listen directly to authStateManager.on('userChanged') in mounted()
            // This prevents duplicate userChanged event handling

            // ‚úÖ REMOVED: Duplicate userChanged listener from authBridge
            // AuthStateManager is the single source of truth for user changes (Rule 3)
            // We already listen to authStateManager.on('userChanged') in mounted()
            console.log('‚úÖ MODULAR AUTH: Using AuthStateManager as single source of truth for user changes');

            // Listen for authentication retry after successful auth
            this._authRetryHandler = async (event) => {
                const { account, pendingDocumentAccess } = event.detail;

                // Track authentication timing using timestamp
                this._authenticationTime = Date.now();
                this._justAuthenticated = true;
                
                // Use computed property to check if still within auth window
                const checkAuthWindow = () => {
                    if (Date.now() - this._authenticationTime > 1000) {
                        this._justAuthenticated = false;
                    } else {
                        requestAnimationFrame(checkAuthWindow);
                    }
                };
                requestAnimationFrame(checkAuthWindow);

                // Prevent duplicate retry processing
                if (this._processingAuthRetry) {
                    console.log('üîÑ RETRY: Skipping duplicate auth retry event');
                    return;
                }

                // üîÑ RETRY DEBUG: Log complete state when retry handler is called

                // üîÑ RETRY: Enhanced retry flow logging
                const retryStartTime = Date.now();
                console.log('üîÑ RETRY: Auth retry handler triggered', {
                    timestamp: retryStartTime,
                    account,
                    pendingDocumentAccess,
                    currentAuthState: {
                        isAuthenticated: this.isAuthenticated,
                        authHeaders: !!this.authHeaders,
                        authHeadersAccount: this.authHeaders?.['x-account'],
                        authHeadersMatch: this.authHeaders?.['x-account'] === account
                    },
                    modalState: authBridge.getState()
                });
                
                // üîÑ AUTH RETRY: Evaluate post-auth action
                console.log('üîÑ AUTH RETRY: Evaluating post-auth action', {
                    hasPendingDocAccess: !!pendingDocumentAccess,
                    hasOwnerPermlink: !!(pendingDocumentAccess?.owner && pendingDocumentAccess?.permlink),
                    hasPendingConversion: !!this.pendingConversion,
                    conversionType: this.pendingConversion?.type,
                    pendingDocType: pendingDocumentAccess?.type
                });

                if (pendingDocumentAccess && pendingDocumentAccess.owner && pendingDocumentAccess.permlink) {
                    // Set flag to prevent duplicate processing
                    this._processingAuthRetry = true;

                    try {
                        // ‚úÖ PERMISSION PRE-CHECK: Clear stale caches before attempting document load
                        if (pendingDocumentAccess.type === 'collaborative') {
                            console.log('üîÑ RETRY: Clearing permission caches before retry');
                            // Clear any cached permissions to force fresh check
                            const docKey = `${pendingDocumentAccess.owner}/${pendingDocumentAccess.permlink}`;

                            // Clear permission cache via AuthStateManager
                            if (this.authStateManager) {
                                this.authStateManager.clearFilePermissionCache();
                            }

                            // Clear permission cache via proper method
                            if (this.authStateManager && typeof this.authStateManager.clearDocumentPermission === 'function') {
                                this.authStateManager.clearDocumentPermission(pendingDocumentAccess.owner, pendingDocumentAccess.permlink);
                                console.log('üîç AUTH RETRY: Cleared AuthStateManager permission cache');
                            }

                            // Force clear collaborative docs to ensure fresh API call
                            if (this.authStateManager) {
                                this.authStateManager.clearCollaborativeDocs();
                            }

                            console.log('üîç AUTH RETRY: Cleared all permission caches for fresh check', {
                                account,
                                document: docKey,
                                willAttemptLoad: true,
                                currentCollaborativeDocs: this.collaborativeDocs?.length || 0,
                                isDocInCurrentList: this.collaborativeDocs?.some(d =>
                                    d.owner === pendingDocumentAccess.owner && d.permlink === pendingDocumentAccess.permlink
                                )
                            });
                        }

                        // ‚úÖ GOLDEN RULE #6: No Timing Dependencies
                        // Use reactive watcher instead of timing-based checks
                        if (!this.isAuthenticated || this.authHeaders?.['x-account'] !== account) {
                            console.log('üîÑ RETRY: Setting up auth headers watcher', {
                                currentAccount: this.authHeaders?.['x-account'],
                                expectedAccount: account,
                                isAuthenticated: this.isAuthenticated
                            });

                            // Create a promise to wait for auth headers
                            const authHeadersReady = new Promise((resolve, reject) => {
                                // ‚úÖ RULE #6: Replace short timeout with event-driven approach
                                console.log('üîÑ RETRY: Waiting for auth headers to update', {
                                    expectedAccount: account,
                                    currentAccount: this.authHeaders?.['x-account']
                                });
                                
                                // Create a one-time watcher for auth headers
                                const unwatch = this.$watch(
                                    () => ({
                                        isAuth: this.isAuthenticated,
                                        account: this.authHeaders?.['x-account']
                                    }),
                                    (newVal) => {
                                        if (newVal.isAuth && newVal.account === account) {
                                            console.log('‚úÖ RETRY: Auth headers ready via watcher', {
                                                account: newVal.account
                                            });
                                            unwatch(); // Remove watcher
                                            resolve();
                                        }
                                    },
                                    { immediate: true }
                                );

                                // ‚úÖ RULE #6: Use timestamp-based approach for safety timeout
                                // This is only a safety net - normal flow should complete much faster
                                const authStartTime = Date.now();
                                const checkAuthTimeout = () => {
                                    if (Date.now() - authStartTime > 30000) {
                                        unwatch();
                                        console.error('‚ùå RETRY: Auth headers timeout after 30 seconds', {
                                            expectedAccount: account,
                                            currentAccount: this.authHeaders?.['x-account'],
                                            isAuthenticated: this.isAuthenticated
                                        });
                                        reject(new Error('Auth headers timeout after 30 seconds'));
                                    } else if (window.authStateManager.authHeaders?.['x-account'] === account) {
                                        // Headers arrived, no need to continue checking
                                        return;
                                    } else {
                                        requestAnimationFrame(checkAuthTimeout);
                                    }
                                };
                                requestAnimationFrame(checkAuthTimeout);
                            });

                            try {
                                await authHeadersReady;
                            } catch (error) {
                                console.error('‚ùå RETRY: Failed to sync auth headers', error);
                                // ‚úÖ FIX: Clear the processing flag before returning
                                this._processingAuthRetry = false;
                                return;
                            }
                        }

                        console.log('‚úÖ RETRY: Auth headers validated, proceeding with document load', {
                            authAccount: this.authHeaders?.['x-account'],
                            expectedAccount: account,
                            isAuthenticated: this.isAuthenticated,
                            hasValidHeaders: this.isAuthenticated && !!this.authHeaders
                        });

                        // ‚úÖ FORCE USERNAME REFRESH: Ensure AuthStateManager has the updated user
                        if (this.authHeaders?.['x-account'] && this.authStateManager) {
                            console.log('üîÑ RETRY: Forcing username refresh in AuthStateManager', {
                                currentUser: this.authStateManager.getUser(),
                                newUser: this.authHeaders['x-account'],
                                willUpdate: this.authStateManager.getUser() !== this.authHeaders['x-account']
                            });
                            this.authStateManager.setUser(this.authHeaders['x-account']);
                            
                            // Force computed property refresh
                            await this.$nextTick();
                            
                            console.log('üîÑ RETRY: Username after forced refresh', {
                                username: this.username,
                                authStateUser: this.authStateManager.getUser(),
                                isGuestUser: this.isGuestUser()
                            });
                        }

                        // Permission check passed - attempt to load the document with new credentials
                        let documentLoaded = false;
                        let loadedPermissionLevel = null;

                        if (pendingDocumentAccess.type === 'collaborative') {
                            // Store current file before attempt
                            const fileBeforeLoad = this.currentFile;

                            await this.autoConnectToCollaborativeDocument(
                                pendingDocumentAccess.owner,
                                pendingDocumentAccess.permlink
                            );

                            // Check if document actually loaded by seeing if currentFile changed
                            documentLoaded = this.currentFile &&
                                this.currentFile.owner === pendingDocumentAccess.owner &&
                                this.currentFile.permlink === pendingDocumentAccess.permlink;

                            // Get the actual permission level after load attempt
                            if (documentLoaded) {
                                loadedPermissionLevel = this.getUserPermissionLevel(this.currentFile);

                            } else {
                            }

                            console.log('üîç AUTH RETRY: Document load result:', {
                                documentLoaded,
                                loadedPermissionLevel,
                                hasAccess: loadedPermissionLevel && loadedPermissionLevel !== 'no-access',
                                currentFile: this.currentFile,
                                pendingDocument: `${pendingDocumentAccess.owner}/${pendingDocumentAccess.permlink}`,
                                fileChanged: this.currentFile !== fileBeforeLoad
                            });

                            // Check if user actually has permission to the loaded document
                            const hasActualAccess = documentLoaded &&
                                loadedPermissionLevel &&
                                loadedPermissionLevel !== 'no-access' &&
                                loadedPermissionLevel !== 'unknown';

                            // If document didn't load OR user has no access, let AuthStateManager handle it
                            if (!hasActualAccess) {
                                console.log('üîÑ AUTH RETRY: User lacks permission - AuthStateManager will handle modal', {
                                    documentLoaded,
                                    permissionLevel: loadedPermissionLevel,
                                    reason: !documentLoaded ? 'document-not-loaded' : 'no-access-permission',
                                    note: 'AuthStateManager already emitted accessDenied event during autoConnectToCollaborativeDocument'
                                });

                                // ‚úÖ SINGLE SOURCE OF TRUTH: Do NOT show modal here
                                // AuthStateManager already emitted accessDenied event which shows the modal
                                // Showing it again here causes the "Had to clean up previous modal" warning
                                // ‚úÖ FIX: Clear the processing flag before returning
                                this._processingAuthRetry = false;
                                return; // Exit early - don't clear pending access
                            }
                        } else if (pendingDocumentAccess.type === 'local') {
                            await this.autoConnectToLocalDocument(
                                pendingDocumentAccess.owner,
                                pendingDocumentAccess.permlink
                            );
                            documentLoaded = true; // Local docs should always load for authenticated users
                        }

                        // Only clear and hide if document actually loaded
                        if (documentLoaded) {
                            const retryCompleteTime = Date.now() - retryStartTime;
                            console.log('üîÑ RETRY: Retry flow completed successfully', {
                                totalRetryTime: `${retryCompleteTime}ms`,
                                documentLoaded: true,
                                permissionLevel: loadedPermissionLevel,
                                modalWillHide: true
                            });

                            // Clear pending access in auth bridge and hide modal
                            authBridge.clearPendingAccess('document-loaded');
                            console.log('‚úÖ AUTH RETRY: Document loaded successfully after authentication');

                            // ‚úÖ MODAL CONTROL: Hide modal and backdrop after successful document load
                            authBridge.hideAuthPrompt(false, true); // Don't preserve pending access, hide backdrop
                        } else {
                            console.log('üîÑ RETRY: Retry flow completed with issues', {
                                totalRetryTime: `${Date.now() - retryStartTime}ms`,
                                documentLoaded: false,
                                modalStillShowing: authBridge.isPromptVisible()
                            });
                        }

                    } catch (error) {
                        console.error('‚ùå Document access retry failed:', error);

                        // ‚úÖ SINGLE SOURCE OF TRUTH: Let AuthStateManager handle modal display
                        if (error.message?.includes('403') || error.response?.status === 403) {
                            // Access denied - AuthStateManager already handled it
                            console.log('üîÑ AUTH RETRY: 403 error - AuthStateManager already showed modal', {
                                error: error.message,
                                note: 'autoConnectToCollaborativeDocument triggers accessDenied event on 403'
                            });
                        } else {
                            // Network or server error - show error state
                            console.log('üîÑ AUTH RETRY: Network/server error - showing error state');
                            authBridge.showAuthPrompt('permission_check_failed', pendingDocumentAccess);
                        }
                    } finally {
                        // Clear the processing flag
                        this._processingAuthRetry = false;
                    }
                } else {
                    // No specific document - handle other AUTHENTICATION scenarios
                    // Note: This is AUTHENTICATION completion, not LOGIN
                    console.log('üîë AUTH RETRY: Authentication completed - routing to appropriate action', {
                        authenticationContext: {
                            showLoadModal: this.showLoadModal,
                            hasPendingConversion: !!this.pendingConversion,
                            pendingConversionType: this.pendingConversion?.type,
                            isAuthenticated: this.isAuthenticated,
                            account: account
                        },
                        note: 'This handles AUTHENTICATION success, not login/user change'
                    });
                    
                    // Scenario 1: Cloud Conversion - Need auth to CREATE resource
                    if (this.pendingConversion && this.pendingConversion.type === 'cloud-conversion') {
                        console.log('‚òÅÔ∏è AUTH RETRY: Executing pending cloud conversion', {
                            pendingData: this.pendingConversion,
                            willExecute: true,
                            timestamp: Date.now()
                        });
                        const pendingData = this.pendingConversion;
                        this.pendingConversion = null;
                        
                        try {
                            await this.executeCloudConversion(pendingData);
                            authBridge.hideAuthPrompt(false, true);
                        } catch (error) {
                            console.error('‚ùå AUTH: Cloud conversion failed after authentication', error);
                            // Restore pending conversion so user can retry
                            this.pendingConversion = pendingData;
                        }
                    }
                    
                    // Scenario 2: Document List - Need auth to ACCESS resources
                    else if (this.showLoadModal && this.isAuthenticated) {
                        console.log('üìÅ AUTH: Loading document list after authentication');
                        try {
                            await this.refreshDocumentLists();
                            authBridge.hideAuthPrompt(false, true);
                        } catch (error) {
                            console.error('‚ùå AUTH: Failed to refresh document lists', error);
                            // Modal stays open so user can see the error
                        }
                    }
                    
                    // Scenario 3: General Authentication - No specific resource
                    else {
                        console.log('‚úÖ AUTH: Authentication flow completed, no pending resource access');
                        authBridge.hideAuthPrompt(false, true);
                    }
                }
            };

            // CRITICAL: This handler is required for authentication flow to complete
            // It triggers document retry after successful authentication
            this.eventManager.addCustomListener(authBridge, 'authRetryReady', this._authRetryHandler);
            console.log('‚úÖ MODULAR AUTH: Auth retry event listener registered with EventManager');

            // Listen for auth header updates from auth bridge
            this._authHeadersUpdatedHandler = (event) => {
                const { headers, account, isAuthenticated, isExpired, challengeAge } = event.detail;

                console.log('üì° Auth headers updated via bridge', {
                    hasHeaders: !!headers,
                    account,
                    isAuthenticated,
                    isExpired,
                    challengeAge
                });

                // Sync using consolidated method
                this.syncAuthStateFromBridge();
            };

            this.eventManager.addCustomListener(authBridge, 'authHeadersUpdated', this._authHeadersUpdatedHandler);
            console.log('‚úÖ MODULAR AUTH: Auth headers updated event listener registered with EventManager');
        },

        /**
         * Setup logout event listener to handle logout directly
         */
        setupLogoutListener() {
            console.log('üîö Setting up logout event listener');

            // Listen for user changes from authStateManager
            if (this.authStateManager) {
                // Store handler for proper cleanup
                this._authStateUserChangedHandler = (event) => {
                    const { oldUser, newUser } = event.detail;

                    // Check if user was logged out
                    if (oldUser && !newUser) {
                        console.log('üîö LOGOUT: Detected user logout via authStateManager');
                        // Use microtask to ensure this runs after current call stack
                        Promise.resolve().then(() => {
                            if (this.currentFile && this.currentFile.type === 'collaborative') {
                                this.handleLogout();
                            }
                        });
                    }
                };

                this.authStateManager.on('userChanged', this._authStateUserChangedHandler);
            }

            // ‚úÖ CLEAN ARCHITECTURE: Removed parent account monitoring
            // Auth state changes are handled through AuthStateManager events
        },

        /**
         * Handle logout event directly
         */
        handleLogout() {
            console.log('üîö LOGOUT: Processing logout', {
                hasCurrentFile: !!this.currentFile,
                fileType: this.currentFile?.type,
                username: this.username,
                timestamp: new Date().toISOString()
            });

            // If we have a collaborative document, we need to show auth modal
            if (this.currentFile && this.currentFile.type === 'collaborative') {
                console.log('üîö LOGOUT: User logged out while viewing collaborative document');

                // Store document info before clearing
                const documentInfo = {
                    owner: this.currentFile.owner,
                    permlink: this.currentFile.permlink,
                    name: this.currentFile.name || this.currentFile.documentName || 'Document',
                    type: 'collaborative'
                };

                // Clear the document first
                this.setCurrentFile(null);

                // Then show auth modal
                this.$nextTick(() => {
                    // ‚úÖ UNIFIED AUTH: Use DLUXAuthBridge directly
                    const authBridge = this.authBridgeInstance;
                    if (authBridge) {
                        // ‚úÖ FIX: Use handleDocumentAccessDenied instead of hardcoded login
                        // This ensures proper auth modal type selection
                        this.handleDocumentAccessDenied(documentInfo);
                    }
                });
            } else {
                // For other document types, just clear
                this.setCurrentFile(null);
            }
        },

        /**
         * Handle authentication state changes
         * Called when isAuthenticated changes
         */
        handleAuthenticationStateChange(isAuthenticated, wasAuthenticated) {
            // Only proceed if changing TO authenticated state
            if (!isAuthenticated) return;

            // Skip if already loading from URL
            if (this.isLoadingFromURL) return;

            // ‚úÖ AUTH RESTORATION: Load collaborative docs when authentication is restored
            // This ensures we have the latest permissions after auth restoration
            if (!wasAuthenticated) {
                console.log('üîê Authentication restored, loading collaborative documents list');
                this.loadCollaborativeDocs().catch(error => {
                    console.warn('‚ö†Ô∏è Failed to load collaborative docs after auth restoration:', error);
                });
            }

            // Check for collaborative URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const collabOwner = urlParams.get('collab_owner');
            const collabPermlink = urlParams.get('collab_permlink');

            if (collabOwner && collabPermlink && !this.isLoadingFromURL) {
                
                // ‚úÖ RACE CONDITION FIX: Ensure collaborative docs are loaded before attempting connection
                if (this.isLoadingCollaborativeDocs) {
                    console.log('‚è≥ Waiting for collaborative docs to load before connecting...');
                    
                    // Watch for collaborative docs to finish loading
                    const unwatch = this.$watch('isLoadingCollaborativeDocs', (newVal) => {
                        if (!newVal && !this.isLoadingFromURL) {
                            console.log('‚úÖ Collaborative docs loaded, now connecting to document');
                            unwatch(); // Remove watcher
                            this.isLoadingFromURL = true;
                            this.autoConnectToCollaborativeDocument(collabOwner, collabPermlink).catch(error => {
                                console.error('‚ùå Failed to auto-connect to collaborative document:', error);
                                this.isLoadingFromURL = false;

                                // Check if it's a temporary error
                                const isTemporaryError = error.message.includes('fetch') ||
                                    error.message.includes('network') ||
                                    error.message.includes('timeout');

                                if (!isTemporaryError) {
                                    console.warn('üîó Clearing URL due to permanent error');
                                    this.clearCollabURLParams();
                                    this.documentManager.newDocument();
                                }
                            });
                        }
                    });
                } else {
                    // Collaborative docs already loaded, proceed
                    this.isLoadingFromURL = true;
                    this.autoConnectToCollaborativeDocument(collabOwner, collabPermlink).catch(error => {
                        console.error('‚ùå Failed to auto-connect to collaborative document:', error);
                        this.isLoadingFromURL = false;

                        // Check if it's a temporary error
                        const isTemporaryError = error.message.includes('fetch') ||
                            error.message.includes('network') ||
                            error.message.includes('timeout');

                        if (!isTemporaryError) {
                            console.warn('üîó Clearing URL due to permanent error');
                            this.clearCollabURLParams();
                            this.documentManager.newDocument();
                        }
                    });
                }
            }
        },

        /**
         * Setup auth headers change listener
         * Uses event-driven approach instead of Vue watchers
         */
        setupAuthHeadersListener() {
            console.log('üì° TIPTAP: Setting up auth headers change listener', {
                currentAuthHeaders: !!this.authHeaders,
                username: this.username,
                timestamp: new Date().toISOString()
            });

            // Track last headers to detect changes
            let lastHeaders = this.authHeaders;

            // Initial check on mount
            if (this.authHeaders) {
                this.handleAuthHeadersChange(this.authHeaders, null);
            }

            // Listen for auth header changes via event
            const authHeadersHandler = (event) => {
                const newHeaders = event.detail?.headers;
                const hasChanged = this.hasAuthHeadersChanged(lastHeaders, newHeaders);

                if (hasChanged) {
                    console.log('üì° Auth headers changed:', {
                        oldAccount: this.authStateManager.getAuthAccount(lastHeaders),
                        newAccount: this.authStateManager.getAuthAccount(newHeaders),
                        timestamp: new Date().toISOString()
                    });

                    // Handle the change
                    this.handleAuthHeadersChange(newHeaders, lastHeaders);
                    lastHeaders = newHeaders;
                }
            };

            // Subscribe to auth header changes
            this.authStateManager.on('authHeadersChanged', authHeadersHandler);

            // Store handler for cleanup
            this._authHeadersHandler = authHeadersHandler;
        },

        /**
         * Check if auth headers have changed
         */
        hasAuthHeadersChanged(oldHeaders, newHeaders) {
            // If one is null and the other isn't, they've changed
            if (!oldHeaders && newHeaders) return true;
            if (oldHeaders && !newHeaders) return true;
            if (!oldHeaders && !newHeaders) return false;

            // Check key fields
            return this.authStateManager.getAuthAccount(oldHeaders) !== this.authStateManager.getAuthAccount(newHeaders) ||
                this.authStateManager.getAuthChallenge(oldHeaders) !== this.authStateManager.getAuthChallenge(newHeaders) ||
                this.authStateManager.getAuthSignature(oldHeaders) !== this.authStateManager.getAuthSignature(newHeaders);
        },

        /**
         * Handle auth headers changes
         * Moved from authHeaders watcher for better control
         */
        async handleAuthHeadersChange(newHeaders, oldHeaders) {
            console.log('üì° TIPTAP: Auth headers change handler triggered:', {
                hasNewHeaders: !!newHeaders,
                account: this.authStateManager.getAuthAccount(newHeaders),
                hasDeferredCollab: !!this.deferredCollabConnection,
                hasDeferredLocal: !!this.deferredLocalConnection,
                isInitialCall: oldHeaders === null,
                timestamp: new Date().toISOString()
            });

            // ‚úÖ AUTH STATE MANAGER: Sync auth headers using consolidated method
            this.syncAuthStateFromBridge();

            // ‚úÖ URL PARAMETER HANDLING: Check if we need to load collaborative document
            const urlParams = new URLSearchParams(window.location.search);
            const collabOwner = urlParams.get('collab_owner');
            const collabPermlink = urlParams.get('collab_permlink');

            if (collabOwner && collabPermlink && !this.currentFile) {
                console.log('üîê AUTH PERSISTENCE: Checking collaborative document from URL params', {
                    owner: collabOwner,
                    permlink: collabPermlink,
                    hasAuthHeaders: !!newHeaders,
                    authAccount: newHeaders?.['x-account']
                });

                // Check if we should load the document
                // Load when:
                // 1. Headers just arrived (null -> headers) - authenticated access
                // 2. User is logged in but no headers - check offline cache
                // 3. We haven't attempted to load yet
                const hasUser = this.authStateManager?.getUser() || this.username;
                const shouldLoadDocument = !this._collabDocLoadAttempted && (
                    newHeaders || // Authenticated
                    (!newHeaders && hasUser) // Logged in but not authenticated - check offline cache
                );

                if (shouldLoadDocument) {
                    console.log('üîê AUTH PERSISTENCE: Attempting to load collaborative document', {
                        owner: collabOwner,
                        permlink: collabPermlink,
                        hasAuthHeaders: !!newHeaders,
                        hasUser: !!hasUser,
                        user: hasUser,
                        account: newHeaders?.['x-account'],
                        isInitialLoad: !oldHeaders,
                        reason: newHeaders ? 'authenticated' : 'checking-offline-cache'
                    });

                    // Mark that we're attempting to load
                    this._collabDocLoadAttempted = true;

                    // Load the collaborative document
                    this.$nextTick(() => {
                        this.autoConnectToCollaborativeDocument(collabOwner, collabPermlink);
                    });
                }
            }

            // Process any deferred connections now that auth is ready
            if (this.deferredCollabConnection) {
                const { owner, permlink, needsAuth, documentContext } = this.deferredCollabConnection;

                // Check if component managers are ready before processing
                const managersReady = this.documentManager && this.recoveryManager && this.contentStateManager;

                if (managersReady) {
                    this.deferredCollabConnection = null;
                    this.showLoadingMessage = '';
                    this.loadingStates.auth = false;
                    this.$nextTick(async () => {
                        // ‚úÖ INTEGRATED AUTH FLOW: Check if auth modal should be triggered first
                        if (needsAuth && !this.isAuthenticated && documentContext) {
                            await this.handleDocumentAccessDenied(documentContext);
                            return;
                        }

                        this.autoConnectToCollaborativeDocument(owner, permlink).catch(error => {
                            console.error('‚ùå Deferred collaborative connection failed:', error);
                            this.isLoadingFromURL = false;

                            // Create a temp document if we don't have one
                            if (!this.currentFile) {
                                this.documentManager.newDocument();
                            }
                        });
                    });
                } else {
                }
            }

            if (this.deferredLocalConnection) {
                const { owner, permlink } = this.deferredLocalConnection;
                this.deferredLocalConnection = null;
                this.$nextTick(() => {
                    this.autoConnectToLocalDocument(owner, permlink).catch(error => {
                        console.error('‚ùå Deferred local connection failed:', error);
                    });
                });
            }

            // ‚úÖ LOCAL DOCUMENT COORDINATION: Handle local document ownership changes
            if (this.currentFile && this.currentFile.type === 'local') {
                const currentAuthUser = newHeaders ? this.authStateManager.getAuthAccount(newHeaders) : null;
                const documentOwner = this.getLocalDocumentOwner();

                if (documentOwner && documentOwner !== currentAuthUser) {

                    // ‚úÖ DEDICATED METHOD: Use new dedicated user switch method
                    await this.clearLocalDocumentForUserSwitch(documentOwner, currentAuthUser, 'auth-headers-handler');
                }
            }

            // ‚úÖ COLLABORATIVE DOCUMENT COORDINATION: Handle permission validation for user switches
            if (this.currentFile && this.currentFile.type === 'collaborative') {
                const currentAuthUser = newHeaders ? this.authStateManager.getAuthAccount(newHeaders) : null;
                const oldAuthUser = oldHeaders ? this.authStateManager.getAuthAccount(oldHeaders) : null;

                // Check if this is a user switch for collaborative documents
                if (oldAuthUser && currentAuthUser && oldAuthUser !== currentAuthUser) {

                    // Clear cached permissions via AuthStateManager
                    if (this.authStateManager) {
                        this.authStateManager.clearFilePermissionCache();
                    }

                    // Reload permission for this document with new user
                    this.loadPermissionForDocument(this.currentFile).catch(error => {
                        console.warn('‚ö†Ô∏è Failed to reload permission after user switch:', error);
                    });
                }
            }
        },

        /**
         * Sync auth state from bridge to manager
         * Consolidates all auth synchronization logic
         */
        syncAuthStateFromBridge() {
            // ‚úÖ RECURSION GUARD: Prevent re-entry to avoid infinite loops
            if (this._syncingFromBridge) {
                console.log('üîÑ Preventing recursive sync from bridge');
                return;
            }

            const authBridge = this.authBridgeInstance;
            if (!authBridge || !this.authStateManager) {
                return;
            }

            this._syncingFromBridge = true;
            try {
                const bridgeState = authBridge.authState || authBridge.getState();
                const account = bridgeState.account;
                let headers = bridgeState.authHeaders || authBridge.getAuthHeaders();
                
                // ‚úÖ AUTH-RESTORE: Try to restore headers from sessionStorage if bridge doesn't have them
                if (!headers && account && typeof sessionStorage !== 'undefined') {
                    const storageKey = `collaborationAuthHeaders_${account}`;
                    const storedHeaders = sessionStorage.getItem(storageKey);
                    if (storedHeaders) {
                        try {
                            headers = JSON.parse(storedHeaders);
                            console.log('üî¥ AUTH-RESTORE: Restored headers from sessionStorage', {
                                account,
                                storageKey,
                                hasHeaders: !!headers,
                                challenge: headers?.['x-challenge']
                            });
                            // Update the bridge with restored headers
                            if (authBridge.setAuthHeaders) {
                                authBridge.setAuthHeaders(headers, account);
                            }
                        } catch (e) {
                            console.error('Failed to parse stored headers:', e);
                        }
                    }
                }

                // ‚úÖ STALE HEADER PREVENTION: Check if headers match current username
                // This prevents stale headers from previous sessions being applied
                if (headers && headers['x-account']) {
                    const currentUsername = this.username; // From v3-nav via v-model
                    const headerAccount = headers['x-account'];
                    
                    if (currentUsername && headerAccount !== currentUsername) {
                        console.log('üî¥ AUTH-FLOW: Blocking stale headers from bridge sync', {
                            currentUsername,
                            headerAccount,
                            action: 'clearing stale headers'
                        });
                        headers = null; // Don't sync stale headers
                        
                        // Also clear them from the bridge to prevent future contamination
                        if (authBridge.setAuthHeaders) {
                            authBridge.setAuthHeaders(null, currentUsername);
                        }
                    }
                }

                // Debug logging
                console.log('üîÑ SYNC: Syncing auth state from bridge to manager', {
                    account,
                    hasHeaders: !!headers,
                    isAuthenticated: bridgeState.isAuthenticated,
                    currentUsername: this.username,
                    timestamp: new Date().toISOString()
                });

                // CRITICAL: Validate headers match account before syncing
                if (headers && account) {
                    const headerAccount = headers['x-account'];
                    if (headerAccount !== account) {
                        console.log('üö® SYNC VALIDATION: Headers do not match account - preventing contamination', {
                            bridgeAccount: account,
                            headerAccount: headerAccount,
                            action: 'clearing mismatched headers from bridge'
                        });
                        
                        // Clear mismatched headers from the bridge
                        authBridge.setAuthHeaders(null, account);
                        headers = null; // Don't sync contaminated headers
                    }
                }

                // Sync user first (order matters for state machine transitions)
                if (account !== undefined) {
                    this.authStateManager.setUser(account);
                }

                // Then sync headers (only if they're valid)
                if (headers !== undefined) {
                    this.authStateManager.setAuthHeaders(headers);
                }

                // ‚ùå REMOVED: Echo back to bridge - this causes infinite loops
                // The bridge is the source of truth, we should only consume from it
                // if (authBridge.setAuthHeaders && headers) {
                //     authBridge.setAuthHeaders(headers, account);
                // }
            } finally {
                this._syncingFromBridge = false;
            }
        },

        /**
         * Setup username listener for event-driven validation
         * Replaces the polling-based username validation interval
         */
        setupUsernameWatcher() {
            console.log('üë§ Setting up username event listener for event-driven validation');

            // Track initial username for immediate check
            let lastUsername = this.username;

            // Handle initial username if present
            if (this.username) {
                console.log('üîÑ Initial username check:', { username: this.username });
                if (this.authStateManager) {
                    this.authStateManager.setUser(this.username);
                }
            }

            // Listen for username changes via userChanged event
            const usernameChangeHandler = (event) => {
                const { oldUser: oldUsername, newUser: newUsername } = event.detail || {};
                if (newUsername === oldUsername || newUsername === lastUsername) return;
                
                console.log('üîÑ Username change detected by event:', {
                    from: oldUsername,
                    to: newUsername,
                    timestamp: new Date().toISOString()
                });
                
                lastUsername = newUsername;
                
                // Update AuthStateManager with the new username
                if (this.authStateManager) {
                    console.log('üîÑ Updating AuthStateManager with new username');
                    this.authStateManager.setUser(newUsername);
                }
                
                // Username change handling is done by event system
                // This follows Rule 7 (Single Responsibility)
                
                // Check if we should trigger validation
                const authBridge = this.authBridgeInstance;
                if (authBridge?.authState?.pendingDocumentAccess) {
                    console.log('üîÑ Username event triggering validation for pending document access');
                    this.triggerUsernameValidationCheck('username-event');
                }

                // Also validate any pending cache permissions
                if (this.pendingCacheValidation && this.pendingCacheValidation.length > 0) {
                    console.log('üîÑ Username event validating pending cache permissions');
                    this.validatePendingCachePermissions();
                }
            };

            // Subscribe to user change events
            if (this.authStateManager) {
                this.authStateManager.on('userChanged', usernameChangeHandler);
                // Store handler for cleanup
                this._usernameChangeHandler = usernameChangeHandler;
            }
        },

        /**
         * Handle user changes from auth bridge events
         * Consolidates logic from username and authHeaders watchers
         */
        async handleUserChange(oldUser, newUser, changeType) {
            // Set flag to prevent race conditions
            this._processingUserChange = true;
            
            console.log('üîÑ EVENT-DRIVEN: Processing user change', {
                oldUser,
                newUser,
                changeType,
                hasCurrentFile: !!this.currentFile,
                currentFileType: this.currentFile?.type,
                currentFileOwner: this.currentFile?.owner,
                timestamp: new Date().toISOString()
            });
            
            try {
                // ‚úÖ CANCEL ALL PENDING REQUESTS
                this.cancelAllPendingRequests('user-switch');
                
                // ‚úÖ FULL CLEANUP: Always do complete cleanup (no special cases)
                if (this.currentFile || this.documentManager?.syncManager?.component?.ydoc) {
                    console.log('üßπ USER SWITCH: Performing full document cleanup');
                    await this.documentManager.lifecycleManager.cleanupDocument();
                }
                
                // ‚úÖ CLEAR CACHES based on online/offline state
                if (navigator.onLine) {
                    // Online: Clear everything for fresh validation
                    console.log('üåê ONLINE USER SWITCH: Clearing all caches for fresh validation');
                    if (this.authStateManager) {
                        this.authStateManager.clearFilePermissionCache();
                    }
                    if (window.cacheService && typeof window.cacheService.clearUserCaches === 'function') {
                        window.cacheService.clearUserCaches(oldUser);
                    }
                } else {
                    // Offline: Keep caches for work continuity
                    console.log('üì± OFFLINE USER SWITCH: Preserving caches for work continuity');
                    // Just clear active session state, not cached data
                }
                
                // URL and pendingDocumentAccess preserved in AuthBridge
                // Document will reload after authentication via authRetryReady
                console.log('‚úÖ USER SWITCH: Cleanup complete, waiting for auth flow');
                
                // ‚úÖ AUTH STATE MANAGER: Update user state
                if (this.authStateManager) {
                    console.log('üîê AuthStateManager: Updating user state', { oldUser, newUser });
                    this.authStateManager.setUser(newUser);
                    
                    // For logout - auth manager handles everything
                    if (!newUser) {
                        console.log('üîê AuthStateManager: User logout detected');
                        return;
                    }
                }
                
                // ‚úÖ CHECK LOCAL DOCUMENT ACCESS: Show auth modal if user doesn't match document owner
                const urlParams = new URLSearchParams(window.location.search);
                const localOwner = urlParams.get('local_owner');
                const localPermlink = urlParams.get('local_permlink');
                
                if (localOwner && localPermlink && localOwner !== newUser) {
                    console.log('üîÑ USER SWITCH: Local document owner mismatch detected', {
                        documentOwner: localOwner,
                        currentUser: newUser,
                        action: 'showing-auth-modal'
                    });
                    
                    const documentInfo = {
                        type: 'local',
                        owner: localOwner,
                        permlink: localPermlink,
                        name: `${localOwner}'s document`
                    };
                    
                    if (this.authBridgeInstance) {
                        // This will set pendingDocumentAccess and show the auth modal
                        // authRetryReady will fire after successful auth and load the document
                        this.authBridgeInstance.showAuthPrompt('switch_account', documentInfo);
                    }
                }
                
                // ‚úÖ CLEAR LOCAL FILES: Prevent showing other users' files
                this.localFiles = [];
                
                // ‚úÖ REFRESH LOCAL FILES: Load new user's files
                this.$nextTick(() => {
                    this.loadLocalFiles().catch(error => {
                        console.warn('‚ö†Ô∏è Failed to refresh local files after user change:', error);
                    });
                });
            } finally {
                // Clear processing flag after user change completes
                this.$nextTick(() => {
                    this._processingUserChange = false;
                });
            }
        },

        /**
         * Setup AuthStateManager event listeners
         */
        setupAuthStateListeners() {
            if (!this.authStateManager) {
                console.warn('‚ö†Ô∏è AuthStateManager not injected - falling back to parent auth bridge');
                return;
            }

            console.log('üîê Setting up AuthStateManager event listeners');

            // Clear document when access is lost
            this.authStateManager.on('clearDocument', (e) => {
                const DEBUG = window.DEBUG || false;
                this.setCurrentFile(null);

                // Also update AuthStateManager's current document state
                this.authStateManager.setCurrentDocument(null);
            });

            // Show auth modal when access denied
            this.authStateManager.on('accessDenied', (e) => {
                const { document, reason, canAuthenticate } = e.detail;
                const DEBUG = window.DEBUG || false;

                // Reset the access denial handling flag now that we're handling the event
                this.authStateManager.resetAccessDenialHandling();

                if (canAuthenticate?.canAuth) {
                    // ‚úÖ UNIFIED AUTH: Use DLUXAuthBridge directly
                    const authBridge = this.authBridgeInstance;
                    if (authBridge) {
                        const action = canAuthenticate.reason === 'switch-user' ? 'switch_account' :
                            canAuthenticate.reason === 'auth-required' || canAuthenticate.reason === 'auth-expired' ? 'authenticate' :
                                'login';
                        authBridge.showAuthPrompt(action, {
                            name: document.name || `${document.owner}/${document.permlink}`,
                            owner: document.owner,
                            permlink: document.permlink,
                            type: document.type
                        });
                    }
                }
            });

            // User change handling is already covered by:
            // 1. The userChanged handler above (line ~10261) for logout detection
            // 2. The authBridge userChanged handler for general user changes
            // No need for another handler here

            // Store cleanup function
            this._authStateCleanup = () => {
                if (this.authStateManager) {
                    this.authStateManager.off('clearDocument', this._clearDocumentHandler);
                    this.authStateManager.off('accessDenied', this._accessDeniedHandler);
                    // userChanged handler is stored in setupLogoutListener() as _authStateUserChangedHandler
                }
            };
        },

        // ===== STATUS MESSAGE HELPERS =====

        /**
         * Get custom JSON performance metrics
         */
        getCustomJsonMetrics() {
            const metrics = {
                customJsonSize: 0,
                customJsonKeys: 0,
                iframeMetrics: {},
                yjsMetrics: {}
            };

            // Get custom JSON size from Y.js
            if (ydocService.isReady()) {
                // ‚úÖ GOLDEN RULE #2: Use YDocService for Y.js operations
                const customJson = ydocService.getMetadata('customJson') || {};
                const jsonString = JSON.stringify(customJson);

                metrics.customJsonSize = jsonString.length;
                metrics.customJsonKeys = Object.keys(customJson).length;
                metrics.customJsonSizeKB = Math.round(jsonString.length / 1024 * 100) / 100;

                // Warning thresholds
                metrics.sizeWarning = jsonString.length > 50000; // 50KB warning
                metrics.sizeCritical = jsonString.length > 100000; // 100KB critical
            }

            // Get iframe integration metrics
            if (this.customJsonMessageHandler) {
                metrics.iframeMetrics = this.customJsonMessageHandler.getMetrics();
            }

            // Get Y.js document metrics
            if (ydocService.isReady()) {
                metrics.yjsMetrics = {
                    clientID: ydocService.getClientId(),
                    subdocs: ydocService.getSubdocCount(),
                    undoStackSize: ydocService.getUndoStackSize(),
                    redoStackSize: ydocService.getRedoStackSize()
                };
            }

            return metrics;
        },

        /**
         * Log custom JSON performance metrics
         */
        logCustomJsonPerformance() {
            const metrics = this.getCustomJsonMetrics();

            if (metrics.sizeWarning) {
                console.warn('‚ö†Ô∏è Custom JSON size warning:', {
                    size: `${metrics.customJsonSizeKB}KB`,
                    recommendation: 'Consider optimizing data structure or using compression'
                });
            }

            return metrics;
        },

        // ===== AUTHENTICATION HANDLING =====

        // ‚úÖ HANDLE AUTHENTICATION READY: Process pending operations when auth completes
        handleAuthenticationReady(authState) {

            // Clear any loading messages
            this.showLoadingMessage = '';
            this.loadingStates.auth = false;

            // Handle pending document connections
            if (this.pendingAutoConnect) {
                const { owner, permlink, type } = this.pendingAutoConnect;
                this.pendingAutoConnect = null;

                // Clear any existing timeout
                if (this.authLoadTimeout) {
                    cancelAnimationFrame(this.authLoadTimeout);
                    this.authLoadTimeout = null;
                }

                // Retry the connection now that auth is ready
                this.$nextTick(async () => {
                    if (type === 'collaborative') {
                        await this.autoConnectToCollaborativeDocument(owner, permlink);
                    } else {
                        await this.autoConnectToLocalDocument(owner, permlink);
                    }
                });
            }

            // Load permissions for current document if needed
            if (this.currentFile && authState === 'authenticated') {
                this.loadPermissionForDocument(this.currentFile);
            }
        },

        // ‚úÖ REACTIVE PERMISSION LOADING: Load permissions with reactive updates
        async loadPermissionForDocument(document) {
            if (!document) return;

            const key = this.getDocumentKey(document);

            // Check if already loading
            if (this.permissionLoadingKey === key) {
                return;
            }

            // Set loading state
            this.permissionLoadingKey = key;
            this.loadingStates.permissions = true;

            try {

                // Use existing permission fetching logic
                // This updates AuthStateManager cache, which triggers reactive updates
                const permission = await this.getMasterPermissionForDocument(document, true, 'reactive-load');

                if (permission && permission.level) {

                    // Trigger reactive updates via Vue's computed property system
                    this.$nextTick(() => {
                        this.updateEditorMode();
                    });
                }

            } catch (error) {
                console.error('‚ùå Failed to load permissions:', error);
                this.errorStates.permissions = error.message;

            } finally {
                // Clear loading state
                this.permissionLoadingKey = null;
                this.loadingStates.permissions = false;
            }
        },

        // ===== ERROR & LOADING HANDLING =====

        // ‚úÖ SHOW ERROR: Display error message to user
        showError(message) {
            console.error('‚ùå Error:', message);
            this.showLoadingMessage = '';

            // Store error in appropriate category
            if (message.toLowerCase().includes('auth')) {
                this.errorStates.auth = message;
            } else if (message.toLowerCase().includes('permission')) {
                this.errorStates.permissions = message;
            } else {
                this.errorStates.document = message;
            }

            // ‚úÖ FIX: Remove legacy alert dialog - errors are shown in UI
            // alert(message);
        },

        // ‚úÖ CLEAR ERROR: Clear all error states
        clearErrorState() {
            this.errorStates.auth = null;
            this.errorStates.permissions = null;
            this.errorStates.document = null;
        },

        // ‚úÖ SHOW LOADING STATE: Display loading message
        showLoadingState(message) {
            this.showLoadingMessage = message;
        },

        // ===== TITLE CONTENT UTILITIES =====
        // ‚úÖ TIPTAP COMPLIANCE: Use methods instead of reactive state
        displayTitle() {
            // For template display only - this is title CONTENT, not document name
            return this.titleInput ? this.titleInput.trim() : '';
        },

        displayTitleForUI() {
            // For UI display in templates - this is title CONTENT
            const titleContent = this.displayTitle;
            return titleContent || 'No title yet...';
        },

        displayBodyExists() {
            // For template validation display
            return Boolean(this.bodyEditor ? this.bodyEditor.getText().trim() : '');
        },

        displayTitleExists() {
            // For template validation display  
            return Boolean(this.titleInput ? this.titleInput.trim() : '');
        },

        // ===== STATUS MESSAGE HELPERS =====

        // ‚úÖ GET SAVE MESSAGE: Contextual save status messages  
        getSaveMessage(state) {
            const isCollaborativeDocument = this.currentFile &&
                (this.currentFile.type === 'collaborative' ||
                    this.currentFile.isCollaborative === true);

            const isConnected = this.connectionStatus === 'connected';

            if (state === 'saving') {
                if (isCollaborativeDocument && isConnected) {
                    return 'Syncing to cloud...';
                } else if (isCollaborativeDocument && !isConnected) {
                    return 'Saving locally...';
                } else {
                    return 'Saving locally...';
                }
            }

            if (state === 'saved') {
                if (isCollaborativeDocument && isConnected) {
                    return 'Synced to cloud';
                } else if (isCollaborativeDocument && !isConnected) {
                    return 'Saved locally';
                } else {
                    return 'Saved locally';
                }
            }

            return 'Unknown status';
        },

        // ‚úÖ SAVE MESSAGE CONTROL: Show save status message with fade behavior
        showSaveMessage(message, persistent = false) {
            // Clear any existing timeout
            if (this.saveMessageTimeout) {
                clearTimeout(this.saveMessageTimeout);
                this.saveMessageTimeout = null;
            }

            // Show the message
            this.saveMessageText = message;
            this.saveMessageVisible = true;
            this.saveMessagePersistent = persistent;

            // If not persistent, fade after 2 seconds
            if (!persistent) {
                this.saveMessageTimeout = this.eventManager.addTimeout(() => {
                    this.fadeSaveMessage();
                }, 2000);
            }
        },

        // ‚úÖ FADE SAVE MESSAGE: Gradually hide the save message
        fadeSaveMessage() {
            this.saveMessageVisible = false;
            // Clear text after transition completes
            const transitionEndHandler = () => {
                if (!this.saveMessageVisible) {
                    this.saveMessageText = '';
                }
            };
            // Listen for transition end
            const messageEl = document.querySelector('.save-message');
            if (messageEl) {
                messageEl.addEventListener('transitionend', transitionEndHandler, { once: true });
            } else {
                // Fallback if element not found
                this.$nextTick(() => {
                    this.saveMessageText = '';
                });
            }
        },

        // ‚úÖ CLEAR SAVE MESSAGE: Immediately hide the save message
        clearSaveMessage() {
            if (this.saveMessageTimeout) {
                clearTimeout(this.saveMessageTimeout);
                this.saveMessageTimeout = null;
            }
            this.saveMessageVisible = false;
            this.saveMessageText = '';
            this.saveMessagePersistent = false;
        },

        // ‚úÖ UPDATE SAVE STATUS: Main logic for showing save status
        updateSaveStatus() {
            const status = this.saveStatus;

            if (!status.visible) {
                this.clearSaveMessage();
                return;
            }

            // Show appropriate message based on state
            this.showSaveMessage(status.message, status.persistent);
        },

        // ===== STATE MONITORING AND VALIDATION =====
        validateEditorState() {
            // ‚úÖ STATE VALIDATION: Check ProseMirror-Y.js consistency
            if (!this.bodyEditor || !this.ydoc) return { valid: true, errors: [] };

            const errors = [];
            const editor = this.bodyEditor;

            try {
                // Check if editor is in valid state
                if (editor.isDestroyed) {
                    errors.push('Editor is destroyed');
                }

                // Check ProseMirror state
                const state = editor.state;
                if (!state) {
                    errors.push('ProseMirror state is null');
                } else {
                    // Validate document structure
                    if (!state.doc) {
                        errors.push('ProseMirror document is null');
                    }

                    // Check for valid selection
                    if (!state.selection) {
                        errors.push('ProseMirror selection is null');
                    }
                }

                // Check Y.js document state
                if (ydocService.isDestroyed()) {
                    errors.push('Y.js document is destroyed');
                }

                // Check y-tiptap binding
                const collaborationExt = editor.extensionManager.extensions.find(ext => ext.name === 'collaboration');
                if (!collaborationExt) {
                    errors.push('Collaboration extension not found');
                } else {
                    // ‚úÖ TIPTAP v3 COMPLIANCE: Trust TipTap to manage Y.js fragments
                    // Fragment existence is handled internally by TipTap Collaboration extension
                    const field = collaborationExt.options.field || 'default';
                }

                this.stateValidationErrors = errors;
                this.debugTimestamps.lastStateValidation = Date.now();

                return {
                    valid: errors.length === 0,
                    errors: errors,
                    timestamp: this.debugTimestamps.lastStateValidation
                };

            } catch (error) {
                console.error('‚ùå State validation error:', error);
                errors.push(`Validation error: ${error.message}`);
                return { valid: false, errors: errors };
            }
        },

        dumpEditorState() {
            // ‚úÖ DEBUG COMMAND: Dump current state for debugging
            if (!this.bodyEditor) {
                return;
            }

            const editor = this.bodyEditor;
            const state = editor.state;

            console.group('üìã Editor State Dump');

            // ProseMirror state

            // Y.js state
            if (ydocService.isReady()) {
            }

            // Extension state
            const extensions = editor.extensionManager.extensions;

            // Validation results
            const validation = this.validateEditorState();

            console.groupEnd();
        },

        toggleStateMonitoring() {
            // ‚úÖ DEBUG COMMAND: Toggle state monitoring on/off
            this.enableStateMonitoring = !this.enableStateMonitoring;

            if (this.enableStateMonitoring) {
                // Run initial validation
                this.validateEditorState();
            }
        },

        setupDebugKeyboardShortcuts() {
            // ‚úÖ DEBUG SHORTCUTS: Add keyboard shortcuts for state debugging

            // Only set up if not already defined to prevent duplicates
            if (this.debugKeydownHandler) {
                return; // Already set up
            }

            // Store handler reference for cleanup
            this.debugKeydownHandler = (event) => {
                // Use Alt + Shift to avoid browser conflicts
                if (event.altKey && event.shiftKey) {
                    switch (event.key.toUpperCase()) {
                        case 'D':
                            // Dump editor state
                            event.preventDefault();
                            this.dumpEditorState();
                            break;

                        case 'M':
                            // Toggle monitoring
                            event.preventDefault();
                            this.toggleStateMonitoring();
                            break;

                        case 'V':
                            // Validate state
                            event.preventDefault();
                            const validation = this.validateEditorState();
                            break;

                        case 'Y':
                            // Dump Y.js specific info
                            event.preventDefault();
                            if (ydocService.isReady()) {
                                console.group('üì¶ Y.js Debug Info');
                                console.groupEnd();
                            } else {
                            }
                            break;
                    }
                }
            };

            // Add event listener using EventManager for automatic cleanup
            this.eventManager.addDOMListener(document, 'keydown', this.debugKeydownHandler);

            // Also add console commands for easy access
            window.dluxDebug = {
                toggleMonitoring: () => this.toggleStateMonitoring(),
                dumpState: () => this.dumpEditorState(),
                validate: () => {
                    const result = this.validateEditorState();
                    return result;
                },
                yjsInfo: () => {
                    if (ydocService.isReady()) {
                        console.group('üì¶ Y.js Debug Info');
                        console.groupEnd();
                    } else {
                    }
                }
            };

        },

        // ===== WEBGL EMERGENCY CLEANUP =====
        setupGlobalErrorHandler() {
            // Store original error handler
            this.originalErrorHandler = window.onerror;

            // ‚úÖ TIPTAP BEST PRACTICE: Remove improper WebSocket error handler
            // WebSocket protocol errors should be handled by proper editor lifecycle management
            // Not by trying to reconnect providers while editors are still active
        },

        async emergencyWebGLCleanup() {

            try {
                // ‚úÖ STEP 1: WEBGL CONTEXT CLEANUP (highest priority)

                // ‚úÖ VUE REACTIVITY: Use $nextTick to ensure DOM queries happen after any pending updates
                this.$nextTick(() => {
                    // Find and force cleanup of all canvas elements with WebGL contexts
                    const canvases = document.querySelectorAll('canvas');
                    canvases.forEach((canvas, index) => {
                        try {
                            // Get WebGL context and force context loss
                            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl') ||
                                canvas.getContext('webgl2') || canvas.getContext('experimental-webgl2');

                            if (gl) {

                                // Force context loss using WebGL extension
                                const loseContextExt = gl.getExtension('WEBGL_lose_context');
                                if (loseContextExt) {
                                    loseContextExt.loseContext();
                                }

                                // Additional cleanup for specific libraries
                                if (canvas.id?.includes('tiptap') || canvas.closest('.ProseMirror')) {
                                }

                                if (canvas.id?.includes('aframe') || canvas.closest('a-scene')) {
                                }

                                if (canvas.closest('model-viewer')) {
                                }
                            }
                        } catch (error) {
                            console.warn(`‚ö†Ô∏è Error cleaning canvas ${index}:`, error.message);
                        }
                    });
                });

                // ‚úÖ STEP 2: TIPTAP EDITOR CLEANUP (TipTap compliant order)

                // ‚úÖ TIPTAP BEST PRACTICE: Use proper destruction method
                await this.documentManager.lifecycleManager.destroyEditors();

                // ‚úÖ STEP 3: Y.JS AND PROVIDER CLEANUP (TipTap compliant order)

                if (this.provider) {
                    this.provider.destroy();
                    this.provider = null;
                }

                if (this.indexeddbProvider) {
                    // ‚úÖ CRITICAL: Clear IndexedDB data before destroy to prevent document contamination
                    if (this.indexeddbProvider.clearData && typeof this.indexeddbProvider.clearData === 'function') {
                        await this.indexeddbProvider.clearData();
                    }
                    this.indexeddbProvider.destroy();
                    this.indexeddbProvider = null;
                }

                if (ydocService.isReady()) {
                    ydocService.destroy();
                    this.ydoc = null;
                }

                // ‚úÖ STEP 4: COMPONENT STATE RESET

                this.setCurrentFile(null);
                this.fileType = 'local';
                // isCollaborativeMode is now a computed property
                this.connectionStatus = 'disconnected';
                this.hasUnsavedChanges = false;
                this.hasUserIntent = false;
                this.isTemporaryDocument = false;
                this.hasIndexedDBPersistence = false;

                // ‚úÖ COMPLIANCE: No arbitrary delays - cleanup is synchronous

            } catch (error) {
                console.error('‚ùå Emergency WebGL cleanup failed:', error);
                // Even if cleanup fails, ensure component state is reset
                // titleEditor removed - using simple input field
                this._bodyEditor = null;
                // permlinkEditor removed - using simple input field
                this.provider = null;
                this.indexeddbProvider = null;
                this.ydoc = null;
            }
        },

        // ===== AUTO-CONNECT METHODS WITH SECURITY =====

        // Helper method to check for local copy of collaborative document
        async checkForLocalCollaborativeDocument(owner, permlink) {
            try {
                // Check IndexedDB for a local copy
                const documentId = `${owner}/${permlink}`;

                if (indexedDB.databases) {
                    const databases = await indexedDB.databases();
                    const localCopy = databases.find(db => db.name === documentId);

                    if (localCopy) {
                        return {
                            id: documentId,
                            name: documentId,
                            type: 'local',
                            owner: owner,
                            permlink: permlink,
                            isOfflineFirst: true,
                            hasLocalCopy: true
                        };
                    }
                }

                // Check localStorage for legacy local copy
                const localFiles = this.documentStorageService.getAllDocuments();
                const legacyCopy = localFiles.find(f =>
                    f.isCollaborative &&
                    f.owner === owner &&
                    f.permlink === permlink
                );

                if (legacyCopy) {
                    return {
                        ...legacyCopy,
                        hasLocalCopy: true
                    };
                }

                return null;
            } catch (error) {
                console.error('Error checking for local collaborative document:', error);
                return null;
            }
        },

        async autoConnectToLocalDocument(owner, permlink) {
            // ‚úÖ NULL SAFETY: Validate required parameters
            if (!owner || !permlink) {
                console.error('‚ùå autoConnectToLocalDocument: Missing required parameters', {
                    owner,
                    permlink,
                    hasOwner: !!owner,
                    hasPermlink: !!permlink
                });
                this.showError(`Cannot load local document: missing ${!owner ? 'owner' : 'document ID'}`);
                this.isLoadingDocument = false;
                return;
            }

            // Set loading flag to prevent user intent detection during load
            this.isLoadingDocument = true;

            try {
                // ‚úÖ AUTHENTICATION STATE CHECK: Wait for auth to load
                if (this.authLoading) {

                    // Store deferred connection for when auth loads
                    this.deferredLocalConnection = { owner, permlink };
                    this.showLoadingMessage = 'Checking authentication...';
                    this.loadingStates.auth = true;

                    // Create temporary document while waiting
                    await this.documentManager.newDocument();

                    return; // Exit early - will be handled by auth headers watcher
                }

                // ‚úÖ ACCESS CHECK: Verify user can access local documents
                if (!this.canAccessLocalDocuments) {
                    console.error('üö´ Cannot access local documents - auth is still loading');

                    // ‚úÖ FIX: Don't create new document - preserve URL for retry after authentication
                    this.connectionStatus = 'error';
                    this.connectionMessage = 'Authentication required for local document access.';
                    return;
                }

                // ‚úÖ SECURITY FIX: Handle authentication for local documents
                // If username is null (not authenticated), treat as guest user
                const currentUser = this.username === null ? 'guest' : this.username;

                // Check if local file requires authentication
                if (this.username === null && owner !== 'anonymous') {
                    console.error('üö´ Authentication required for local documents');
                    // ‚úÖ FIX: Don't create new document - preserve URL for retry after authentication
                    alert('Please log in to access local documents.');
                    this.connectionStatus = 'error';
                    this.connectionMessage = 'Authentication required to access this local document.';
                    return;
                }

                if (owner !== currentUser && owner !== 'anonymous') {
                    console.log('üö´ STREAMLINED: User boundary violation - using auth modal instead of legacy alert', {
                        urlOwner: owner,
                        currentUser: currentUser,
                        documentId: permlink
                    });
                    // ‚úÖ CONSISTENT AUTH FLOW: Use same authentication logic as collaborative documents
                    const documentContext = {
                        type: 'local',
                        owner: owner,
                        permlink: permlink
                    };
                    await this.handleDocumentAccessDenied(documentContext);
                    return; // Exit early - no document creation
                }

                // ‚úÖ OFFLINE-FIRST: Convert permlink back to original document ID format
                // Permlink format: local-1234-abc (with dashes for URL safety)
                // IndexedDB format: local_1234_abc (with underscores, original ID)
                const documentId = permlink.replace(/-/g, '_');

                // ‚úÖ CACHE-FIRST PATTERN: Check cache (IndexedDB) before permissions
                // This follows offline-first best practices - load from cache immediately
                const hasLocalCopy = await this.checkDocumentExistsInIndexedDB(documentId);

                if (!hasLocalCopy) {
                    console.warn('‚ö†Ô∏è No local copy found for document:', documentId);

                    // ‚úÖ FALLBACK: Try to find a similar document by timestamp
                    // Extract timestamp from the document ID (local_TIMESTAMP_random)
                    const timestampMatch = documentId.match(/local_(\d+)_/);
                    if (timestampMatch) {
                        const targetTimestamp = parseInt(timestampMatch[1]);
                        const searchWindow = 60000; // 1 minute window

                        // Check localStorage for documents created around the same time
                        const localFiles = this.documentStorageService.getAllDocuments();
                        const similarDoc = localFiles.find(file => {
                            const fileTimestampMatch = file.id.match(/local_(\d+)_/);
                            if (fileTimestampMatch) {
                                const fileTimestamp = parseInt(fileTimestampMatch[1]);
                                return Math.abs(fileTimestamp - targetTimestamp) < searchWindow;
                            }
                            return false;
                        });

                        if (similarDoc) {
                            // Load the similar document instead
                            await this.documentManager.loadDocument(similarDoc);
                            // Update URL with the correct ID
                            this.updateURLWithLocalParams(this.username, similarDoc.id.replace(/_/g, '-'));
                            return;
                        }
                    }

                    // ‚úÖ SMART FALLBACK: Check if this is a very recent document that might not be fully persisted yet
                    const isRecentDocument = this.isRecentTempDocument(documentId);

                    if (isRecentDocument) {

                        // Create the document as if it's new (it probably just wasn't fully saved)
                        const targetDocument = {
                            id: documentId,
                            name: documentId,
                            type: 'local',
                            isCollaborative: false,
                            owner: this.username,
                            created: new Date().toISOString(),
                            modified: new Date().toISOString(),
                            permlink: permlink,
                            owner: owner,
                            hasLocalVersion: false, // Mark as new
                            isOfflineFirst: true
                        };

                        await this.documentManager.loadDocument(targetDocument);
                        this.updateURLWithLocalParams(this.username, permlink);

                        return;
                    }

                    // ‚úÖ LOCAL DOCUMENT: If no local copy exists, the document is gone
                    // Local documents are NEVER stored in the cloud
                    console.error('‚ùå Local document not found in IndexedDB');
                    alert('Local document not found. It may have been deleted or the browser storage was cleared.');
                    this.clearLocalURLParams();
                    await this.documentManager.newDocument();
                    return;
                }

                // ‚úÖ CACHE-FIRST: Try to get document name from cache for instant display
                const cachedMetadata = await documentService.getDocumentMetadata(documentId);
                let documentName = cachedMetadata?.documentName;

                // If no cached name, extract from Y.js (this may take time)
                if (!documentName) {
                    documentName = await this.extractDocumentNameFromYjs(documentId) || documentId;
                    // Update the extracted name - caching handled internally
                    if (documentName && documentName !== documentId) {
                        documentService.updateDocumentMetadata(documentId, {
                            documentName,
                            timestamp: Date.now(),
                            documentId,
                            type: 'local'
                        });
                    }
                }

                // ‚úÖ STEP 2: Create file object and load document immediately (cache-first pattern)
                const targetDocument = {
                    id: documentId,
                    name: documentName,
                    type: 'local',
                    isCollaborative: false,
                    owner: this.username,
                    created: new Date().toISOString(),
                    modified: new Date().toISOString(),
                    permlink: permlink,
                    owner: owner,
                    hasLocalVersion: true,
                    isOfflineFirst: true
                };

                // ‚úÖ STEP 3: Load document directly using DocumentManager (cache-first)
                // This loads from IndexedDB immediately without checking permissions first

                await this.documentManager.loadDocument(targetDocument);

                // ‚úÖ STEP 4: Update URL to reflect current document
                this.updateURLWithLocalParams(this.username, permlink);

                // ‚úÖ STEP 5: Check permissions in background after loading (non-blocking)
                // This matches the pattern used for collaborative documents
                this.checkDocumentPermissionsFromYjs(documentId).then(permissions => {
                    if (!permissions.canRead) {
                        console.error('‚ùå Access denied after load:', permissions.reason);
                        // Handle permission denial after document is already loaded
                        this.handleDocumentAccessDenied();
                    } else {
                    }
                }).catch(error => {
                    console.warn('‚ö†Ô∏è Background permission check failed:', error);
                    // Continue with document - permissions can be checked later
                });

                // ‚úÖ STEP 6: Reset loading flag after successful load
                this.isLoadingFromURL = false;

                // Reset document loading flag after Y.js sync completes
                this.$nextTick(() => {
                    this.isLoadingDocument = false;

                    // ‚úÖ CLEAR AUTH BACKDROP: Clear pending access after successful local document load
                    const authBridge = this.authBridgeInstance;
                    if (authBridge) {
                        authBridge.clearPendingAccess('document-loaded');
                    }
                }, 1000);

            } catch (error) {
                console.error('‚ùå Failed to auto-connect to local document:', error);
                this.clearLocalURLParams();
                this.isLoadingDocument = false; // Reset flag on error
                throw error;
            }
        },

        async autoConnectToCollaborativeDocument(owner, permlink) {
            console.log('üî¥ CACHE-TEST: autoConnectToCollaborativeDocument called:', {
                owner,
                permlink,
                isAuthenticated: this.isAuthenticated,
                username: this.username
            });
            console.log('üîê OFFLINE-LOAD: autoConnectToCollaborativeDocument called:', {
                owner,
                permlink,
                isAuthenticated: this.isAuthenticated,
                username: this.username,
                hasAuthHeaders: this.isAuthenticated && !!this.authHeaders,
                authAccount: this.authStateManager.getAuthAccount(this.isAuthenticated ? this.authHeaders : null),
                currentFile: this.currentFile,
                timestamp: new Date().toISOString(),
                callStack: new Error().stack.split('\n').slice(1, 5).join('\n')
            });

            // ‚úÖ COORDINATION: Check if we're already loading this document
            const documentKey = `${owner}/${permlink}`;
            if (this.pendingDocumentLoad === documentKey) {
                console.log('üîÑ COORDINATION: Already loading this document, preventing duplicate load:', documentKey);
                return; // Prevent duplicate load
            }

            // ‚úÖ VALIDATION: Check for essential parameters to prevent corruption
            if (!owner || !permlink) {
                const error = new Error(`Invalid document parameters: owner="${owner}", permlink="${permlink}"`);
                console.error('‚ùå autoConnectToCollaborativeDocument validation failed:', {
                    owner,
                    permlink,
                    hasOwner: !!owner,
                    hasPermlink: !!permlink,
                    error: error.message
                });
                throw error;
            }

            // Set coordination flag
            this.pendingDocumentLoad = documentKey;

            // ‚úÖ AUTH STATE MANAGER: Use centralized access control if available
            if (this.authStateManager && window.USE_AUTH_STATE_MANAGER !== false) {
                console.log('üî¥ CACHE-TEST: AuthStateManager checking document access');
                console.log('üîê OFFLINE-LOAD: AuthStateManager checking document access for collaborative document');

                const access = await this.authStateManager.checkDocumentAccess(
                    { owner, permlink, type: 'collaborative' },
                    'url-load'
                );

                if (!access.hasAccess) {
                    // AuthStateManager already emitted accessDenied event
                    console.log('üîê AuthStateManager: Access denied for collaborative document');
                    this.isLoadingDocument = false;
                    this.pendingDocumentLoad = null; // Clear coordination flag
                    return; // Don't load document
                }

                // ‚úÖ OFFLINE-FIRST: Check if we're in offline mode with cached document
                if (access.isOfflineMode) {
                    console.log('üì± OFFLINE-FIRST: Loading document from IndexedDB cache in read-only mode', {
                        document: `${owner}/${permlink}`,
                        permissionLevel: access.permissionLevel,
                        reason: access.reason,
                        user: this.username
                    });
                    
                    // Set offline mode flag for UI indicators
                    this.isOfflineMode = true;
                    this.offlineModeReason = 'not-authenticated';
                    
                    // Show offline mode message
                    console.log('üî• CACHE-DEBUG: Setting connectionStatus to offline-cache', {
                        isOfflineMode: true,
                        reason: 'not-authenticated',
                        location: 'loadCollaborativeFromUrl'
                    });
                    this.connectionStatus = 'offline-cache';
                    this.connectionMessage = 'Loading from offline cache (read-only)';
                }

                // ‚úÖ TIMING: Wait for auth state to stabilize using nextTick
                if (this._processingUserChange || this._justAuthenticated) {
                    await this.$nextTick();
                    // If still processing, wait one more tick
                    if (this._processingUserChange) {
                        await this.$nextTick();
                    }
                }

                // Store the permission level for later use
                if (access.permissionLevel) {
                    // Permission caching is handled internally by getMasterPermissionForDocument
                    
                    console.log('üîê AuthStateManager: Cached permission level', {
                        document: `${owner}/${permlink}`,
                        permissionLevel: access.permissionLevel,
                        isReadOnly: this.isReadonlyPermission(access.permissionLevel),
                        isOfflineMode: access.isOfflineMode || false
                    });
                }

                console.log('üîê AuthStateManager: Access granted, proceeding with document load', {
                    isOfflineMode: access.isOfflineMode || false
                });
                // Continue with document loading below...
            }

            // ‚úÖ DEBUG CHECKPOINT 1: After AuthStateManager check

            // Set loading flag to prevent user intent detection during load
            this.isLoadingDocument = true;

            // Set initial connection status
            this.connectionStatus = 'connecting';

            // ‚úÖ DEBUG: Log authentication state before check

            // ‚úÖ AUTHENTICATION STATE CHECK: Wait for auth to load
            if (this.authLoading) {

                // Store deferred connection for when auth loads
                this.deferredCollabConnection = { owner, permlink };
                this.showLoadingMessage = 'Checking authentication...';
                this.loadingStates.auth = true;
                this.connectionStatus = 'auth-required';

                this.pendingDocumentLoad = null; // Clear coordination flag
                return;
            }

            // ‚úÖ DEBUG CHECKPOINT 2: After authentication state check

            // ‚úÖ DEBUG CHECKPOINT 3: Before canAccessCollaborativeDocuments check

            // ‚úÖ ACCESS CHECK: For URL-loaded documents, allow loading to proceed so permission system can trigger auth modal
            if (!this.canAccessCollaborativeDocuments) {
                console.warn('‚ö†Ô∏è AUTH DECISION POINT: Cannot access collaborative documents', {
                    document: `${owner}/${permlink}`,
                    isAuthenticated: this.isAuthenticated,
                    username: this.username,
                    isGuestUser: this.isGuestUser(),
                    timestamp: new Date().toISOString()
                });

                // For URL-loaded documents (from direct links), proceed with document loading
                // so the permission system can properly trigger the authentication modal
                const urlParams = new URLSearchParams(window.location.search);
                const isURLLoaded = urlParams.has('collab_owner') && urlParams.has('collab_permlink');

                if (isURLLoaded) {

                    // ‚úÖ AUTH CHECK: Ensure user is authenticated before any special URL handling
                    // This fixes the bypass where unauthenticated users could skip the auth modal
                    if (!this.isAuthenticated) {
                        console.log('üîê URL-loaded document requires authentication', {
                            document: `${owner}/${permlink}`,
                            username: this.username,
                            isGuestUser: this.isGuestUser()
                        });
                        
                        const documentContext = {
                            type: 'collaborative',
                            owner: owner,
                            permlink: permlink
                        };
                        
                        this.handleDocumentAccessDenied(documentContext);
                        this.pendingDocumentLoad = null; // Clear coordination flag
                        return;
                    }

                    // For authenticated URL-loaded documents, handle based on component readiness
                    if (!this.documentManager || !this.documentManager?.editorFactory) {

                        // ‚úÖ Store deferred connection for authenticated user
                        this.deferredCollabConnection = {
                            owner,
                            permlink,
                            needsAuth: false, // User is already authenticated
                            documentContext: {
                                type: 'collaborative',
                                owner: owner,
                                permlink: permlink
                            }
                        };
                        this.showLoadingMessage = 'Initializing editor...';
                        this.loadingStates.auth = true;
                        this.connectionStatus = 'initializing';
                        this.isLoadingFromURL = false;
                        this.showLoadingMessage = '';

                        // ‚úÖ TIMING FIX: Set up a polling mechanism to check for component manager readiness
                        // This handles the case where managers are initialized after deferred connection is set
                        const checkManagersReady = () => {

                            if (this.documentManager && this.documentManager.editorFactory && this.deferredCollabConnection) {

                                const { owner: deferredOwner, permlink: deferredPermlink, needsAuth, documentContext } = this.deferredCollabConnection;
                                this.deferredCollabConnection = null;
                                this.showLoadingMessage = '';
                                this.loadingStates.auth = false;

                                // Check if auth modal should be triggered
                                if (needsAuth && !this.isAuthenticated && documentContext) {
                                    this.handleDocumentAccessDenied(documentContext);
                                } else {
                                    this.isLoadingFromURL = true;
                                    this.autoConnectToCollaborativeDocument(deferredOwner, deferredPermlink).catch(error => {
                                        console.error('‚ùå Immediate deferred collaborative connection failed:', error);
                                        this.isLoadingFromURL = false;
                                        if (!this.currentFile) {
                                            this.documentManager.newDocument();
                                        }
                                    });
                                }
                                return true; // Managers are ready and connection processed
                            }
                            return false; // Managers not ready yet
                        };

                        // Use Vue's reactivity to wait for managers
                        this.$nextTick(async () => {
                            // Use MutationObserver to wait for managers to be ready
                            const waitForManagers = () => {
                                return new Promise((resolve) => {
                                    if (checkManagersReady()) {
                                        resolve();
                                        return;
                                    }
                                    
                                    // Watch for global object changes
                                    const checkInterval = requestAnimationFrame(function check() {
                                        if (checkManagersReady()) {
                                            resolve();
                                        } else {
                                            requestAnimationFrame(check);
                                        }
                                    });
                                });
                            };
                            
                            await waitForManagers();
                            
                            if (!checkManagersReady()) {
                                // The deferred connection will be processed when managers are ready
                            }
                        });

                        this.pendingDocumentLoad = null; // Clear coordination flag
                        return;
                    }

                    // ‚úÖ AUTH ALREADY VERIFIED: At this point, user is authenticated (checked at top of URL-loaded block)
                    // We can proceed directly to loading the document

                    // ‚úÖ FORCE USERNAME REFRESH: Ensure username is up-to-date before access check
                    if (this.authStateManager && this.authHeaders?.['x-account']) {
                        console.log('üîÑ AUTH SYNC: Forcing username sync before access check', {
                            currentUsername: this.username,
                            authHeadersAccount: this.authHeaders['x-account'],
                            authStateUser: this.authStateManager.getUser(),
                            needsUpdate: this.username !== this.authHeaders['x-account']
                        });
                        this.authStateManager.setUser(this.authHeaders['x-account']);
                    }
                    
                    } else {
                        // For other cases (programmatic access), use the traditional flow
                        if (!this.isAuthenticated) {
                            this.connectionStatus = 'auth-required';
                            this.requestAuthentication();
                        } else if (this.isAuthExpired) {
                            this.connectionStatus = 'auth-required';
                            // Use DLUXAuthBridge instead of showing error message
                            this.requestAuthentication();
                        } else {
                            this.connectionStatus = 'error';
                            // Use DLUXAuthBridge instead of showing error message
                            this.requestAuthentication();
                        }

                        this.isLoadingFromURL = false;
                        this.showLoadingMessage = '';
                        this.pendingDocumentLoad = null; // Clear coordination flag
                        return;
                    }
            }

            // ‚úÖ DEBUG CHECKPOINT 4: Before authentication & permission gate

            // ‚úÖ REMOVED REDUNDANT AUTH GATE: Authentication is already handled earlier via handleDocumentAccessDenied
            // The previous auth gate here was causing double modals and color inconsistencies

            // ‚úÖ DEBUG CHECKPOINT 5: Before permission gate

            // ‚úÖ PERMISSION GATE: Check if authenticated user has permission to access this document
            const hasPermission = this.checkDocumentPermissionsPreFlight({
                owner: owner,
                permlink: permlink,
                type: 'collaborative'
            });

            // ‚úÖ DEBUG CHECKPOINT 6: After permission check

            if (!hasPermission) {
                console.log('üö´ PERMISSION GATE: Authenticated user lacks permission for document', {
                    document: `${owner}/${permlink}`,
                    username: this.username,
                    isAuthenticated: this.isAuthenticated,
                    reason: 'no-permission-for-document',
                    isLoadingCollaborativeDocs: this.isLoadingCollaborativeDocs,
                    collaborativeDocsCount: this.collaborativeDocs?.length || 0
                });

                // Trigger access denial flow immediately to prevent document structure creation
                const documentContext = {
                    type: 'collaborative',
                    owner: owner,
                    permlink: permlink
                };

                // ‚úÖ FIX: Call directly without nextTick to ensure proper timing
                this.handleDocumentAccessDenied(documentContext);

                // Exit early - access denied flow will handle this
                return;
            }

            // ‚úÖ AUTHENTICATED & AUTHORIZED DOCUMENT LOADING: Only proceed after both authentication and permission validation
            console.log('üîê AUTH & PERMISSION GATE: Both authentication and permissions confirmed, proceeding with document creation', {
                document: `${owner}/${permlink}`,
                username: this.username,
                hasPermission: true
            });

            try {
                // ‚úÖ TIPTAP BEST PRACTICE: Use cached metadata for instant display
                const documentId = `${owner}/${permlink}`;
                const documentKey = `${owner}/${permlink}`;

                // ‚úÖ PERFORMANCE: Load cached metadata from DocumentService
                const cachedMetadata = await documentService.getDocumentMetadata(documentKey);

                // ‚úÖ FLASH FIX: Try to get real document name from collaborative docs API before creating document
                let displayName = cachedMetadata?.documentName;

                if (!displayName && this.isAuthenticated && !this.isAuthExpired) {
                    // ‚úÖ INSTANT LOAD: Get real document name from collaborative docs API
                    try {
                        const collabDocsResponse = await fetch('https://data.dlux.io/api/collaboration/documents', {
                            headers: this.getAuthHeadersForRequest()
                        });

                        if (collabDocsResponse.ok) {
                            const collabData = await collabDocsResponse.json();
                            const targetDoc = collabData.documents?.find(doc =>
                                doc.owner === owner && doc.permlink === permlink
                            );

                            if (targetDoc && targetDoc.documentName) {
                                displayName = targetDoc.documentName;

                                // Update document metadata - caching handled internally
                                documentService.updateDocumentMetadata(`${owner}/${permlink}`, {
                                    documentName: targetDoc.documentName,
                                    timestamp: Date.now(),
                                    owner,
                                    permlink
                                });
                                this.reactiveDocumentName = targetDoc.documentName;
                            }
                        }
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Failed to preload document name from API:', error.message);
                    }
                }

                // Final fallback if we still don't have a name
                if (!displayName) {
                    displayName = `Document ${permlink ? permlink.substring(0, 8) : 'unknown'}`;
                }

                // ‚úÖ TIPTAP COMPLIANT: Create proper document object

                // ‚úÖ OFFLINE-FIRST: Check for cached permission before creating document object
                let cachedPermission = null;
                cachedPermission = this.authStateManager.getCachedPermission(owner, permlink);
                
                if (cachedPermission) {
                    console.log('‚úÖ PERMISSION: Using cached permission from AuthStateManager', {
                        document: documentKey,
                        permission: cachedPermission
                    });
                } else {
                    console.log('‚ö†Ô∏è PERMISSION: No cached permission found for URL-loaded document', {
                        document: documentKey,
                        willCallGetMasterPermission: true
                    });
                }

                const localDocumentFile = {
                    id: documentId,
                    owner: owner,
                    permlink: permlink,
                    name: displayName, // Use cached name for instant display
                    documentName: displayName,
                    title: displayName,
                    type: 'collaborative',
                    created: new Date().toISOString(),
                    modified: new Date().toISOString(),
                    isCollaborative: true,
                    isOfflineFirst: true,
                    permissionLevel: cachedPermission, // Apply cached permission immediately
                    loadedFromURL: true, // ‚úÖ CONTEXT: Track that this document came from URL parameters
                    isURLLoaded: true    // ‚úÖ CONTEXT: Additional flag for permission system
                };

                if (cachedMetadata) {
                }

                // ‚úÖ TIPTAP BEST PRACTICE: Only verify permissions if we don't already have them
                if (this.isAuthenticated && !this.isAuthExpired && !cachedPermission) {
                    // We don't have cached permission, so load it in background
                    this.getMasterPermissionForDocument(localDocumentFile, true, 'url-refresh').then(permissionResult => {
                        if (permissionResult && this.permissionService.hasAccess(permissionResult.level)) {
                            // Permission caching is handled internally by getMasterPermissionForDocument
                            this.updateFilePermission(localDocumentFile, permissionResult.level);

                        } else if (permissionResult && permissionResult.level === 'no-access') {
                            // ‚úÖ PERMISSION DENIED: Trigger access denial flow
                            const documentContext = {
                                type: 'collaborative',
                                owner: owner,
                                permlink: permlink
                            };
                            // ‚úÖ FIX: Call directly without nextTick
                            this.handleDocumentAccessDenied(documentContext);
                        }
                    }).catch(error => {
                        console.warn('‚ö†Ô∏è Background permission loading failed:', error.message);
                        // Check if this is a permission-related error
                        if (error.message.includes('403') || error.message.includes('Forbidden') ||
                            error.message.includes('permission') || error.message.includes('access denied')) {
                            const documentContext = {
                                type: 'collaborative',
                                owner: owner,
                                permlink: permlink
                            };
                            // ‚úÖ FIX: Call directly without nextTick
                            this.handleDocumentAccessDenied(documentContext);
                        }
                    });
                } else {

                    // ‚úÖ REMOVED AUTO-AUTH: No longer automatically request authentication
                    // Users must manually authenticate when needed
                    if (this.isAuthenticated && this.authHeaders && this.isAuthExpired) {
                    }
                }

                // ‚úÖ AUTHENTICATED DOCUMENT LOADING: Document object created, now load it

                if (!this.documentManager) {
                    console.error('‚ùå CRITICAL: documentManager is not available!');
                    throw new Error('DocumentManager not initialized');
                }

                await this.documentManager.loadDocument(localDocumentFile);

                // ‚úÖ PHASE 2: BACKGROUND TASKS (non-blocking) - now that document is loaded

                // ‚úÖ PHASE 3: BACKGROUND SERVER METADATA FETCH (optional enhancement)

                this.fetchDocumentMetadataInBackground(owner, permlink).then(documentData => {
                    if (documentData && documentData.documentName) {
                        // Update document name from server metadata
                        this.updateDocumentNameFromServerMetadata(documentData.documentName);

                    }
                }).catch(error => {
                    console.warn('‚ö†Ô∏è Server metadata fetch failed (not critical):', error.message);
                });

                // Note: Tier 2 upgrade happens automatically in setupCloudPersistence when WebSocket connects

                // ‚úÖ STEP 5: Reset loading flag after successful load
                this.isLoadingFromURL = false;

                // Reset document loading flag after Y.js sync completes
                this.$nextTick(() => {
                    this.isLoadingDocument = false;
                    this.pendingDocumentLoad = null; // Clear coordination flag on success

                    // ‚úÖ CLEAR AUTH BACKDROP: Clear pending access after successful collaborative document load
                    const authBridge = this.authBridgeInstance;
                    if (authBridge) {
                        authBridge.clearPendingAccess('document-loaded');
                    }
                }, 1000);

            } catch (error) {
                console.error('‚ùå Failed to auto-connect to collaborative document:', error);

                // Reset connection status on error
                this.connectionStatus = 'error';
                this.isLoadingFromURL = false;
                this.showLoadingMessage = '';
                this.isLoadingDocument = false; // Reset flag on error

                // ‚úÖ CHECK FOR PERMISSION ERRORS: Handle access denial before other error handling
                const status = error.response?.status;
                if (apiAuthErrorHandler.isAuthError(status)) {

                    // Handle through centralized error handler
                    const result = await apiAuthErrorHandler.handleAuthError(
                        status,
                        `collaboration/${owner}/${permlink}`,
                        null, // No retry for WebSocket connection
                        {
                            context: {
                                type: 'collaborative',
                                owner: owner,
                                permlink: permlink
                            }
                        }
                    );

                    // If it's a permission error, trigger access denial flow
                    if (result.isPermissionError) {
                        const documentContext = {
                            type: 'collaborative',
                            owner: owner,
                            permlink: permlink
                        };
                        // ‚úÖ FIX: Call directly without nextTick
                        this.handleDocumentAccessDenied(documentContext);
                    }
                    this.pendingDocumentLoad = null; // Clear coordination flag
                    return; // Don't throw error for auth issues - handled by error handler
                }

                // ‚úÖ SMART ERROR HANDLING: Only clear URL for invalid documents, not authentication-related errors
                const isTemporaryError = error.message.includes('fetch') ||
                    error.message.includes('network') ||
                    error.message.includes('timeout') ||
                    error.message.includes('authentication') ||
                    error.message.includes('updateReactiveDocumentName is not a function') ||
                    error.message.includes('not a function');

                // ‚úÖ AUTHENTICATION FLOW PRESERVATION: Don't clear URL for authentication-related errors
                const isAuthenticationError = error.message.includes('Y.js document is destroyed') ||
                    error.message.includes('will retry after login') ||
                    error.message.includes('during authentication') ||
                    error.message.includes('permission') ||
                    error.message.includes('access denied') ||
                    error.message.includes('Forbidden') ||
                    error.message.includes('403') ||
                    error.message.includes('auth');

                if (!isTemporaryError && !isAuthenticationError) {
                    // Only clear URL for truly permanent errors (invalid document, etc.)
                    console.warn('üîó Clearing URL parameters due to permanent error:', error.message);
                    this.clearCollabURLParams();
                } else {
                    // Keep URL for temporary errors and authentication flows - user can refresh to retry
                    const reason = isAuthenticationError ? 'authentication-related error' : 'temporary error';
                    console.log(`üîó Preserving URL parameters - ${reason}, user can authenticate or refresh to retry`);
                }

                this.pendingDocumentLoad = null; // Clear coordination flag
                throw error;
            }
        },

        // ‚úÖ NEW: Background server metadata fetch (non-blocking)
        async fetchDocumentMetadataInBackground(owner, permlink) {
            try {
                // ‚úÖ AUTHENTICATION: Include auth headers for collaborative document metadata
                const headers = this.isAuthenticated && !this.isAuthExpired ? this.getAuthHeadersForRequest() : {};

                const response = await fetch(`https://data.dlux.io/api/collaboration/info/${owner}/${permlink}`, {
                    headers: {
                        ...headers,
                        'Connection': 'close'  // Prevent connection reuse to avoid ERR_CONNECTION_CLOSED
                    }
                });

                if (response.ok) {
                    const documentData = await response.json();

                    // ‚úÖ OFFLINE-FIRST: Extract and cache permission from document metadata if available
                    if (documentData && documentData.accessType && this.currentFile) {

                        // Permission caching is handled internally by getMasterPermissionForDocument
                        this.updateFilePermission(this.currentFile, documentData.accessType);

                        // Force UI reactivity update
                        this.$nextTick(() => {
                            // Permission caching is handled internally by getMasterPermissionForDocument

                            // Force editor to update its editable state if needed
                            if (this.bodyEditor) {
                                const shouldBeEditable = this.canEditWithPermission(documentData.accessType);
                                if (this.bodyEditor.isEditable !== shouldBeEditable) {
                                    this.bodyEditor.setEditable(shouldBeEditable);
                                }
                            }
                        });
                    }

                    return documentData;
                } else {
                    console.warn('‚ö†Ô∏è Server returned:', response.status, response.statusText);
                    return null;
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Server metadata fetch error:', error.message);
                return null;
            }
        },

        // ‚úÖ NEW: Update document name from server metadata
        updateDocumentNameFromServerMetadata(serverDocumentName) {
            try {
                // Update Y.js config with server document name
                if (ydocService.isReady() && serverDocumentName) {
                    // ‚úÖ GOLDEN RULE #2: Use YDocService for Y.js operations
                    const currentName = ydocService.getConfig('documentName');

                    // Check if the server name is generic or a fallback
                    const isServerNameFallback = serverDocumentName.includes('/');
                    const isServerNameGeneric = serverDocumentName.startsWith('Untitled') ||
                        serverDocumentName === 'New Document' ||
                        serverDocumentName.includes('Untitled -');

                    // Check if we have a user-set name in Y.js
                    const hasUserSetName = currentName &&
                        currentName.trim() !== '' &&
                        !currentName.startsWith('Untitled') &&
                        currentName !== 'New Document';

                    // Only update if different and not replacing a user-set name with a generic one
                    const shouldUpdate = currentName !== serverDocumentName &&
                        !isServerNameFallback &&
                        (!isServerNameGeneric || !hasUserSetName);

                    if (shouldUpdate) {
                        // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                        this.batchUpdateYjsConfig({
                            documentName: serverDocumentName,
                            lastServerSync: new Date().toISOString()
                        }, 'server-sync');

                        // ‚úÖ REACTIVITY FIX: Update reactive property for Vue
                        this.updateReactiveDocumentName(serverDocumentName);

                        // Update component state immediately
                        if (this.currentFile) {

                            this.currentFile.name = serverDocumentName;
                            this.currentFile.documentName = serverDocumentName;
                            this.currentFile.title = serverDocumentName;

                            // ‚úÖ CACHE: Update metadata with server name - caching handled internally
                            documentService.updateDocumentMetadata(`${this.currentFile.owner}/${this.currentFile.permlink}`, {
                                documentName: serverDocumentName,
                                timestamp: Date.now(),
                                owner: this.currentFile.owner,
                                permlink: this.currentFile.permlink
                            });

                            // ‚úÖ Vue reactivity handles updates automatically via data binding

                        }

                    } else {
                        // Log why we're not updating
                        let skipReason = 'unknown';
                        if (currentName === serverDocumentName) {
                            skipReason = 'name-already-matches';
                        } else if (isServerNameFallback) {
                            skipReason = 'server-name-is-fallback';
                        } else if (isServerNameGeneric && hasUserSetName) {
                            skipReason = 'preserving-user-set-name';
                        }

                    }
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to update document name from server:', error);
            }
        },

        // ===== DOCUMENT KEY GENERATION =====
        // Helper method to generate unique document key for merging local/cloud versions
        getDocumentKey(file) {
            // Document key generation - removed verbose logging for performance

            // ‚úÖ TIPTAP.DEV UNIFIED ARCHITECTURE: Use consistent document ID pattern

            // PRIORITY 1: For truly collaborative documents, use owner/permlink
            // ‚úÖ FIX: Check type/isCollaborative flag, not just owner/permlink presence
            if ((file.type === 'collaborative' || file.isCollaborative) && file.owner && file.permlink) {
                const key = `${file.owner}/${file.permlink}`;
                return key;
            }

            // PRIORITY 2: For linked local documents (have collaborative metadata but are still local)
            if (file.type === 'local' && file.collaborativeOwner && file.collaborativePermlink) {
                // Use the collaborative key for linked documents to prevent duplicates
                const key = `${file.collaborativeOwner}/${file.collaborativePermlink}`;
                return key;
            }

            // PRIORITY 3: For documents with owner/permlink but no explicit type
            // (backwards compatibility - assume collaborative)
            if (!file.type && file.owner && file.permlink) {
                const key = `${file.owner}/${file.permlink}`;
                return key;
            }

            // PRIORITY 2: For local documents that have been converted to collaborative
            if (file.collaborativeId) {
                return file.collaborativeId;
            }

            // PRIORITY 3: For local documents with collaborative ID pattern (converted documents)
            const localKey = file.id || file.name || file.documentName || file.filename;
            if (localKey && localKey.includes('/') && localKey.split('/').length === 2 && file.isCollaborative) {
                return localKey;
            }

            // PRIORITY 4: For pure local documents, prefix to avoid conflicts with collaborative pattern
            const prefixedKey = `local:${localKey}`;
            return prefixedKey;
        },

        // ===== STATUS HELPERS =====
        // Get local document status - TipTap.dev offline-first pattern
        getLocalStatus(file) {
            if (!file) return 'none';

            const documentKey = this.getDocumentKey(file);

            // ‚úÖ COLLABORATIVE FIX: Collaborative documents can have local cache (IndexedDB)
            // Don't exclude them from local status - they use offline-first architecture
            // The local status shows if they're cached in IndexedDB for offline access

            // For local documents (localStorage), they always have local status
            if (file.id && !file.owner) {
                // This is a localStorage document
                if (this.hasUnsavedChanges && this.isCurrentDocument(file)) {
                    return 'saving'; // Orange - has unsaved changes
                }
                return 'saved'; // Blue - saved locally
            }

            // For cloud documents, check if they're cached in IndexedDB (offline-first pattern)
            // ‚úÖ FIX: Check for collaborative type/flag, not just owner/permlink
            if ((file.type === 'collaborative' || file.isCollaborative) && file.owner && file.permlink) {
                // Checking local cache for cloud document - removed verbose logging

                // Check if this cloud document is cached locally in IndexedDB
                if (this.indexedDBDocuments && this.indexedDBDocuments.has(documentKey)) {
                    // Check if currently saving
                    if (this.hasUnsavedChanges && this.isCurrentDocument(file)) {
                        return 'saving'; // Orange - has unsaved changes
                    }
                    return 'saved'; // Blue - cached locally in IndexedDB
                }

                return 'none'; // Cloud document not cached locally yet
            }

            return 'none'; // Unknown document type
        },

        // Get cloud document status  
        getCloudStatus(cloudFile) {
            if (!cloudFile) return 'none';

            // ‚úÖ FIXED: Determine cloud status based on document properties and authentication
            // Check if this is a collaborative document (has owner/permlink OR type is collaborative)
            const isCollaborativeDoc = (cloudFile.isCollaborative || cloudFile.type === 'collaborative') && cloudFile.owner && cloudFile.permlink;

            // Cloud status calculation - removed verbose logging for performance

            if (!isCollaborativeDoc) return 'none';

            // Check if user is authenticated (required for cloud features)
            if (!this.isAuthenticated || this.isAuthExpired) {
                return 'available'; // Gray - collaborative document but user not authenticated
            }

            // Check if this is the currently open document to determine connection status
            const isCurrentDoc = this.isCurrentDocument(cloudFile);

            if (isCurrentDoc) {
                // For currently open document, check WebSocket connection status
                if (this.provider && this.connectionStatus === 'connected') {
                    return 'synced'; // Green - synced to cloud
                } else if (this.provider && this.connectionStatus === 'connecting') {
                    return 'syncing'; // Yellow - syncing to cloud
                } else if (this.hasUnsavedChanges) {
                    return 'pending'; // Orange - has unsynced changes
                }
                return 'available'; // Gray - collaborative but not connected
            } else {
                // For non-current documents, show as available if user can access them
                // ‚úÖ UNIFIED: Use getUserPermissionLevel for access check
                const permissionLevel = this.getUserPermissionLevel(cloudFile);
                const canAccess = this.permissionService.hasAccess(permissionLevel);

                return canAccess ? 'available' : 'available'; // Gray - available in cloud
            }
        },

        // ‚úÖ TIPTAP ENHANCED: Comprehensive sync status for unified document list
        getSyncStatus(localFile, cloudFile) {
            if (!localFile && !cloudFile) return 'none';

            // For documents with both local and cloud versions
            if (localFile && cloudFile) {
                const localModified = new Date(localFile.lastModified || localFile.modified || 0);
                const cloudModified = new Date(cloudFile.updatedAt || cloudFile.lastModified || 0);

                // Compare timestamps to determine sync status

                // Check if currently open document to determine real-time sync status
                const isCurrentDoc = this.isCurrentDocument(localFile) || this.isCurrentDocument(cloudFile);

                if (isCurrentDoc && this.provider && this.connectionStatus === 'connected') {
                    if (this.hasUnsavedChanges) {
                        return 'syncing'; // Orange - currently syncing changes
                    }
                    return 'synced'; // Green - all changes synced
                }

                // For non-current documents, show as synced unless there's a significant difference
                if (Math.abs(localModified - cloudModified) < 60000) { // Within 1 minute
                    return 'synced'; // Green - timestamps close enough, consider synced
                } else if (localModified > cloudModified) {
                    return 'local-newer'; // Orange - local has newer changes (needs upload)
                } else {
                    // ‚úÖ FIX: For non-current documents, don't show as actively syncing
                    // Show as available for sync instead of actively syncing
                    return 'cloud-newer'; // Gray - cloud has newer changes (available for download)
                }
            }

            // For cloud-only documents
            if (!localFile && cloudFile) {
                return 'cloud-only'; // Gray - available for download
            }

            // For local-only documents
            if (localFile && !cloudFile) {
                return 'local-only'; // Gray - available for upload
            }

            return 'unknown';
        },

        // ‚úÖ TIPTAP ENHANCED: Status title helpers for tooltips
        getLocalStatusTitle(status) {
            switch (status) {
                case 'saved': return 'Saved locally in browser storage';
                case 'saving': return 'Saving changes to browser storage...';
                case 'none': return 'Not cached locally';
                default: return 'Local status unknown';
            }
        },

        getCloudStatusTitle(status) {
            switch (status) {
                case 'synced': return 'Synced to cloud and up to date';
                case 'syncing': return 'Syncing changes to cloud...';
                case 'pending': return 'Has changes not yet synced to cloud';
                case 'available': return 'Collaborative document - click to connect to cloud';
                case 'none': return 'Not a collaborative document';
                default: return 'Cloud status unknown';
            }
        },

        getSyncStatusTitle(status) {
            switch (status) {
                case 'synced': return 'Local and cloud versions are synchronized';
                case 'syncing': return 'Synchronizing changes between local and cloud';
                case 'local-newer': return 'Local version has newer changes - click to upload';
                case 'cloud-newer': return 'Cloud version has newer changes - click to download';
                case 'cloud-only': return 'Available in cloud - click to download';
                case 'local-only': return 'Local document - click to upload to cloud';
                case 'none': return 'No synchronization available';
                default: return 'Sync status unknown';
            }
        },

        // ‚úÖ TIPTAP ENHANCED: Status class helpers for styling
        getLocalStatusClass(status) {
            switch (status) {
                case 'saved': return 'text-primary'; // Blue - saved locally
                case 'saving': return 'text-warning'; // Orange - saving changes
                case 'none': return 'opacity-25'; // Faded - not available
                default: return 'text-muted';
            }
        },

        getCloudStatusClass(status) {
            switch (status) {
                case 'synced': return 'text-success'; // Green - synced to cloud
                case 'syncing': return 'text-info'; // Blue - syncing to cloud
                case 'pending': return 'text-warning'; // Orange - has unsynced changes
                case 'available': return 'text-secondary'; // Gray - available but not connected
                case 'none': return 'opacity-25'; // Faded - not available
                default: return 'text-muted';
            }
        },

        getSyncStatusClass(status) {
            switch (status) {
                case 'synced': return 'text-success'; // Green - synchronized
                case 'syncing': return 'text-info'; // Blue - syncing
                case 'local-newer': return 'text-warning'; // Orange - local changes to upload
                case 'cloud-newer': return 'text-secondary'; // Gray - cloud changes available to download
                case 'cloud-only': return 'text-secondary'; // Gray - available for download
                case 'local-only': return 'text-secondary'; // Gray - available for upload
                case 'none': return 'opacity-25'; // Faded - no sync available
                default: return 'text-muted';
            }
        },

        // Helper method to check if a file is the currently open document
        isCurrentDocument(file) {
            if (!this.currentFile || !file) return false;

            // For collaborative documents, compare owner/permlink
            // ‚úÖ FIX: Check type/flag to properly identify collaborative documents
            const isCollabFile = (file.type === 'collaborative' || file.isCollaborative) && file.owner && file.permlink;
            const isCurrentCollabFile = (this.currentFile.type === 'collaborative' || this.currentFile.isCollaborative) && this.currentFile.owner && this.currentFile.permlink;

            if (isCollabFile && isCurrentCollabFile) {
                // ‚úÖ UNIFIED: Use helper for document matching
                return this.isDocumentMatch(file, this.currentFile);
            }

            // For local documents, compare IDs
            return file.id === this.currentFile.id;
        },

        // ===== URL MANAGEMENT =====
        // ‚úÖ TIPTAP BEST PRACTICE: All documents should have URL parameters for shareability

        updateURLWithCollabParams(owner, permlink) {
            const url = new URL(window.location);

            // ‚úÖ CRITICAL: Clear any local parameters first to prevent stacking
            url.searchParams.delete('local_owner');
            url.searchParams.delete('local_permlink');

            // Set collaborative parameters
            url.searchParams.set('collab_owner', owner);
            url.searchParams.set('collab_permlink', permlink);

            // Update URL without triggering a page reload
            window.history.replaceState({}, '', url.toString());

        },

        // ‚úÖ UNIFIED: Update URL with local document params (same pattern as collaborative)
        updateURLWithLocalParams(username, permlink) {
            const url = new URL(window.location);

            // Clear any collaborative parameters first
            url.searchParams.delete('collab_owner');
            url.searchParams.delete('collab_permlink');

            // Set local document parameters (same pattern as collaborative)
            url.searchParams.set('local_owner', username);
            url.searchParams.set('local_permlink', permlink);

            // Update URL without triggering a page reload
            window.history.replaceState({}, '', url.toString());

        },

        // Clear all document URL parameters (collaborative and local)
        clearAllURLParams() {
            const url = new URL(window.location);

            // Remove all document parameters (collaborative and local)
            url.searchParams.delete('collab_owner');
            url.searchParams.delete('collab_permlink');
            url.searchParams.delete('local_owner');
            url.searchParams.delete('local_permlink');

            // Update URL without triggering a page reload
            window.history.replaceState({}, '', url.toString());

        },

        // Clear only collaborative URL parameters
        clearCollabURLParams() {
            console.trace();

            const url = new URL(window.location);

            // Remove only collaborative parameters
            url.searchParams.delete('collab_owner');
            url.searchParams.delete('collab_permlink');

            // Update URL without triggering a page reload
            window.history.replaceState({}, '', url.toString());

        },

        // Clear only local document URL parameters
        clearLocalURLParams() {
            const url = new URL(window.location);

            // Remove only local document parameters
            url.searchParams.delete('local_owner');
            url.searchParams.delete('local_permlink');

            // Update URL without triggering a page reload
            window.history.replaceState({}, '', url.toString());

        },

        // Generate shareable URL for current document
        generateShareableURL() {
            if (!this.currentFile) {
                return null;
            }

            const baseUrl = window.location.origin + window.location.pathname;
            const params = new URLSearchParams();

            if (this.currentFile.type === 'collaborative' && this.currentFile.owner && this.currentFile.permlink) {
                params.set('collab_owner', this.currentFile.owner);
                params.set('collab_permlink', this.currentFile.permlink);
            } else if (this.currentFile.type === 'local' && this.currentFile.id) {
                params.set('local_owner', this.username);
                params.set('local_permlink', this.currentFile.id);
            }

            return `${baseUrl}?${params.toString()}`;
        },

        /**
         * ‚úÖ PERMISSION FALLBACK: Extract permission level from URL parameters
         * @param {Object} file - File object to check permissions for
         * @returns {string} Permission level from URL or 'unknown' if none found
         */
        getPermissionFromURLParams(_file) {
            // ‚úÖ CONSOLIDATED: Use PermissionService for URL parameter hints
            try {
                const urlParams = new URLSearchParams(window.location.search);
                return this.permissionService.getPermissionHintFromURL(urlParams);
            } catch (error) {
                console.warn('Failed to parse URL parameters:', error);
                return null;
            }
        },

        // Original implementation kept for reference
        _getPermissionFromURLParams_OLD(file) {
            try {
                const urlParams = new URLSearchParams(window.location.search);

                // 1. Check for explicit permission parameter
                const explicitPermission = urlParams.get('permission') || urlParams.get('perm') || urlParams.get('access_level');
                if (explicitPermission) {
                    if (VALID_PERMISSION_LEVELS.includes(explicitPermission)) {
                        return explicitPermission;
                    }
                }

                // 2. Check for readonly flag (common in shared links)
                const isReadonlyFlag = urlParams.get('readonly') === 'true' ||
                    urlParams.get('ro') === 'true' ||
                    urlParams.get('view') === 'readonly';
                if (isReadonlyFlag) {
                    return this.getDefaultPermissionLevel();
                }

                // 3. Check for editor invitation flag
                const isEditorInvite = urlParams.get('editor') === 'true' ||
                    urlParams.get('edit') === 'true' ||
                    urlParams.get('invite') === 'editor';
                if (isEditorInvite) {
                    return 'editable';
                }

                // 4. Check for context-specific parameters for current document
                if (file && file.owner && file.permlink) {
                    const currentDocOwner = urlParams.get('collab_owner');
                    const currentDocPermlink = urlParams.get('collab_permlink');

                    // Only apply URL permission if URL matches current document
                    if (currentDocOwner === file.owner && currentDocPermlink === file.permlink) {

                        // Check for shared view parameters
                        const sharedView = urlParams.get('shared') || urlParams.get('public');
                        if (sharedView === this.getDefaultPermissionLevel() || sharedView === 'view') {
                            return this.getDefaultPermissionLevel();
                        }

                        // Check for invite context
                        const inviteType = urlParams.get('invite_type') || urlParams.get('invitation');
                        if (inviteType === 'editor' || inviteType === 'editable') {
                            return 'editable';
                        }
                        if (inviteType === 'viewer' || inviteType === 'readonly') {
                            return 'readonly';
                        }
                    }
                }

                // 5. Check for permission hints based on referrer or source
                const source = urlParams.get('source') || urlParams.get('from');
                if (source) {
                    // Shared links from social media often default to readonly
                    if (source.includes('share') || source.includes('social')) {
                        return 'readonly';
                    }
                    // Direct invites might suggest editor access
                    if (source.includes('invite') || source.includes('collab')) {
                        return 'editable';
                    }
                }

                return 'unknown';

            } catch (error) {
                console.warn('‚ö†Ô∏è Error extracting permission from URL parameters:', error);
                return 'unknown';
            }
        },

        /**
         * ‚úÖ COMPREHENSIVE ERROR RECOVERY: Recover from API endpoint failures with retry and fallback strategies
         * @param {string} operation - Name of the operation for logging
         * @param {Object} config - Request configuration and fallback options
         * @returns {*} Recovered data or null if all recovery attempts fail
         */
        async recoverFromAPIFailure(operation, config) {
            const { url, method = 'GET', headers = {}, cachedData, documentKey, error } = config;

            console.log(`üîÑ API RECOVERY: Starting recovery for ${operation}`, {
                originalError: error.message,
                url,
                hasCache: !!cachedData,
                documentKey
            });

            // 1. Determine if error is retryable
            const isRetryable = this.isRetryableError(error);

            if (isRetryable) {
                console.log(`üîÑ API RECOVERY: Attempting retries for ${operation}`);

                // 2. Retry with exponential backoff
                const retryResult = await this.retryWithBackoff(url, method, headers, operation);
                if (retryResult) {
                    console.log(`‚úÖ API RECOVERY: Retry successful for ${operation}`);
                    return retryResult;
                }
            }

            // 3. Try alternative endpoints if available
            const alternativeResult = await this.tryAlternativeEndpoints(operation, config);
            if (alternativeResult) {
                console.log(`‚úÖ API RECOVERY: Alternative endpoint successful for ${operation}`);
                return alternativeResult;
            }

            // 4. Use cached data if available
            if (cachedData) {
                console.log(`üì± API RECOVERY: Using cached data for ${operation}`);
                return cachedData;
            }

            // 5. Provide minimal fallback data
            const fallbackData = this.generateFallbackData(operation, config);
            if (fallbackData) {
                console.log(`üîß API RECOVERY: Using fallback data for ${operation}`);
                return fallbackData;
            }

            console.error(`‚ùå API RECOVERY: All recovery attempts failed for ${operation}`);
            return null;
        },

        /**
         * ‚úÖ ERROR CLASSIFICATION: Determine if an error is worth retrying
         */
        isRetryableError(error) {
            // Network errors (timeout, connection refused, etc.)
            if (!error.response && (error.code === 'NETWORK_ERROR' || error.message.includes('fetch'))) {
                return true;
            }

            // Server errors (5xx)
            if (error.response && error.response.status >= 500) {
                return true;
            }

            // Rate limiting (429)
            if (error.response && error.response.status === 429) {
                return true;
            }

            // Temporary service unavailable (503)
            if (error.response && error.response.status === 503) {
                return true;
            }

            // Auth errors (401) - might be resolved with fresh tokens
            if (error.response && error.response.status === 401) {
                return true;
            }

            return false;
        },

        /**
         * ‚úÖ CENTRALIZED API ERROR HANDLER: Handle auth errors through ApiAuthErrorHandler service
         * @param {Error} error - API error object
         * @param {Object} context - Context about the API call
         * @returns {Promise<boolean>} true if error was handled
         */
        async handleApiAuthError(error, context = {}) {
            // Check if this is an auth error
            const status = error.response?.status || error.status;
            if (!apiAuthErrorHandler.isAuthError(status)) {
                return false; // Not an auth error
            }

            // Build endpoint from context
            const endpoint = context.endpoint || context.operation || 'api-request';

            // Handle through centralized service
            const result = await apiAuthErrorHandler.handleAuthError(
                status,
                endpoint,
                context.retryCallback || null,
                {
                    context: {
                        operation: context.operation,
                        type: context.type || 'api-error',
                        owner: context.owner,
                        permlink: context.permlink,
                        documentInfo: context.documentInfo
                    },
                    isOwnerAction: context.isOwnerAction || false
                }
            );

            // Handle auth bridge integration if needed
            if (result.requiresAuth && this.authBridgeInstance) {
                const action = status === 401 ? 'authenticate' : 'switch_account';
                const documentInfo = context.documentInfo || {
                    name: context.operation || 'API Request',
                    type: context.type || 'api-error',
                    owner: context.owner,
                    permlink: context.permlink
                };
                this.authBridgeInstance.showAuthPrompt(action, documentInfo);
            }

            // Clear any cached data if needed (for backwards compatibility)
            if (status === 401 && context.clearCache) {
                if (context.cacheKey === 'collaborativeDocs') {
                    this.clearCollaborativeDocs();
                }
            }

            return true; // Error was handled
        },

        /**
         * ‚úÖ RETRY MECHANISM: Retry API calls with exponential backoff
         */
        async retryWithBackoff(url, method, headers, operation, maxRetries = 3) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    // Calculate delay: 1s, 2s, 4s
                    const delay = Math.pow(2, attempt - 1) * 1000;

                    if (attempt > 1) {
                        console.log(`‚è≥ API RECOVERY: Waiting ${delay}ms before retry ${attempt}/${maxRetries} for ${operation}`);
                        // Use requestAnimationFrame for delay (Rule 6 compliant)
                        await new Promise(resolve => {
                            const frames = Math.ceil(delay / 16); // Convert ms to frames at 60fps
                            let frameCount = 0;
                            const tick = () => {
                                if (++frameCount >= frames) {
                                    resolve();
                                } else {
                                    requestAnimationFrame(tick);
                                }
                            };
                            requestAnimationFrame(tick);
                        });

                        // Request fresh auth headers for auth-related retries
                        if (this.authStateManager.getAuthAccount(headers)) {
                            const authBridge = this.authBridgeInstance;
                            if (authBridge) {
                                // Don't show modal, just request headers refresh
                                authBridge.hideAuthPrompt(); // Clear any existing modal
                                // For silent refresh, we still emit to parent
                                // Use authBridge for silent authentication refresh
                                this.authBridgeInstance.showAuthPrompt('authenticate', {
                                    name: 'API Access',
                                    reason: 'Authentication expired, please refresh'
                                });
                            } else {
                                // Use authBridge for silent authentication refresh
                                this.authBridgeInstance.showAuthPrompt('authenticate', {
                                    name: 'API Access',
                                    reason: 'Authentication expired, please refresh'
                                });
                            }
                            // ‚úÖ ARCHITECTURE RULE 6: Use requestAnimationFrame instead of setTimeout
                            await new Promise(resolve => {
                                const frames = Math.ceil(500 / 16); // ~31 frames for 500ms at 60fps
                                let frameCount = 0;
                                const frameTimeout = () => {
                                    if (++frameCount >= frames) {
                                        resolve();
                                    } else {
                                        requestAnimationFrame(frameTimeout);
                                    }
                                };
                                requestAnimationFrame(frameTimeout);
                            });
                        }
                    }

                    console.log(`üîÑ API RECOVERY: Retry attempt ${attempt}/${maxRetries} for ${operation}`);

                    const response = await fetch(url, {
                        method,
                        headers: {
                            ...headers,
                            ...this.getAuthHeadersForRequest() // Use fresh headers if available
                        }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        console.log(`‚úÖ API RECOVERY: Retry ${attempt} successful for ${operation}`);
                        return data.document || data;
                    } else {
                        console.warn(`‚ö†Ô∏è API RECOVERY: Retry ${attempt} failed with status ${response.status} for ${operation}`);
                        if (attempt === maxRetries) {
                            throw new Error(`Max retries reached: ${response.status} ${response.statusText}`);
                        }
                    }
                } catch (error) {
                    console.warn(`‚ö†Ô∏è API RECOVERY: Retry ${attempt} error for ${operation}:`, error.message);
                    if (attempt === maxRetries) {
                        throw error;
                    }
                }
            }

            return null;
        },

        /**
         * ‚úÖ ALTERNATIVE ENDPOINTS: Try backup endpoints when primary fails
         */
        async tryAlternativeEndpoints(operation, config) {
            const { documentKey } = config;

            // For collaboration info, try different API endpoints
            if (operation === 'loadCollaborationInfo' && documentKey) {
                const alternatives = [
                    `https://data.dlux.io/api/collaboration/documents/${documentKey}`,
                    `https://data.dlux.io/api/documents/${documentKey}/info`,
                    `https://data.dlux.io/api/v2/collaboration/info/${documentKey}`
                ];

                for (const altUrl of alternatives) {
                    try {
                        console.log(`üîÑ API RECOVERY: Trying alternative endpoint: ${altUrl}`);

                        const response = await fetch(altUrl, {
                            method: 'GET',
                            headers: {
                                'Content-Type': 'application/json',
                                ...this.getAuthHeadersForRequest()
                            }
                        });

                        if (response.ok) {
                            const data = await response.json();
                            console.log(`‚úÖ API RECOVERY: Alternative endpoint successful: ${altUrl}`);
                            return data.document || data;
                        }
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è API RECOVERY: Alternative endpoint failed: ${altUrl}`, error.message);
                    }
                }
            }

            return null;
        },

        /**
         * ‚úÖ FALLBACK DATA: Generate minimal functional data when all else fails
         */
        generateFallbackData(operation, config) {
            const { documentKey } = config;

            if (operation === 'loadCollaborationInfo' && documentKey) {
                // Provide basic document structure from URL/current file
                if (this.currentFile) {
                    return {
                        owner: this.currentFile.owner,
                        permlink: this.currentFile.permlink,
                        title: this.currentFile.title || 'Untitled Document',
                        accessType: 'readonly', // Conservative fallback
                        lastModified: new Date().toISOString(),
                        source: 'fallback-generated',
                        warning: 'API unavailable - using fallback data'
                    };
                }
            }

            return null;
        },

        // ===== DOCUMENT OPERATIONS =====

        async loadDocument(file) {

            // ‚è±Ô∏è AUTH SEQUENCE: Start tracking if loading collaborative document
            if (file && file.type === 'collaborative') {
                this.startAuthSequence(`load-${file.owner}/${file.permlink}`);
            }

            // üèÅ RACE DEBUG: Log state before permission check
            const accessStartTime = Date.now();

            this.logAuthSequenceEvent('before_access_check', {
                hasAuthHeaders: !!this.authHeaders,
                username: this.username
            });

            // ‚úÖ SECURITY: Validate access before loading document
            const accessCheck = await this.validateDocumentAccess(file);

            // üèÅ RACE DEBUG: Log result after permission check

            this.logAuthSequenceEvent('after_access_check', {
                allowed: accessCheck.allowed,
                reason: accessCheck.reason
            });

            if (!accessCheck.allowed) {
                console.error('üö´ Access denied:', accessCheck.reason);
                this.endAuthSequence('access_denied');
                alert(`Access Denied: ${accessCheck.reason}\n\nYou do not have permission to view this document.`);
                return false;
            }

            const result = await this.documentManager.loadDocument(file);

            // ‚úÖ URL UPDATE: Set URL parameters for shareability and refresh persistence
            if (file && file.type === 'collaborative' && file.owner && file.permlink) {
                this.updateURLWithCollabParams(file.owner, file.permlink);
            }

            // ‚úÖ TIPTAP BEST PRACTICE: Force permission refresh for document access
            if (file && file.type === 'collaborative') {
                this.loadDocumentPermissions('document-access').then(() => {
                    // ‚úÖ FIX: Force Vue to re-evaluate computed properties
                    if (this.collaborativeDocs && this.collaborativeDocs.length > 0) {
                        this.$nextTick(() => {
                            // Permission caching is handled internally by getMasterPermissionForDocument
                        });
                    }
                }).catch(error => {
                    console.warn('‚ö†Ô∏è Background permission loading failed:', error.message);
                });
            }

            return result;
        },

        async loadLocalFile(file) {

            // ‚úÖ TIPTAP BEST PRACTICE: Clear collaborative params and set local params
            this.clearCollabURLParams();

            // ‚úÖ CRITICAL FIX: Ensure local files have correct type and collaborative flags
            const localFile = {
                ...file,
                type: 'local',
                isCollaborative: false
            };

            // ‚úÖ TIPTAP COMPLIANCE: Use documentManager for proper loading
            await this.documentManager.loadDocument(localFile);

            // ‚úÖ CRITICAL: Set local URL parameters for shareability and refresh persistence
            if (file && file.id) {
                this.updateURLWithLocalParams(this.username || 'anonymous', file.id);
            }
        },

        // ‚úÖ TIPTAP COMPLIANCE: Removed loadCollaborativeDocument method to prevent duplicate editor creation
        // All document loading now goes through documentManager.loadDocument for proper TipTap compliance

        // ===== CONTENT MANAGEMENT =====
        getCustomJson() {
            // ‚úÖ REACTIVE PATTERN: Return reactive property instead of direct Y.js access
            return this.reactiveCustomJson;
        },

        setCustomJsonField(key, value) {
            if (ydocService.isReady()) {
                // ‚úÖ GOLDEN RULE #2: Use YDocService for Y.js operations
                const customJson = ydocService.getMetadata('customJson') || {};
                customJson[key] = value;
                ydocService.updateMetadata('customJson', customJson, 'metadata-update');

                // ‚úÖ TIPTAP USER INTENT: Custom JSON field setting shows intent to create document
                if (this.isTemporaryDocument && !this.indexeddbProvider) {
                    this.debouncedCreateIndexedDBForTempDocument();
                }
            }
            this.reactiveCustomJson[key] = value;
            this.collaborativeDataVersion++;
        },

        removeCustomJsonField(key) {
            if (ydocService.isReady()) {
                // ‚úÖ GOLDEN RULE #2: Use YDocService for Y.js operations
                const customJson = ydocService.getMetadata('customJson') || {};
                delete customJson[key];
                ydocService.updateMetadata('customJson', customJson, 'metadata-update');

                // ‚úÖ TIPTAP USER INTENT: Custom JSON field removal shows intent to create document
                if (this.isTemporaryDocument && !this.indexeddbProvider) {
                    this.debouncedCreateIndexedDBForTempDocument();
                }
            }
            delete this.reactiveCustomJson[key];
            this.collaborativeDataVersion++;
        },

        // ===== EDITOR UTILITIES =====
        updateContent() {
            // ‚ùå VIOLATION REMOVED: No content syncing (violates TipTap best practices)
            // ‚úÖ CORRECT: Only emit metadata and flags to parent
            if (!window.editorEventBus) {
                window.editorEventBus = new EventTarget();
            }
            /**
             * @event content-changed
             * @description Notify external components that document content has changed
             * @param {Object} detail - Content state information
             * @param {boolean} detail.hasUnsavedChanges - Whether there are unsaved changes
             * @param {boolean} detail.isCollaborativeMode - Whether in collaborative mode
             * @param {string} detail.documentId - Current document ID
             * @param {Array} detail.tags - Document tags
             */
            window.editorEventBus.dispatchEvent(new CustomEvent('content-changed', {
                detail: {
                    hasUnsavedChanges: this.hasUnsavedChanges,
                    isCollaborativeMode: this.isCollaborativeMode,
                    documentId: this.currentFile?.id,
                    tags: this.reactiveTags,
                    custom_json: this.getCustomJson(),
                    // ‚ùå REMOVED: title and body content syncing
                    // TipTap editors maintain their own state via Y.js Collaboration
                }
            }));
        },


        // ‚úÖ FIXED: Debounced permlink sync using metadata map
        debouncedSetPermlinkInMetadata() {
            // ‚úÖ ARCHITECTURE FIX: Store permlink in metadata map per CLAUDE.md
            // ‚úÖ RECURSION FIX: Apply sanitization inline to avoid calling actualPermlink()
            let permlink = this.permlinkInput || '';
            if (permlink.trim()) {
                // Sanitize custom permlink
                permlink = permlink.trim()
                    .toLowerCase()
                    .replace(/[^a-z0-9\s-]/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/-+/g, '-')
                    .replace(/^-+|-+$/g, '')
                    .substring(0, 100);
            } else {
                // Use generated permlink if no custom input
                permlink = this.generatedPermlink;
            }
            this.setPermlinkInMetadata(permlink);

            // ‚úÖ CONSISTENT UX: Use same debounced auto-save pattern as title and custom JSON
            if (!this.isReadOnlyMode) {
                this.hasUnsavedChanges = true;
                this.hasUserIntent = true;
                this.debouncedUpdateContent();

                // Apply same save pattern as other inputs
                if (this.isTemporaryDocument && !this.indexeddbProvider && !this.isCreatingPersistence) {
                    // Permlink shows user intent - create persistence immediately without content check
                    this.debouncedCreateIndexedDBForTempDocument();
                } else if (!this.isTemporaryDocument && this.hasIndexedDBPersistence) {
                    this.autoSave();
                }
            }
        },

        // ‚úÖ TIPTAP COMPLIANCE: Removed manual content waiting - violates best practices
        // TipTap Collaboration extension with onSynced callbacks handles all content loading automatically
        // This method was causing race conditions and data corruption

        triggerContentReactivity() {
            // ‚úÖ TIPTAP BEST PRACTICE: Force Vue reactivity without manual content syncing
            // This forces Vue to re-evaluate computed properties that depend on editor content

            if (this.bodyEditor) {
                // ‚úÖ CORRECT: Use titleInput and editor methods to check if content exists
                const hasTitle = Boolean(this.titleInput?.trim());
                const hasBody = Boolean(this.bodyEditor.getText().trim());

                // ‚úÖ PERFORMANCE FIX: Let Vue's reactivity handle updates automatically
                // Vue will re-evaluate computed properties when needed

                // Also emit content availability for parent components (if needed)
                if (hasTitle || hasBody) {
                    // Emit content-available event using event bus
                    if (!window.editorEventBus) {
                        window.editorEventBus = new EventTarget();
                    }
                    /**
                     * @event content-available
                     * @description Notify that content is now available after sync
                     * @param {Object} detail - Content availability information
                     * @param {boolean} detail.hasTitle - Whether title content exists
                     * @param {boolean} detail.hasBody - Whether body content exists
                     * @param {string} detail.documentName - Document name from config
                     */
                    window.editorEventBus.dispatchEvent(new CustomEvent('content-available', {
                        detail: {
                            hasTitle,
                            hasBody,
                            documentName: this.getDocumentNameFromConfig
                        }
                    }));
                }
            } else {

            }
        },

        validatePermission(action) {
            // ‚úÖ CONSOLIDATED: Use PermissionService for action validation
            const permissionLevel = this.getUserPermissionLevel(this.currentFile);
            return this.permissionService.canPerformAction(action, permissionLevel);
        },

        // ===== UTILITY METHODS =====
        confirmUnsavedChanges() {
            return new Promise((resolve) => {
                const confirmed = confirm('You have unsaved changes. Do you want to continue without saving?');
                resolve(confirmed);
            });
        },

        // ‚è±Ô∏è AUTH SEQUENCE: Authentication flow timing tracker
        startAuthSequence(reason) {
            this.authSequence = {
                start: Date.now(),
                reason: reason,
                events: []
            };
            this.logAuthSequenceEvent('sequence_started', { reason });
        },

        logAuthSequenceEvent(event, details = {}) {
            if (!this.authSequence) return;

            const eventData = {
                event: event,
                timestamp: Date.now(),
                elapsed: Date.now() - this.authSequence.start,
                ...details
            };

            this.authSequence.events.push(eventData);

            // Log immediately for debugging
            console.log(`‚è±Ô∏è AUTH SEQUENCE [${eventData.elapsed}ms]: ${event}`, details);
        },

        endAuthSequence(result) {
            if (!this.authSequence) return;

            this.logAuthSequenceEvent('sequence_ended', { result });

            // Output complete sequence
            console.log('‚è±Ô∏è AUTH SEQUENCE COMPLETE:', {
                reason: this.authSequence.reason,
                result: result,
                totalTime: Date.now() - this.authSequence.start,
                events: this.authSequence.events
            });

            this.authSequence = null;
        },

        // ===== AUTO SAVE METHOD =====
        autoSave() {
            // ‚úÖ FIX: Prevent auto-save during initialization or document loading
            if (!this.editorInitialized || this.isLoadingDocument) {
                return;
            }

            // ‚úÖ TIPTAP v3 COMPLIANT: Debounced autosave for metadata changes
            if (this.autoSaveFrame) {
                cancelAnimationFrame(this.autoSaveFrame);
            }
            
            this.autoSaveTimestamp = Date.now();
            const scheduleAutoSave = () => {
                this.autoSaveFrame = requestAnimationFrame(() => {
                    const elapsed = Date.now() - this.autoSaveTimestamp;
                    if (elapsed >= 1000) {
                        // Remove verbose autosave logging
                        this.saveDocument();
                    } else {
                        scheduleAutoSave();
                    }
                });
            };
            scheduleAutoSave();
        },

        // ===== PLACEHOLDER METHODS =====
        // (These would be implemented based on the current file functionality)

        async saveDocument() {
            // ‚úÖ TIPTAP BEST PRACTICE: Use Y.js as single source of truth
            // ‚ùå NEVER: Extract content manually from editors

            // ‚úÖ TIPTAP v3 COMPLIANT: Allow save for metadata-only documents
            // Check if we have either content or metadata to save
            const hasContent = this.hasContentToSave();
            const hasMetadata = this.hasMetadataToSave();

            // ‚úÖ FIX: For existing documents, always allow save if there are unsaved flags
            const shouldSave = hasContent || hasMetadata || this.hasUnsavedChanges || this.hasUserIntent;

            // Only log save eligibility in debug mode or when there's an issue
            if (!shouldSave && (hasContent || hasMetadata)) {
            }

            if (!shouldSave) {
                return;
            }

            // ‚úÖ FIX: Prevent concurrent saves
            if (this.saving) {
                return;
            }

            this.saving = true;

            try {
                // Determine save strategy based on current file state
                if (!this.currentFile || this.isTemporaryDocument) {
                    // ‚úÖ TIPTAP v3 COMPLIANT: Use unified persistence method
                    // This ensures metadata is synced and document structure is valid

                    // Ensure document persistence (includes metadata sync)
                    await this.ensureDocumentPersistence();

                    // Provide immediate user feedback
                    this.hasUnsavedChanges = false;
                    this.hasUserIntent = false; // Clear immediately for UX

                } else if (this.currentFile.type === 'local') {
                    // Existing local document - Y.js + IndexedDB handles persistence automatically
                    if (ydocService.isReady()) {
                        // ‚úÖ TIPTAP v3 COMPLIANT: Ensure metadata is synced before auto-save
                        await this.ensureMetadataInYjs();

                        // Update metadata
                        // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                        this.batchUpdateYjsConfig({
                            lastModified: new Date().toISOString(),
                            savedAt: new Date().toISOString()
                        }, 'auto-save');

                        // ‚úÖ Wait for Y.js to propagate changes
                        await this.$nextTick();
                    }
                } else if (this.currentFile.type === 'collaborative') {
                    // Collaborative document - WebSocket provider handles sync automatically
                    if (ydocService.isReady() && this.provider) {
                        // Update metadata
                        // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                        this.batchUpdateYjsConfig({
                            lastModified: new Date().toISOString(),
                            savedAt: new Date().toISOString()
                        }, 'auto-save');

                    }
                }

                // ‚úÖ FIX: Always clear unsaved flags after successful save
                this.hasUnsavedChanges = false;
                this.hasUserIntent = false;

                // ‚úÖ TIPTAP v3 COMPLIANT: Trigger save indicator update
                this.clearUnsavedAfterSync();

                // Remove success logging - too verbose for normal operation

            } catch (error) {
                console.error('‚ùå Save failed:', error);
                alert('Save failed: ' + error.message);
                // Don't throw - just log and continue
            } finally {
                // ‚úÖ CRITICAL: Always clear saving flag
                this.saving = false;
            }
        },

        async publishDocument() {
            // ‚úÖ TIPTAP BEST PRACTICE: Use computed properties and Y.js metadata for validation

            // Basic validation using computed properties
            if (!this.canPublish) {
                alert('Please fill in title, content, and at least one tag before publishing.');
                return;
            }

            // Validate Hive requirements
            if (!this.validateHiveRequirements()) {
                return;
            }

            this.showPublishModal = true;
        },

        // Validate Hive publishing requirements
        validateHiveRequirements() {
            const errors = [];

            // ‚úÖ TIPTAP BEST PRACTICE: Use method calls for display data
            const titleText = this.titleInput ? this.titleInput.trim() : '';
            const permlink = this.actualPermlink;

            // Get tags from Y.js metadata
            let tags = [];
            if (ydocService.isReady()) {
                tags = ydocService.getMetadata('tags') || [];
            }

            // Validate permlink format
            if (!/^[a-z0-9-]+$/.test(permlink)) {
                errors.push('Permlink must contain only lowercase letters, numbers, and hyphens');
            }

            // Validate title length
            if (titleText.length > 255) {
                errors.push('Title must be 255 characters or less');
            }

            // Get body content length using TipTap method
            let bodyLength = 0;
            if (this.bodyEditor) {
                bodyLength = this.bodyEditor.getText().length;
            }

            if (bodyLength > 60000) {
                errors.push('Post content is too long (max ~60,000 characters)');
            }

            // Validate tags
            if (tags.length === 0) {
                errors.push('At least one tag is required');
            }
            if (tags.length > 10) {
                errors.push('Maximum 10 tags allowed');
            }
            tags.forEach(tag => {
                if (tag.length > 24) {
                    errors.push(`Tag "${tag}" is too long (max 24 characters)`);
                }
                if (!/^[a-z0-9-]+$/.test(tag)) {
                    errors.push(`Tag "${tag}" contains invalid characters`);
                }
            });

            if (errors.length > 0) {
                alert('Cannot publish post:\n\n' + errors.join('\n'));
                return false;
            }

            return true;
        },

        async shareDocument() {
            // ‚úÖ TIPTAP BEST PRACTICE: Check document state using computed properties

            // If local file, prompt to publish to cloud first
            if (this.currentFile && this.currentFile.type === 'local') {
                const confirmPublish = confirm('This document needs to be published to the cloud before sharing. Publish now?');
                if (confirmPublish) {
                    await this.convertToCollaborative();
                    // After publishing, continue to share modal
                    if (this.currentFile?.type === 'collaborative') {
                        await this.loadDocumentPermissions('force-refresh');
                        await this.loadSharedUsers();
                        this.showShareModal = true;
                    }
                }
                return;
            }

            // For collaborative documents, show share modal directly
            if (this.currentFile?.type === 'collaborative') {
                await this.loadDocumentPermissions('force-refresh');
                await this.loadSharedUsers();

                // No public access option - all documents require authentication

                this.showShareModal = true;
                return;
            }

            alert('Please create or load a document first to enable sharing.');
        },

        loadCachedCollaborativeDocs() {
            try {
                const cacheData = this.cacheService.getCachedCollaborativeDocs(this.username);
                if (cacheData) {
                    const isStale = (Date.now() - cacheData.timestamp) > 300000; // 5 min TTL
                    // ‚úÖ UNIFIED: Use helper for cache validation
                    const isCorrectUser = this.isCacheValidForUser(cacheData);

                    if (!isStale && isCorrectUser && cacheData.documents) {
                        this.setCollaborativeDocs(cacheData.documents);
                        // ‚úÖ FIX: Ensure cached collaborative documents have type set
                        this.collaborativeDocs.forEach(doc => {
                            doc.type = 'collaborative';
                            doc.isCollaborative = true;
                        });

                        // ‚úÖ AUTH STATE MANAGER: Sync collaborative docs from cache
                        if (this.authStateManager) {
                            console.log('üîê AuthStateManager: Syncing collaborative docs from cache', { count: this.collaborativeDocs.length });
                            this.authStateManager.setCollaborativeDocs(this.collaborativeDocs);
                        }

                        return true;
                    }
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Could not load cached collaborative docs:', error);
            }
            return false;
        },

        async loadCollaborativeDocs(forceRefresh = false) {
            if (!this.showCollaborativeFeatures) {
                this.clearCollaborativeDocs();
                this.isLoadingCollaborativeDocs = false;
                return;
            }
            
            // ‚úÖ RACE CONDITION FIX: Set loading state in AuthStateManager
            if (this.authStateManager) {
                this.authStateManager.startLoadingCollaborativeDocs();
            }

            // ‚úÖ OFFLINE-FIRST: Load from cache immediately
            // ‚úÖ GOLDEN RULE #3: Use AuthStateManager's user for cache lookup
            const currentUser = this.authStateManager?.state?.user;
            const cacheData = this.cacheService.getCachedCollaborativeDocs(currentUser);
            if (cacheData) {
                try {
                    const isStale = (Date.now() - cacheData.timestamp) > 300000; // 5 min TTL
                    // ‚úÖ UNIFIED: Use helper for cache validation
                    const isCorrectUser = this.isCacheValidForUser(cacheData);

                    if (!isStale && isCorrectUser && cacheData.documents) {
                        // üìö PHANTOM DEBUG: Log cache loading
                        console.log('üìö PHANTOM DEBUG: Loading collaborative docs from cache', {
                            source: 'cache',
                            user: currentUser,
                            cacheUser: cacheData.user,
                            count: cacheData.documents?.length || 0,
                            isStale: isStale,
                            isCorrectUser: isCorrectUser,
                            docs: cacheData.documents?.slice(0, 3).map(d => ({
                                owner: d.owner,
                                permlink: d.permlink,
                                accessType: d.accessType,
                                type: d.type
                            })),
                            timestamp: Date.now()
                        });
                        
                        this.setCollaborativeDocs(cacheData.documents);
                        // ‚úÖ FIX: Ensure cached collaborative documents have type set
                        this.collaborativeDocs.forEach(doc => {
                            doc.type = 'collaborative';
                            doc.isCollaborative = true;
                        });

                        // ‚úÖ AUTH STATE MANAGER: Sync collaborative docs from cache
                        if (this.authStateManager) {
                            console.log('üîê AuthStateManager: Syncing collaborative docs from cache (background)', { count: this.collaborativeDocs.length });
                            this.authStateManager.setCollaborativeDocs(this.collaborativeDocs);
                        }

                        // Continue to fetch fresh data in background
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Could not parse collaborative docs cache:', error);
                }
            }

            // ‚úÖ OFFLINE-FIRST: Only make API call if authenticated
            // When not authenticated, rely on cached documents and IndexedDB scan
            if (!this.isAuthenticated) {
                console.log('üì± OFFLINE-FIRST: Not authenticated, scanning for cached documents', {
                    cachedDocsCount: this.collaborativeDocs.length,
                    offlineCachesBeforeScan: this.offlineCaches?.length || 0,
                    username: this.username,
                    isAuthenticated: this.isAuthenticated,
                    hasAuthHeaders: !!this.authHeaders
                });
                
                // ‚úÖ OFFLINE-FIRST: Always scan IndexedDB for cached collaborative docs
                try {
                    const additionalDocs = await this.scanIndexedDBDocuments();
                    console.log('üì± OFFLINE-FIRST: IndexedDB scan complete in loadCollaborativeDocs', {
                        offlineCachesAfterScan: this.offlineCaches?.length || 0,
                        additionalLocalDocs: additionalDocs?.length || 0,
                        allDocumentsCount: this.allDocuments?.length || 0
                    });
                } catch (error) {
                    console.error('‚ùå OFFLINE-FIRST: IndexedDB scan failed in loadCollaborativeDocs:', error);
                }
                
                // Mark loading as complete
                this.loadingDocs = false;
                this.isLoadingCollaborativeDocs = false;
                
                // ‚úÖ RACE CONDITION FIX: Clear loading state in AuthStateManager
                if (this.authStateManager) {
                    this.authStateManager.finishLoadingCollaborativeDocs();
                }
                
                return;
            }

            // ‚úÖ PERFORMANCE: Cancel any previous request to prevent race conditions
            if (this.loadCollaborativeDocsController) {
                this.loadCollaborativeDocsController.abort();
                this.loadCollaborativeDocsController = null;
            }

            // ‚úÖ TIPTAP COMPLIANCE: Prevent multiple simultaneous API calls (race condition prevention)
            if (this.loadingDocs) {
                return;
            }

            // ‚úÖ TIPTAP COMPLIANCE: Throttle API calls to prevent excessive requests
            const now = Date.now();
            const lastLoad = this.apiTimestamps.lastCollabDocsLoad || 0;
            const throttleMs = 2000; // 2 second throttle

            if (now - lastLoad < throttleMs) {
                // Skip loading due to throttle
                return;
            }

            this.apiTimestamps.lastCollabDocsLoad = now;

            // Starting collaborative document load - removed verbose logging

            this.loadingDocs = true;
            this.isLoadingCollaborativeDocs = true; // ‚úÖ PERMISSION FIX: Set loading state

            // ‚úÖ PERFORMANCE: Create AbortController for request cancellation
            this.loadCollaborativeDocsController = new AbortController();

            try {
                // ‚úÖ CACHE BUSTING: Add user-specific parameters to force fresh connections
                const cacheBustingParams = new URLSearchParams();
                if (this.userSwitchTimestamp) {
                    cacheBustingParams.append('_t', this.userSwitchTimestamp);
                }
                
                // ‚úÖ GOLDEN RULE #3: Use AuthStateManager's user for API requests
                const currentUser = this.authStateManager?.state?.user || 'anonymous';
                cacheBustingParams.append('_u', currentUser);

                const apiUrl = `https://data.dlux.io/api/collaboration/documents?${cacheBustingParams.toString()}`;
                
                // ‚úÖ API LOGGING: Log the endpoint being called
                console.log('üì° API ENDPOINT: Loading collaborative documents', {
                    url: apiUrl,
                    method: 'GET',
                    user: currentUser,
                    timestamp: new Date().toISOString()
                });

                const authHeaders = this.getAuthHeadersForRequest();
                console.log('üîë API AUTH: Request headers', {
                    hasXAccount: !!authHeaders['x-account'],
                    xAccount: authHeaders['x-account'],
                    hasXSignature: !!authHeaders['x-signature'],
                    hasXChallenge: !!authHeaders['x-challenge'],
                    hasXPubkey: !!authHeaders['x-pubkey']
                });

                const response = await fetch(apiUrl, {
                    headers: {
                        ...authHeaders,
                        'Connection': 'close',  // Prevent connection reuse to avoid ERR_CONNECTION_CLOSED
                        'Cache-Control': 'no-cache, no-store, must-revalidate', // Force fresh request
                        'Pragma': 'no-cache', // HTTP/1.0 compatibility
                        'Expires': '0' // Prevent caching
                    },
                    signal: this.loadCollaborativeDocsController.signal
                });

                // ‚úÖ VERSION CHECK: Look for server version info in headers
                const serverVersion = response.headers.get('x-server-version') ||
                    response.headers.get('server-version') ||
                    response.headers.get('x-hocuspocus-version') ||
                    response.headers.get('hocuspocus-version');
                if (serverVersion) {
                    // Collaboration server version logged - removed verbose logging
                }

                if (response.ok) {
                    const data = await response.json();
                    
                    // ‚úÖ API LOGGING: Log the response data
                    console.log('üì° API RESPONSE: Collaborative documents loaded', {
                        status: response.status,
                        totalDocuments: data.documents?.length || 0,
                        user: currentUser,
                        documentsPreview: data.documents?.slice(0, 3).map(doc => ({
                            owner: doc.owner,
                            permlink: doc.permlink,
                            accessType: doc.accessType,
                            hasAccessType: !!doc.accessType
                        })),
                        timestamp: new Date().toISOString()
                    });

                    // üö® DETAILED LOGGING: Complete JSON structure from collaborative documents endpoint
                    // Collaborative documents API response - removed verbose logging

                    // üö® DETAILED LOGGING: Individual document analysis
                    if (data.documents && Array.isArray(data.documents)) {
                    }

                    // ‚úÖ RULE #8: Validate Online, Trust Offline - Filter documents without valid accessType
                    const unfilteredDocs = data.documents || [];
                    const validAccessTypes = ['readonly', 'editable', 'postable', 'editor', 'publisher', 'owner'];
                    
                    // ‚úÖ API LOGGING: Log document filtering details
                    console.log('üì° API FILTERING: Processing collaborative documents', {
                        unfilteredCount: unfilteredDocs.length,
                        documentsWithoutAccessType: unfilteredDocs.filter(doc => !doc.accessType).map(doc => ({
                            owner: doc.owner,
                            permlink: doc.permlink,
                            accessType: doc.accessType
                        })),
                        currentUser: this.username
                    });
                    
                    // Filter to only include documents with valid access
                    const filteredDocs = unfilteredDocs.filter(doc => {
                        // Always include documents where user is owner
                        if (doc.owner === this.username) {
                            return true;
                        }
                        
                        // Check for valid accessType
                        if (doc.accessType && validAccessTypes.includes(doc.accessType)) {
                            return true;
                        }
                        
                        // Filter out documents without valid accessType
                        console.log('üìö PHANTOM DEBUG: Filtering out doc', {
                            owner: doc.owner,
                            permlink: doc.permlink,
                            accessType: doc.accessType,
                            reason: !doc.accessType ? 'no-access-type' : 'invalid-access-type',
                            currentUser: this.username
                        });
                        return false;
                    });
                    
                    // üìö PHANTOM DEBUG: Log API filtering results
                    console.log('üìö PHANTOM DEBUG: Setting collaborative docs from API', {
                        source: 'api',
                        unfilteredCount: unfilteredDocs.length,
                        filteredCount: filteredDocs.length,
                        removedCount: unfilteredDocs.length - filteredDocs.length,
                        currentUser: this.username,
                        filteredDocs: filteredDocs.slice(0, 3).map(d => ({
                            owner: d.owner,
                            permlink: d.permlink,
                            accessType: d.accessType
                        })),
                        timestamp: Date.now()
                    });
                    
                    this.setCollaborativeDocs(filteredDocs);
                    
                    // ‚úÖ AUTH STATE MANAGER: Sync collaborative docs
                    if (this.authStateManager) {
                        console.log('üîê AuthStateManager: Syncing collaborative docs', {
                            count: this.collaborativeDocs.length,
                            authStateManagerBefore: this.authStateManager.getCollaborativeDocs().length || 0
                        });
                        this.authStateManager.setCollaborativeDocs(this.collaborativeDocs);
                        console.log('üîê AuthStateManager: After sync', {
                            authStateManagerAfter: this.authStateManager.getCollaborativeDocs().length || 0
                        });
                    }

                    // ‚úÖ OFFLINE-FIRST: Cache collaborative documents list
                    try {
                        this.cacheService.cacheCollaborativeDocs(this.collaborativeDocs, currentUser);
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Could not cache collaborative documents:', error);
                    }

                    // ‚úÖ ENHANCED: Extract and cache permissions from collaborative documents list
                    this.collaborativeDocs.forEach((doc) => {
                        // ‚úÖ FIX: Ensure all collaborative documents have type set
                        doc.type = 'collaborative';
                        doc.isCollaborative = true;

                        const hasPermissions = !!doc.permissions;
                        const isOwner = this.isOwnerPermission(this.getUserPermissionLevel(doc));

                        // ‚úÖ CRITICAL FIX: Extract accessType from collaborative documents API response
                        if (doc.accessType) {

                            // Permission caching is handled internally by getMasterPermissionForDocument
                            // ‚úÖ OFFLINE-FIRST: Set permission level for consistent access throughout the app
                            this.updateFilePermission(doc, doc.accessType);

                            // ‚úÖ CURRENT FILE SYNC: If this is the current document, update current file permissions
                            if (this.currentFile &&
                                this.currentFile.owner === doc.owner &&
                                this.currentFile.permlink === doc.permlink) {
                                // Transferring permissions from collab docs to current file - removed verbose logging

                                // Permission caching is handled internally by getMasterPermissionForDocument
                                this.updateFilePermission(this.currentFile, doc.accessType);

                                // ‚úÖ DOCUMENT NAME UPDATE: Update document name from collaborative docs API

                                // Update if we have a server document name and it's different from any current name
                                const currentNames = [this.currentFile.name, this.currentFile.documentName, this.currentFile.title];

                                // Check if the server name is a generic "Untitled" name
                                const isServerNameGeneric = doc.documentName &&
                                    (doc.documentName.startsWith('Untitled') ||
                                        doc.documentName === 'New Document' ||
                                        doc.documentName.includes('Untitled -'));

                                // Check if we have a user-set name (not empty, not generic)
                                const hasUserSetName = currentNames.some(name =>
                                    name &&
                                    name.trim() !== '' &&
                                    !name.startsWith('Untitled') &&
                                    name !== 'New Document'
                                );

                                // Only update if server has a non-generic name or we don't have a user-set name
                                const shouldUpdate = doc.documentName &&
                                    !currentNames.includes(doc.documentName) &&
                                    (!isServerNameGeneric || !hasUserSetName);

                                if (shouldUpdate) {

                                    // Use the same method that handles server metadata updates
                                    this.updateDocumentNameFromServerMetadata(doc.documentName);
                                } else {
                                    let reason = 'unknown';
                                    if (!doc.documentName) {
                                        reason = 'no-server-name';
                                    } else if (currentNames.includes(doc.documentName)) {
                                        reason = 'name-already-matches';
                                    } else if (isServerNameGeneric && hasUserSetName) {
                                        reason = 'preserving-user-set-name';
                                    }

                                }

                                // ‚úÖ TIPTAP BEST PRACTICE: Update editor editable state based on permission
                                this.$nextTick(() => {
                                    // Permission caching is handled internally by getMasterPermissionForDocument

                                    // Force editor to update its editable state if needed
                                    if (this.bodyEditor) {
                                        const shouldBeEditable = this.canEditWithPermission(doc.accessType);

                                        if (this.bodyEditor.isEditable !== shouldBeEditable) {
                                            this.bodyEditor.setEditable(shouldBeEditable);
                                        }
                                    }
                                });
                            }

                            // ‚úÖ OFFLINE-FIRST: Permissions are cached via AuthStateManager
                        }

                        // ‚úÖ UNIFIED PERMISSIONS: Use standardized permission detection
                        const permissionLevel = doc.permissionLevel || doc.permission || doc.access || doc.userPermission || doc.accessType;

                        // ‚úÖ COMPLIANCE: Use unified permission system instead of legacy flags
                        const unifiedPermission = this.getUserPermissionLevel(doc);

                        // ‚úÖ UPDATED LOGIC: Only mark for individual check if no permission data at all
                        if (!hasPermissions && !isOwner && !doc.accessType && !permissionLevel) {

                            // Mark document as needing individual permission check when opened
                            doc._needsPermissionCheck = true;
                        } else {
                        }
                    });

                    // ‚úÖ ENHANCED: Load individual permissions for documents that need permission checks
                    await this.loadIndividualPermissionsForDocuments();
                    
                    // ‚úÖ RESET RETRY COUNTER: Reset on successful load
                    this.loadCollaborativeDocsRetryCount = 0;

                    // ‚úÖ OFFLINE-FIRST: Non-blocking IndexedDB scan
                    this.scanIndexedDBDocuments().catch(error => {
                        console.warn('‚ö†Ô∏è Background IndexedDB scan failed:', error);
                    });
                } else {
                    const errorText = await response.text().catch(() => 'Unable to read error response');
                    console.error('‚ùå COLLAB DOCS: Failed to load collaborative documents', {
                        status: response.status,
                        statusText: response.statusText,
                        errorText: errorText,
                        user: this.username,
                        url: response.url
                    });

                    if (apiAuthErrorHandler.isAuthError(response.status)) {
                        // Handle through centralized error handler
                        await this.handleApiAuthError(
                            { response },
                            {
                                endpoint: 'collaboration/documents',
                                operation: 'Load Collaborative Documents',
                                type: 'api-error',
                                clearCache: true,
                                cacheKey: 'collaborativeDocs'
                            }
                        );
                    }
                    // For other HTTP errors (403, 404, 500), preserve cached data
                }
            } catch (error) {
                // ‚úÖ PERFORMANCE: Handle request cancellation gracefully
                if (error.name === 'AbortError') {
                    return; // Don't set error states for cancelled requests
                }

                // Classify error type for appropriate handling
                const isConnectionError = error.message.includes('Failed to fetch') ||
                    error.message.includes('ERR_CONNECTION_CLOSED') ||
                    error.message.includes('NetworkError') ||
                    error.message.includes('connection was closed');

                if (isConnectionError) {
                    // ‚úÖ RETRY LOGIC: Attempt retry for connection errors
                    const shouldRetry = this.loadCollaborativeDocsRetryCount < 2;

                    if (shouldRetry) {
                        this.loadCollaborativeDocsRetryCount++;

                        console.warn('‚ö†Ô∏è COLLAB DOCS: Connection error, retrying with fresh connection:', {
                            error: error.message,
                            user: this.username,
                            retryAttempt: this.loadCollaborativeDocsRetryCount,
                            retryMethod: 'nextTick'
                        });

                        // ‚úÖ REACTIVE PATTERN: Immediate retry without artificial delays
                        this.$nextTick(() => {
                            this.loadCollaborativeDocs().catch(retryError => {
                                console.warn('‚ö†Ô∏è COLLAB DOCS: Retry failed, preserving cached data:', {
                                    retryError: retryError.message,
                                    cachedDocsCount: this.collaborativeDocs.length
                                });
                            });
                        });

                        return; // Don't process as regular error
                    } else {
                        // Max retries reached, preserve cached data
                        console.warn('‚ö†Ô∏è COLLAB DOCS: Max retries reached, preserving cached data:', {
                            error: error.message,
                            user: this.username,
                            cachedDocsCount: this.collaborativeDocs.length,
                            retryAttempts: this.loadCollaborativeDocsRetryCount
                        });

                        // Reset retry counter for next attempt
                        this.loadCollaborativeDocsRetryCount = 0;
                    }
                } else {
                    // For other errors (parsing, unexpected), log as error but still preserve cache
                    console.error('‚ùå COLLAB DOCS: Unexpected error loading collaborative documents:', {
                        error: error.message,
                        stack: error.stack,
                        user: this.username
                    });
                    // Could consider clearing cache here for non-connection errors if needed
                }
            } finally {
                this.loadingDocs = false;
                this.isLoadingCollaborativeDocs = false; // ‚úÖ PERMISSION FIX: Clear loading state
                // ‚úÖ PERFORMANCE: Clean up AbortController
                this.loadCollaborativeDocsController = null;
            }
        },

        // ‚úÖ ENHANCED: Load individual permissions for documents that need permission checks
        async loadIndividualPermissionsForDocuments() {

            if (!this.collaborativeDocs || this.collaborativeDocs.length === 0) {

                return;
            }

            // Find documents that need permission checks
            const documentsNeedingPermissions = this.collaborativeDocs.filter(doc => doc._needsPermissionCheck);

            if (documentsNeedingPermissions.length === 0) {

                return;
            }

            // Load permissions in parallel with concurrency limit
            const maxConcurrent = 3;
            const batches = [];

            for (let i = 0; i < documentsNeedingPermissions.length; i += maxConcurrent) {
                batches.push(documentsNeedingPermissions.slice(i, i + maxConcurrent));
            }

            let permissionsLoaded = 0;

            for (const batch of batches) {
                const batchPromises = batch.map(async (doc) => {
                    try {

                        const permissionResult = await this.getMasterPermissionForDocument(doc, true, 'individual-permission-check');

                        if (permissionResult && permissionResult.level) {
                            // Store the permission result
                            this.updateFilePermission(doc, permissionResult.level);
                            doc.permissionDetails = permissionResult;

                            // Clear the needsPermissionCheck flag
                            delete doc._needsPermissionCheck;

                            permissionsLoaded++;
                        } else {
                            console.warn(`‚ö†Ô∏è No permission result for ${doc.name || doc.documentName}`);
                            // Default to no-access if permission check fails
                            this.updateFilePermission(doc, this.getNoAccessPermissionLevel());
                            delete doc._needsPermissionCheck;
                        }

                    } catch (error) {
                        console.error(`‚ùå Failed to load permission for ${doc.name || doc.documentName}:`, error.message);
                        // Default to no-access on error
                        this.updateFilePermission(doc, 'no-access');
                        delete doc._needsPermissionCheck;
                    }
                });

                await Promise.allSettled(batchPromises);
            }

        },

        async convertToCollaborative() {
            // ‚úÖ TIPTAP BEST PRACTICE: Handle both persisted and temporary documents

            // Check if we have a temporary document that needs persistence
            if (this.isTemporaryDocument && !this.indexeddbProvider && this.ydoc) {

                // Ensure document has a name
                if (!ydocService.getConfig('documentName')) {
                    const documentName = `Untitled - ${new Date().toLocaleDateString()}`;
                    // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                    ydocService.batchUpdate({
                        documentName: documentName,
                        lastModified: new Date().toISOString()
                    }, {}, 'cloud-conversion'); // Origin tag to identify this transaction
                }

                // Sync metadata to Y.js
                await this.ensureMetadataInYjs();

                // Create IndexedDB persistence (user intent = clicking the button)
                await this.createIndexedDBForTempDocument();

                // Wait for Vue reactivity
                await this.$nextTick();
            }

            // Now check if we have a valid document to convert
            if (!this.currentFile || (this.currentFile.type !== 'local' && !this.isTemporaryDocument)) {
                console.warn('Cannot convert: No document available');
                return;
            }

            // ‚úÖ CONCURRENCY PROTECTION: Prevent multiple simultaneous conversions
            if (this.conversionInProgress) {

                return;
            }

            if (!this.isAuthenticated) {
                // ‚úÖ OFFLINE-FIRST COMPLIANCE: Store conversion state for resumption after auth
                this.pendingConversion = {
                    type: 'cloud-conversion',
                    originalFile: { ...this.currentFile },
                    timestamp: Date.now(),
                    documentName: this.titleInput || `Untitled - ${new Date().toLocaleDateString()}`
                };
                
                console.log('‚òÅÔ∏è CONVERT: Setting pendingConversion for cloud upgrade', {
                    pendingConversion: this.pendingConversion,
                    currentFile: this.currentFile?.id,
                    willRequestAuth: true
                });
                
                this.requestAuthentication({ forConversion: true, autoTrigger: true });
                return;
            }

            // Continue with authenticated conversion
            await this.executeCloudConversion();
        },

        async executeCloudConversion(pendingData = null) {
            console.log('‚òÅÔ∏è CONVERT: executeCloudConversion called', {
                fromAuthRetry: !!pendingData,
                pendingData,
                currentFileId: this.currentFile?.id,
                documentName: this.documentName || this.titleInput,
                timestamp: Date.now()
            });
            
            // ‚úÖ TIPTAP COMPLIANCE: Unified conversion logic for both direct and resumed conversions
            this.conversionInProgress = true;

            try {
                // ‚úÖ FIX: Get document name from Y.js config, not from title
                let documentName = null;
                if (ydocService.isReady()) {
                    documentName = ydocService.getConfig('documentName');
                }

                // Use Y.js document name, fallback to pending data, then title, then default
                documentName = documentName || pendingData?.documentName || this.documentName || this.currentFile?.documentName || this.currentFile?.name;

                // Keep document name as is - don't use title
                if (!documentName || documentName.includes('/')) {
                    documentName = `Untitled - ${new Date().toLocaleDateString()}`;
                }

                const title = this.titleInput || documentName;
                const description = 'Document created with DLUX TipTap Editor';

                // Create cloud document via API
                const response = await fetch('https://data.dlux.io/api/collaboration/documents', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...this.getAuthHeadersForRequest()
                    },
                    body: JSON.stringify({
                        documentName: documentName,
                        title: title,
                        description: description
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    throw new Error(`Failed to create cloud document: ${errorData.error || response.statusText}`);
                }

                const docData = await response.json();
                const serverDoc = docData.document || docData;

                // ‚úÖ TIPTAP BEST PRACTICE: NO manual content extraction/upload
                // Y.js document handles content continuity automatically during tier conversion

                // Create collaborative file object with proper ID
                const collaborativeFile = {
                    ...serverDoc,
                    id: `${serverDoc.owner}/${serverDoc.permlink}`, // Collaborative documents use owner/permlink as ID
                    type: 'collaborative',
                    name: serverDoc.documentName || title
                };

                // ‚úÖ TIPTAP BEST PRACTICE: Convert current Y.js document to collaborative tier
                // This preserves content automatically without manual extraction
                await this.convertCurrentDocumentToCollaborative(collaborativeFile);

                // Update URL parameters for collaborative document
                this.updateURLWithCollabParams(collaborativeFile.owner, collaborativeFile.permlink);

            } catch (error) {
                console.error('‚ùå Failed to convert to collaborative:', {
                    error: error,
                    message: error.message,
                    stack: error.stack,
                    name: error.name,
                    step: 'executeCloudConversion'
                });
                alert('Failed to convert document to collaborative: ' + error.message);

                // ‚úÖ ERROR RECOVERY: Reset state to allow retry
                this.fileType = 'local';
                // isCollaborativeMode is now a computed property

            } finally {
                this.conversionInProgress = false;
            }
        },

        async convertCurrentDocumentToCollaborative(collaborativeFile) {
            try {
                // ‚úÖ TIPTAP BEST PRACTICE: Don't destroy Y.js document during conversion
                // Keep the same Y.js document and just change persistence

                if (!this.ydoc) {
                    throw new Error('No Y.js document to convert');
                }

                // STEP 1: Extract current document name
                let currentDocumentName = collaborativeFile.documentName;
                try {
                    const extractedName = ydocService.getConfig('documentName');
                    if (extractedName && extractedName.trim()) {
                        currentDocumentName = extractedName;
                    }
                } catch (error) {
                    console.warn('Could not extract document name from Y.js config:', error);
                }

                // Preserve original local file reference
                const originalLocalFile = this.currentFile && this.currentFile.id && this.currentFile.id.startsWith('local_')
                    ? { ...this.currentFile }
                    : null;
                    
                console.log('üîç PHANTOM DEBUG: convertCurrentDocumentToCollaborative', {
                    hasCurrentFile: !!this.currentFile,
                    currentFileId: this.currentFile?.id,
                    startsWithLocal: this.currentFile?.id?.startsWith('local_'),
                    originalLocalFile: !!originalLocalFile,
                    originalId: originalLocalFile?.id
                });

                // STEP 2: Update file reference and mode
                this.setCurrentFile(collaborativeFile);
                this.fileType = 'collaborative';
                // isCollaborativeMode is now a computed property

                // STEP 3: Get Y.js and persistence modules
                // ‚úÖ FIX: Use username prefix for proper IndexedDB naming convention
                const cloudDocumentId = `${this.username}__${collaborativeFile.owner}/${collaborativeFile.permlink}`;

                // ‚úÖ CORRECT: Use smart access pattern like other methods
                const tiptapBundle = window.TiptapCollaboration?.Editor
                    ? window.TiptapCollaboration
                    : window.TiptapCollaboration?.default;
                const Y = tiptapBundle?.Y;
                const IndexeddbPersistence = tiptapBundle?.IndexeddbPersistence;

                if (!Y || !IndexeddbPersistence) {
                    console.error('üîç Bundle access debug:', {
                        windowTiptapCollaboration: !!window.TiptapCollaboration,
                        hasEditor: !!window.TiptapCollaboration?.Editor,
                        hasDefault: !!window.TiptapCollaboration?.default,
                        bundleKeys: window.TiptapCollaboration ? Object.keys(window.TiptapCollaboration) : [],
                        defaultKeys: window.TiptapCollaboration?.default ? Object.keys(window.TiptapCollaboration.default) : [],
                        Y: !!Y,
                        IndexeddbPersistence: !!IndexeddbPersistence
                    });
                    throw new Error('Y.js or IndexedDB persistence not available');
                }

                // STEP 4: Copy Y.js state to cloud IndexedDB location
                // This preserves all content and structure
                if (originalLocalFile && originalLocalFile.id) {
                    await this.copyYjsDocumentToCloudKey(originalLocalFile.id, cloudDocumentId);
                }

                // STEP 5: Switch IndexedDB provider to cloud ID
                // ‚úÖ TIPTAP BEST PRACTICE: Keep same Y.js document, just change persistence
                if (this.indexeddbProvider) {
                    this.indexeddbProvider.destroy();
                    this.indexeddbProvider = null;
                }

                // Create new IndexedDB provider with cloud ID
                this.indexeddbProvider = new IndexeddbPersistence(cloudDocumentId, this.ydoc);

                // ‚úÖ TIPTAP BEST PRACTICE: Use onSynced callback properly
                await new Promise((resolve) => {
                    this.indexeddbProvider.once('synced', () => {
                        resolve();
                    });
                });

                // STEP 6: Update document metadata
                // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                ydocService.batchUpdate({
                    documentName: currentDocumentName,
                    createdAt: new Date().toISOString(),
                    convertedFromLocal: true,
                    originalLocalId: originalLocalFile?.id,
                    cloudDocumentId: cloudDocumentId
                }, {}, 'cloud-conversion'); // Origin tag to identify this transaction

                // ‚úÖ TIPTAP BEST PRACTICE: Editors already exist, no need to recreate
                // Just update the connection status and wait for WebSocket

                // STEP 8: Connect to WebSocket
                const webSocketProvider = await this.documentManager.persistenceManager.setupWebSocketWithOnSynced(this.ydoc, collaborativeFile);

                if (webSocketProvider) {
                    this.provider = webSocketProvider;
                    console.log('üî• CACHE-DEBUG: Setting connectionStatus to connected', {
                        hasProvider: !!webSocketProvider,
                        isAuthenticated: this.isAuthenticated,
                        hasAuthHeaders: !!this.authHeaders,
                        location: 'convertLocalToCollaborative'
                    });
                    this.connectionStatus = 'connected';
                    // ‚úÖ DUPLICATE PREVENTION: onConnect callback will handle upgrade to Tier 2 editors

                } else {
                    console.log('üî• CACHE-DEBUG: Setting connectionStatus to offline', {
                        hasProvider: false,
                        isAuthenticated: this.isAuthenticated,
                        hasAuthHeaders: !!this.authHeaders,
                        location: 'convertLocalToCollaborative'
                    });
                    this.connectionStatus = 'offline';
                }

                // ‚úÖ TIPTAP COMPLIANCE: No manual content sync waiting
                // TipTap Collaboration extension handles content sync automatically via onSynced callbacks

                // STEP 10: Link original local file for recovery
                if (originalLocalFile) {
                    await this.linkLocalFileMetadata(originalLocalFile, collaborativeFile);

                    // ‚úÖ TIPTAP COMPLIANCE: Clean up old local document AFTER successful conversion
                    // Use nextTick to ensure all operations complete before cleanup
                    console.log('üîç PHANTOM DEBUG: Scheduling cleanup in nextTick', {
                        localId: originalLocalFile.id
                    });
                    
                    this.$nextTick(async () => {
                        console.log('üîç PHANTOM DEBUG: nextTick executing, calling cleanup');
                        await this.cleanupOldLocalDocumentAfterConversion(originalLocalFile.id);
                    });
                } else {
                    console.log('üîç PHANTOM DEBUG: No originalLocalFile, skipping cleanup');
                }

            } catch (error) {
                console.error('Failed to convert to collaborative tier:', error);

                // Reset state if conversion fails
                this.fileType = 'local';
                // isCollaborativeMode is now a computed property

                throw error;
            }
        },

        // ‚úÖ RULE 6 COMPLIANCE: Simplified metadata linking for conversion tracking
        async linkLocalFileMetadata(localFile, collaborativeFile) {
            console.log('üîç PHANTOM DEBUG: linkLocalFileMetadata called', {
                localFileId: localFile?.id,
                collaborativeOwner: collaborativeFile?.owner,
                collaborativePermlink: collaborativeFile?.permlink
            });
            
            try {
                const localFileMetadata = {
                    cloudOwner: collaborativeFile.owner,
                    cloudPermlink: collaborativeFile.permlink,
                    collaborativeOwner: collaborativeFile.owner, // Keep both for compatibility
                    collaborativePermlink: collaborativeFile.permlink,
                    convertedToCollaborative: true,
                    collaborativeConvertedAt: new Date().toISOString(),
                    originalLocalId: localFile.id,
                    cloudDocumentId: `${collaborativeFile.owner}/${collaborativeFile.permlink}`,
                    conversionVersion: '2.0-rule6-compliant'
                };

                await this.atomicUpdateLocalFileMetadata(localFile.id, localFileMetadata);

            } catch (error) {
                console.warn('Failed to update local file metadata (non-critical):', error);
            }
        },

        async copyLocalContentToCloudDocument(localId, cloudId, contentBackup) {
            try {
                // ‚úÖ CORRECT: Use smart access pattern like other methods
                const tiptapBundle = window.TiptapCollaboration?.Editor
                    ? window.TiptapCollaboration
                    : window.TiptapCollaboration?.default;
                const Y = tiptapBundle?.Y;
                const IndexeddbPersistence = tiptapBundle?.IndexeddbPersistence;

                if (!Y || !IndexeddbPersistence) {
                    return; // Content will be handled via other means
                }

                try {
                    const sourceDoc = new Y.Doc();
                    const sourceProvider = new IndexeddbPersistence(localId, sourceDoc);

                    // Wait for source document to load
                    await this.waitForProviderSync(sourceProvider, 1000);

                    // ‚úÖ TIPTAP COMPLIANCE: Check if source document has content without direct fragment access
                    // We check by looking at the document's update size
                    const sourceState = Y.encodeStateAsUpdate(sourceDoc);
                    const hasSourceContent = sourceState.length > 100; // Minimal Y.js doc is ~90 bytes

                    if (hasSourceContent) {
                        // Copy Y.js document state to current cloud document
                        Y.applyUpdate(this.ydoc, sourceState);
                    }

                    // ‚úÖ TIPTAP COMPLIANCE: Clean up source with proper timing
                    // Wait for any pending operations to complete
                    await this.$nextTick();

                    // Destroy provider first, then document
                    sourceProvider.destroy();
                    sourceDoc.destroy();

                } catch (copyError) {
                    console.warn('Y.js document copying failed (non-critical):', copyError.message);
                }

            } catch (error) {
                console.warn('Content copying failed (non-critical):', error.message);
            }
        },

        // ‚úÖ TIPTAP.DEV BEST PRACTICE: Robust offline‚Üíonline document linking with resilience
        async linkLocalDocumentToCloud(localFile, collaborativeFile) {
            try {

                // ‚úÖ STEP 1: Create cloud IndexedDB persistence for SAME Y.js document
                // This maintains document continuity while adding cloud sync
                const cloudDocumentId = `${collaborativeFile.owner}/${collaborativeFile.permlink}`;

                // ‚úÖ STEP 2: Copy Y.js document from local IndexedDB to cloud IndexedDB key
                // This ensures same document content is available under cloud key
                await this.copyYjsDocumentToCloudKey(localFile.id, cloudDocumentId);

                // ‚úÖ STEP 3: Update local file metadata with resilience
                const localFileMetadata = {
                    collaborativeOwner: collaborativeFile.owner,
                    collaborativePermlink: collaborativeFile.permlink,
                    convertedToCollaborative: true,
                    collaborativeConvertedAt: new Date().toISOString(),
                    // ‚úÖ RESILIENCE: Store both IDs for recovery
                    originalLocalId: localFile.id,
                    cloudDocumentId: cloudDocumentId,
                    // ‚úÖ VERSIONING: Track conversion for debugging
                    conversionVersion: '1.0'
                };

                // ‚úÖ STEP 4: Atomic update with rollback capability
                const success = await this.atomicUpdateLocalFileMetadata(localFile.id, localFileMetadata);

                if (success) {
                } else {
                    throw new Error('Failed to update local file metadata atomically');
                }

            } catch (error) {
                console.error('‚ùå Failed to link local document to cloud:', error);

                // ‚úÖ RESILIENCE: Don't break the conversion process
                // The document will still work, just might show as duplicate until next refresh
                console.warn('‚ö†Ô∏è Continuing conversion without perfect linking - document will still function');
            }
        },

        // ‚úÖ TIPTAP.DEV BEST PRACTICE: Copy Y.js document between IndexedDB keys
        // ‚úÖ TIPTAP COMPLIANCE: Clean up old local document after successful conversion
        async cleanupOldLocalDocumentAfterConversion(localId) {
            console.log('üîç PHANTOM DEBUG: cleanupOldLocalDocumentAfterConversion called', {
                localId: localId,
                timestamp: Date.now()
            });
            
            try {

                // ‚úÖ CORRECT: Use smart access pattern like other methods
                const tiptapBundle = window.TiptapCollaboration?.Editor
                    ? window.TiptapCollaboration
                    : window.TiptapCollaboration?.default;
                const Y = tiptapBundle?.Y;
                const IndexeddbPersistence = tiptapBundle?.IndexeddbPersistence;

                if (!Y || !IndexeddbPersistence) {
                    console.warn('‚ö†Ô∏è Cannot clean up - Y.js or IndexedDB persistence not available');
                    return;
                }

                // ‚úÖ TIPTAP BEST PRACTICE: Create temporary Y.js document for cleanup
                const tempDoc = new Y.Doc();
                const tempProvider = new IndexeddbPersistence(localId, tempDoc);

                // ‚úÖ TIPTAP BEST PRACTICE: Use onSynced to ensure provider is ready
                await this.waitForProviderSync(tempProvider, 2000);

                // ‚úÖ CRITICAL: Clear the old document's IndexedDB data
                if (tempProvider.clearData && typeof tempProvider.clearData === 'function') {
                    await tempProvider.clearData();

                    // ‚úÖ TIPTAP COMPLIANCE: Use nextTick to ensure cleanup completes
                    await this.$nextTick();
                }

                // ‚úÖ TIPTAP BEST PRACTICE: Proper cleanup order
                tempProvider.destroy();
                tempDoc.destroy();
                
                // ‚úÖ PHANTOM FIX: Delete the IndexedDB database entirely to prevent it from being detected as orphaned
                try {
                    // üìö PHANTOM DEBUG: List databases before deletion
                    if (indexedDB.databases) {
                        const dbsBefore = await indexedDB.databases();
                        const localDbBefore = dbsBefore.find(db => db.name === localId);
                        console.log('üìö PHANTOM DEBUG: Before IndexedDB deletion', {
                            localId,
                            databaseExists: !!localDbBefore,
                            totalDatabases: dbsBefore.length,
                            localDatabases: dbsBefore.filter(db => db.name.startsWith('local_')).map(db => db.name)
                        });
                    }
                    
                    // ‚úÖ PHANTOM FIX: Properly wait for IndexedDB deletion to complete
                    const deleteRequest = indexedDB.deleteDatabase(localId);
                    await new Promise((resolve, reject) => {
                        deleteRequest.onsuccess = () => {
                            console.log('üßπ Successfully deleted IndexedDB database:', localId);
                            resolve();
                        };
                        deleteRequest.onerror = () => {
                            console.error('‚ùå Failed to delete IndexedDB database:', localId, deleteRequest.error);
                            reject(deleteRequest.error);
                        };
                        deleteRequest.onblocked = () => {
                            console.warn('‚ö†Ô∏è IndexedDB deletion blocked - database may be open elsewhere:', localId);
                            // ‚úÖ ARCHITECTURE RULE 6: Use requestAnimationFrame instead of setTimeout
                            const frames = Math.ceil(1000 / 16); // ~63 frames for 1000ms at 60fps
                            let frameCount = 0;
                            const frameTimeout = () => {
                                if (++frameCount >= frames) {
                                    resolve();
                                } else {
                                    requestAnimationFrame(frameTimeout);
                                }
                            };
                            requestAnimationFrame(frameTimeout);
                        };
                    });
                    
                    // üìö PHANTOM DEBUG: Verify deletion
                    if (indexedDB.databases) {
                        const dbsAfter = await indexedDB.databases();
                        const localDbAfter = dbsAfter.find(db => db.name === localId);
                        console.log('üìö PHANTOM DEBUG: After IndexedDB deletion', {
                            localId,
                            stillExists: !!localDbAfter,
                            totalDatabases: dbsAfter.length,
                            localDatabases: dbsAfter.filter(db => db.name.startsWith('local_')).map(db => db.name),
                            deletionSuccess: !localDbAfter
                        });
                    }
                } catch (dbError) {
                    console.error('‚ö†Ô∏è Failed to delete IndexedDB database:', {
                        localId,
                        error: dbError,
                        errorMessage: dbError?.message,
                        errorStack: dbError?.stack
                    });
                }
                
                // ‚úÖ PHANTOM FIX: Remove localStorage metadata entry to prevent phantom documents
                // This prevents the document from appearing as a collaborative document with no-access
                try {
                    const files = this.documentStorageService.getAllDocuments();
                    const filteredFiles = files.filter(f => f.id !== localId);
                    this.documentStorageService.saveAllDocuments(filteredFiles);
                    console.log('üßπ Removed localStorage metadata for converted document:', localId);
                    
                    // Don't call loadLocalFiles here - it can recreate the entry we just deleted
                    // The UI will update naturally through Vue reactivity
                } catch (metadataError) {
                    console.warn('‚ö†Ô∏è Failed to remove localStorage metadata (non-critical):', metadataError);
                }

            } catch (error) {
                console.error('‚ùå Failed to clean up old local document:', error);
                // Non-critical error - conversion can continue
            }
        },

        async copyYjsDocumentToCloudKey(localId, cloudId) {
            try {

                // ‚úÖ CORRECT: Use smart access pattern like other methods
                const tiptapBundle = window.TiptapCollaboration?.Editor
                    ? window.TiptapCollaboration
                    : window.TiptapCollaboration?.default;
                const Y = tiptapBundle?.Y;
                const IndexeddbPersistence = tiptapBundle?.IndexeddbPersistence;

                if (!Y || !IndexeddbPersistence) {
                    console.error('üîç copyYjsDocumentToCloudKey Bundle access debug:', {
                        windowTiptapCollaboration: !!window.TiptapCollaboration,
                        hasEditor: !!window.TiptapCollaboration?.Editor,
                        hasDefault: !!window.TiptapCollaboration?.default,
                        bundleKeys: window.TiptapCollaboration ? Object.keys(window.TiptapCollaboration) : [],
                        defaultKeys: window.TiptapCollaboration?.default ? Object.keys(window.TiptapCollaboration.default) : [],
                        Y: !!Y,
                        IndexeddbPersistence: !!IndexeddbPersistence
                    });
                    throw new Error('Y.js or IndexedDB persistence not available');
                }

                // ‚úÖ Load source document
                const sourceDoc = new Y.Doc();
                const sourceProvider = new IndexeddbPersistence(localId, sourceDoc);

                await this.waitForProviderSync(sourceProvider, 2000, true).catch(err => {
                    throw new Error('Source document load timeout');
                });

                // ‚úÖ Create target document and copy content
                const targetDoc = new Y.Doc();
                const targetProvider = new IndexeddbPersistence(cloudId, targetDoc);

                // ‚úÖ TIPTAP BEST PRACTICE: Copy all Y.js document state
                const sourceState = Y.encodeStateAsUpdate(sourceDoc);
                Y.applyUpdate(targetDoc, sourceState);

                // ‚úÖ Wait for target to sync
                await this.waitForProviderSync(targetProvider, 2000, true).catch(err => {
                    throw new Error('Target document save timeout');
                });

                // ‚úÖ Cleanup
                sourceProvider.destroy();
                targetProvider.destroy();
                sourceDoc.destroy();
                targetDoc.destroy();

            } catch (error) {
                console.error('‚ùå Failed to copy Y.js document:', error);
                throw error;
            }
        },

        // ‚úÖ RESILIENCE: Atomic metadata update with rollback
        async atomicUpdateLocalFileMetadata(fileId, updates) {
            try {
                // ‚úÖ Load current metadata
                const files = this.documentStorageService.getAllDocuments();
                const fileIndex = files.findIndex(f => f.id === fileId);

                if (fileIndex === -1) {
                    console.warn('‚ö†Ô∏è File not found in localStorage for metadata update:', fileId);
                    return false;
                }

                // ‚úÖ Create backup for rollback
                const originalFile = { ...files[fileIndex] };

                // ‚úÖ Apply updates
                files[fileIndex] = { ...files[fileIndex], ...updates };

                // ‚úÖ Atomic save with verification
                const saveResult = this.documentStorageService.saveAllDocuments(files);

                // ‚úÖ Verify save worked
                const verification = this.documentStorageService.getAllDocuments();
                const verifiedFile = verification.find(f => f.id === fileId);

                if (verifiedFile && verifiedFile.collaborativeOwner === updates.collaborativeOwner) {

                    return true;
                } else {
                    // ‚úÖ Rollback on verification failure
                    files[fileIndex] = originalFile;
                    this.documentStorageService.saveAllDocuments(files);
                    console.error('‚ùå Metadata update verification failed, rolled back');
                    return false;
                }

            } catch (error) {
                console.error('‚ùå Atomic metadata update failed:', error);
                return false;
            }
        },

        // ‚úÖ OBSOLETE: No longer needed - we keep the same Y.js document during conversion
        async cleanupForConversion(preserveIndexedDBData = true) {
            console.warn('‚ö†Ô∏è cleanupForConversion is obsolete - conversion now keeps the same Y.js document');
        },

        // ‚úÖ RULE 6 COMPLIANCE: Initialize Y.js schema for fresh collaborative documents
        initializeCollaborativeSchema() {

            try {
                if (!this.ydoc) {
                    console.warn('‚ö†Ô∏è No Y.js document available for schema initialization');
                    return;
                }

                // ‚úÖ TIPTAP COMPLIANCE: Initialize Y.js document metadata only
                // Content fragments are automatically created by TipTap Collaboration extension

                // Set default config values if not already set
                // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                const updates = {};
                if (!ydocService.getConfig('createdAt')) {
                    updates.createdAt = new Date().toISOString();
                }
                if (!ydocService.getConfig('documentVersion')) {
                    updates.documentVersion = '1.0';
                }
                if (!ydocService.getConfig('schemaInitialized')) {
                    updates.schemaInitialized = true;
                }
                
                if (Object.keys(updates).length > 0) {
                    ydocService.batchUpdate(updates, {}, 'schema-init'); // Origin tag to identify this transaction
                }

            } catch (error) {
                console.error('‚ùå Failed to initialize collaborative schema:', error);
            }
        },

        // ‚úÖ ENHANCED: Unified cloud file permission system with Info endpoint integration
        async loadDocumentPermissions(context = 'document-access', targetFile = null) {
            // Skip permission loading if we're in the middle of user switching
            if (this._processingUserChange) {
                console.log('üîÑ Skipping permission load during user switch');
                return null;
            }
            
            const file = targetFile || this.currentFile;
            if (!file || file.type !== 'collaborative') return;
            if (!this.isAuthenticated || this.isAuthExpired) {
                console.warn('Cannot load permissions: Authentication not ready', {
                    isAuthenticated: this.isAuthenticated,
                    isAuthExpired: this.isAuthExpired,
                    hasAuthHeaders: this.isAuthenticated && !!this.authHeaders,
                    context
                });
                return;
            }

            // ‚úÖ CACHE-FIRST: Check if we have fresh cached permissions first via AuthStateManager
            const documentKey = `${file.owner}/${file.permlink}`;
            const cachedPermission = this.authStateManager?.getCachedFilePermission(file);

            // ‚úÖ BALANCED CACHING: Distinguish between contexts
            const isDocumentAccess = context === 'document-access' || context === 'force-refresh';
            const shouldUseCache = cachedPermission && !isDocumentAccess;

            if (shouldUseCache) {
                const cacheAge = typeof cachedPermission === 'object' && cachedPermission.timestamp
                    ? Date.now() - cachedPermission.timestamp
                    : 0;

                // For file browser operations, use cache if fresh
                if (cacheAge < 300000) {

                    // No need to update documentPermissions - computed property handles it

                    return; // Skip API call entirely for file browser
                }
            }

            // ‚úÖ DOCUMENT ACCESS: Use cache for immediate display but always refresh
            if (isDocumentAccess && cachedPermission) {
                const cachedLevel = typeof cachedPermission === 'string' ? cachedPermission : cachedPermission.level;
                const cacheTimestamp = typeof cachedPermission === 'object' ? cachedPermission.timestamp : Date.now();

                // Cached data will be used via computed property

                // Continue to refresh in background
            }

            // ‚úÖ PERFORMANCE: Prevent duplicate loads within 5 seconds
            const recentLoadKey = `_recentPermissionLoad_${documentKey}`;
            const now = Date.now();

            if (this[recentLoadKey] && (now - this[recentLoadKey]) < 5000) {
                return; // Skip duplicate load
            }

            // ‚úÖ PERFORMANCE: Mark as recently loaded
            this[recentLoadKey] = now;

            this.loadingPermissions = true;

            try {
                // ‚úÖ STEP 1: Load Info endpoint for document metadata (includes access type)
                const infoUrl = `https://data.dlux.io/api/collaboration/info/${file.owner}/${file.permlink}`;
                const permissionsUrl = `https://data.dlux.io/api/collaboration/permissions/${file.owner}/${file.permlink}`;

                // ‚úÖ OWNER-BASED API STRATEGY: Only owners can access permissions endpoint
                // ‚úÖ UNIFIED: Use getUserPermissionLevel for owner check
                const isOwner = this.isOwnerPermission(this.getUserPermissionLevel(file));

                // ‚úÖ OWNER-BASED API CALLS: Skip permissions endpoint for non-owners to avoid 403
                let apiPromises;
                if (isOwner) {
                    // Owner: Use info + permissions endpoints
                    apiPromises = [
                        this.loadCollaborationInfo(false), // Use cache when available
                        fetch(permissionsUrl, {
                            method: 'GET',
                            headers: {
                                'Content-Type': 'application/json',
                                ...this.getAuthHeadersForRequest()
                            }
                        })
                    ];
                } else {
                    // Non-owner: Only use info endpoint
                    apiPromises = [
                        this.loadCollaborationInfo(false), // Use cache when available
                        Promise.resolve({ status: 'skipped', reason: 'non-owner-permissions-skip' }) // Placeholder for permissions
                    ];
                }

                const [infoResult, permissionsResponse] = await Promise.allSettled(apiPromises);

                // üö® DEBUGGING: Process Info endpoint using cached method result
                let documentInfo = null;
                if (infoResult.status === 'fulfilled') {
                    documentInfo = this.collaborationInfo; // Use the cached result
                } else {
                    console.warn('‚ö†Ô∏è INFO LOAD: Failed to load document metadata via cached method', {
                        error: infoResult.reason?.message || 'Unknown error'
                    });
                }

                // ‚úÖ STEP 3: Process Permissions endpoint (user permissions) - Owner-aware
                let permissionsData = null;
                let permissionError = null;

                // Check if permissions endpoint was skipped (non-owner)
                if (permissionsResponse.status === 'fulfilled' && permissionsResponse.value.status === 'skipped') {
                } else if (permissionsResponse.status === 'fulfilled' && permissionsResponse.value.ok) {
                    // Process successful permissions response (owner)
                    try {
                        permissionsData = await permissionsResponse.value.json();
                    } catch (jsonError) {
                        const responseText = await permissionsResponse.value.text();
                        console.error('‚ùå JSON Parse Error in permissions check - Server returned HTML:', {
                            status: permissionsResponse.value.status,
                            responseText: responseText.substring(0, 500) + '...'
                        });
                        permissionsData = null;
                    }

                    // ‚úÖ CACHE PERMISSIONS: Store in CacheService instead of component
                    const documentKey = `${file.owner}/${file.permlink}`;
                    this.cacheService.cacheDocumentPermissions(documentKey, permissionsData.permissions || []);

                } else {
                    // Handle permissions API error (should not happen for non-owners due to skipping)
                    const error = permissionsResponse.status === 'fulfilled' ?
                        permissionsResponse.value :
                        permissionsResponse.reason;

                    permissionError = {
                        status: permissionsResponse.status === 'fulfilled' ? error.status : 'network-error',
                        message: error.message || error.statusText || 'Unknown error'
                    };

                    console.error('‚ùå PERMISSION LOAD: Failed to load user permissions', {
                        document: `${file.owner}/${file.permlink}`,
                        error: permissionError,
                        context: context,
                        requestUrl: isOwner ? permissionsUrl : 'SKIPPED',
                        requestHeaders: this.authHeaders,
                        responseStatus: permissionsResponse.status === 'fulfilled' ? error.status : 'network-error',
                        responseStatusText: permissionsResponse.status === 'fulfilled' ? error.statusText : 'Network error',
                        ownershipNote: isOwner ? 'Owner - unexpected error' : 'Non-owner - should have been skipped'
                    });

                    // ‚úÖ DEBUGGING: Try to get response text for more details (only for real API calls)
                    if (permissionsResponse.status === 'fulfilled' && error.text && isOwner) {
                        try {
                            const responseText = await error.text();
                            console.error('‚ùå PERMISSION API: Response body:', responseText);
                        } catch (textError) {
                            console.error('‚ùå PERMISSION API: Could not read response body:', textError);
                        }
                    }
                }

                // ‚úÖ STEP 4: Unified permission resolution (INFO + PERMISSIONS only)
                const unifiedPermission = this.resolveUnifiedPermission(documentInfo, permissionsData, permissionError, context);

                // Permission caching is handled internally by resolveUnifiedPermission

                // ‚úÖ STEP 5.5: Update collaborative docs cache with fresh server data
                if (documentInfo && documentInfo.accessType) {
                    const collaborativeDocToUpdate = this.collaborativeDocs?.find(doc =>
                        // ‚úÖ UNIFIED: Use helper for document matching
                        this.isDocumentMatch(doc, file));

                    if (collaborativeDocToUpdate) {
                        // Update the cached accessType with fresh server data
                        this.updateDocumentAccessType(collaborativeDocToUpdate, documentInfo.accessType);
                    }
                }

                // ‚úÖ STEP 6: Handle access denial if needed
                if (unifiedPermission.level === 'no-access' && context === 'document-access') {
                    console.warn('üö´ Unified permission resolution: Access denied');
                    // Permissions cleared - computed property will return empty array
                    // ‚úÖ FIX: Call directly without nextTick
                    this.handleDocumentAccessDenied();
                    return;
                }

                // ‚úÖ STEP 7: Set final permissions based on unified resolution
                if (this.permissionService.hasAccess(unifiedPermission.level)) {
                    // Check if permission changed from cached version
                    const currentPermission = this.documentPermissions?.[0]?.permissionType;
                    const newPermission = unifiedPermission.level;
                    const hasPermissionChanged = currentPermission !== newPermission;

                    // Fresh permissions are cached via CacheService - computed property will update

                    // ‚úÖ REACTIVE UPDATE: If permission changed, update UI and editor state
                    if (hasPermissionChanged && isDocumentAccess) {

                        // Permission caching is handled internally by getMasterPermissionForDocument

                        // ‚úÖ COMPREHENSIVE UI UPDATE: Update all permission-dependent UI elements
                        this.$nextTick(() => {
                            // Update editor mode (handles WebSocket reconnection if needed)
                            this.updateEditorMode();

                            // Vue reactivity automatically handled by AuthStateManager's reactive state

                            // Log permission transition for debugging
                        });
                    }
                }

            } catch (error) {
                // Classify error type for appropriate handling
                const isConnectionError = error.message && (
                    error.message.includes('Failed to fetch') ||
                    error.message.includes('ERR_CONNECTION_CLOSED') ||
                    error.message.includes('NetworkError') ||
                    error.message.includes('connection was closed')
                );

                if (isConnectionError && context === 'background-refresh') {
                    // For connection errors during background refresh, preserve cached permissions
                    console.warn('‚ö†Ô∏è PERMISSION LOAD: Connection error during background refresh (cached permissions preserved):', {
                        error: error.message,
                        user: this.username,
                        document: file ? `${file.owner}/${file.permlink}` : 'none',
                        cachedPermissionsCount: this.documentPermissions.length
                    });
                    // Keep existing documentPermissions data
                } else {
                    // For other errors or non-background contexts, log and clear
                    console.error('‚ùå PERMISSION LOAD: Error during unified permission load:', error);
                    // Permissions cleared - computed property will return empty array
                }

                // ‚úÖ ENHANCED FALLBACK: Handle authentication errors gracefully
                if (error.message && error.message.includes('Keychain not available')) {

                    // Use readonly as safe fallback when keychain isn't ready
                    // Note: This fallback is handled by getUserPermissionLevel method
                } else {
                    // ‚úÖ FALLBACK: Try to use cached permissions for offline-first
                    const cachedPermission = this.getUserPermissionLevel(this.currentFile);
                    if (cachedPermission && cachedPermission !== 'unknown') {

                        // Cached permission will be used via computed property
                    }
                }
            } finally {
                this.loadingPermissions = false;
            }
        },

        // ‚úÖ NEW: Unified permission resolution with server compliance
        resolveUnifiedPermission(documentInfo, permissionsData, permissionError, context) {
            // ‚úÖ NULL SAFETY: Handle missing currentFile gracefully
            if (!this.currentFile) {
                // During user switching, skip permission resolution
                if (context === 'user-switch' || this._processingUserChange) {
                    return {
                        level: 'no-access',
                        source: 'user-switching',
                        confidence: 'transient',
                        reasoning: 'Permission resolution skipped during user switch'
                    };
                }
                console.warn('‚ö†Ô∏è PERMISSION RESOLUTION: currentFile is null, using documentInfo fallback');

                // Try to extract document info from parameters
                if (documentInfo && documentInfo.owner && documentInfo.permlink) {
                    const document = `${documentInfo.owner}/${documentInfo.permlink}`;

                    // Check if user is document owner via documentInfo
                    // ‚úÖ UNIFIED: Use getUserPermissionLevel for owner check
                    if (this.isOwnerPermission(this.getUserPermissionLevel(documentInfo))) {
                        return {
                            level: 'owner',
                            source: 'document-owner-fallback',
                            confidence: 'high',
                            reasoning: 'Document owner has full access (via documentInfo)'
                        };
                    }
                } else {
                    console.error('‚ùå PERMISSION RESOLUTION: Cannot resolve permissions - both currentFile and documentInfo are insufficient');
                    return {
                        level: 'no-access',
                        source: 'error-fallback',
                        confidence: 'low',
                        reasoning: 'Cannot determine document context for permission resolution'
                    };
                }
            }

            // ‚úÖ NULL SAFETY: Check currentFile exists before accessing properties
            if (!this.currentFile || !this.currentFile.owner || !this.currentFile.permlink) {
                return {
                    level: 'unknown',
                    source: 'error',
                    confidence: 'none',
                    reasoning: 'No current file or missing owner/permlink'
                };
            }

            const document = `${this.currentFile.owner}/${this.currentFile.permlink}`;

            // ‚úÖ STEP 1: Document owner always has full access
            // ‚úÖ UNIFIED: Use getUserPermissionLevel for owner check
            if (this.isOwnerPermission(this.getUserPermissionLevel(this.currentFile))) {
                return {
                    level: 'owner',
                    source: 'document-owner',
                    confidence: 'high',
                    reasoning: 'Document owner has full access'
                };
            }

            // ‚úÖ STEP 2: Check Info endpoint accessType (HIGHEST PRIORITY - Fresh server data)
            if (documentInfo && documentInfo.accessType) {
                const accessType = documentInfo.accessType.toLowerCase();

                // Parse access type using unified helper
                const parsedPermission = this.parseAccessTypeToPermission(accessType);
                if (parsedPermission) {
                    const reasoningMap = {
                        'postable': 'can publish to blockchain',
                        'editable': 'can edit content',
                        'readonly': 'view only',
                        'owner': 'full control',
                        'no-access': 'access denied'
                    };
                    return {
                        level: parsedPermission,
                        source: 'info-access-type',
                        confidence: 'high',
                        reasoning: `Info endpoint shows accessType: ${documentInfo.accessType} (${reasoningMap[parsedPermission]})`
                    };
                }
            }

            // ‚úÖ STEP 3: Check Permissions endpoint (explicit user permissions)
            if (permissionsData && permissionsData.permissions) {
                // ‚úÖ UNIFIED: Direct permission array access (API response, not our array)
                const userPermission = permissionsData.permissions.find(p => p.account === this.username);
                if (userPermission) {
                    return {
                        level: userPermission.permissionType,
                        source: 'explicit-user-permission',
                        confidence: 'high',
                        reasoning: `User has explicit ${userPermission.permissionType} permission`
                    };
                }
            }

            // ‚úÖ STEP 4: FALLBACK - Check collaborative docs cache (only if no fresh server data)
            if (!documentInfo && !permissionsData) {
                const collaborativeDocFallback = this.collaborativeDocs?.find(doc =>
                    // ‚úÖ UNIFIED: Use helper for document matching
                    this.isDocumentMatch(doc, this.currentFile));

                if (collaborativeDocFallback && collaborativeDocFallback.accessType) {
                    const accessType = collaborativeDocFallback.accessType.toLowerCase();

                    // Parse access type using unified helper
                    const parsedPermission = this.parseAccessTypeToPermission(accessType);
                    if (parsedPermission) {
                        return {
                            level: parsedPermission,
                            source: 'collaborative-docs-cache',
                            confidence: 'medium',
                            reasoning: `Cached collaborative docs shows accessType: ${collaborativeDocFallback.accessType}`
                        };
                    }
                }
            }

            // ‚úÖ STEP 5: Handle permission API errors with Info endpoint context
            if (permissionError) {
                if (permissionError.status === 403) {

                    // ‚úÖ 403 with collaborative list presence = check for enhanced permissions
                    const collaborativeDoc403 = this.collaborativeDocs.find(doc =>
                        // ‚úÖ UNIFIED: Use helper for document matching
                        this.isDocumentMatch(doc, file));

                    if (context === 'file-browser' || collaborativeDoc403) {
                        // ‚úÖ ENHANCED: Use permission indicators from collaborative list
                        if (collaborativeDoc403) {
                            const permissionLevel = collaborativeDoc403.permissionLevel || collaborativeDoc403.permission ||
                                collaborativeDoc403.access || collaborativeDoc403.userPermission;
                            // ‚úÖ COMPLIANCE: Use unified permission system
                            const unifiedPermission = this.getUserPermissionLevel(collaborativeDoc403);
                            const isEditor = this.canEditWithPermission(unifiedPermission);

                            if (permissionLevel) {
                                const parsedPermission = this.parseAccessTypeToPermission(permissionLevel);
                                if (parsedPermission && this.canEditWithPermission(parsedPermission)) {
                                    return {
                                        level: parsedPermission,
                                        source: 'collaborative-list-403-fallback-editor',
                                        confidence: 'medium',
                                        reasoning: `403 on permissions but document has ${permissionLevel} in collaborative list`
                                    };
                                }
                            }

                            if (isEditor === true) {
                                return {
                                    level: 'editable',
                                    source: 'collaborative-list-403-fallback-editor-flag',
                                    confidence: 'medium',
                                    reasoning: '403 on permissions but document marked as editable in collaborative list'
                                };
                            }
                        }

                        return {
                            level: 'readonly',
                            source: 'collaborative-list-implied',
                            confidence: 'medium',
                            reasoning: '403 on permissions but document in collaborative list'
                        };
                    }

                    // ‚úÖ Pure 403 = no access
                    return {
                        level: 'no-access',
                        source: 'permission-api-forbidden',
                        confidence: 'high',
                        reasoning: '403 Forbidden from permissions API'
                    };
                }

                if (permissionError.status === 404) {

                    // ‚úÖ 404 with collaborative list presence = check for enhanced permissions
                    const collaborativeDoc404 = this.collaborativeDocs.find(doc =>
                        // ‚úÖ UNIFIED: Use helper for document matching
                        this.isDocumentMatch(doc, file));

                    if (context === 'file-browser' || collaborativeDoc404) {
                        // ‚úÖ ENHANCED: Use permission indicators from collaborative list
                        if (collaborativeDoc404) {
                            const permissionLevel = collaborativeDoc404.permissionLevel || collaborativeDoc404.permission ||
                                collaborativeDoc404.access || collaborativeDoc404.userPermission;
                            // ‚úÖ COMPLIANCE: Use unified permission system
                            const unifiedPermission404 = this.getUserPermissionLevel(collaborativeDoc404);
                            const isEditor = this.canEditWithPermission(unifiedPermission404);

                            if (permissionLevel) {
                                const parsedPermission = this.parseAccessTypeToPermission(permissionLevel);
                                if (parsedPermission && this.canEditWithPermission(parsedPermission)) {
                                    return {
                                        level: parsedPermission,
                                        source: 'collaborative-list-404-fallback-editor',
                                        confidence: 'medium',
                                        reasoning: `404 on permissions but document has ${permissionLevel} in collaborative list`
                                    };
                                }
                            }

                            if (isEditor === true) {
                                return {
                                    level: 'editable',
                                    source: 'collaborative-list-404-fallback-editor-flag',
                                    confidence: 'medium',
                                    reasoning: '404 on permissions but document marked as editable in collaborative list'
                                };
                            }
                        }

                        return {
                            level: 'readonly',
                            source: 'collaborative-list-404-fallback',
                            confidence: 'medium',
                            reasoning: '404 on permissions but document in collaborative list'
                        };
                    }
                }
            }

            // ‚úÖ STEP 4: Use document metadata for access type
            if (documentInfo) {

                // ‚úÖ ENHANCED: Handle Info endpoint returning minimal data
                const hasMinimalData = !documentInfo.accessType ||
                    documentInfo.accessType === 'private' ||
                    documentInfo.contentStatus === 'unknown' ||
                    documentInfo.hasContent === false;

                if (hasMinimalData) {
                } else {
                    // ‚úÖ ENHANCED: Log document info for debugging when access is restricted
                }
            }

            // ‚úÖ STEP 5: Enhanced collaborative list permission detection
            const collaborativeDoc = this.collaborativeDocs.find(doc =>
                // ‚úÖ UNIFIED: Use helper for document matching
                this.isDocumentMatch(doc, this.currentFile));

            if (collaborativeDoc) {

                // ‚úÖ ENHANCED: Check for permission indicators in collaborative document
                const permissionLevel = collaborativeDoc.permissionLevel || collaborativeDoc.permission ||
                    collaborativeDoc.access || collaborativeDoc.userPermission;
                // ‚úÖ COMPLIANCE: Use unified permission system instead of legacy flags
                const unifiedPermissionCollab = this.getUserPermissionLevel(collaborativeDoc);
                const isEditor = this.canEditWithPermission(unifiedPermissionCollab);
                const isViewer = this.permissionService.hasAccess(unifiedPermissionCollab);

                // ‚úÖ PRIORITY: Use explicit permission level if available
                if (permissionLevel) {
                    const parsedPermission = this.parseAccessTypeToPermission(permissionLevel);
                    if (parsedPermission) {
                        return {
                            level: parsedPermission,
                            source: 'collaborative-list-permission-level',
                            confidence: 'high',
                            reasoning: `Document has explicit ${permissionLevel} permission in collaborative list`
                        };
                    }
                }

                // ‚úÖ FALLBACK: Use boolean permission indicators
                if (isEditor === true) {
                    return {
                        level: 'editable',
                        source: 'collaborative-list-editor-flag',
                        confidence: 'high',
                        reasoning: 'Document marked as editable in collaborative list'
                    };
                }

                if (isViewer === true) {
                    return {
                        level: 'readonly',
                        source: 'collaborative-list-viewer-flag',
                        confidence: 'high',
                        reasoning: 'Document marked as viewable in collaborative list'
                    };
                }

                // ‚úÖ DEFAULT: Document in collaborative list implies readonly access minimum
                return {
                    level: 'readonly',
                    source: 'collaborative-list-presence',
                    confidence: 'medium',
                    reasoning: 'Document exists in user\'s collaborative list'
                };
            }

            // ‚úÖ STEP 6: Default to no access for strict security
            return {
                level: 'no-access',
                source: 'unified-resolution-default',
                confidence: 'high',
                reasoning: 'No explicit permissions found'
            };
        },

        async handleDocumentAccessDenied(documentContext = null) {
            console.log('üö´ AUTH MODAL TRIGGER: handleDocumentAccessDenied called', {
                documentContext,
                timestamp: new Date().toISOString(),
                username: this.username,
                isGuestUser: this.isGuestUser(),
                isAuthenticated: this.isAuthenticated,
                isPermissionLoading: this.isPermissionLoading,
                callStack: new Error().stack.split('\n').slice(1, 5).join('\n')
            });
            
            // ‚úÖ RACE CONDITION FIX: Don't show modal if permissions are still loading
            if (this.isPermissionLoading) {
                console.log('üîÑ Permissions are still loading, deferring access denial handling');
                
                // Set up a watcher to handle access denial once loading completes
                const unwatch = this.$watch('isPermissionLoading', (newVal) => {
                    if (!newVal) {
                        console.log('üîÑ Permissions finished loading, re-evaluating access');
                        unwatch(); // Remove watcher
                        
                        // Re-check permissions now that loading is complete
                        if (this.currentPermissionLevel === 'no-access') {
                            // Actually denied - show modal
                            this.handleDocumentAccessDenied(documentContext);
                        } else {
                            console.log('‚úÖ User has access after loading completed');
                        }
                    }
                });
                
                return; // Exit early - don't show modal while loading
            }

            // Extract document info from current file, passed context, or URL fallback
            let documentInfo = null;

            if (this.currentFile) {
                documentInfo = {
                    type: this.currentFile.type,
                    owner: this.currentFile.owner,
                    permlink: this.currentFile.permlink,
                    id: this.currentFile.id,
                    name: this.currentFile.name || 'document'
                };
            } else if (documentContext) {
                documentInfo = { ...documentContext, name: documentContext.name || 'document' };
            } else {
                // Extract from URL parameters as fallback
                const urlParams = new URLSearchParams(window.location.search);
                const collabOwner = urlParams.get('collab_owner');
                const collabPermlink = urlParams.get('collab_permlink');
                const localOwner = urlParams.get('local_owner');
                const localPermlink = urlParams.get('local_permlink');

                if (collabOwner && collabPermlink) {
                    documentInfo = {
                        type: 'collaborative',
                        owner: collabOwner,
                        permlink: collabPermlink,
                        name: 'document'
                    };
                } else if (localOwner && localPermlink) {
                    documentInfo = {
                        type: 'local',
                        owner: localOwner,
                        permlink: localPermlink,
                        name: 'document'
                    };
                }
            }

            try {
                // IMMEDIATE SECURITY - Clear permissions
                // Permissions cleared via cache - computed property will return empty array

                // ‚úÖ FORCE USERNAME REFRESH: Ensure username is current before auth check
                if (this.authStateManager && this.authHeaders?.['x-account']) {
                    console.log('üîÑ AUTH SYNC: Forcing username sync in handleDocumentAccessDenied', {
                        currentUsername: this.username,
                        authHeadersAccount: this.authHeaders['x-account'],
                        authStateUser: this.authStateManager.getUser(),
                        needsUpdate: this.username !== this.authHeaders['x-account']
                    });
                    this.authStateManager.setUser(this.authHeaders['x-account']);
                }

                // Check if user can authenticate to gain access
                const canAuthenticate = this.canUserAuthenticateForAccess(documentInfo);

                // Conditional cleanup - preserve Y.js document if user can authenticate
                if (canAuthenticate.canAuth) {
                    await this.documentManager.lifecycleManager.partialCleanupForAuth();
                } else {
                    await this.documentManager.lifecycleManager.cleanupDocument();
                }

                // Handle authentication flow using DLUXAuthBridge
                if (canAuthenticate.canAuth && documentInfo) {

                    // ‚úÖ UNIFIED AUTH: Use DLUXAuthBridge directly
                    const authBridge = this.authBridgeInstance;

                    // Check state before showing modal
                    if (authBridge) {
                    }

                    if (authBridge) {
                        // üîê AUTH TIMING: Log the decision logic for action type
                        console.log('üîê AUTH TIMING: Determining auth modal action type', {
                            canAuthenticateReason: canAuthenticate.reason,
                            username: this.username,
                            usernameProp: this.usernameProp,
                            isAuthenticated: this.isAuthenticated,
                            isAuthExpired: this.isAuthExpired,
                            authHeaders: !!this.authHeaders,
                            decision: {
                                'is_switch-user': canAuthenticate.reason === 'switch-user',
                                'is_auth-required': canAuthenticate.reason === 'auth-required',
                                'is_auth-expired': canAuthenticate.reason === 'auth-expired',
                                'is_login-required': canAuthenticate.reason === 'login-required'
                            }
                        });

                        // ‚úÖ TIMING FIX: Better auth modal logic that respects auth loading state
                        let action;
                        if (canAuthenticate.reason === 'switch-user') {
                            action = 'switch_account';
                        } else if (canAuthenticate.reason === 'auth-required' || canAuthenticate.reason === 'auth-expired') {
                            // For logged-in users who need to authenticate
                            action = 'authenticate';
                        } else if (canAuthenticate.reason === 'login-required') {
                            // ‚úÖ SAFETY CHECK: Double-check that this is truly a guest user
                            // If we have a username but somehow got login-required, show authenticate instead
                            if (this.username && this.username !== 'GUEST') {
                                console.warn('‚ö†Ô∏è AUTH MODAL: Safety check triggered - user has username but got login-required', {
                                    username: this.username,
                                    reason: canAuthenticate.reason,
                                    override: 'showing authenticate instead of login'
                                });
                                action = 'authenticate';
                            } else {
                                // Show login only for truly guest users
                                action = 'login';
                            }
                        } else {
                            // Default to authenticate for uncertain cases
                            action = 'authenticate';
                        }

                        console.log('üîê AUTH TIMING: Auth modal action selected', {
                            selectedAction: action,
                            reason: canAuthenticate.reason,
                            username: this.username,
                            isGuestUser: this.isGuestUser(),
                            expectedBehavior: action === 'login' ? 'Show login modal' :
                                action === 'authenticate' ? 'Show authenticate modal' :
                                    'Show switch account modal'
                        });

                        authBridge.showAuthPrompt(action, documentInfo);

                        // Check state after showing modal
                    } else {
                        console.error('‚ùå Auth bridge is null - cannot show auth prompt!');
                    }

                } else {
                    // User cannot authenticate - just show error message
                    this.connectionStatus = 'permission-denied';
                    this.connectionMessage = 'Access denied. Please contact the document owner for permissions.';
                }

            } catch (error) {
                console.error('‚ùå Error during document security cleanup:', error);

                // Emergency cleanup if standard cleanup fails
                try {
                    await this.emergencyWebGLCleanup();
                    await this.documentManager.newDocument();
                } catch (fallbackError) {
                    console.error('‚ùå Emergency cleanup also failed:', fallbackError);
                    // Force page refresh as last resort for security
                    window.location.reload();
                }
            }
        },

        /**
         * ‚úÖ UNIFIED PRE-FLIGHT CHECK: Simplified to use getUserPermissionLevel consistently
         * @param {Object} documentInfo - Document information  
         * @returns {boolean} true if user has access, false otherwise
         */
        checkDocumentPermissionsPreFlight(documentInfo) {
            // ‚úÖ CONSOLIDATED: Delegate to PermissionService
            const canConnect = this.permissionService.canAttemptConnection(
                documentInfo,
                this.username,
                this.isAuthenticated,
                this.isAuthExpired,
                this.collaborativeDocs,
                this.isLoadingCollaborativeDocs,  // ‚úÖ RACE CONDITION FIX: Pass loading state
                this.authStateManager  // ‚úÖ RULE #3: Pass AuthStateManager for cache checking
            );

            console.log('üöÄ PRE-FLIGHT: Permission check result', {
                documentInfo,
                username: this.username,
                canConnect,
                isAuthenticated: this.isAuthenticated,
                collaborativeDocsCount: this.collaborativeDocs?.length || 0,
                isLoadingCollaborativeDocs: this.isLoadingCollaborativeDocs
            });

            return canConnect;
        },

        // Original implementation kept for reference during transition
        _checkDocumentPermissionsPreFlight_OLD(documentInfo) {
            console.log('üöÄ PRE-FLIGHT: Checking document permissions', {
                documentInfo,
                username: this.username,
                isAuthenticated: this.isAuthenticated,
                isLoadingCollaborativeDocs: this.isLoadingCollaborativeDocs,
                collaborativeDocsCount: this.collaborativeDocs?.length || 0
            });

            // Basic validation
            // ‚úÖ UNIFIED: Use helper for guest check
            if (!documentInfo || this.isGuestUser()) {
                console.log('üöÄ PRE-FLIGHT: Missing basic requirements');
                return false;
            }

            // Authentication check
            if (!this.isAuthenticated || this.isAuthExpired) {
                console.log('üöÄ PRE-FLIGHT: User not authenticated or auth expired');
                return false;
            }

            // ‚úÖ FIX: Allow authenticated users to attempt connection
            // The server will handle the actual permission validation
            // This is especially important after authentication when collaborativeDocs might not be loaded yet
            if (this.isAuthenticated && !this.isAuthExpired) {
                // Check if user is the owner - owners always have access
                if (documentInfo.owner === this.username) {
                    console.log('üöÄ PRE-FLIGHT: User is document owner - allowing connection');
                    return true;
                }

                // Check if document is in collaborative docs list
                const isInCollabDocs = this.collaborativeDocs?.some(d =>
                    d.owner === documentInfo.owner && d.permlink === documentInfo.permlink
                );

                if (isInCollabDocs) {
                    console.log('üöÄ PRE-FLIGHT: Document found in collaborative docs - allowing connection');
                    return true;
                }

                // ‚úÖ LENIENT CHECK: If collaborative docs is empty or still loading, allow attempt
                // This handles the case where user just authenticated and docs haven't loaded yet
                if (!this.collaborativeDocs || this.collaborativeDocs.length === 0) {
                    console.log('üöÄ PRE-FLIGHT: Collaborative docs not loaded yet - allowing connection attempt for authenticated user');
                    return true;
                }

                // If we have a loaded collaborative docs list and document isn't in it, check permission level
                const permissionLevel = this.getUserPermissionLevel(documentInfo);
                const hasAccess = this.permissionService.hasAccess(permissionLevel);

                console.log('üöÄ PRE-FLIGHT: Permission check result:', {
                    document: `${documentInfo.owner}/${documentInfo.permlink}`,
                    type: documentInfo.type,
                    permissionLevel,
                    hasAccess,
                    reasoning: 'Document not in collaborative docs list'
                });

                return hasAccess;
            }

            return false;
        },

        /**
         * ‚úÖ PERMISSION CHECK: Check if current user has permission to access document
         * @param {Object} documentInfo - Document information
         * @returns {boolean} true if user has access, false otherwise
         */
        checkDocumentPermissions(documentInfo) {

            // ‚úÖ UNIFIED: Use helper for guest check
            if (!documentInfo || this.isGuestUser()) {
                return false;
            }

            // ‚úÖ USER SWITCH VALIDATION: Ensure we're not using stale authentication state
            if (!this.isAuthenticated || this.isAuthExpired) {
                return false;
            }

            // For collaborative documents, check if user is owner or has cached permissions
            if (documentInfo.type !== 'local') {
                // If user is the document owner, they have access
                // ‚úÖ UNIFIED: Use getUserPermissionLevel for owner check
                if (this.isOwnerPermission(this.getUserPermissionLevel(documentInfo))) {
                    return true;
                }

                // ‚úÖ REACTIVE PERMISSION CHECK: Use computed property which auto-updates
                const hasValidPermission = this.currentPermissionLevel &&
                    this.permissionService.hasAccess(this.currentPermissionLevel) &&
                    this.currentPermissionLevel !== 'unknown';

                if (hasValidPermission) {
                    return true;
                }

                return false;
            }

            // For local documents, user needs to be the owner
            // ‚úÖ UNIFIED: Use getUserPermissionLevel for local access check
            const hasLocalAccess = this.isOwnerPermission(this.getUserPermissionLevel(documentInfo));

            return hasLocalAccess;
        },

        canUserAuthenticateForAccess(fallbackDocumentInfo = null) {

            // ‚úÖ COMPREHENSIVE DEBUG: Determine if user can potentially gain access through authentication

            // ‚úÖ FIX: For permission checks, prioritize URL context over temp documents
            // Check if fallback is from URL context (collaborative documents)
            const isUrlContext = fallbackDocumentInfo &&
                (fallbackDocumentInfo.type === 'collaborative' || fallbackDocumentInfo.type === 'local') &&
                fallbackDocumentInfo.owner && fallbackDocumentInfo.permlink;

            // Priority: URL context > currentFile > fallback
            const documentInfo = isUrlContext ? fallbackDocumentInfo : (this.currentFile || fallbackDocumentInfo);

            if (!documentInfo) {
                return { canAuth: false, reason: 'no-document' };
            }

            const isLocal = documentInfo.type === 'local';
            const isTemp = documentInfo.type === 'temp';

            // ‚úÖ TEMP DOCUMENTS: No authentication needed for temporary documents
            if (isTemp) {
                return { canAuth: false, reason: 'temp-document' };
            }

            if (isLocal) {
                // ‚úÖ STREAMLINED LOCAL DOCUMENT LOGIC: Simple ownership check
                // ‚úÖ UNIFIED: Use helper for guest check
                if (this.isGuestUser()) {
                    console.log('üîê AUTH TIMING: Local doc - isGuestUser() returned true', {
                        username: this.username,
                        account: this.account,
                        isGuestUser: true
                    });
                    return { canAuth: true, reason: 'login-required' };
                }
                // Simple ownership check: can user switch to correct account?
                // ‚úÖ UNIFIED: Use helper for owner check
                const canSwitch = !this.isUserOwner(documentInfo);
                return { canAuth: canSwitch, reason: canSwitch ? 'switch-user' : 'has-access' };
            } else {
                // For collaborative documents

                // üîê AUTH TIMING: Add detailed logging for the critical decision point
                console.log('üîê AUTH TIMING: Collaborative doc access decision point', {
                    username: this.username,
                    account: this.account,
                    isGuestUser: this.isGuestUser(),
                    isAuthenticated: this.isAuthenticated,
                    isAuthExpired: this.isAuthExpired,
                    usernameProp: this.usernameProp,
                    authHeaders: !!this.authHeaders,
                    authHeadersAccount: this.authHeaders?.['x-account'],
                    timestamp: new Date().toISOString()
                });

                // ‚úÖ TIMING FIX: Check if we have enough info to make a decision
                // If username is still being resolved, we can check authLoading
                if (this.authLoading) {
                    console.log('üîê AUTH TIMING: Auth still loading - cannot determine auth requirement yet', {
                        username: this.username,
                        authLoading: true
                    });
                    // Return a special case that won't trigger the modal
                    return { canAuth: false, reason: 'auth-loading' };
                }

                // ‚úÖ FIX: Check for logged-in but unauthenticated users FIRST
                // This ensures users with usernames get the "authenticate" modal, not "login"
                if (this.username && this.username !== 'GUEST' && !this.isAuthenticated) {
                    console.log('üîê AUTH TIMING: User needs to authenticate', {
                        username: this.username,
                        isAuthenticated: false,
                        authHeaders: !!this.authHeaders,
                        authLoading: this.authLoading,
                        decision: 'AUTHENTICATE modal (not login)'
                    });
                    const result = { canAuth: true, reason: 'auth-required' };
                    return result;
                }

                // ‚úÖ UNIFIED: Only check for guest AFTER confirming no username
                if (this.isGuestUser()) {
                    console.log('üîê AUTH TIMING: isGuestUser() check details', {
                        username: this.username,
                        usernameType: typeof this.username,
                        usernameValue: this.username,
                        isNull: this.username === null,
                        isUndefined: this.username === undefined,
                        isGUEST: this.username === 'GUEST',
                        isEmpty: this.username === '',
                        isGuestUserResult: true
                    });
                    const result = { canAuth: true, reason: 'login-required' };
                    return result;
                }

                if (this.isAuthExpired) {
                    const result = { canAuth: true, reason: 'auth-expired' };
                    return result;
                }

                // ‚úÖ PRE-FLIGHT PERMISSION CHECK: Use collaborative docs list to avoid 403 errors
                const hasActualPermission = this.checkDocumentPermissionsPreFlight(documentInfo);
                if (!hasActualPermission) {

                    // Check if this could be a user who needs authentication
                    if (!this.isAuthenticated) {
                        const result = { canAuth: true, reason: 'auth-required' };
                        return result;
                    }
                }

                // ‚úÖ PRE-FLIGHT PERMISSION CHECK: Use collaborative docs list to avoid 403 errors
                const hasPermission = this.checkDocumentPermissionsPreFlight(documentInfo);
                if (hasPermission) {
                    const result = { canAuth: false, reason: 'has-access' };
                    return result;
                }

                // If logged in and authenticated but still no access, they need different user
                const result = { canAuth: true, reason: 'switch-user' };
                return result;
            }
        },

        // ‚úÖ REMOVED: showAuthenticationPrompt and fallbackAuthenticationPrompt - all callers now use DLUXAuthBridge directly

        /**
         * ‚úÖ CONNECTION CLEANUP: Cancel all pending HTTP requests during user switch
         * Prevents ERR_CONNECTION_CLOSED errors from connection reuse
         */
        cancelAllPendingRequests(reason = 'user-switch') {
            console.log('üîÑ CONNECTION CLEANUP: Canceling all pending HTTP requests:', {
                reason,
                hasLoadCollabController: !!this.loadCollaborativeDocsController,
                hasPermissionController: !!this.permissionLoadController,
                timestamp: new Date().toISOString()
            });

            // Cancel collaborative docs loading
            if (this.loadCollaborativeDocsController) {
                try {
                    this.loadCollaborativeDocsController.abort();
                    console.log('‚úÖ Cancelled collaborative docs request');
                } catch (error) {
                    console.warn('‚ö†Ô∏è Error cancelling collaborative docs request:', error.message);
                }
                this.loadCollaborativeDocsController = null;
            }

            // Cancel permission loading requests
            if (this.permissionLoadController) {
                try {
                    this.permissionLoadController.abort();
                    console.log('‚úÖ Cancelled permission load request');
                } catch (error) {
                    console.warn('‚ö†Ô∏è Error cancelling permission load request:', error.message);
                }
                this.permissionLoadController = null;
            }

            // Cancel any other pending requests
            // Note: Add other AbortControllers here as needed

            console.log('‚úÖ All pending HTTP requests cancelled for user switch');
        },

        /**
         * ‚úÖ CACHE BUSTING: Reset connection pool state for new user
         * Forces fresh connections to prevent auth header mismatches
         */
        resetConnectionPoolForUserSwitch(oldUser, newUser) {
            console.log('üîÑ CONNECTION POOL RESET: Preparing fresh connections for new user:', {
                oldUser,
                newUser,
                timestamp: new Date().toISOString()
            });

            // Generate cache-busting parameter for new user
            this.userSwitchTimestamp = Date.now();

            console.log('‚úÖ Connection pool reset complete - ready for new user requests');
        },

        /**
         * ‚úÖ MANUAL VALIDATION TRIGGER: Force validation check when watchers fail
         * Called as backup when username watchers don't fire properly
         */
        triggerUsernameValidationCheck(reason = 'manual-trigger') {

            const authBridge = this.authBridgeInstance;
            if (authBridge?.authState?.pendingDocumentAccess) {
                this.$nextTick(() => {
                    this.validateAccountForPendingDocument(authBridge.authState.pendingDocumentAccess);
                });
            } else {
            }
        },

        /**
         * ‚úÖ ACCOUNT CHANGE VALIDATION: Validate account permissions for pending document access
         * Called when account changes and there's pending document access
         */
        async validateAccountForPendingDocument(pendingDocumentAccess) {
            // ‚úÖ RECURSION GUARD: Prevent recursive validation
            if (this._validatingAccount) {
                console.log('üõ°Ô∏è Validation already in progress, preventing recursion');
                return;
            }
            
            if (!pendingDocumentAccess) {
                return;
            }
            
            this._validatingAccount = true;

            try {
                // Check if the new account has access to the pending document
                const permissionCheck = this.canUserAuthenticateForAccess(pendingDocumentAccess);

                // If user has access, try to load the document
                if (!permissionCheck.canAuth && permissionCheck.reason === 'has-access') {

                    // ‚úÖ STREAMLINED: Clear current document FIRST before loading new one
                    if (this.currentFile) {
                        await this.documentManager.lifecycleManager.cleanupDocument();
                    }

                    // Clear loading states and attempt document load
                    this.connectionStatus = 'connecting';
                    this.connectionMessage = 'Loading document with new account...';
                    this.isLoadingFromURL = true;

                    // Load the document based on type
                    let loadSuccess = false;
                    try {
                        if (pendingDocumentAccess.type === 'local') {
                            await this.autoConnectToLocalDocument(pendingDocumentAccess.owner, pendingDocumentAccess.permlink);
                            loadSuccess = true;
                        } else {
                            // For collaborative documents, use loadDocument directly to avoid duplicate auth checks
                            const documentToLoad = {
                                id: pendingDocumentAccess.id || `${pendingDocumentAccess.owner}/${pendingDocumentAccess.permlink}`,
                                name: pendingDocumentAccess.name || pendingDocumentAccess.permlink,
                                documentName: pendingDocumentAccess.name || pendingDocumentAccess.permlink,
                                owner: pendingDocumentAccess.owner,
                                permlink: pendingDocumentAccess.permlink,
                                type: 'collaborative',
                                isCollaborative: true
                            };

                            await this.loadDocument(documentToLoad);
                            loadSuccess = true;
                        }
                    } catch (error) {
                        loadSuccess = false;
                    }

                    if (loadSuccess) {
                        // Success - clear pending access and loading state
                        const authBridge = this.authBridgeInstance;
                        if (authBridge) {
                            authBridge.clearPendingAccess('document-loaded');
                        }
                        this.connectionStatus = 'connected';
                        this.connectionMessage = '';
                        this.isLoadingFromURL = false;

                    } else {
                        this.connectionStatus = 'error';
                        this.connectionMessage = 'Failed to load document';
                    }

                } else if (permissionCheck.canAuth) {
                    // User still needs authentication/different account

                    if (permissionCheck.reason === 'switch-user') {
                        // Already authenticated but still wrong user

                        // Force refresh collaborative docs list to ensure we have latest permissions
                        await this.loadCollaborativeDocs(true); // Force refresh

                        // Re-check permissions after refresh
                        const recheckPermission = this.canUserAuthenticateForAccess(pendingDocumentAccess);

                        if (!recheckPermission.canAuth && recheckPermission.reason === 'has-access') {
                            // User now has access after refresh!
                            await this.autoConnectToCollaborativeDocument(pendingDocumentAccess.owner, pendingDocumentAccess.permlink);
                            return;
                        }

                        // Still no access - show switch account modal
                        // üö™ ACCESS DEBUG: Log decision to show switch user modal

                        // ‚úÖ UNIFIED AUTH: Use DLUXAuthBridge directly
                        const authBridge = this.authBridgeInstance;
                        if (authBridge) {
                            authBridge.showAuthPrompt('switch_account', pendingDocumentAccess);
                        }
                    } else if (permissionCheck.reason === 'auth-required' || permissionCheck.reason === 'auth-expired') {
                        // User needs to authenticate
                        // ‚úÖ UNIFIED AUTH: Use DLUXAuthBridge directly
                        const authBridge = this.authBridgeInstance;
                        if (authBridge) {
                            authBridge.showAuthPrompt('authenticate', pendingDocumentAccess);
                        }
                    } else {
                        // ‚úÖ SAFETY CHECK: Determine proper auth modal type
                        const authBridge = this.authBridgeInstance;
                        if (authBridge) {
                            // If we have a username but somehow got here, show authenticate instead of login
                            const modalType = (this.username && this.username !== 'GUEST') ? 'authenticate' : 'login';
                            if (modalType === 'authenticate' && permissionCheck.reason === 'login-required') {
                                console.warn('‚ö†Ô∏è AUTH MODAL: Safety check in validateAccount - user has username but got login-required', {
                                    username: this.username,
                                    reason: permissionCheck.reason,
                                    override: 'showing authenticate instead of login'
                                });
                            }
                            authBridge.showAuthPrompt(modalType, pendingDocumentAccess);
                        }
                    }
                } else {
                    // Permission check failed for unknown reason
                    this.connectionStatus = 'error';
                    this.connectionMessage = 'Unable to determine document access permissions. Please try again.';
                    this.isLoadingFromURL = false;
                }

            } catch (error) {
                console.error('‚ùå Error validating account for pending document:', error);

                // Show error and reset states
                this.connectionStatus = 'error';
                this.connectionMessage = 'Failed to load document with new account. Please try again.';
                this.isLoadingFromURL = false;
            } finally {
                // ‚úÖ RECURSION GUARD: Always clear the flag
                this._validatingAccount = false;
            }
        },

        /**
         * ‚úÖ SIMPLE LOCAL DOCUMENT OWNER: Get owner from Y.js config (authoritative source)
         */
        getLocalDocumentOwner() {
            if (!ydocService.isReady()) return this.currentFile?.owner;

            return ydocService.getConfig('owner') || this.currentFile?.owner;
        },

        /**
         * ‚úÖ DEDICATED LOCAL DOCUMENT USER SWITCH: Clean method specifically for user boundary violations
         * This method handles the complete lifecycle of switching users on local documents
         */
        async clearLocalDocumentForUserSwitch(documentOwner, currentUser, source = 'generic') {
            console.log('üîÑ USER SWITCH: clearLocalDocumentForUserSwitch called', {
                documentOwner,
                currentUser,
                source,
                currentFile: this.currentFile
            });

            // Event-driven architecture prevents duplicate handling

            try {
                // Begin local document user switch

                // Step 1: CRITICAL - Clear all authentication context to prevent cross-contamination
                const authBridge = this.authBridgeInstance;
                if (authBridge) {
                    console.log('üîë CONTAMINATION FIX: Clearing authentication context during user switch');
                    authBridge.hideAuthPrompt(); // Clear any pending document access

                }

                // Step 2: Capture clean document info for the correct owner
                const documentInfo = {
                    name: this.currentFile?.name || this.currentFile?.documentName || `${documentOwner}'s document`,
                    owner: documentOwner,
                    permlink: this.currentFile?.permlink,
                    id: this.currentFile?.id,
                    type: 'local'
                };

                // Step 4: Perform complete document cleanup (no partial cleanup for user switches)
                console.log('üîÑ USER SWITCH: Performing complete document cleanup for user boundary violation');
                await this.documentManager.lifecycleManager.cleanupDocument();

                // Step 5: Show fresh authentication modal with clean context
                if (authBridge) {
                    console.log('üîë USER BOUNDARY: Showing fresh auth modal for user switch', {
                        fromUser: currentUser,
                        toUser: documentOwner,
                        documentInfo
                    });
                    authBridge.showAuthPrompt('switch_account', documentInfo);
                } else {
                    console.warn('‚ö†Ô∏è Auth bridge not available during user switch');
                    // Set error state since we can't show auth prompt
                    this.connectionStatus = 'error';
                    this.connectionMessage = 'Authentication system unavailable. Please refresh the page.';
                }

                console.log('‚úÖ USER SWITCH: Local document user switch completed successfully');
            } catch (error) {
                console.error('‚ùå USER SWITCH: Error during local document user switch:', error);
                // Ensure cleanup happens even on error
                await this.documentManager.lifecycleManager.cleanupDocument();
                const authBridge = this.authBridgeInstance;
                if (authBridge) {
                    authBridge.hideAuthPrompt(); // Clear any contaminated context
                }
            } finally {
                // User switch complete
            }
        },

        async clearAllCloudFiles() {
            // ‚úÖ SAFETY CHECK: If current document is collaborative, warn and offer to create new document first
            if (this.currentFile && this.currentFile.owner && this.currentFile.permlink && this.isOwner) {
                const currentDocName = this.currentFile.name || this.currentFile.documentName || 'current document';
                if (!confirm(`‚ö†Ô∏è You are currently editing a cloud document: "${currentDocName}"\n\nThis document will be deleted in the clear operation.\n\nDo you want to continue and create a new document?\n\n(Click Cancel to save your work first)`)) {
                    return;
                }

                await this.documentManager.lifecycleManager.cleanupDocument();
                await this.documentManager.newDocument();

            }

            if (!confirm('‚ö†Ô∏è This will delete ALL cloud documents you own. This action cannot be undone. Are you sure?')) {
                return;
            }

            if (!this.isAuthenticated) {
                this.requestAuthentication();
                return;
            }

            try {
                // ‚úÖ OFFLINE-FIRST: Load collaborative docs for deletion (still need to wait for this one)
                await this.loadCollaborativeDocs();

                if (this.collaborativeDocs.length === 0) {
                    alert('No cloud documents found to delete.');
                    return;
                }

                const ownedDocs = this.collaborativeDocs.filter(doc => this.canDeleteFile(doc));

                if (ownedDocs.length === 0) {
                    alert('No cloud documents owned by you found to delete.');
                    return;
                }

                // Confirm again with exact count
                if (!confirm(`This will delete ${ownedDocs.length} cloud document(s) that you own:\n\n${ownedDocs.map(d => `- ${d.documentName || d.name}`).join('\n')}\n\nContinue?`)) {
                    return;
                }

                let deletedCount = 0;
                let errorCount = 0;

                for (const doc of ownedDocs) {
                    try {
                        const response = await fetch(`https://data.dlux.io/api/collaboration/documents/${doc.owner}/${doc.permlink}`, {
                            method: 'DELETE',
                            headers: {
                                'Content-Type': 'application/json',
                                ...this.getAuthHeadersForRequest()
                            }
                        });

                        if (response.ok) {
                            deletedCount++;

                            // Also delete the local IndexedDB copies
                            // Cloud documents can have multiple IndexedDB keys
                            const possibleKeys = [
                                `${this.username}__${doc.owner}/${doc.permlink}`, // User-isolated key
                                `${doc.owner}/${doc.permlink}`, // Direct owner/permlink key
                                `markegiles__${doc.owner}/${doc.permlink}`, // Hardcoded username key (legacy)
                                `dlux-collaborative-${doc.owner}-${doc.permlink}` // Legacy pattern
                            ];

                            // Also scan for any database containing this permlink or owner
                            if (indexedDB.databases) {
                                try {
                                    const allDatabases = await indexedDB.databases();
                                    for (const db of allDatabases) {
                                        if (db.name && (
                                            db.name.includes(doc.permlink) ||
                                            (db.name.includes(doc.owner) && db.name.includes('/'))
                                        )) {
                                            possibleKeys.push(db.name);
                                        }
                                    }

                                    // Also check localStorage for any local files that were converted to this cloud document
                                    const localFiles = this.documentStorageService.getAllDocuments();
                                    const convertedFiles = localFiles.filter(f =>
                                        f.cloudOwner === doc.owner && f.cloudPermlink === doc.permlink
                                    );

                                    for (const convertedFile of convertedFiles) {
                                        if (convertedFile.id) {
                                            possibleKeys.push(convertedFile.id);
                                            // Remove from localStorage
                                            const updatedLocalFiles = localFiles.filter(f => f.id !== convertedFile.id);
                                            this.documentStorageService.saveAllDocuments(updatedLocalFiles);
                                        }
                                    }
                                } catch (scanError) {
                                    console.warn('‚ö†Ô∏è Could not scan for additional database keys:', scanError);
                                }
                            }

                            // Remove duplicates
                            const uniqueKeys = [...new Set(possibleKeys)];

                            for (const indexedDBKey of uniqueKeys) {
                                try {
                                    const deleteReq = indexedDB.deleteDatabase(indexedDBKey);
                                    await new Promise((resolve) => {
                                        deleteReq.onsuccess = () => {
                                            resolve();
                                        };
                                        deleteReq.onerror = () => {
                                            // Silently continue - database might not exist
                                            resolve();
                                        };
                                        deleteReq.onblocked = () => {
                                            console.warn('‚ö†Ô∏è Database deletion blocked:', indexedDBKey);
                                            resolve(); // Continue anyway
                                        };
                                    });
                                } catch (localError) {
                                    // Continue with next key
                                }
                            }
                        } else {
                            errorCount++;
                            console.error('Failed to delete cloud document:', doc.documentName, response.statusText);
                        }
                    } catch (error) {
                        errorCount++;
                        console.error('Error deleting cloud document:', doc.documentName, error);
                    }
                }

                // Final sweep - check all IndexedDB databases for any we might have missed
                if (indexedDB.databases && deletedCount > 0) {
                    try {
                        const remainingDatabases = await indexedDB.databases();
                        let additionalDeleted = 0;

                        for (const db of remainingDatabases) {
                            // Check if this database belongs to any of the deleted documents
                            for (const doc of ownedDocs) {
                                if (db.name && (
                                    db.name.includes(doc.permlink) ||
                                    db.name.includes(`${doc.owner}/${doc.permlink}`) ||
                                    db.name === `local_${doc.permlink}` // In case permlink was reused
                                )) {
                                    try {
                                        const deleteReq = indexedDB.deleteDatabase(db.name);
                                        await new Promise((resolve) => {
                                            deleteReq.onsuccess = () => {
                                                additionalDeleted++;
                                                resolve();
                                            };
                                            deleteReq.onerror = resolve;
                                            deleteReq.onblocked = resolve;
                                        });
                                    } catch (err) {
                                        // Continue
                                    }
                                }
                            }
                        }

                        if (additionalDeleted > 0) {
                        }
                    } catch (sweepError) {
                        console.warn('‚ö†Ô∏è Final sweep encountered error:', sweepError);
                    }
                }

                // Also refresh local files to remove any orphaned entries
                await this.loadLocalFiles();

                // Refresh the collaborative docs list
                await this.loadCollaborativeDocs();

                alert(`Cloud file cleanup complete:\n- Deleted: ${deletedCount} documents (cloud and local copies)\n- Errors: ${errorCount} documents`);

            } catch (error) {
                console.error('‚ùå Failed to clear cloud files:', error);
                alert('Error clearing cloud files: ' + error.message);
            }
        },

        // Enhanced delete document with collaborative support
        async deleteCollaborativeDocument(file) {
            if (!file || file.type !== 'collaborative') return;

            if (!this.isAuthenticated) {
                this.requestAuthentication();
                return;
            }

            try {
                const response = await fetch(`https://data.dlux.io/api/collaboration/documents/${file.owner}/${file.permlink}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        ...this.getAuthHeadersForRequest()
                    }
                });

                if (response.ok) {

                    // Delete all possible local IndexedDB copies
                    const possibleKeys = [
                        `${this.username}__${file.owner}/${file.permlink}`, // User-isolated key
                        `${file.owner}/${file.permlink}`, // Direct owner/permlink key
                        `markegiles__${file.owner}/${file.permlink}`, // Hardcoded username key (legacy)
                        `dlux-collaborative-${file.owner}-${file.permlink}` // Legacy pattern
                    ];

                    // Also scan for any database containing this permlink
                    if (indexedDB.databases) {
                        try {
                            const allDatabases = await indexedDB.databases();
                            for (const db of allDatabases) {
                                if (db.name && db.name.includes(file.permlink)) {
                                    possibleKeys.push(db.name);
                                }
                            }
                        } catch (scanError) {
                            console.warn('‚ö†Ô∏è Could not scan for additional database keys:', scanError);
                        }
                    }

                    // Remove duplicates
                    const uniqueKeys = [...new Set(possibleKeys)];

                    for (const indexedDBKey of uniqueKeys) {
                        try {
                            const deleteReq = indexedDB.deleteDatabase(indexedDBKey);
                            await new Promise((resolve) => {
                                deleteReq.onsuccess = () => {
                                    resolve();
                                };
                                deleteReq.onerror = () => {
                                    // Silently continue - database might not exist
                                    resolve();
                                };
                                deleteReq.onblocked = () => {
                                    console.warn('‚ö†Ô∏è Database deletion blocked:', indexedDBKey);
                                    resolve(); // Continue anyway
                                };
                            });
                        } catch (localError) {
                            // Continue with next key
                        }
                    }

                    // Refresh collaborative docs list
                    // ‚úÖ OFFLINE-FIRST: Non-blocking collaborative docs refresh
                    this.loadCollaborativeDocs().catch(error => {
                        console.warn('‚ö†Ô∏è Background collaborative docs refresh failed:', error);
                    });

                    // If this was the current file, create new document
                    if (this.currentFile && this.currentFile.permlink === file.permlink && this.currentFile.owner === file.owner) {
                        await this.documentManager.newDocument();
                    }

                } else {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    throw new Error(`Failed to delete collaborative document: ${errorData.error || response.statusText}`);
                }

            } catch (error) {
                console.error('‚ùå Failed to delete collaborative document:', error);
                alert('Error deleting collaborative document: ' + error.message);
            }
        },

        // ‚úÖ COLLABORATIVE DOCUMENT NAME UPDATE: Sync document name to server metadata
        async updateCollaborativeDocumentName(newDocumentName) {
            if (!this.currentFile || this.currentFile.type !== 'collaborative') {
                console.warn('‚ö†Ô∏è Cannot update document name: Not a collaborative document');
                return;
            }

            if (!this.isAuthenticated) {
                console.warn('‚ö†Ô∏è Cannot update document name: Authentication required');
                this.requestAuthentication();
                return;
            }

            const { owner, permlink } = this.currentFile;
            if (!owner || !permlink) {
                console.warn('‚ö†Ô∏è Cannot update document name: Missing owner or permlink');
                return;
            }

            try {

                // Update save status to show syncing
                this.updateSaveStatus('saving', 'Syncing document name to server...');

                const response = await fetch(`https://data.dlux.io/api/collaboration/documents/${owner}/${permlink}/name`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        ...this.getAuthHeadersForRequest()
                    },
                    body: JSON.stringify({
                        documentName: newDocumentName
                    })
                });

                if (response.ok) {
                    const data = await response.json();

                    // Update save status
                    this.updateSaveStatus('saved', 'Document name synced to server');

                    // ‚úÖ CACHE UPDATE: Update cached metadata to prevent reversion
                    if (data.document) {
                        // Update metadata with server response - caching handled internally
                        documentService.updateDocumentMetadata(`${owner}/${permlink}`, {
                            documentName: data.document.documentName || newDocumentName,
                            timestamp: Date.now(),
                            owner,
                            permlink
                        });

                        // Also update collaborative docs cache if present
                        const cachedDocs = this.collaborativeDocs.find(doc =>
                            doc.owner === owner && doc.permlink === permlink
                        );
                        if (cachedDocs) {
                            cachedDocs.documentName = data.document.documentName || newDocumentName;
                            cachedDocs.name = data.document.documentName || newDocumentName;
                        }

                        // ‚úÖ UPDATE LOCALSTORAGE CACHE: Ensure the cache reflects the new name
                        try {
                            const cacheData = this.cacheService.getCachedCollaborativeDocs(this.username);
                            if (cacheData) {
                                if (cacheData.documents && Array.isArray(cacheData.documents)) {
                                    // Find and update the document in the cache
                                    const docIndex = cacheData.documents.findIndex(doc =>
                                        doc.owner === owner && doc.permlink === permlink
                                    );
                                    if (docIndex >= 0) {
                                        cacheData.documents[docIndex].documentName = data.document.documentName || newDocumentName;
                                        cacheData.documents[docIndex].name = data.document.documentName || newDocumentName;

                                        // Update timestamp to keep cache fresh
                                        cacheData.timestamp = Date.now();

                                        // Save back to cache
                                        this.cacheService.cacheCollaborativeDocs(cacheData.documents, this.authStateManager?.state?.user);
                                    }
                                }
                            }
                        } catch (cacheError) {
                            console.warn('‚ö†Ô∏è Could not update collaborative docs cache:', cacheError);
                        }
                    }

                    return data;
                } else {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    throw new Error(`Server error: ${errorData.error || response.statusText}`);
                }

            } catch (error) {
                console.error('‚ùå Failed to update document name on server:', error);

                // Update save status to show error
                this.updateSaveStatus('error', `Failed to sync name: ${error.message}`);

                // Don't revert local changes - user can retry
                throw error;
            }
        },

        async shareWithUser() {

            if (!this.shareForm?.username || !this.shareForm?.permission) {
                alert('Please enter a username and select a permission level');
                return;
            }

            if (!this.currentFile || this.currentFile.type !== 'collaborative') {
                alert('Can only share collaborative documents');
                return;
            }

            if (!this.isAuthenticated) {
                this.requestAuthentication();
                return;
            }

            const username = this.shareForm.username.trim();

            try {
                const requestPayload = {
                    targetAccount: username,
                    permissionType: this.shareForm.permission
                };

                const response = await fetch(`https://data.dlux.io/api/collaboration/permissions/${this.currentFile.owner}/${this.currentFile.permlink}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...this.getAuthHeadersForRequest()
                    },
                    body: JSON.stringify(requestPayload)
                });

                if (response.ok) {
                    // Get the raw response text to see what we're actually getting
                    const responseText = await response.text();

                    // Try to parse as JSON if there's content
                    let responseData = {};
                    if (responseText.trim()) {
                        try {
                            responseData = JSON.parse(responseText);
                        } catch (jsonError) {
                        }
                    }

                    alert(`Successfully shared with ${username}!`);

                    // ‚úÖ OFFLINE-FIRST: Real-time permission updates
                    if (this.realtimePermissionUpdates) {
                        // ‚úÖ IMMEDIATELY reload permissions to reflect the change
                        // ‚úÖ TIPTAP BEST PRACTICE: Non-blocking permission refresh
                        this.loadDocumentPermissions('permission-grant-update').catch(error => {
                            console.warn('‚ö†Ô∏è Background permission refresh failed:', error);
                        });

                        // ‚úÖ CRITICAL FIX: Refresh shared users list to show the new user
                        await this.loadSharedUsers();

                        // ‚úÖ FORCE REACTIVITY: Ensure Vue detects the sharedUsers change
                        this.$nextTick(() => {
                        });

                        // ‚úÖ BACKGROUND: Refresh collaborative documents list to update accessType
                        // Only refresh if not viewing a single document
                        const isViewingSingleDoc = this.currentFile && 
                                                 this.currentFile.type === 'collaborative';
                        if (!isViewingSingleDoc) {
                            this.loadCollaborativeDocs().catch(error => {
                                console.warn('‚ö†Ô∏è REAL-TIME UPDATE: Collaborative docs refresh failed:', error.message);
                            });
                        } else {
                            console.log('‚ÑπÔ∏è Skipping document list refresh after permission update - viewing single document');
                        }

                        // ‚úÖ TRIGGER: Force permission refresh timestamp update
                        this.permissionTimestamps.lastRefresh = Date.now();
                    } else {
                        await this.loadSharedUsers();

                        // ‚úÖ FORCE REACTIVITY: Ensure Vue detects the sharedUsers change
                        this.$nextTick(() => {
                        });
                    }

                    // ‚úÖ CLEAR permission caches to force fresh lookups
                    this.clearAllPermissionCaches();

                    // Clear form but keep modal open to show the updated list
                    this.shareForm.username = '';
                    this.shareForm.permission = 'readonly';

                } else {
                    const errorText = await response.text().catch(() => 'Unknown error');
                    console.error('‚ùå PERMISSION GRANT: Failed to grant permissions', {
                        status: response.status,
                        statusText: response.statusText,
                        error: errorText,
                        grantingUser: this.username,
                        targetUser: username,
                        permission: this.shareForm.permission,
                        document: `${this.currentFile.owner}/${this.currentFile.permlink}`
                    });
                    throw new Error(`Failed to share: ${response.statusText}\n${errorText}`);
                }
            } catch (error) {
                console.error('‚ùå PERMISSION GRANT: Error during permission grant:', error);
                alert('Failed to share document. Please try again.');
            }
        },

        // ===== COMPLIANCE UTILITIES =====

        /**
         * üö® DEVELOPMENT COMPLIANCE CHECKER
         * Run this method during development to detect TipTap violations
         * 
         * Usage: this.checkTipTapCompliance() in console
         */
        checkTipTapCompliance() {
            const violations = [];
            const warnings = [];

            // ‚úÖ COMPLIANCE: content.title/body have been removed from architecture
            // Single editor architecture eliminates need for content sync patterns

            // Check editor existence
            if (!this.bodyEditor) {
                warnings.push('‚ö†Ô∏è WARNING: Editor not initialized yet');
            }

            // Check Y.js document
            if (!this.ydoc) {
                violations.push('‚ùå VIOLATION: Y.js document missing - should exist before editors');
            }

            // Check temp document strategy
            if (this.isTemporaryDocument && this.indexeddbProvider) {
                violations.push('‚ùå VIOLATION: Temp document should not have IndexedDB persistence yet');
            }

            // Check content state tracking
            const contentSyncMethods = ['updateContent', 'getMarkdownContent', 'getPlainTextContent'];
            contentSyncMethods.forEach(method => {
                if (typeof this[method] === 'function') {
                    const methodString = this[method].toString();
                    if (methodString.includes('content.title') || methodString.includes('content.body')) {
                        violations.push(`‚ùå VIOLATION: ${method}() contains direct content access`);
                    }
                }
            });

            // Check for setContent usage
            if (this.bodyEditor) {
                try {
                    const bodyHtml = this.bodyEditor.getHTML();
                    // This is OK for display/export only

                } catch (error) {
                    warnings.push('‚ö†Ô∏è WARNING: Could not access editor content for compliance check');
                }
            }

            // Report results

            if (violations.length === 0) {

            } else {
                if (DEBUG) violations.forEach(v => console.log(v));
            }

            if (warnings.length > 0) {
                if (DEBUG) warnings.forEach(w => console.log(w));
            }

            // Show allowed patterns reminder

            return {
                violations,
                warnings,
                compliant: violations.length === 0
            };
        },

        /**
         * üîç DETECT SPECIFIC VIOLATION PATTERNS
         * Check for common violation patterns in method implementations
         */
        detectViolationPatterns() {
            const patterns = {
                contentSync: /(content\.title|content\.body)\s*=/,
                manualSetContent: /setContent\(|setHTML\(|insertContent\(/,
                yjsFragmentAccess: /ydoc\.get\(.*XmlFragment\)|getXmlFragment/,
                fragmentToString: /fragment\.toString\(\)|\.toJSON\(\)/,
                directFragmentManip: /fragment\.insert\(|fragment\.delete\(/,
                onUpdateContentSync: /onUpdate.*getText\(\)|onUpdate.*getHTML\(\)/
            };

            Object.entries(patterns).forEach(([name, pattern]) => {
                // This would typically scan source code, but in runtime we can only check method strings
            });

        },

        // ===== TAG MANAGEMENT =====
        addTagToYjs(tag) {
            // ‚úÖ TIPTAP BEST PRACTICE: Update Y.js metadata instead of content object
            if (ydocService.isReady() && tag && !this.displayTags.includes(tag)) {
                // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                const currentTags = ydocService.getMetadata('tags') || [];
                if (!currentTags.includes(tag)) {
                    ydocService.updateMetadata('tags', [...currentTags, tag]);
                }

                // ‚úÖ TIPTAP USER INTENT: Direct tag addition shows intent to create document
                if (this.isTemporaryDocument && !this.indexeddbProvider) {
                    this.debouncedCreateIndexedDBForTempDocument();
                }

                // ‚úÖ FIX: Show save indicator and trigger autosave
                if (!this.isReadOnlyMode) {
                    this.hasUnsavedChanges = true;
                    this.hasUserIntent = true;

                    // Call updateSaveStatus directly to ensure message shows
                    this.$nextTick(() => {
                        this.updateSaveStatus();
                    });

                    this.autoSave();
                }
            }
        },

        removeTagFromYjs(tag) {
            // ‚úÖ TIPTAP BEST PRACTICE: Update Y.js metadata instead of content object
            if (ydocService.isReady()) {
                // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                const currentTags = ydocService.getMetadata('tags') || [];
                const updatedTags = currentTags.filter(t => t !== tag);
                ydocService.updateMetadata('tags', updatedTags);

                // ‚úÖ TIPTAP USER INTENT: Direct tag removal shows intent to create document
                if (this.isTemporaryDocument && !this.indexeddbProvider) {
                    this.debouncedCreateIndexedDBForTempDocument();
                }

                // ‚úÖ FIX: Show save indicator and trigger autosave
                if (!this.isReadOnlyMode) {
                    this.hasUnsavedChanges = true;
                    this.hasUserIntent = true;

                    // Call updateSaveStatus directly to ensure message shows
                    this.$nextTick(() => {
                        this.updateSaveStatus();
                    });

                    this.autoSave();
                }
            }
        },

        // ===== FILE MANAGEMENT =====
        async loadLocalFiles() {
            return await this.documentManager.loadLocalFiles();
        },

        // Document name extraction method for optimized IndexedDB scanning
        async extractDocumentNameFromIndexedDB(documentId) {
            return await this.documentManager.extractDocumentNameFromIndexedDB(documentId);
        },

        // ‚úÖ HELPER: Validate collaboration state before commands
        validateCollaborationState() {
            // Check WebSocket provider state
            if (this.websocketProvider && !this.websocketProvider.synced) {
                return { valid: false, reason: 'WebSocket not synced' };
            }

            // Check Y.js document state
            if (!ydocService.isValid()) {
                return { valid: false, reason: 'Y.js document invalid' };
            }

            // Check for pending Y.js transactions
            if (ydocService.hasPendingTransactions()) {
                return { valid: false, reason: 'Y.js transactions pending' };
            }

            // Check if Y.js is currently syncing
            if (this.isYjsSyncing) {
                return { valid: false, reason: 'Y.js is syncing' };
            }

            return { valid: true };
        },

        // ===== TOOLBAR ACTIONS =====

        insertLink() {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;

            // Check if text is selected
            const { from, to } = this.bodyEditor.state.selection;
            const selectedText = this.bodyEditor.state.selection.empty
                ? ''
                : this.bodyEditor.state.doc.textBetween(from, to, ' ');

            // Create modal dialog
            const dialog = document.createElement('div');
            dialog.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#212529;border:1px solid #495057;padding:20px;border-radius:8px;z-index:10000;min-width:450px;';
            dialog.innerHTML = `
                <h5 style="color:#fff;margin:0 0 15px 0;">Insert Link</h5>
                <div style="margin-bottom:15px;">
                    <label style="color:#adb5bd;display:block;margin-bottom:5px;">URL <span style="color:#dc3545;">*</span></label>
                    <input type="text" id="linkUrl" placeholder="https://example.com" 
                           style="width:100%;padding:8px;background:#2c2f33;border:1px solid #495057;color:#fff;border-radius:4px;">
                </div>
                <div style="margin-bottom:15px;">
                    <label style="color:#adb5bd;display:block;margin-bottom:5px;">
                        Display Text ${selectedText ? '<span style="color:#6c757d;">(optional)</span>' : '<span style="color:#dc3545;">*</span>'}
                    </label>
                    <input type="text" id="linkText" placeholder="${selectedText ? 'Leave empty to use selected text' : 'Enter link text'}" 
                           value="${selectedText}"
                           style="width:100%;padding:8px;background:#2c2f33;border:1px solid #495057;color:#fff;border-radius:4px;">
                </div>
                <div style="text-align:right;">
                    <button id="cancelBtn" style="padding:6px 12px;margin-right:8px;background:#6c757d;border:none;color:#fff;border-radius:4px;cursor:pointer;">Cancel</button>
                    <button id="insertBtn" style="padding:6px 12px;background:#0d6efd;border:none;color:#fff;border-radius:4px;cursor:pointer;">Insert</button>
                </div>
            `;

            const backdrop = document.createElement('div');
            backdrop.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:9999;';
            backdrop.onclick = () => {
                dialog.remove();
                backdrop.remove();
            };

            document.body.appendChild(backdrop);
            document.body.appendChild(dialog);

            const urlInput = dialog.querySelector('#linkUrl');
            const textInput = dialog.querySelector('#linkText');
            const insertBtn = dialog.querySelector('#insertBtn');
            const cancelBtn = dialog.querySelector('#cancelBtn');

            urlInput.focus();

            const handleInsert = () => {
                const url = urlInput.value.trim();
                const displayText = textInput.value.trim();

                // Validate inputs
                if (!url) {
                    urlInput.style.borderColor = '#dc3545';
                    urlInput.focus();
                    return;
                }

                // If no selected text and no display text provided, show error
                if (!selectedText && !displayText) {
                    textInput.style.borderColor = '#dc3545';
                    textInput.focus();
                    return;
                }

                // Insert the link
                if (selectedText && !displayText) {
                    // Use existing selection
                    this.bodyEditor.chain().focus().setLink({ href: url }).run();
                } else {
                    // Insert new text with link
                    const linkText = displayText || selectedText;
                    if (selectedText) {
                        // Replace selection with new text and apply link
                        this.bodyEditor.chain()
                            .focus()
                            .deleteRange({ from, to })
                            .insertContent(linkText)
                            .setTextSelection({ from, to: from + linkText.length })
                            .setLink({ href: url })
                            .run();
                    } else {
                        // Insert at cursor position
                        const currentPos = this.bodyEditor.state.selection.from;
                        this.bodyEditor.chain()
                            .focus()
                            .insertContent(linkText)
                            .setTextSelection({ from: currentPos, to: currentPos + linkText.length })
                            .setLink({ href: url })
                            .run();
                    }
                }

                dialog.remove();
                backdrop.remove();
            };

            insertBtn.onclick = handleInsert;
            cancelBtn.onclick = () => {
                dialog.remove();
                backdrop.remove();
            };

            // Handle keyboard shortcuts
            const handleKeypress = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleInsert();
                } else if (e.key === 'Escape') {
                    dialog.remove();
                    backdrop.remove();
                }
            };

            urlInput.addEventListener('keydown', handleKeypress);
            textInput.addEventListener('keydown', handleKeypress);
        },

        executeEditorCommand(commandName, commandFn) {
            // ‚úÖ ENHANCED ERROR TRACKING: Wrap command execution with state tracking
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return false;

            // ‚úÖ CRITICAL: Check for Y.js/IndexedDB transitional states
            if (this.isCreatingPersistence) {
                console.warn(`‚ö†Ô∏è Command ${commandName} blocked - IndexedDB persistence is being created`);
                return false;
            }

            // ‚úÖ Check Y.js sync state
            if (this.isYjsSyncing) {
                console.warn(`‚ö†Ô∏è Command ${commandName} blocked - Y.js is syncing`);
                return false;
            }

            // Check if we're too soon after IndexedDB creation
            const timeSinceIndexedDB = this.contentTimestamps.lastIndexedDBCreation ? Date.now() - this.contentTimestamps.lastIndexedDBCreation : Infinity;
            if (timeSinceIndexedDB < 100) {
                console.warn(`‚ö†Ô∏è Command ${commandName} blocked - only ${timeSinceIndexedDB}ms since IndexedDB creation`);
                return false;
            }

            // ‚úÖ Check for recent Y.js updates
            const timeSinceLastUpdate = this.contentTimestamps.lastChange ? Date.now() - this.contentTimestamps.lastChange : Infinity;
            if (timeSinceLastUpdate < 50) { // 50ms stabilization period
                console.warn(`‚ö†Ô∏è Command ${commandName} blocked - only ${timeSinceLastUpdate}ms since last Y.js update`);
                return false;
            }

            // ‚úÖ Validate collaboration state
            const collabState = this.validateCollaborationState();
            if (!collabState.valid) {
                console.warn(`‚ö†Ô∏è Command ${commandName} blocked - ${collabState.reason}`);
                return false;
            }

            // Track command execution state
            this.isExecutingCommand = true;
            const startTime = Date.now();

            try {
                // Validate state before command
                if (this.enableStateMonitoring) {
                    const preValidation = this.validateEditorState();
                    if (!preValidation.valid) {
                        console.warn(`‚ö†Ô∏è Pre-command validation failed for ${commandName}:`, preValidation.errors);
                    }
                }

                // Log command attempt

                // Execute the command
                const result = commandFn();

                // Log success

                // Validate state after command
                if (this.enableStateMonitoring) {
                    this.$nextTick(() => {
                        const postValidation = this.validateEditorState();
                        if (!postValidation.valid) {
                            console.error(`‚ùå Post-command validation failed for ${commandName}:`, postValidation.errors);
                        }
                    });
                }

                return result;

            } catch (error) {
                // ‚úÖ ENHANCED ERROR TRACKING: Capture detailed error state
                console.error(`‚ùå Command ${commandName} failed:`, error);

                if (this.enableStateMonitoring) {
                    console.error(`üî¥ Error state at failure:`, {
                        command: commandName,
                        error: {
                            message: error.message,
                            type: error.constructor.name,
                            stack: error.stack
                        },
                        editorState: {
                            isDestroyed: this.bodyEditor.isDestroyed,
                            isEditable: this.bodyEditor.isEditable,
                            hasSelection: !!this.bodyEditor.state.selection
                        },
                        yjsState: {
                            exists: !!this.ydoc,
                            isDestroyed: this.ydoc?.isDestroyed
                        },
                        timing: {
                            lastContentChange: Date.now() - (this.contentTimestamps.lastChange || 0),
                            commandDuration: Date.now() - startTime
                        }
                    });

                    // Dump full state for debugging
                    this.dumpEditorState();
                }

                // Check for specific error types
                if (error.message?.includes('mismatched transaction')) {
                    console.error('üî¥ MISMATCHED TRANSACTION ERROR DETECTED');
                    console.error('This typically indicates state desynchronization between ProseMirror and Y.js');
                    console.error('Possible causes:');
                    console.error('1. IndexedDB created after content changes');
                    console.error('2. Command executed too soon after state change');
                    console.error('3. Y.js fragment not properly initialized');
                }

                return false;

            } finally {
                // Always clear execution flag
                this.isExecutingCommand = false;
            }
        },

        toggleBold() {
            // ‚úÖ TIPTAP v3: Use chain pattern with enhanced error tracking
            return this.executeEditorCommand('toggleBold', () => {
                return this.bodyEditor.chain().focus().toggleBold().run();
            });
        },

        toggleItalic() {
            // ‚úÖ TIPTAP v3: Use chain pattern with enhanced error tracking
            return this.executeEditorCommand('toggleItalic', () => {
                return this.bodyEditor.chain().focus().toggleItalic().run();
            });
        },

        // ===== MEMORY PROFILING =====
        /**
         * ‚úÖ TIPTAP COMPLIANCE: Track memory usage for large documents
         */
        getMemoryProfile() {
            const profile = {
                timestamp: new Date().toISOString(),
                yjsDocument: null,
                editors: {
                    title: null,
                    body: null,
                    permlink: null
                },
                providers: {
                    websocket: null,
                    indexeddb: null
                },
                content: {
                    titleLength: 0,
                    bodyLength: 0,
                    totalNodes: 0
                },
                performance: {
                    heapUsed: 0,
                    heapTotal: 0
                }
            };

            try {
                // Y.js document size
                if (ydocService.isReady()) {
                    const state = Y.encodeStateAsUpdate(this.ydoc);
                    profile.yjsDocument = {
                        stateSize: state.length,
                        stateSizeKB: (state.length / 1024).toFixed(2),
                        maps: ydocService.getMapCount(),
                        hasContent: state.length > 100
                    };
                }

                // Title content size from titleInput
                if (this.titleInput) {
                    profile.editors.title = {
                        textLength: this.titleInput.length,
                        nodeCount: 0 // No ProseMirror nodes for simple input
                    };
                    profile.content.titleLength = this.titleInput.length;
                }

                if (this.bodyEditor && !this.bodyEditor.isDestroyed) {
                    const bodyText = this.bodyEditor.getText();
                    profile.editors.body = {
                        textLength: bodyText.length,
                        nodeCount: this.bodyEditor.state.doc.nodeSize,
                        isLargeDocument: bodyText.length > 100000
                    };
                    profile.content.bodyLength = bodyText.length;
                    profile.content.totalNodes = this.bodyEditor.state.doc.nodeSize;
                }

                if (this.permlinkEditor && !this.permlinkEditor.isDestroyed) {
                    profile.editors.permlink = {
                        textLength: this.permlinkEditor.getText().length,
                        nodeCount: this.permlinkEditor.state.doc.nodeSize
                    };
                }

                // Provider status
                if (this.provider) {
                    profile.providers.websocket = {
                        connected: this.connectionStatus === 'connected',
                        awareness: this.provider.awareness?.states?.size || 0
                    };
                }

                if (this.indexeddbProvider) {
                    profile.providers.indexeddb = {
                        synced: true,
                        documentId: this.currentFile?.id
                    };
                }

                // Browser memory (if available)
                if (performance.memory) {
                    profile.performance = {
                        heapUsed: (performance.memory.usedJSHeapSize / 1048576).toFixed(2) + ' MB',
                        heapTotal: (performance.memory.totalJSHeapSize / 1048576).toFixed(2) + ' MB',
                        heapLimit: (performance.memory.jsHeapSizeLimit / 1048576).toFixed(2) + ' MB'
                    };
                }

                // Recommendations
                if (profile.content.bodyLength > 100000) {
                    profile.recommendations = [
                        'Consider implementing content virtualization for documents over 100KB',
                        'Enable lazy loading for embedded media',
                        'Use pagination for very long documents'
                    ];
                }

            } catch (error) {
                console.error('‚ùå Memory profiling error:', error);
                profile.error = error.message;
            }

            return profile;
        },

        /**
         * ‚úÖ TIPTAP COMPLIANCE: Monitor memory for large documents
         */
        startMemoryMonitoring(intervalMs = 30000) {
            if (this.memoryMonitorInterval) {
                cancelAnimationFrame(this.memoryMonitorInterval);
            }

            // ‚úÖ ARCHITECTURE RULE 6: Replace setInterval with requestAnimationFrame
            let lastMonitorTime = Date.now();
            const monitorInterval = intervalMs;
            
            const memoryMonitor = () => {
                const now = Date.now();
                if (now - lastMonitorTime >= monitorInterval) {
                    const profile = this.getMemoryProfile();

                    // Log if document is large
                    if (profile.content.bodyLength > 50000) {
                    }

                    // Warn if memory usage is high
                    if (performance.memory && performance.memory.usedJSHeapSize > 200 * 1048576) {
                        console.warn('‚ö†Ô∏è High memory usage detected:', profile.performance);
                    }

                    // Store last profile for debugging
                    this.debugTimestamps.lastMemoryProfile = profile;
                    
                    lastMonitorTime = now;
                }
                
                this.memoryMonitorInterval = requestAnimationFrame(memoryMonitor);
            };
            
            // Start monitoring
            this.memoryMonitorInterval = requestAnimationFrame(memoryMonitor);
        },

        stopMemoryMonitoring() {
            if (this.memoryMonitorInterval) {
                cancelAnimationFrame(this.memoryMonitorInterval);
                this.memoryMonitorInterval = null;
            }
        },



        // ===== ARCHITECTURE RULE 6 COMPLIANCE =====
        // The following setTimeout uses are acceptable per the rules:
        // 1. API retry delays (lines 12447, 12468) - actual delays needed for exponential backoff
        // 2. Promise timeouts (lines 13881, 13983, 14039, 14057, 19730, 20945, 21635) - safety timeouts in Promises
        // These are intentional delays, not deferrals, and thus comply with Architecture Rule 6.
        
        // ‚úÖ PHASE 2: Metadata change handlers with Y.js transactions and temp document conversion

        // Tags change handler
        onTagsChange(newTags) {

            // ‚úÖ Y.js TRANSACTION: Individual transaction for tags (per best practices)
            if (ydocService.isReady()) {
                ydocService.batchUpdate(
                    { lastModified: new Date().toISOString() },
                    { tags: newTags || [] },
                    'tags-update'
                );
            }

            this.triggerUserIntentDetection('tags-change');
        },

        // Beneficiaries change handler
        onBeneficiariesChange(newBeneficiaries) {

            // ‚úÖ Y.js TRANSACTION: Individual transaction for beneficiaries
            if (ydocService.isReady()) {
                ydocService.batchUpdate(
                    { lastModified: new Date().toISOString() },
                    { beneficiaries: newBeneficiaries || [] },
                    'beneficiaries-update'
                );
            }

            this.triggerUserIntentDetection('beneficiaries-change');
        },

        // Custom JSON change handler
        onCustomJsonChange(newCustomJson) {

            // ‚úÖ Y.js TRANSACTION: Individual transaction for custom JSON
            if (ydocService.isReady()) {
                ydocService.batchUpdate(
                    { lastModified: new Date().toISOString() },
                    { customJson: newCustomJson || {} },
                    'customjson-update'
                );
            }

            this.triggerUserIntentDetection('customjson-change');
        },

        // Comment options change handler
        onCommentOptionsChange(newCommentOptions) {

            // ‚úÖ Y.js TRANSACTION: Individual transaction for comment options
            if (ydocService.isReady()) {
                ydocService.batchUpdate(
                    { lastModified: new Date().toISOString() },
                    { commentOptions: newCommentOptions || {} },
                    'commentoptions-update'
                );
            }

            this.triggerUserIntentDetection('commentoptions-change');
        },

        // ‚úÖ REMOVED: onPermlinkChange() - duplicate method causing recursion

        // ‚úÖ UNIFIED USER INTENT DETECTION: Common handler for all metadata changes
        triggerUserIntentDetection(changeType) {

            // ‚úÖ TEMP DOCUMENT CONVERSION: Any metadata change triggers conversion
            if (this.isTemporaryDocument && !this.indexeddbProvider && !this.isCreatingPersistence) {
                this.debouncedCreateIndexedDBForTempDocument();
            }

            // ‚úÖ AUTO-SAVE TRIGGER: Mark as unsaved and trigger auto-save
            // ‚úÖ READ-ONLY PROTECTION: Block save operations for read-only users
            if (!this.isReadOnlyMode) {
                this.hasUnsavedChanges = true;
                this.hasUserIntent = true;

                // ‚úÖ FIX: Apply same pattern as body editor for immediate save indicator
                // Call updateSaveStatus directly to ensure message shows
                this.$nextTick(() => {
                    this.updateSaveStatus();
                });

                this.debouncedUpdateContent();
            }
        },

        // ===== EXPORT FUNCTIONALITY =====
        /**
         * Generates markdown content from the TipTap editor using the static renderer
         * with custom node mappings for Hive blockchain compatibility.
         * 
         * Features:
         * - Uses TipTap v3 static renderer with custom node mappings
         * - Preserves HTML tags needed for Hive: <center> for alignment, <video> for media
         * - Handles all standard markdown formatting (bold, italic, lists, etc.)
         * - Recursively processes nested content structures
         * 
         * @returns {string} Markdown string with title as H1 and body content
         */
        getMarkdownContent() {
            // ‚úÖ TIPTAP BEST PRACTICE: Use static renderer for proper markdown conversion
            try {
                const titleText = this.titleInput ? this.titleInput.trim() : '';

                if (!this.bodyEditor) {
                    return titleText ? `# ${titleText}` : '';
                }

                // Get the editor JSON content
                const doc = this.bodyEditor.getJSON();

                // Get TipTap extensions from the global bundle
                // Use the same pattern as the editor to ensure we get the correct bundle
                const tiptapBundle = window.TiptapCollaboration.Editor ? window.TiptapCollaboration : window.TiptapCollaboration.default;
                const {
                    renderToMarkdown,
                    Document,
                    Paragraph,
                    Text,
                    Heading,
                    Bold,
                    Italic,
                    Strike,
                    Underline,
                    Code,
                    Subscript,
                    Superscript,
                    BulletList,
                    OrderedList,
                    ListItem,
                    CustomBlockquote,
                    CustomHorizontalRule,
                    HardBreak,
                    Link,
                    CustomImage,
                    CodeBlock,
                    CustomTextAlign,
                    IPFSVideo,
                    Mention,
                    TableKit,
                    CustomTableCell
                } = tiptapBundle;

                if (!renderToMarkdown) {
                    throw new Error('TipTap static renderer not available');
                }

                // Build extensions array
                // Note: Only include extensions that define node/mark schemas
                // Behavioral extensions (filters, UI menus, drag handles) are excluded

                // Test with minimal extensions first
                const minimalTest = false; // Set to true to test with minimal extensions

                const extensions = minimalTest ? [
                    Document,
                    Text,
                    Paragraph,
                    Bold,
                    Italic
                ] : [
                    Document,
                    Text,
                    CustomTextAlign && CustomTextAlign.configure({
                        types: ['heading', 'paragraph', 'tableCell', 'tableHeader'],
                        alignments: ['left', 'center', 'right', 'justify']
                    }),
                    Paragraph,
                    Heading,
                    Bold,
                    Italic,
                    Strike,
                    Underline,
                    Code,
                    Subscript,
                    Superscript,
                    BulletList,
                    OrderedList,
                    ListItem,
                    CustomBlockquote,
                    CustomHorizontalRule,
                    HardBreak,
                    Link,
                    CustomImage, // Use CustomImage for consistency
                    CodeBlock,
                    IPFSVideo,
                    Mention,
                    TableKit && TableKit.configure({
                        tableCell: false,  // Using CustomTableCell instead
                        // tableHeader uses the default from TableKit
                        table: {
                            resizable: false,
                            handleWidth: 0,
                            allowTableNodeSelection: false
                        }
                    }),
                    CustomTableCell
                ].filter(ext => !!ext);  // Filter out ALL falsy values

                // Simple check to ensure extensions are defined
                console.log('Extensions count:', extensions.length);
                console.log('First few extensions:', extensions.slice(0, 5).map(ext => ext?.name || 'unnamed'));

                // Using TipTap static renderer with custom node mappings for Hive-compatible markdown

                /**
                 * Recursively renders child nodes using the appropriate node mappings.
                 * This is necessary because the static renderer doesn't provide a built-in
                 * children serializer for custom mappings.
                 * 
                 * @param {Array|string} children - Child nodes or string content
                 * @param {Object} options - Options object containing nodeMapping
                 * @returns {string} Rendered markdown string
                 */
                const renderChildren = (children, options) => {
                    if (!children) return '';
                    if (typeof children === 'string') return children;

                    // Handle both array of children and content object with content array
                    let childArray = children;
                    if (children.content && Array.isArray(children.content)) {
                        childArray = children.content;
                    } else if (!Array.isArray(children)) {
                        return '';
                    }

                    return childArray.map((child, index) => {
                        if (typeof child === 'string') return child;
                        if (child.type === 'text') {
                            return options.nodeMapping.text ? options.nodeMapping.text({ node: child, context: options.context }) : child.text || '';
                        }
                        const mapping = options.nodeMapping[child.type];
                        if (mapping) {
                            return mapping({
                                node: child,
                                children: child.content || child,
                                options,
                                context: options.context,
                                index
                            });
                        }
                        return '';
                    }).join('');
                };

                /**
                 * Processes table cell content with proper context and line break handling.
                 * Shared logic for both tableCell and tableHeader handlers.
                 * 
                 * Handles the complex line break processing required for table cells:
                 * 1. Sets inTableCell context to true for child processing
                 * 2. Processes all children with the table context
                 * 3. Applies text alignment if specified
                 * 4. Converts newlines to <br> tags using 3-step process to handle
                 *    the static renderer's automatic doubling of user line breaks
                 * 
                 * @param {Object} node - The table cell/header node
                 * @param {Function|Array|string|Object} children - The cell content in various formats
                 * @param {Object} options - Rendering options containing nodeMapping
                 * @param {Object} context - Current rendering context
                 * @returns {string} Processed cell content with proper line breaks for markdown tables
                 */
                const processTableCellContent = (node, children, options, context) => {
                    // Set context for table cell
                    const cellContext = { ...context, inTableCell: true };

                    // Handle different types of children
                    let content = '';
                    if (typeof children === 'function') {
                        const result = children();
                        if (Array.isArray(result)) {
                            // Process children with context
                            content = result.map((child, index) => {
                                if (typeof child === 'object' && child.type) {
                                    const mapping = options.nodeMapping[child.type];
                                    if (mapping) {
                                        return mapping({
                                            node: child,
                                            children: child.content || child,
                                            options,
                                            context: cellContext,
                                            index
                                        });
                                    }
                                }
                                return child;
                            }).join('');
                        } else {
                            content = String(result || '');
                        }
                    } else if (Array.isArray(children)) {
                        // If children is already processed content, just join
                        content = children.join('');
                    } else if (node.content && node.content.content) {
                        // Process node content directly with context
                        content = renderChildren(node.content, { ...options, nodeMapping, context: cellContext });
                    } else {
                        content = String(children || '');
                    }

                    // Apply text alignment if specified
                    if (node.attrs?.textAlign && node.attrs.textAlign !== 'left') {
                        content = `<div class="text-${node.attrs.textAlign}">${content}</div>`;
                    }

                    // Process line breaks in table cells using 3-step approach:
                    // 1. Remove base trailing newlines automatically added by static renderer
                    content = content.replace(/\n\n$/, '');

                    // 2. Convert pairs of newlines (user line breaks) to single <br> tags
                    // The static renderer doubles each user line break, so we convert pairs back to singles
                    content = content.replace(/\n\n/g, '<br>');

                    // 3. Convert any remaining single newlines to <br>
                    return content.replace(/\n/g, '<br>');
                };

                /**
                 * Normalizes the children parameter into a consistent array format.
                 * Handles various input types: function, array, string, or object with content.
                 * 
                 * @param {Function|Array|string|Object} children - The children parameter in various formats
                 * @returns {Array} Normalized array of children
                 */
                const normalizeChildren = (children) => {
                    if (!children) return [];

                    if (Array.isArray(children)) {
                        return children;
                    }

                    if (typeof children === 'function') {
                        const result = children();
                        return Array.isArray(result) ? result : [result];
                    }

                    if (children && typeof children === 'object' && children.content) {
                        return Array.isArray(children.content) ? children.content : [children.content];
                    }

                    return [children];
                };

                /**
                 * Complete node mapping configuration for TipTap static renderer.
                 * Each mapping function receives:
                 * - node: The current TipTap node to render
                 * - children: Child nodes (array or string)
                 * - options: Options object containing nodeMapping for recursion
                 * 
                 * Custom mappings handle:
                 * - Center alignment via <center> tags (Hive compatibility)
                 * - Video elements with full attribute preservation
                 * - Standard markdown elements (headings, lists, etc.)
                 */
                // Initialize context object for tracking rendering state
                // Currently tracks whether we're inside a table cell to handle line breaks differently
                const context = {
                    inTableCell: false
                };

                const nodeMapping = {
                    // Text node
                    text({ node }) {
                        // Let the static renderer handle marks automatically
                        return node.text || '';
                    },

                    // Paragraph with full text alignment support
                    paragraph({ node, children, options, context, index }) {
                        const content = renderChildren(children, { ...options, nodeMapping, context });

                        // In table cells, handle line breaks differently
                        if (context?.inTableCell) {
                            let result = '';
                            // Add <br> before paragraph if it's not the first one
                            if (index > 0) {
                                result = '<br>';
                            }

                            if (node.attrs?.textAlign === 'center') {
                                result += `<div class="text-center">${content}</div>`;
                            } else if (node.attrs?.textAlign === 'right') {
                                result += `<div class="text-right">${content}</div>`;
                            } else if (node.attrs?.textAlign === 'justify') {
                                result += `<div class="text-justify">${content}</div>`;
                            } else {
                                result += content;
                            }
                            return result;
                        }

                        // Normal paragraph handling outside table cells
                        if (node.attrs?.textAlign === 'center') {
                            return `<div class="text-center">${content}</div>\n\n`;
                        } else if (node.attrs?.textAlign === 'right') {
                            return `<div class="text-right">${content}</div>\n\n`;
                        } else if (node.attrs?.textAlign === 'justify') {
                            return `<div class="text-justify">${content}</div>\n\n`;
                        }
                        // 'left' is default, no special handling needed
                        return `${content}\n\n`;
                    },

                    // Heading with full text alignment support
                    heading({ node, children, options, context }) {
                        const level = node.attrs?.level || 1;
                        const content = renderChildren(children, { ...options, nodeMapping, context });
                        const hashes = '#'.repeat(level);

                        if (node.attrs?.textAlign === 'center') {
                            return `${hashes} <div class="text-center">${content}</div>\n\n`;
                        } else if (node.attrs?.textAlign === 'right') {
                            return `${hashes} <div class="text-right">${content}</div>\n\n`;
                        } else if (node.attrs?.textAlign === 'justify') {
                            return `${hashes} <div class="text-justify">${content}</div>\n\n`;
                        }
                        // 'left' is default, no special handling needed
                        return `${hashes} ${content}\n\n`;
                    },

                    // Lists
                    bulletList({ node, children, options }) {
                        const itemsArray = normalizeChildren(children);

                        // The children are already rendered list items, just add bullet prefix
                        const items = itemsArray.map(item => {
                            const content = String(item).trim();
                            return content ? `- ${content}\n` : '';
                        }).join('');

                        return items ? `${items}\n` : '\n';
                    },

                    orderedList({ node, children, options }) {
                        const itemsArray = normalizeChildren(children);

                        // The children are already rendered list items, add numbered prefix
                        const items = itemsArray.map((item, index) => {
                            const content = String(item).trim();
                            return content ? `${index + 1}. ${content}\n` : '';
                        }).join('');

                        return items ? `${items}\n` : '\n';
                    },

                    listItem({ node, children, options }) {
                        // The static renderer processes list items
                        // Just return the content without prefix (parent list will add it)
                        const childArray = normalizeChildren(children);
                        return childArray.join('').trim();
                    },

                    // Blockquote
                    blockquote({ node, children, options }) {
                        const content = renderChildren(children, { ...options, nodeMapping });
                        // Remove trailing newlines and split by double newlines (paragraph breaks)
                        const paragraphs = content.trim().split('\n\n');
                        // Join paragraphs with single newline and prefix each line with >
                        const blockquoteContent = paragraphs
                            .join('\n')
                            .split('\n')
                            .map(line => line ? `> ${line}` : '>')
                            .join('\n');
                        return blockquoteContent + '\n\n';
                    },

                    // Horizontal rule
                    horizontalRule() {
                        return '---\n\n';
                    },

                    // Hard break (line break with Shift+Enter)
                    hardBreak({ context }) {
                        return context?.inTableCell ? '<br>' : '\n';
                    },

                    // Code block
                    codeBlock({ node, children, options }) {
                        const content = renderChildren(children, { ...options, nodeMapping });
                        const lang = node.attrs?.language || '';
                        return `\`\`\`${lang}\n${content}\n\`\`\`\n\n`;
                    },

                    // Image
                    image({ node }) {
                        const alt = node.attrs?.alt || '';
                        const src = node.attrs?.src || '';
                        const title = node.attrs?.title ? ` "${node.attrs.title}"` : '';
                        return `![${alt}](${src}${title})\n\n`;
                    },

                    // Mention
                    mention({ node }) {
                        const username = node.attrs?.label || node.attrs?.id || '';
                        return `@${username}`;
                    },

                    // Table - process rows and add header separator after first row
                    table({ children }) {
                        const rowsArray = normalizeChildren(children);

                        // Process rows and add header separator after first row
                        let output = '';
                        rowsArray.forEach((row, index) => {
                            output += row;

                            // Add separator after first row (header)
                            if (index === 0 && row.trim()) {
                                // Count columns from the row
                                const columnCount = (row.match(/\|/g) || []).length - 1;
                                if (columnCount > 0) {
                                    const separator = Array(columnCount).fill('---').join(' | ');
                                    output += '| ' + separator + ' |\n';
                                }
                            }
                        });

                        return output + '\n';
                    },

                    // Table row - format as markdown row
                    tableRow({ node, children }) {
                        const cellsArray = normalizeChildren(children);

                        // Clean up cell content (remove delimiters if present)
                        const cells = cellsArray.map(cell => {
                            if (typeof cell === 'string') {
                                return cell.replace(/\|\|\|CELL\|\|\|/g, '').trim();
                            }
                            return String(cell).trim();
                        });

                        if (cells.length > 0) {
                            return '| ' + cells.join(' | ') + ' |\n';
                        } else {
                            // No cells - create empty cells based on node content
                            const cellCount = node.content ? node.content.content.length : 1;
                            const emptyCells = Array(cellCount).fill('');
                            return '| ' + emptyCells.join(' | ') + ' |\n';
                        }
                    },

                    // Table cell - handle content with context and alignment
                    tableCell({ node, children, options, context }) {
                        return processTableCellContent(node, children, options, context);
                    },

                    // Table header - handle content with context and alignment (headers are also cells)
                    tableHeader({ node, children, options, context }) {
                        return processTableCellContent(node, children, options, context);
                    },

                    // Video (custom)
                    video({ node }) {
                        const attrs = node.attrs || {};
                        let html = '<video';
                        if (attrs.src) html += ` src="${attrs.src}"`;
                        if (attrs.type) html += ` type="${attrs.type}"`;
                        if (attrs['data-type']) html += ` data-type="${attrs['data-type']}"`;
                        if (attrs['data-original-src']) html += ` data-original-src="${attrs['data-original-src']}"`;
                        if (attrs.width) html += ` width="${attrs.width}"`;
                        if (attrs.height) html += ` height="${attrs.height}"`;
                        html += ' controls></video>';
                        return html + '\n\n';
                    },

                    // IPFSVideo (same as video)
                    ipfsvideo({ node }) {
                        const attrs = node.attrs || {};
                        let html = '<video';
                        if (attrs.src) html += ` src="${attrs.src}"`;
                        if (attrs.type) html += ` type="${attrs.type}"`;
                        if (attrs['data-type']) html += ` data-type="${attrs['data-type']}"`;
                        if (attrs['data-original-src']) html += ` data-original-src="${attrs['data-original-src']}"`;
                        if (attrs.width) html += ` width="${attrs.width}"`;
                        if (attrs.height) html += ` height="${attrs.height}"`;
                        html += ' controls></video>';
                        return html + '\n\n';
                    },

                    // Document node
                    doc({ children }) {
                        if (Array.isArray(children)) {
                            return children.join('');
                        } else if (typeof children === 'function') {
                            const result = children();
                            return Array.isArray(result) ? result.join('') : result;
                        }
                        return children || '';
                    }
                };

                // Define custom mark mappings for proper markdown rendering
                const markMapping = {
                    link({ mark, children }) {
                        const href = mark.attrs?.href || '';
                        return `[${children}](${href})`;
                    },
                    bold({ children }) {
                        return `**${children}**`;
                    },
                    italic({ children }) {
                        return `*${children}*`;
                    },
                    strike({ children }) {
                        return `~~${children}~~`;
                    },
                    underline({ children }) {
                        return `<u>${children}</u>`;
                    },
                    code({ children }) {
                        return `\`${children}\``;
                    },
                    subscript({ children }) {
                        return `<sub>${children}</sub>`;
                    },
                    superscript({ children }) {
                        return `<sup>${children}</sup>`;
                    }
                };

                let finalMarkdown;
                try {
                    finalMarkdown = renderToMarkdown({
                        extensions: extensions,
                        content: doc,
                        options: {
                            nodeMapping,
                            markMapping,
                            context
                        }
                    });
                } catch (renderError) {
                    console.error('Error in renderToMarkdown:', renderError);
                    console.error('Error stack:', renderError.stack);
                    throw renderError;
                }

                console.log('Final markdown from static renderer:', finalMarkdown);
                return finalMarkdown;
            } catch (error) {
                console.error('Error generating markdown with static renderer:', error);
                throw error;
            }
        },

        getPlainTextContent() {
            // ‚úÖ TIPTAP BEST PRACTICE: Use editor methods for export only
            const title = this.titleInput ? this.titleInput.trim() : '';
            const body = this.bodyEditor ? this.bodyEditor.getText().trim() : '';

            return title ? `${title}\n\n${body}` : body;
        },

        // ===== TOOLBAR FORMAT METHODS =====
        // ‚úÖ TIPTAP v3 BEST PRACTICE: Guard all editor commands
        // This is a known issue with collaborative editing when state is out of sync
        formatBold() {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;
            this.executeFormattingCommand('bold');
        },

        formatItalic() {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;
            this.executeFormattingCommand('italic');
        },

        formatStrike() {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;
            this.executeFormattingCommand('strike');
        },

        formatCode() {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;
            this.executeFormattingCommand('code');
        },

        formatUnderline() {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;
            this.executeFormattingCommand('underline');
        },

        formatSubscript() {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;
            this.executeFormattingCommand('subscript');
        },

        formatSuperscript() {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;
            this.executeFormattingCommand('superscript');
        },

        // ‚úÖ HELPER: Execute formatting commands following TipTap v3 best practices
        executeFormattingCommand(commandName) {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;

            // ‚úÖ TIPTAP v3 COMPLIANT: Route through comprehensive command handler
            this.executeEditorCommand(`format-${commandName}`, () => {
                // First check if command is available
                const chain = this.bodyEditor.chain().focus();

                switch (commandName) {
                    case 'bold':
                        // ‚úÖ Check command availability before execution
                        if (!this.bodyEditor.can().chain().focus().toggleBold().run()) {
                            console.warn('Bold command not available in current state');
                            return false;
                        }
                        return chain.toggleBold().run();

                    case 'italic':
                        if (!this.bodyEditor.can().chain().focus().toggleItalic().run()) {
                            console.warn('Italic command not available in current state');
                            return false;
                        }
                        return chain.toggleItalic().run();

                    case 'strike':
                        if (!this.bodyEditor.can().chain().focus().toggleStrike().run()) {
                            console.warn('Strike command not available in current state');
                            return false;
                        }
                        return chain.toggleStrike().run();

                    case 'code':
                        if (!this.bodyEditor.can().chain().focus().toggleCode().run()) {
                            console.warn('Code command not available in current state');
                            return false;
                        }
                        return chain.toggleCode().run();

                    case 'underline':
                        if (!this.bodyEditor.can().chain().focus().toggleUnderline().run()) {
                            console.warn('Underline command not available in current state');
                            return false;
                        }
                        return chain.toggleUnderline().run();

                    case 'subscript':
                        if (!this.bodyEditor.can().chain().focus().toggleSubscript().run()) {
                            console.warn('Subscript command not available in current state');
                            return false;
                        }
                        return chain.toggleSubscript().run();

                    case 'superscript':
                        if (!this.bodyEditor.can().chain().focus().toggleSuperscript().run()) {
                            console.warn('Superscript command not available in current state');
                            return false;
                        }
                        return chain.toggleSuperscript().run();

                    default:
                        console.error(`Unknown formatting command: ${commandName}`);
                        return false;
                }
            });
        },

        setHeading(level) {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;

            try {
                // Check if we're inside a blockquote
                if (this.bodyEditor.isActive('blockquote')) {
                    // First lift out of blockquote, then apply heading
                    // This ensures heading replaces blockquote rather than being added inside
                    this.bodyEditor.chain()
                        .focus()
                        .lift('blockquote')
                        .toggleHeading({ level })
                        .run();
                } else {
                    // Normal heading toggle
                    this.bodyEditor.chain()
                        .focus()
                        .toggleHeading({ level })
                        .run();
                }
            } catch (error) {
                console.error('Heading command failed:', error);
            }
        },

        setParagraph() {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;

            try {
                this.bodyEditor.chain().focus().setParagraph().run();
            } catch (error) {
                console.error('Paragraph command failed:', error);
            }
        },

        setTextAlign(alignment) {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;

            try {
                const success = this.bodyEditor.chain().focus().setTextAlign(alignment).run();

                // Log the current selection's JSON to verify the attribute was set
                this.$nextTick(() => {
                    const { from, to } = this.bodyEditor.state.selection;
                    const selectedNode = this.bodyEditor.state.doc.nodeAt(from);
                });
            } catch (error) {
                console.error('Text align command failed:', error);
            }
        },

        toggleBulletList() {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;

            try {
                // Check if we're inside a blockquote
                if (this.bodyEditor.isActive('blockquote')) {
                    // First lift out of blockquote, then apply bullet list
                    // This ensures list replaces blockquote rather than being added inside
                    this.bodyEditor.chain()
                        .focus()
                        .lift('blockquote')
                        .toggleBulletList()
                        .run();
                } else {
                    // Normal bullet list toggle
                    this.bodyEditor.chain()
                        .focus()
                        .toggleBulletList()
                        .run();
                }
            } catch (error) {
                console.error('Bullet list command failed:', error);
            }
        },

        toggleOrderedList() {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;

            try {
                // Check if we're inside a blockquote
                if (this.bodyEditor.isActive('blockquote')) {
                    // First lift out of blockquote, then apply ordered list
                    // This ensures list replaces blockquote rather than being added inside
                    this.bodyEditor.chain()
                        .focus()
                        .lift('blockquote')
                        .toggleOrderedList()
                        .run();
                } else {
                    // Normal ordered list toggle
                    this.bodyEditor.chain()
                        .focus()
                        .toggleOrderedList()
                        .run();
                }
            } catch (error) {
                console.error('Ordered list command failed:', error);
            }
        },

        toggleBlockquote() {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;

            try {
                this.bodyEditor.chain().focus().toggleBlockquote().run();
            } catch (error) {
                console.error('Blockquote command failed:', error);
            }
        },

        setBlockquote() {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;

            try {
                // Check if we're already in a blockquote
                const isInBlockquote = this.bodyEditor.isActive('blockquote');

                if (isInBlockquote) {
                    // If in blockquote, lift out of it (converts to paragraph)
                    this.bodyEditor.chain()
                        .focus()
                        .lift('blockquote')
                        .run();
                } else {
                    // For all other nodes (paragraphs, headings, lists, code blocks)
                    // Use clearNodes to remove all node-level formatting first
                    // This converts headings, lists, code blocks to plain paragraphs
                    // Then apply blockquote formatting
                    this.bodyEditor.chain()
                        .focus()
                        .clearNodes()
                        .setBlockquote()
                        .run();
                }
            } catch (error) {
                console.error('Set blockquote command failed:', error);
            }
        },

        // ‚úÖ REACTIVE COMMAND PATTERN: Exit blockquote and continue writing
        // This demonstrates proper command chaining without setTimeout
        exitBlockquoteAndContinue() {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;

            try {
                const { state } = this.bodyEditor;
                const { $from } = state.selection;

                // Check if we're inside a blockquote
                let blockquoteDepth = null;
                for (let d = $from.depth; d > 0; d--) {
                    if ($from.node(d).type.name === 'blockquote') {
                        blockquoteDepth = d;
                        break;
                    }
                }

                if (blockquoteDepth === null) {
                    console.log('Not inside a blockquote');
                    return;
                }

                // Use command chaining with a custom command function
                this.bodyEditor.chain()
                    .focus()
                    .command(({ tr, dispatch }) => {
                        // Get blockquote position
                        const blockquotePos = $from.before(blockquoteDepth);
                        const blockquote = $from.node(blockquoteDepth);
                        const afterPos = blockquotePos + blockquote.nodeSize;

                        // Insert a paragraph after the blockquote
                        const paragraph = state.schema.nodes.paragraph.create();
                        tr.insert(afterPos, paragraph);

                        // Move cursor to the new paragraph
                        const newPos = tr.doc.resolve(afterPos + 1);
                        const { TextSelection } = window.TiptapCollaboration;
                        tr.setSelection(TextSelection.near(newPos));

                        if (dispatch) dispatch(tr);
                        return true;
                    })
                    .run();

                console.log('Exited blockquote and created new paragraph');
            } catch (error) {
                console.error('Exit blockquote command failed:', error);
            }
        },

        toggleCodeBlock() {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;

            try {
                // Check if we're inside a blockquote
                if (this.bodyEditor.isActive('blockquote')) {
                    // First lift out of blockquote, then apply code block
                    // This ensures code block replaces blockquote rather than being added inside
                    this.bodyEditor.chain()
                        .focus()
                        .lift('blockquote')
                        .toggleCodeBlock()
                        .run();
                } else {
                    // Normal code block toggle
                    this.bodyEditor.chain()
                        .focus()
                        .toggleCodeBlock()
                        .run();
                }
            } catch (error) {
                console.error('Code block command failed:', error);
            }
        },

        insertHorizontalRule() {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;

            try {
                // Check if we're inside a blockquote
                if (this.bodyEditor.isActive('blockquote')) {
                    // Complete the blockquote exit and HR insertion in one transaction
                    this.bodyEditor.chain()
                        .focus()
                        .command(({ tr, dispatch, state }) => {
                            const { $from } = tr.selection;

                            // Find blockquote
                            let blockquoteDepth = -1;
                            for (let d = $from.depth; d >= 0; d--) {
                                if ($from.node(d).type.name === 'blockquote') {
                                    blockquoteDepth = d;
                                    break;
                                }
                            }

                            if (blockquoteDepth >= 0) {
                                const blockquotePos = $from.before(blockquoteDepth);
                                const blockquote = $from.node(blockquoteDepth);
                                const afterPos = blockquotePos + blockquote.nodeSize;

                                // Only insert the HR, no extra paragraphs
                                const hr = state.schema.nodes.horizontalRule.create();
                                tr.insert(afterPos, hr);

                                // Position cursor after the HR
                                const hrEndPos = afterPos + hr.nodeSize;
                                try {
                                    const $pos = tr.doc.resolve(hrEndPos);
                                    const { TextSelection } = window.TiptapCollaboration;
                                    tr.setSelection(TextSelection.near($pos));
                                } catch (e) {
                                    // Continue without setting selection
                                }

                                if (dispatch) dispatch(tr);
                                return true;
                            }
                            return false;
                        })
                        .run();
                } else {
                    // Normal insertion
                    this.bodyEditor.chain().focus().setHorizontalRule().run();
                }
            } catch (error) {
                console.error('Horizontal rule command failed:', error);
                // Fallback to simple insertion
                try {
                    this.bodyEditor?.chain().focus().setHorizontalRule().run();
                } catch (retryError) {
                    console.error('Horizontal rule command retry failed:', retryError);
                }
            }
        },

        insertImage() {
            // Create a simple dialog for image URL input
            const dialog = document.createElement('div');
            dialog.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#212529;border:1px solid #495057;padding:20px;border-radius:8px;z-index:10000;';
            dialog.innerHTML = `
                <h5 style="color:#fff;margin:0 0 15px 0;">Insert Image</h5>
                <input type="text" id="imageUrl" placeholder="Enter image URL" style="width:400px;padding:8px;margin-bottom:10px;background:#2c2f33;border:1px solid #495057;color:#fff;border-radius:4px;">
                <div style="margin-bottom:10px;">
                </div>
                <div style="text-align:right;">
                    <button id="cancelBtn" style="padding:6px 12px;margin-right:8px;background:#6c757d;border:none;color:#fff;border-radius:4px;cursor:pointer;">Cancel</button>
                    <button id="insertBtn" style="padding:6px 12px;background:#0d6efd;border:none;color:#fff;border-radius:4px;cursor:pointer;">Insert</button>
                </div>
            `;

            const backdrop = document.createElement('div');
            backdrop.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:9999;';
            backdrop.onclick = () => {
                dialog.remove();
                backdrop.remove();
            };

            document.body.appendChild(backdrop);
            document.body.appendChild(dialog);

            const urlInput = dialog.querySelector('#imageUrl');
            const insertBtn = dialog.querySelector('#insertBtn');
            const cancelBtn = dialog.querySelector('#cancelBtn');

            urlInput.focus();

            const handleInsert = () => {
                const url = urlInput.value.trim();
                if (url) {
                    this.insertImageEmbed(url);
                    dialog.remove();
                    backdrop.remove();
                }
            };

            insertBtn.onclick = handleInsert;
            cancelBtn.onclick = () => {
                dialog.remove();
                backdrop.remove();
            };
            urlInput.onkeypress = (e) => {
                if (e.key === 'Enter') handleInsert();
            };
        },

        insertTable() {
            if (!this.bodyEditor || this.isReadOnlyMode || this.bodyEditor.isDestroyed) return;

            // ‚úÖ NESTED TABLE PREVENTION: Check if cursor is currently inside a table
            // This is now handled by disabling the button, but keep as safety check
            if (this.bodyEditor.isActive('table')) {
                return;
            }

            try {
                // Check if we're inside a blockquote
                if (this.bodyEditor.isActive('blockquote')) {
                    const { state } = this.bodyEditor;
                    const { $from } = state.selection;

                    // Check if blockquote is empty by looking at the current paragraph
                    const currentNode = $from.parent;
                    const isEmpty = currentNode.type.name === 'paragraph' && currentNode.content.size === 0;

                    if (isEmpty) {
                        // Replace empty blockquote with table
                        this.bodyEditor.chain()
                            .focus()
                            .lift('blockquote')
                            .insertTable({ rows: 3, cols: 3, withHeaderRow: false })
                            .run();
                    } else {
                        // Use proper command pattern to exit blockquote and insert table
                        this.bodyEditor.chain()
                            .focus()
                            .command(({ tr, dispatch }) => {
                                const { $from } = tr.selection;

                                // Find the blockquote depth
                                let blockquoteDepth = -1;
                                for (let d = $from.depth; d >= 0; d--) {
                                    if ($from.node(d).type.name === 'blockquote') {
                                        blockquoteDepth = d;
                                        break;
                                    }
                                }

                                if (blockquoteDepth >= 0 && dispatch) {
                                    // Get position after blockquote
                                    const blockquoteEnd = $from.end(blockquoteDepth);
                                    const afterPos = blockquoteEnd + 1;

                                    // Insert a paragraph after the blockquote
                                    const paragraph = tr.doc.type.schema.nodes.paragraph.create();
                                    tr.insert(afterPos, paragraph);

                                    // Move cursor to the new paragraph
                                    const { TextSelection } = window.TiptapCollaboration;
                                    const newPos = tr.doc.resolve(afterPos + 1);
                                    const selection = TextSelection.near(newPos);
                                    tr.setSelection(selection);
                                }

                                return true;
                            })
                            .insertTable({ rows: 3, cols: 3, withHeaderRow: false })
                            .run();
                    }
                    return;
                }

                // Check if we're in an empty document (only has an empty paragraph)
                const { doc } = this.bodyEditor.state;
                const isEmptyDoc = doc.childCount === 1 &&
                    doc.firstChild.type.name === 'paragraph' &&
                    doc.firstChild.content.size === 0;

                if (isEmptyDoc) {
                    // Replace the empty paragraph with the table
                    this.bodyEditor.chain()
                        .focus()
                        .deleteRange({ from: 0, to: doc.content.size })
                        .insertTable({ rows: 3, cols: 3, withHeaderRow: false })
                        .run();
                } else {
                    // Insert normally
                    this.bodyEditor.chain()
                        .focus()
                        .insertTable({ rows: 3, cols: 3, withHeaderRow: false })
                        .run();
                }
            } catch (error) {
                console.error('Table insertion failed:', error);
            }
        },

        // Table manipulation methods
        addTableRowBefore() {
            if (!this.bodyEditor) return;
            this.bodyEditor.chain().focus().addRowBefore().run();
        },

        addTableRowAfter() {
            if (!this.bodyEditor) return;
            this.bodyEditor.chain().focus().addRowAfter().run();
        },

        addTableColumnBefore() {
            if (!this.bodyEditor) return;
            this.bodyEditor.chain().focus().addColumnBefore().run();
        },

        addTableColumnAfter() {
            if (!this.bodyEditor) return;
            this.bodyEditor.chain().focus().addColumnAfter().run();
        },

        deleteTableRow() {
            if (!this.bodyEditor) return;
            this.bodyEditor.chain().focus().deleteRow().run();
        },

        deleteTableColumn() {
            if (!this.bodyEditor) return;
            this.bodyEditor.chain().focus().deleteColumn().run();
        },

        deleteTable() {
            if (!this.bodyEditor) return;
            this.bodyEditor.chain().focus().deleteTable().run();
        },

        updateTableToolbarPosition() {
            if (!this.bodyEditor || !this.isInTable) return;

            // Get the table toolbar element
            const toolbar = document.querySelector('.table-toolbar');
            if (!toolbar) return;

            // Get the editor element
            const editorEl = this.$refs.bodyEditor;
            if (!editorEl) return;

            // Find the table with selected cells or the table containing the cursor
            let tableEl = null;

            // First try to find a table with selected cells
            const selectedCell = editorEl.querySelector('.ProseMirror .selectedCell');
            if (selectedCell) {
                tableEl = selectedCell.closest('table');
            }

            // If no selected cells, find the table containing the cursor
            if (!tableEl) {
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    const container = range.commonAncestorContainer;
                    const element = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;
                    tableEl = element.closest('.ProseMirror table');
                }
            }

            if (!tableEl) {
                // Table element not found - this shouldn't happen with double nextTick
                // Just return silently as the table toolbar will be hidden by CSS
                return;
            }

            const tableRect = tableEl.getBoundingClientRect();

            // Position the toolbar above the table
            toolbar.style.left = `${tableRect.left}px`;
            toolbar.style.top = `${tableRect.top - 50}px`; // 50px above the table

        },

        insertVideo() {
            // Open SPK file browser with video filter
            if (window.parent && window.parent !== window) {
                // Send message to parent to open SPK browser for video files
                window.parent.postMessage({
                    type: 'requestSPKBrowser',
                    filter: 'video',
                    fileTypes: ['.mp4', '.mov', '.avi', '.mkv', '.webm', '.m3u8', '.flv', '.wmv', '.mpg', '.mpeg', '.3gp', '.ogv'],
                    target: 'editor'
                }, '*');
            } else {
                // Fallback for standalone editor - create a simple dialog
                const dialog = document.createElement('div');
                dialog.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#212529;border:1px solid #495057;padding:20px;border-radius:8px;z-index:10000;';
                dialog.innerHTML = `
                    <h5 style="color:#fff;margin:0 0 15px 0;">Insert Video</h5>
                    <input type="text" id="videoUrl" placeholder="Enter video URL" style="width:400px;padding:8px;margin-bottom:10px;background:#2c2f33;border:1px solid #495057;color:#fff;border-radius:4px;">
                    <br>
                    <label style="color:#adb5bd;display:flex;align-items:center;margin-bottom:15px;">
                        <input type="checkbox" id="isHls" style="margin-right:8px;">
                        This is an HLS/streaming video (m3u8)
                    </label>
                    <div style="text-align:right;">
                        <button id="cancelBtn" style="padding:6px 12px;margin-right:8px;background:#6c757d;border:none;color:#fff;border-radius:4px;cursor:pointer;">Cancel</button>
                        <button id="insertBtn" style="padding:6px 12px;background:#0d6efd;border:none;color:#fff;border-radius:4px;cursor:pointer;">Insert</button>
                    </div>
                `;

                const backdrop = document.createElement('div');
                backdrop.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:9999;';
                backdrop.onclick = () => {
                    dialog.remove();
                    backdrop.remove();
                };

                document.body.appendChild(backdrop);
                document.body.appendChild(dialog);

                const urlInput = dialog.querySelector('#videoUrl');
                const hlsCheckbox = dialog.querySelector('#isHls');
                const insertBtn = dialog.querySelector('#insertBtn');
                const cancelBtn = dialog.querySelector('#cancelBtn');

                urlInput.focus();

                const handleInsert = () => {
                    const url = urlInput.value.trim();
                    if (url) {
                        const isHls = hlsCheckbox.checked;
                        this.insertVideoEmbed(url, isHls ? { type: 'm3u8' } : null);
                        dialog.remove();
                        backdrop.remove();
                    }
                };

                insertBtn.onclick = handleInsert;
                cancelBtn.onclick = () => {
                    dialog.remove();
                    backdrop.remove();
                };
                urlInput.onkeypress = (e) => {
                    if (e.key === 'Enter') handleInsert();
                };
            }
        },

        insertVideoEmbed(url, metadata = null) {
            if (!this.bodyEditor || !url) return;

            // Use the modular URL processor
            const { url: processedUrl, fileType } = URLProcessor.processUrl(url, metadata);

            // Use the IPFSVideo extension's setIPFSVideo command
            const videoAttrs = {
                src: processedUrl,
                controls: true,
                width: '100%',
                height: 'auto',
                crossorigin: 'anonymous'
            };

            // Only set type attributes for m3u8 which requires it
            if (fileType === 'm3u8') {
                videoAttrs.type = 'application/x-mpegURL';
                videoAttrs['data-type'] = 'm3u8';
                videoAttrs['data-mime-type'] = 'application/x-mpegURL';
            }
            // For all other formats, let the browser auto-detect

            this.bodyEditor.chain()
                .focus()
                .setIPFSVideo(videoAttrs)
                .run();

            // Mark document as having unsaved changes
            this.hasUnsavedChanges = true;
            this.hasUserIntent = true;
        },

        insertImageEmbed(url, altText = '') {
            if (!this.bodyEditor || !url) {
                return;
            }

            // Use the modular URL processor
            const { url: processedUrl } = URLProcessor.processUrl(url, { type: 'image' });

            // If no alt text provided, try to extract filename from URL
            if (!altText) {
                const urlParts = url.split('/');
                altText = urlParts[urlParts.length - 1] || '';
            }

            try {
                // Use the Image extension's setImage command
                this.bodyEditor.chain()
                    .focus()
                    .setImage({
                        src: processedUrl,
                        alt: altText,
                        title: altText
                    })
                    .run();

                // Mark document as having unsaved changes
                this.hasUnsavedChanges = true;
                this.hasUserIntent = true;

            } catch (error) {
                if (DEBUG) console.error('Error inserting image:', error);
            }
        },

        /**
         * Handle SPK Drive add-to-editor event
         * Inserts the file into the editor based on its type
         */
        handleSpkAddToEditor(fileData) {
            if (!this.bodyEditor || this.bodyEditor.isDestroyed) {
                console.warn('‚ö†Ô∏è Editor not available for SPK file insertion');
                return;
            }

            const { cid, fileName, fileType, cleanFileType, url } = fileData;

            // Determine if it's a video or image
            const isVideo = fileName.match(/\.(mp4|webm|ogg|m3u8|mov|avi|mkv|m4v|3gp|3g2)$/i) ||
                fileType.match(/^video\//i) ||
                cleanFileType === 'm3u8' ||
                ['mp4', 'webm', 'ogg', 'm3u8', 'mov', 'avi', 'mkv', 'm4v', '3gp', '3g2'].includes(cleanFileType);

            const isImage = fileName.match(/\.(jpg|jpeg|png|gif|webp|svg|bmp|ico|tiff|tif|avif|jfif|heic|heif)$/i) ||
                fileType.match(/^image\//i) ||
                ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'bmp', 'ico', 'tiff', 'tif', 'avif', 'jfif', 'heic', 'heif'].includes(cleanFileType);

            if (isVideo) {
                // Insert as video
                this.insertVideoEmbed(url, { type: cleanFileType });
            } else if (isImage) {
                // Insert as image with filename as caption
                this.insertImageEmbed(url, fileName);
            } else {
                // Insert as link for other file types
                const linkText = fileName || cid;
                this.bodyEditor.chain()
                    .focus()
                    .insertContent(`<a href="${url}">${linkText}</a>`)
                    .run();

                // Mark document as having unsaved changes
                this.hasUnsavedChanges = true;
                this.hasUserIntent = true;
            }
        },

        editImage(pos, attrs) {
            console.log('editImage called with:', { pos, attrs });

            // Store the component reference if not already done
            if (!window.dluxEditor) {
                window.dluxEditor = {};
            }
            window.dluxEditor.component = this;

            // Use the new modular media edit system
            this.editMedia(pos, attrs, 'image');
        },

        saveImageEdit() {
            // Redirect to the modular save method
            this.saveMediaEdit();
        },

        closeImageEditModal() {
            // Redirect to the modular close method
            this.closeMediaEditModal();
        },

        // ===== MODULAR MEDIA EDIT METHODS =====
        // Generic edit method that works for any media type
        editMedia(pos, attrs, type) {

            this.mediaEditData = {
                pos: pos,
                type: type,
                src: attrs.src || '',
                alt: attrs.alt || '',
                title: attrs.title || '',
                width: attrs.width || '',
                height: attrs.height || '',
                controls: attrs.controls !== false,
                autoplay: attrs.autoplay || false,
                loop: attrs.loop || false,
                muted: attrs.muted || false
            };

            this.showMediaEditModal = true;

            this.$nextTick(() => {
                // Focus on first editable field based on media type
                let selector = '#mediaEditAlt, #mediaEditTitle';
                if (type === 'video') {
                    selector = '#mediaEditTitle, #videoControls';
                }
                const firstInput = document.querySelector(selector);
                if (firstInput) {
                    firstInput.focus();
                    if (firstInput.type === 'text') {
                        firstInput.select();
                    }
                }
            });
        },

        // Add editVideo for videos
        editVideo(pos, attrs) {
            this.editMedia(pos, attrs, 'video');
        },

        // Generic save method for all media types
        saveMediaEdit() {
            if (this.mediaEditData.pos !== null && this.bodyEditor && !this.bodyEditor.isDestroyed) {
                const { pos, type, ...attrs } = this.mediaEditData;

                // Clean up attributes based on type
                const cleanAttrs = {};

                if (type === 'image') {
                    cleanAttrs.src = attrs.src;
                    cleanAttrs.alt = attrs.alt.trim();
                } else if (type === 'video') {
                    cleanAttrs.src = attrs.src;
                    cleanAttrs.controls = attrs.controls;
                    cleanAttrs.autoplay = attrs.autoplay;
                    cleanAttrs.loop = attrs.loop;
                    cleanAttrs.muted = attrs.muted;
                    if (attrs.width) cleanAttrs.width = attrs.width;
                    if (attrs.height) cleanAttrs.height = attrs.height;
                }

                try {
                    const tr = this.bodyEditor.state.tr;
                    tr.setNodeMarkup(pos, null, cleanAttrs);
                    this.bodyEditor.view.dispatch(tr);

                    this.hasUnsavedChanges = true;
                    this.hasUserIntent = true;

                    this.closeMediaEditModal();
                } catch (error) {
                    console.error('Error updating media:', error);
                    alert('Failed to update media. Please try again.');
                }
            }
        },

        closeMediaEditModal() {
            this.showMediaEditModal = false;
            this.mediaEditData = {
                pos: null,
                type: 'image',
                src: '',
                alt: '',
                title: '',
                width: '',
                height: '',
                controls: true,
                autoplay: false,
                loop: false,
                muted: false
            };
        },

        // Delete the media node from the document
        deleteMediaNode() {
            if (this.mediaEditData.pos !== null && this.bodyEditor && !this.bodyEditor.isDestroyed) {
                try {
                    // Create transaction to delete the node
                    const tr = this.bodyEditor.state.tr;

                    // Delete the node at the stored position
                    // We need to delete from pos to pos + node.nodeSize
                    const node = this.bodyEditor.state.doc.nodeAt(this.mediaEditData.pos);
                    if (node) {
                        tr.delete(this.mediaEditData.pos, this.mediaEditData.pos + node.nodeSize);
                        this.bodyEditor.view.dispatch(tr);

                        // Mark as unsaved
                        this.hasUnsavedChanges = true;
                        this.hasUserIntent = true;

                        // Close the modal
                        this.closeMediaEditModal();
                    }
                } catch (error) {
                    console.error('Error deleting media:', error);
                    alert('Failed to delete media. Please try again.');
                }
            }
        },

        // ===== TEMPLATE UTILITY METHODS =====
        isActive(name, attrs = {}) {
            // ‚úÖ TIPTAP v3: Safe active state check
            if (!this.bodyEditor || this.bodyEditor.isDestroyed) return false;
            try {
                // Handle object syntax for text alignment checks
                if (typeof name === 'object' && name.textAlign) {
                    // If alignment is disabled in current context, no button should be active
                    if (!this.canUseTextAlign) return false;

                    // Check if nodes have explicit textAlign attribute
                    const hasExplicitAlign = this.bodyEditor.isActive('paragraph', { textAlign: name.textAlign }) ||
                        this.bodyEditor.isActive('heading', { textAlign: name.textAlign });

                    // For 'left' alignment, also check if no explicit alignment is set (default behavior)
                    if (name.textAlign === 'left' && !hasExplicitAlign) {
                        // Check if current node has no explicit textAlign (defaults to left)
                        try {
                            const { selection } = this.bodyEditor.state;
                            const { $from } = selection;
                            const currentNode = $from.node();
                            return !currentNode.attrs?.textAlign;
                        } catch (error) {
                            return false;
                        }
                    }

                    return hasExplicitAlign;
                }
                // Standard string-based check
                return this.bodyEditor.isActive(name, attrs);
            } catch (error) {
                // During Y.js sync, isActive might fail
                return false;
            }
        },

        // ===== DOCUMENT NAME EDITING =====
        // ===== DOCUMENT NAME MANAGEMENT =====
        // ‚úÖ CORRECT: Set document name in Y.js config (NOT title content)
        setDocumentNameInConfig(documentName) {
            if (!ydocService.isReady() || !documentName) {
                console.warn('‚ö†Ô∏è Cannot set document name: Y.js document not available or empty name');
                return false;
            }

            try {
                // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                ydocService.updateConfig('documentName', documentName);
                ydocService.updateConfig('lastModified', new Date().toISOString());
                // ‚úÖ ROBUST: No flags needed - meaningful name existence prevents auto-updates

                return true;
            } catch (error) {
                console.error('‚ùå Failed to set document name in Y.js config:', error);
                return false;
            }
        },


        // ‚úÖ FIXED: Set permlink in Y.js metadata map (following CLAUDE.md architecture)
        setPermlinkInMetadata(permlink) {
            if (!ydocService.isReady()) {
                console.warn('‚ö†Ô∏è Cannot set permlink: Y.js document not available');
                return false;
            }

            try {
                // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                ydocService.batchUpdate(
                    { lastModified: new Date().toISOString() },
                    { permlink: permlink || '' },
                    'permlink-update'
                );

                return true;
            } catch (error) {
                console.error('‚ùå Failed to set permlink in Y.js metadata:', error);
                return false;
            }
        },

        // ===== DOCUMENT NAME EDITING =====
        // ‚úÖ CORRECT: Edit document name (NOT title content)
        startEditingDocumentName() {
            // ‚úÖ SECURITY: Prevent editing for read-only users
            if (this.isReadOnlyMode) {
                return;
            }

            // ‚úÖ CORRECT: Get current document name from Y.js config first (computed property - no parentheses)
            const currentDocumentName = this.getDocumentNameFromConfig ||
                this.currentFile?.name ||
                this.currentFile?.documentName || '';

            this.isEditingDocumentName = true;
            this.documentNameInput = currentDocumentName;

            this.$nextTick(() => {
                if (this.$refs.documentNameInput) {
                    this.$refs.documentNameInput.focus();
                    this.$refs.documentNameInput.select(); // Select all for easy replacement
                }
            });
        },

        async saveDocumentName() {
            // ‚úÖ FIX: Skip if canceling to prevent blur event from triggering save
            if (this.cancelingEdit) return;

            const newDocumentName = this.documentNameInput.trim();

            if (!newDocumentName) {
                this.isEditingDocumentName = false;
                return;
            }

            // ‚úÖ FIX: Only save if name actually changed
            const currentName = this.getDocumentNameFromConfig || this.currentFile?.name || '';
            if (newDocumentName === currentName) {
                this.isEditingDocumentName = false;
                return;
            }

            try {
                // ‚úÖ TEMP FILE HANDLING: Create IndexedDB persistence when user sets name (shows intent)
                if (this.isTemporaryDocument && !this.indexeddbProvider) {
                    this.debouncedCreateIndexedDBForTempDocument();
                }

                // ‚úÖ CORRECT: Store document name in Y.js config (NOT title content)
                const success = this.setDocumentNameInConfig(newDocumentName);
                // ‚úÖ ROBUST: No flags needed - meaningful name existence prevents auto-updates

                if (success) {
                    // Update reactive document name for immediate UI update
                    this.updateReactiveDocumentName(newDocumentName);

                    // Update component state for immediate UI feedback
                    if (this.currentFile) {
                        this.currentFile.name = newDocumentName;
                        this.currentFile.documentName = newDocumentName;
                        this.currentFile.title = newDocumentName; // For UI display

                        // ‚úÖ SYNC: Update localStorage metadata to keep file list in sync
                        if (this.currentFile.id && this.currentFile.type === 'local') {
                            this.documentStorageService.updateDocumentMetadata(this.currentFile.id, { name: newDocumentName });

                            // ‚úÖ PERFORMANCE: Update document metadata - caching handled internally
                            documentService.updateDocumentMetadata(this.currentFile.id, {
                                documentName: newDocumentName,
                                timestamp: Date.now(),
                                documentId: this.currentFile.id,
                                type: 'local'
                            });

                            // ‚úÖ OFFLINE-FIRST: Update URL when user explicitly saves with name
                            // This shows user intent to persist the document
                            this.updateURLWithLocalParams(this.username || 'anonymous', this.currentFile.id);
                        }

                        // ‚úÖ COLLABORATIVE SYNC: Update server metadata for collaborative documents
                        if (this.currentFile.type === 'collaborative' && this.currentFile.owner && this.currentFile.permlink) {

                            // Update server metadata asynchronously
                            this.updateCollaborativeDocumentName(newDocumentName).catch(error => {
                                console.error('‚ùå Failed to update document name on server:', error);
                                // Show error to user but don't revert local changes
                                this.updateSaveStatus('error', 'Failed to sync document name to server');
                            });
                        }
                    }

                    // ‚úÖ TRIGGER AUTOSAVE: Y.js config change will trigger sync automatically
                    // ‚úÖ READ-ONLY PROTECTION: Block save operations for read-only users
                    if (!this.isReadOnlyMode) {
                        this.hasUnsavedChanges = true;
                        this.clearUnsavedAfterSync(); // Clear unsaved flag after delay (follows TipTap pattern)
                    }

                } else {
                    throw new Error('Failed to update document name in Y.js config');
                }

                this.isEditingDocumentName = false;

            } catch (error) {
                console.error('‚ùå Failed to save document name:', error);
                alert('Failed to save document name: ' + error.message);
            }
        },

        handleDocumentNameKeydown(event) {
            if (event.key === 'Enter') {
                this.saveDocumentName();
            } else if (event.key === 'Escape') {
                this.cancelDocumentNameEdit();
            }
        },

        // Get display name for document, preferring local custom names over server generic names
        getDocumentDisplayName(file) {
            // For collaborative documents, always use documentName from server
            if (file.type === 'collaborative' || file.isCollaborative || file.hasCloudVersion) {
                // Use only documentName for collaborative documents - no fallback
                return file.documentName;
            }

            // For local files, use the name field
            return file.name;
        },

        // ‚úÖ FIX: Proper cancel method that prevents blur save
        cancelDocumentNameEdit() {
            this.cancelingEdit = true; // Prevent blur save
            this.isEditingDocumentName = false;

            // Clear the flag after a short delay to allow blur event to be skipped
            this.$nextTick(() => {
                this.cancelingEdit = false;
            });
        },

        // ===== PERMLINK EDITING =====
        togglePermlinkEditor() {
            if (!this.showPermlinkEditor) {
                // Starting edit - store original value and set temp value
                // ‚úÖ FIX: Use actualPermlink to show current effective value (custom or generated)
                const currentPermlink = this.actualPermlink || '';
                this.originalPermlinkValue = currentPermlink;
                this.permlinkInputTemp = currentPermlink;
                this.showPermlinkEditor = true;

                // Focus the input after it's rendered
                this.$nextTick(() => {
                    if (this.$refs.permlinkInput) {
                        this.$refs.permlinkInput.focus();
                        this.$refs.permlinkInput.select();
                    }
                });
            } else {
                this.showPermlinkEditor = false;
            }
        },

        savePermlink() {
            const newPermlink = this.permlinkInputTemp.trim();

            // Only save if actually changed
            if (newPermlink === this.originalPermlinkValue) {
                this.showPermlinkEditor = false;
                return;
            }

            // ‚úÖ FIX: Update permlinkInput to commit the change to reactive state
            // This ensures debouncedSetPermlinkInMetadata() reads the new value
            this.permlinkInput = newPermlink;

            // Save to Y.js metadata
            this.debouncedSetPermlinkInMetadata();

            // Trigger user intent detection
            this.triggerUserIntentDetection('permlink-change');

            this.showPermlinkEditor = false;
        },

        cancelPermlinkEdit() {
            // ‚úÖ FIX: Restore original state properly
            // If original was a custom permlink, restore it to permlinkInput
            // If original was generated, clear permlinkInput
            if (this.originalPermlinkValue && this.originalPermlinkValue !== this.generatedPermlink) {
                // Was a custom permlink - restore it
                this.permlinkInput = this.originalPermlinkValue;
            } else {
                // Was a generated permlink - clear input so generated shows
                this.permlinkInput = '';
            }

            this.permlinkInputTemp = this.originalPermlinkValue;
            this.showPermlinkEditor = false;

        },

        handlePermlinkKeydown(event) {
            if (event.key === 'Enter') {
                this.savePermlink();
            } else if (event.key === 'Escape') {
                this.cancelPermlinkEdit();
            }
        },

        useGeneratedPermlink() {
            // ‚úÖ RECURSION FIX: Don't modify permlinkInput directly - triggers watcher!
            if (ydocService.isReady() && this.generatedPermlink) {
                // ‚úÖ ARCHITECTURE FIX: Store generated permlink directly in metadata
                ydocService.updateMetadata('permlink', this.generatedPermlink);

                // ‚úÖ TIPTAP USER INTENT: Setting permlink shows intent to create document
                if (this.isTemporaryDocument && !this.indexeddbProvider) {
                    this.debouncedCreateIndexedDBForTempDocument();
                }

                // ‚úÖ RECURSION FIX: Clear permlinkInput so UI shows generated permlink
                this.permlinkInput = '';

                // ‚úÖ FIX: If editor is open, update the temp input to show generated value
                if (this.showPermlinkEditor) {
                    this.permlinkInputTemp = this.generatedPermlink;
                }

            }
        },

        // ===== TAG MANAGEMENT (UI) =====
        addTag() {
            const tag = this.tagInput.trim().toLowerCase();
            if (tag && this.displayTags.length < 10) {
                this.addTagToYjs(tag);
                this.tagInput = '';

                // ‚úÖ CONSISTENT UX: Use same debounced auto-save pattern as other inputs
                if (!this.isReadOnlyMode) {
                    this.hasUnsavedChanges = true;
                    this.hasUserIntent = true;

                    // ‚úÖ FIX: Show save indicator immediately
                    this.$nextTick(() => {
                        this.updateSaveStatus();
                    });

                    this.debouncedUpdateContent();

                    // ‚úÖ TIPTAP USER INTENT: Tag management shows intent to create document
                    if (this.isTemporaryDocument && !this.indexeddbProvider && !this.isCreatingPersistence) {
                        // Tags show user intent - create persistence immediately without content check
                        this.debouncedCreateIndexedDBForTempDocument();
                    } else if (!this.isTemporaryDocument && this.hasIndexedDBPersistence) {
                        this.autoSave();
                    }
                }
            }
        },

        removeTag(index) {
            const tags = this.displayTags;
            if (index >= 0 && index < tags.length) {
                this.removeTagFromYjs(tags[index]);

                // ‚úÖ CONSISTENT UX: Use same debounced auto-save pattern as other inputs
                if (!this.isReadOnlyMode) {
                    this.hasUnsavedChanges = true;
                    this.hasUserIntent = true;

                    // ‚úÖ FIX: Show save indicator immediately
                    this.$nextTick(() => {
                        this.updateSaveStatus();
                    });

                    this.debouncedUpdateContent();

                    // ‚úÖ TIPTAP USER INTENT: Tag management shows intent to create document
                    if (this.isTemporaryDocument && !this.indexeddbProvider && !this.isCreatingPersistence) {
                        // Tags show user intent - create persistence immediately without content check
                        this.debouncedCreateIndexedDBForTempDocument();
                    } else if (!this.isTemporaryDocument && this.hasIndexedDBPersistence) {
                        this.autoSave();
                    }
                }
            }
        },

        // ‚úÖ TIPTAP COMPLIANCE: Tag management through Y.js metadata
        // ===== BENEFICIARIES MANAGEMENT =====
        addBeneficiary() {
            const account = this.beneficiaryInput.account.trim().replace('@', '');
            const percent = parseFloat(this.beneficiaryInput.percent);

            if (account && percent > 0 && percent <= 100 && this.ydoc) {
                const weight = Math.round(percent * 100);

                // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                const currentBeneficiaries = ydocService.getMetadata('beneficiaries') || [];

                // Check if account already exists
                const existingIndex = currentBeneficiaries.findIndex(ben => ben.account === account);
                if (existingIndex !== -1) {
                    currentBeneficiaries[existingIndex].weight = weight;
                } else {
                    currentBeneficiaries.push({ account, weight });
                }

                ydocService.updateMetadata('beneficiaries', currentBeneficiaries);

                // Clear inputs (reset percent to default 1%)
                this.beneficiaryInput.account = '';
                this.beneficiaryInput.percent = '1';

                // ‚úÖ CONSISTENT UX: Use same debounced auto-save pattern as other inputs
                if (!this.isReadOnlyMode) {
                    this.hasUnsavedChanges = true;
                    this.hasUserIntent = true;

                    // ‚úÖ FIX: Show save indicator immediately
                    this.$nextTick(() => {
                        this.updateSaveStatus();
                    });

                    this.debouncedUpdateContent();

                    // ‚úÖ TIPTAP USER INTENT: Beneficiary management shows intent to create document
                    if (this.isTemporaryDocument && !this.indexeddbProvider && !this.isCreatingPersistence) {
                        // Beneficiaries show user intent - create persistence immediately without content check
                        this.debouncedCreateIndexedDBForTempDocument();
                    } else if (!this.isTemporaryDocument && this.hasIndexedDBPersistence) {
                        this.autoSave();
                    }
                }
            } else {
                console.warn('‚ö†Ô∏è Invalid beneficiary input:', { account, percent, hasYdoc: !!this.ydoc });
            }
        },

        removeBeneficiary(index) {
            if (ydocService.isReady()) {
                // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                const currentBeneficiaries = ydocService.getMetadata('beneficiaries') || [];
                if (index >= 0 && index < currentBeneficiaries.length) {
                    // Check if this beneficiary is required (can't be removed)
                    if (currentBeneficiaries[index].required) {
                        console.warn('‚ö†Ô∏è Cannot remove required beneficiary:', currentBeneficiaries[index]);
                        return;
                    }
                    currentBeneficiaries.splice(index, 1);
                    ydocService.updateMetadata('beneficiaries', currentBeneficiaries);
                }

                // ‚úÖ CONSISTENT UX: Use same debounced auto-save pattern as other inputs
                if (!this.isReadOnlyMode) {
                    this.hasUnsavedChanges = true;
                    this.hasUserIntent = true;

                    // ‚úÖ FIX: Show save indicator immediately
                    this.$nextTick(() => {
                        this.updateSaveStatus();
                    });

                    this.debouncedUpdateContent();

                    // ‚úÖ TIPTAP USER INTENT: Beneficiary management shows intent to create document
                    if (this.isTemporaryDocument && !this.indexeddbProvider && !this.isCreatingPersistence) {
                        // Beneficiaries show user intent - create persistence immediately without content check
                        this.debouncedCreateIndexedDBForTempDocument();
                    } else if (!this.isTemporaryDocument && this.hasIndexedDBPersistence) {
                        this.autoSave();
                    }
                }
            }
        },

        // ===== COMMENT OPTIONS HANDLING =====
        handleCommentOptionChanged() {
            if (!this.ydoc || this.isReadOnlyMode) return;
            
            console.log('üìù COMMENT OPTIONS: Change detected', {
                reactive: this.reactiveCommentOptions,
                hasYdoc: !!this.ydoc,
                isReadOnly: this.isReadOnlyMode,
                timestamp: Date.now()
            });
            
            // ‚úÖ IMMEDIATELY save to Y.js (like title and custom JSON do)
            if (ydocService.isReady()) {
                ydocService.batchUpdate(
                    { lastModified: new Date().toISOString() },
                    { 
                        allowVotes: this.reactiveCommentOptions.allowVotes,
                        allowCurationRewards: this.reactiveCommentOptions.allowCurationRewards,
                        maxAcceptedPayout: this.reactiveCommentOptions.maxAcceptedPayout,
                        percentHbd: this.reactiveCommentOptions.percentHbd
                    },
                    'commentoptions-update'
                );
                
                console.log('üìù COMMENT OPTIONS: Saved to Y.js immediately', {
                    values: this.reactiveCommentOptions,
                    timestamp: Date.now()
                });
            }
            
            // ‚úÖ Then trigger persistence and auto-save (like other fields)
            this.triggerUserIntentDetection('commentoptions-change');
        },

        // ===== TITLE HANDLING =====
        handleTitleInput() {
            console.log('üìù TITLE: Input changed', {
                title: this.titleInput,
                isTemporary: this.isTemporaryDocument,
                hasYdoc: !!this.ydoc
            });
            
            // Sync title to Y.js metadata map
            if (ydocService.isReady() && this.titleInput !== undefined) {
                ydocService.batchUpdate(
                    { lastModified: new Date().toISOString() },
                    { title: this.titleInput || '' },
                    'title-sync'
                );
            }
            
            // Use standard user intent detection
            this.triggerUserIntentDetection('title-change');
        },

        // ===== CUSTOM JSON HANDLING =====
        handleCustomJsonInput() {
            try {
                if (this.customJsonString.trim() && this.ydoc) {
                    const parsed = JSON.parse(this.customJsonString);

                    // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                    ydocService.updateMetadata('customJson', parsed);

                    this.customJsonError = '';

                    // ‚úÖ FIX: Show save indicator and trigger autosave
                    if (!this.isReadOnlyMode) {
                        this.hasUnsavedChanges = true;
                        this.hasUserIntent = true;

                        // Call updateSaveStatus directly to ensure message shows
                        this.$nextTick(() => {
                            this.updateSaveStatus();
                        });

                        this.autoSave();
                    }

                    // ‚úÖ TIPTAP USER INTENT: Custom JSON editing shows intent to create document
                    if (this.isTemporaryDocument && !this.indexeddbProvider) {
                        this.debouncedCreateIndexedDBForTempDocument();
                    }
                } else if (ydocService.isReady()) {
                    // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                    ydocService.updateMetadata('customJson', {});

                    this.customJsonError = '';
                }

                // ‚úÖ CONSISTENT UX: Use same debounced auto-save pattern as title and body
                if (!this.isReadOnlyMode) {
                    this.hasUnsavedChanges = true;
                    this.hasUserIntent = true;

                    // ‚úÖ FIX: Show save indicator immediately
                    this.$nextTick(() => {
                        this.updateSaveStatus();
                    });

                    this.debouncedUpdateContent();

                    // Apply same save pattern as title input
                    if (this.isTemporaryDocument && !this.indexeddbProvider && !this.isCreatingPersistence) {
                        this.debouncedCheckUserIntentAndCreatePersistence();
                    } else if (!this.isTemporaryDocument && this.hasIndexedDBPersistence) {
                        this.autoSave();
                    }
                }
            } catch (error) {
                this.customJsonError = 'Invalid JSON format';
            }
        },

        // ===== COMMENT OPTIONS =====
        handleCommentOptionChange() {
            if (ydocService.isReady()) {
                // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                ydocService.updateMetadata('commentOptions', this.commentOptions);

                // ‚úÖ TIPTAP USER INTENT: Comment options editing shows intent to create document
                if (this.isTemporaryDocument && !this.indexeddbProvider) {
                    this.debouncedCreateIndexedDBForTempDocument();
                }
            }
        },

        // ===== MODAL MANAGEMENT =====
        openLoadModal() {
            // üì± OFFLINE-FIRST: Log state when opening modal
            console.log('üì± OFFLINE-FIRST: Opening load modal');
            console.log('  localFilesCount:', this.localFiles.length);
            console.log('  collaborativeDocsCount:', this.collaborativeDocs.length);
            console.log('  offlineCachesCount:', this.offlineCaches?.length || 0);
            if (this.offlineCaches && this.offlineCaches.length > 0) {
                console.log('  offlineCaches:');
                this.offlineCaches.forEach((c, i) => {
                    console.log(`    [${i}]:`, {
                        id: c.id,
                        owner: c.owner,
                        permlink: c.permlink,
                        name: c.name
                    });
                });
            }
            console.log('  allDocumentsCount:', this.allDocuments.length);
            console.log('  accessibleDocumentsCount:', this.accessibleDocuments.length);
            console.log('  isAuthenticated:', this.isAuthenticated);
            console.log('  username:', this.username);
            
            this.showLoadModal = true;

            // ‚úÖ VUE REACTIVITY: Use $nextTick to ensure modal DOM is rendered before operations
            this.$nextTick(() => {
                // ‚úÖ OFFLINE-FIRST: Always scan for cached collaborative documents
                console.log('üì± OFFLINE-FIRST: Triggering IndexedDB scan from modal open');
                
                // First try to load collaborative docs (which includes scan if not authenticated)
                this.loadCollaborativeDocs().then(() => {
                    console.log('üì± OFFLINE-FIRST: loadCollaborativeDocs complete from modal');
                    console.log('  offlineCachesAfter:', this.offlineCaches?.length || 0);
                    console.log('  accessibleDocumentsAfter:', this.accessibleDocuments?.length || 0);
                }).catch(error => {
                    console.error('‚ùå OFFLINE-FIRST: loadCollaborativeDocs failed from modal');
                    console.error('  Error:', error.message);
                    console.error('  Stack:', error.stack);
                });
                
                // Also trigger direct scan as backup
                const cachedScan = documentService.getIndexedDBScanCache();
                if (!cachedScan) {
                    this.scanIndexedDBDocuments().then(additionalDocs => {
                        if (additionalDocs && additionalDocs.length > 0) {
                            // Merge additional IndexedDB documents that aren't already in localStorage
                            additionalDocs.forEach(doc => {
                                // Handle collaborative caches differently
                                if (doc.type === 'collaborative') {
                                    // Check if already in offlineCaches
                                    const existsInOfflineCaches = this.offlineCaches.some(
                                        c => c.owner === doc.owner && c.permlink === doc.permlink
                                    );
                                    if (!existsInOfflineCaches) {
                                        this.offlineCaches.push(doc);
                                    }
                                } else {
                                    // Handle local/temp documents
                                    const existsInLocalStorage = this.localFiles.some(f => f.id === doc.id);
                                    if (!existsInLocalStorage && (doc.id.startsWith('local_') || doc.id.startsWith('temp_'))) {
                                        this.localFiles.push({
                                            ...doc,
                                            type: 'local',
                                            hasLocalVersion: true,
                                            isOfflineFirst: true
                                        });
                                    }
                                }
                            });
                        }
                    }).catch(error => {
                        console.error('‚ùå Lazy IndexedDB scan failed:', error);
                    });
                }
            });
        },

        closeLoadModal() {
            this.showLoadModal = false;
        },

        openSaveModal() {
            this.showSaveModal = true;

            // ‚úÖ VUE REACTIVITY: Use $nextTick for potential DOM-dependent operations
            this.$nextTick(() => {
                // Focus first input field if needed in the future
                if (this.$refs.saveModalInput) {
                    this.$refs.saveModalInput.focus();
                }
            });
        },

        closeSaveModal() {
            this.showSaveModal = false;
        },

        async openShareModal() {

            // Clear the form before showing the modal
            this.shareForm.username = '';
            this.shareForm.permission = 'readonly';

            // ‚úÖ CRITICAL FIX: Load shared users when opening share modal
            await this.loadSharedUsers();

            // ‚úÖ VUE REACTIVITY: Use $nextTick to ensure modal DOM is rendered
            this.$nextTick(() => {
                this.showShareModal = true;

                // Focus username input field when modal opens
                if (this.$refs.shareUsernameInput) {
                    this.$refs.shareUsernameInput.focus();
                }
            });
        },

        closeShareModal() {
            this.showShareModal = false;
            // Clear the form when closing
            this.shareForm.username = '';
            this.shareForm.permission = 'readonly';
        },

        async loadSharedUsers() {
            if (!this.currentFile || this.currentFile.type !== 'collaborative') {
                return;
            }

            if (!this.isAuthenticated) {
                console.warn('Cannot load shared users: Not authenticated');
                return;
            }

            // Only owners can see the full permissions list
            if (this.currentFile.owner !== this.username) {
                return;
            }

            // ‚úÖ DEBUG: Always fetch fresh permissions for share modal to ensure accuracy

            try {

                const permissionsUrl = `https://data.dlux.io/api/collaboration/permissions/${this.currentFile.owner}/${this.currentFile.permlink}`;
                const response = await fetch(permissionsUrl, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        ...this.getAuthHeadersForRequest()
                    }
                });

                // ‚úÖ VERSION CHECK: Look for server version info in permissions API headers
                const serverVersion = response.headers.get('x-server-version') ||
                    response.headers.get('server-version') ||
                    response.headers.get('x-hocuspocus-version') ||
                    response.headers.get('hocuspocus-version');
                if (serverVersion) {
                }

                if (response.ok) {
                    try {
                        const permissionsData = await response.json();

                        // Cache permissions instead of setting directly
                        const documentKey = `${this.currentFile.owner}/${this.currentFile.permlink}`;
                        this.cacheService.cacheDocumentPermissions(documentKey, permissionsData.permissions || []);

                    } catch (jsonError) {
                        // Get raw response for debugging
                        const responseText = await response.text().catch(() => 'Could not read response');
                        console.error('‚ùå LOADSHAREDUSERS JSON PARSE ERROR:', {
                            url: permissionsUrl,
                            status: response.status,
                            error: jsonError.message,
                            responsePreview: responseText.substring(0, 200)
                        });
                        // Permissions cleared - computed properties will return empty arrays
                    }
                } else {
                    console.error('‚ùå SHARE MODAL: Failed to load shared users', {
                        status: response.status,
                        statusText: response.statusText
                    });
                    // sharedUsers computed property will return empty array
                }

            } catch (error) {
                console.error('‚ùå SHARE MODAL: Error loading shared users:', error);
                // sharedUsers computed property will return empty array
            }
        },

        async updateUserPermission(username, newPermission) {
            if (!this.currentFile || this.currentFile.type !== 'collaborative') {
                return;
            }

            // Find the current user to check if permission actually changed
            const currentUser = this.sharedUsers.find(user => user.account === username);
            if (!currentUser || currentUser.permissionType === newPermission) {
                return; // No change needed
            }

            try {

                const requestPayload = {
                    targetAccount: username,
                    permissionType: newPermission
                };

                const response = await fetch(`https://data.dlux.io/api/collaboration/permissions/${this.currentFile.owner}/${this.currentFile.permlink}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...this.getAuthHeadersForRequest()
                    },
                    body: JSON.stringify(requestPayload)
                });

                if (response.ok) {

                    // ‚úÖ CLEAR CACHES FIRST: Clear permission caches before reloading fresh data
                    this.clearAllPermissionCaches();

                    // ‚úÖ RELOAD FRESH DATA: Get updated permissions from API
                    await this.loadSharedUsers();

                    // ‚úÖ OFFLINE-FIRST: Real-time permission updates
                    if (this.realtimePermissionUpdates) {
                        // Reload permissions to update caches
                        // ‚úÖ TIPTAP BEST PRACTICE: Non-blocking permission refresh
                        this.loadDocumentPermissions('permission-update').catch(error => {
                            console.warn('‚ö†Ô∏è Background permission refresh failed:', error);
                        });

                        // ‚úÖ BACKGROUND: Refresh collaborative documents list to update accessType
                        // Only refresh if not viewing a single document
                        const isViewingSingleDoc = this.currentFile && 
                                                 this.currentFile.type === 'collaborative';
                        if (!isViewingSingleDoc) {
                            this.loadCollaborativeDocs().catch(error => {
                                console.warn('‚ö†Ô∏è REAL-TIME UPDATE: Collaborative docs refresh failed:', error.message);
                            });
                        } else {
                            console.log('‚ÑπÔ∏è Skipping document list refresh after permission update - viewing single document');
                        }

                        // ‚úÖ TRIGGER: Force permission refresh timestamp update
                        this.permissionTimestamps.lastRefresh = Date.now();
                    }

                    // Show success message
                    const permissionLabels = {
                        'readonly': 'Read Only',
                        'editable': 'Editable',
                        'postable': 'Full Access'
                    };
                    alert(`Updated @${username} permission to ${permissionLabels[newPermission]}!`);

                } else {
                    const errorText = await response.text().catch(() => 'Unknown error');
                    console.error('‚ùå SHARE MODAL: Failed to update user permission', {
                        status: response.status,
                        statusText: response.statusText,
                        error: errorText
                    });

                    // Revert the dropdown to the original value
                    // Vue's computed property will handle reactivity automatically

                    alert(`Failed to update permission: ${response.statusText}\n${errorText}`);
                }

            } catch (error) {
                console.error('‚ùå SHARE MODAL: Error updating user permission:', error);

                // Revert the dropdown to the original value
                // Vue's computed property will handle reactivity automatically

                alert('Failed to update user permission. Please try again.');
            }
        },

        async removeUserAccess(username) {
            if (!this.currentFile || this.currentFile.type !== 'collaborative') {
                return;
            }

            if (!confirm(`Remove access for @${username}?`)) {
                return;
            }

            try {

                const response = await fetch(`https://data.dlux.io/api/collaboration/permissions/${this.currentFile.owner}/${this.currentFile.permlink}/${username}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        ...this.getAuthHeadersForRequest()
                    }
                });

                if (response.ok) {

                    // The sharedUsers computed property will automatically update when cache changes

                    // ‚úÖ OFFLINE-FIRST: Real-time permission updates
                    if (this.realtimePermissionUpdates) {
                        // Reload permissions to update caches
                        // ‚úÖ TIPTAP BEST PRACTICE: Non-blocking permission refresh
                        this.loadDocumentPermissions('permission-revoke-update').catch(error => {
                            console.warn('‚ö†Ô∏è Background permission refresh failed:', error);
                        });

                        // ‚úÖ BACKGROUND: Refresh collaborative documents list to update accessType
                        // Only refresh if not viewing a single document
                        const isViewingSingleDoc = this.currentFile && 
                                                 this.currentFile.type === 'collaborative';
                        if (!isViewingSingleDoc) {
                            this.loadCollaborativeDocs().catch(error => {
                                console.warn('‚ö†Ô∏è REAL-TIME UPDATE: Collaborative docs refresh failed:', error.message);
                            });
                        } else {
                            console.log('‚ÑπÔ∏è Skipping document list refresh after permission update - viewing single document');
                        }

                        // ‚úÖ TRIGGER: Force permission refresh timestamp update
                        this.permissionTimestamps.lastRefresh = Date.now();
                    }

                    this.clearAllPermissionCaches();

                } else {
                    const errorText = await response.text().catch(() => 'Unknown error');
                    console.error('‚ùå SHARE MODAL: Failed to remove user access', {
                        status: response.status,
                        statusText: response.statusText,
                        error: errorText
                    });
                    alert(`Failed to remove access: ${response.statusText}\n${errorText}`);
                }

            } catch (error) {
                console.error('‚ùå SHARE MODAL: Error removing user access:', error);
                alert('Failed to remove user access. Please try again.');
            }
        },

        openPublishModal() {
            this.showPublishModal = true;
        },

        closePublishModal() {
            this.showPublishModal = false;
        },

        // ===== TABLE SORTING =====
        sortTable(column) {
            if (this.sortColumn === column) {
                // If clicking the same column, toggle direction
                this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                // If clicking a different column, set it as sort column with descending order
                this.sortColumn = column;
                this.sortDirection = 'desc';
            }

        },

        // ===== MAIN ACTION DELEGATION =====
        async publishPost() {
            await this.publishDocument();
        },

        // ===== DUPLICATE DOCUMENT =====
        async duplicateDocument() {
            if (!this.currentFile) {
                alert('No document to duplicate');
                return;
            }

            try {
                // Extract current document data
                const documentData = this.extractCurrentDocumentData();

                // Generate copy name
                const originalName = documentData.documentName || 'Untitled';
                const copyName = `${originalName} - Copy`;

                // Create new document based on type
                if (this.currentFile.type === 'collaborative') {
                    await this.duplicateCollaborativeDocument(copyName, documentData);
                } else {
                    await this.duplicateLocalDocument(copyName, documentData);
                }

                // Show success message
                this.showSaveMessage(`Document duplicated as "${copyName}"`, false);

            } catch (error) {
                console.error('Failed to duplicate document:', error);
                alert(`Failed to duplicate document: ${error.message}`);
            }
        },

        extractCurrentDocumentData() {
            // Extract all current document data
            const bodyHtml = this.bodyEditor ? this.bodyEditor.getHTML() : '';

            const data = {
                // Get document name from Y.js config
                documentName: ydocService.getConfig('documentName') || this.currentFile?.name || 'Untitled',

                // Content from editors (following TipTap best practices)
                title: this.titleInput || '',
                body: bodyHtml,

                // Metadata from reactive properties
                tags: [...(this.reactiveTags || [])],
                beneficiaries: [...(this.reactiveBeneficiaries || [])],
                customJson: { ...(this.reactiveCustomJson || {}) },
                commentOptions: { ...(this.reactiveCommentOptions || {}) },

                // Additional metadata from Y.js maps if available
                permlink: ydocService.getMetadata('permlink') || ''
            };

            return data;
        },

        async duplicateLocalDocument(copyName, documentData) {
            // Create new local document
            await this.newDocument();

            // Populate with extracted data
            await this.populateDocumentData(copyName, documentData);

            // Trigger persistence immediately since we have content
            this.hasUserIntent = true;
            this.hasUnsavedChanges = true;
            this.debouncedCreateIndexedDBForTempDocument();
        },

        async duplicateCollaborativeDocument(copyName, documentData) {
            if (!this.isAuthenticated) {
                throw new Error('Authentication required for collaborative document duplication');
            }

            // Create collaborative document via API
            const response = await fetch('https://data.dlux.io/api/collaboration/documents', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    ...this.getAuthHeadersForRequest()
                },
                body: JSON.stringify({
                    documentName: copyName,
                    title: documentData.title || copyName,
                    description: 'Duplicated document created with DLUX TipTap Editor'
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                throw new Error(`Failed to create collaborative document: ${errorData.error || response.statusText}`);
            }

            const docData = await response.json();
            const serverDoc = docData.document || docData;

            // Create collaborative file object with proper structure
            const collaborativeFile = {
                ...serverDoc,
                id: `${serverDoc.owner}/${serverDoc.permlink}`, // Collaborative documents use owner/permlink as ID
                type: 'collaborative',
                name: serverDoc.documentName || copyName,
                documentName: serverDoc.documentName || copyName
            };

            // Load the new collaborative document using the main loadDocument method
            await this.loadDocument(collaborativeFile);

            // Populate with extracted data
            await this.populateDocumentData(copyName, documentData);
        },

        async populateDocumentData(documentName, data) {
            if (!this.ydoc) {
                console.error('No Y.js document available for population');
                return;
            }

            // Set document name in config map
            ydocService.updateConfig('documentName', documentName);

            // Set metadata in metadata map
            const metadataUpdates = {};
            if (data.title) metadataUpdates.title = data.title;
            if (data.tags.length > 0) metadataUpdates.tags = data.tags;
            if (data.beneficiaries.length > 0) metadataUpdates.beneficiaries = data.beneficiaries;
            if (Object.keys(data.customJson).length > 0) metadataUpdates.customJson = data.customJson;
            if (data.permlink) metadataUpdates.permlink = data.permlink;

            // Set comment options
            if (data.commentOptions.allowVotes !== undefined) metadataUpdates.allowVotes = data.commentOptions.allowVotes;
            if (data.commentOptions.allowCurationRewards !== undefined) metadataUpdates.allowCurationRewards = data.commentOptions.allowCurationRewards;
            if (data.commentOptions.maxAcceptedPayout !== undefined) metadataUpdates.maxAcceptedPayout = data.commentOptions.maxAcceptedPayout;
            if (data.commentOptions.percentHbd !== undefined) metadataUpdates.percentHbd = data.commentOptions.percentHbd;
            
            // Apply all metadata updates at once
            ydocService.batchUpdate({}, metadataUpdates);

            // Set title in input (will sync to metadata map via watcher)
            if (data.title) {
                this.titleInput = data.title;
            }

            // Set body content in editor (following TipTap best practices)
            if (data.body && this.bodyEditor) {
                // Use nextTick to ensure editor is ready
                await this.$nextTick();
                if (!this.bodyEditor.isDestroyed) {
                    this.bodyEditor.commands.setContent(data.body);
                }
            }

        },

        // ===== ENHANCED DELETE DOCUMENT =====
        async deleteDocument(file) {
            if (!file) return;

            // Use getDocumentDisplayName for consistent naming
            const fileName = this.getDocumentDisplayName(file) || 'Untitled';
            if (confirm(`‚ö†Ô∏è Delete "${fileName}"? This action cannot be undone.`)) {
                try {
                    if (file.type === 'local') {
                        // Delete from localStorage
                        const localFiles = this.documentStorageService.getAllDocuments();
                        const updatedFiles = localFiles.filter(f => f.id !== file.id);
                        this.documentStorageService.saveAllDocuments(updatedFiles);

                        // Delete from IndexedDB if exists
                        if (file.id) {
                            try {
                                const deleteReq = indexedDB.deleteDatabase(file.id);
                                await new Promise((resolve) => {
                                    deleteReq.onsuccess = resolve;
                                    deleteReq.onerror = resolve; // Don't fail if database doesn't exist
                                    deleteReq.onblocked = resolve;
                                });
                            } catch (error) {
                                console.warn('‚ö†Ô∏è Could not delete IndexedDB document:', error.message);
                            }
                        }

                        // Refresh local files list
                        await this.loadLocalFiles();

                    } else if (file.type === 'collaborative') {
                        // Delete collaborative document using dedicated method
                        await this.deleteCollaborativeDocument(file);
                        return;
                    }

                    // If this was the current file, clear it
                    if (this.currentFile && this.currentFile.id === file.id) {
                        await this.documentManager.newDocument();
                    }

                } catch (error) {
                    console.error('‚ùå Failed to delete document:', error);
                    alert('Error deleting document: ' + error.message);
                }
            }
        },

        // ===== UTILITY METHODS =====
        // Status and display helpers
        // Status indicator styling methods (matching autosave banner style)
        getStatusStyle(state) {
            const styles = {
                // Temp documents (not yet drafts) - grey background
                'temp-editing': 'background: rgba(108, 117, 125, 0.1); border-left: 3px solid #6c757d;', // Grey for temp editing
                'temp-ready': 'background: rgba(108, 117, 125, 0.1); border-left: 3px solid #6c757d;', // Grey for temp ready
                'initializing': 'background: rgba(108, 117, 125, 0.1); border-left: 3px solid #6c757d;', // Grey for initializing
                'cleaning-up': 'background: rgba(108, 117, 125, 0.1); border-left: 3px solid #6c757d;', // Grey for cleanup
                'no-document': 'background: rgba(108, 117, 125, 0.1); border-left: 3px solid #6c757d;', // Grey for no document

                // Local documents (dotted cloud) - proper color coding for save states
                'saving-local': 'background: rgba(255, 193, 7, 0.1); border-left: 3px solid #ffc107;', // Orange for changes
                'saved-local': 'background: rgba(13, 202, 240, 0.1); border-left: 3px solid #0dcaf0;', // Blue for locally saved

                // Collaborative documents offline mode
                'cloud-offline': 'background: rgba(25, 135, 84, 0.1); border-left: 3px solid #198754;', // Green for collaborative offline
                'cloud-disconnected': 'background: rgba(13, 202, 240, 0.1); border-left: 3px solid #0dcaf0;', // Blue for disconnected
                'cloud-disconnected-saving': 'background: rgba(255, 193, 7, 0.1); border-left: 3px solid #ffc107;', // Orange for disconnected saving
                'offline-saving': 'background: rgba(255, 193, 7, 0.1); border-left: 3px solid #ffc107;', // Orange for changes
                'offline-ready': 'background: rgba(13, 202, 240, 0.1); border-left: 3px solid #0dcaf0;', // Blue for offline ready
                'unsynced-changes': 'background: rgba(255, 193, 7, 0.1); border-left: 3px solid #ffc107;', // Orange for unsynced
                'offline': 'background: rgba(13, 202, 240, 0.1); border-left: 3px solid #0dcaf0;', // Blue for offline

                // Collaborative documents online mode
                'connecting': 'background: rgba(13, 110, 253, 0.1); border-left: 3px solid #0d6efd;',
                'syncing': 'background: rgba(255, 193, 7, 0.1); border-left: 3px solid #ffc107;', // Orange for syncing
                'collaborating': 'background: rgba(25, 135, 84, 0.1); border-left: 3px solid #198754;', // Green for collaborating
                'synced': 'background: rgba(25, 135, 84, 0.1); border-left: 3px solid #198754;', // Green for synced

                // New states for collaborative documents
                'read-only-collaborative': 'background: rgba(108, 117, 125, 0.1); border-left: 3px solid #6c757d;', // Grey for read-only
                'loading-collaborative': 'background: rgba(13, 110, 253, 0.1); border-left: 3px solid #0d6efd;', // Blue for loading

                // Error states
                'error': 'background: rgba(220, 53, 69, 0.1); border-left: 3px solid #dc3545;', // Red for errors
                'unknown': 'background: rgba(108, 117, 125, 0.1); border-left: 3px solid #6c757d;' // Grey for unknown
            };
            return styles[state] || styles.unknown;
        },

        getStatusIconClass(state) {
            const icons = {
                // Temp documents (not yet drafts)
                'temp-editing': 'fas fa-edit text-muted', // Grey edit icon for temp editing
                'temp-ready': 'fas fa-file-alt text-muted', // Grey file icon for temp ready
                'initializing': 'fas fa-circle-notch fa-spin text-muted', // Grey spinner for initializing
                'cleaning-up': 'fas fa-broom text-muted', // Grey broom icon for cleanup
                'no-document': 'fas fa-file text-muted', // Grey file icon for no document

                // Local documents (dotted cloud)
                'saving-local': 'fas fa-circle-notch fa-spin text-warning', // Orange spinner for saving
                'saved-local': 'fas fa-check text-info', // Blue check for locally saved

                // Collaborative documents offline mode
                'cloud-offline': 'fas fa-cloud text-success', // Green cloud for collaborative offline
                'cloud-disconnected': 'fas fa-cloud-slash text-warning', // Orange cloud with slash for disconnected
                'cloud-disconnected-saving': 'fas fa-circle-notch fa-spin text-warning', // Orange spinner for disconnected saving
                'offline-saving': 'fas fa-circle-notch fa-spin text-warning', // Orange spinner for saving
                'offline-ready': 'fas fa-hard-drive text-info', // Blue hard drive for offline ready
                'unsynced-changes': 'fas fa-exclamation-triangle text-warning', // Orange warning for unsynced
                'offline': 'fas fa-wifi-slash text-info', // Blue wifi slash for offline

                // Collaborative documents online mode
                'connecting': 'fas fa-circle-notch fa-spin text-primary', // Blue spinner for connecting
                'syncing': 'fas fa-sync fa-spin text-warning', // Orange sync for syncing
                'collaborating': 'fas fa-users text-success', // Green users for collaborating
                'synced': 'fas fa-cloud text-success', // Green cloud for synced

                // New states for collaborative documents
                'read-only-collaborative': 'fas fa-eye text-muted', // Grey eye for read-only
                'loading-collaborative': 'fas fa-circle-notch fa-spin text-primary', // Blue spinner for loading

                // Error states
                'error': 'fas fa-exclamation-circle text-danger', // Red error icon
                'unknown': 'fas fa-question-circle text-muted' // Grey question for unknown
            };
            return icons[state] || icons.unknown;
        },

        // Utility methods
        formatTime(date) {
            if (!date) return '';
            return new Date(date).toLocaleTimeString();
        },

        copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {

            }).catch(err => {
                console.error('‚ùå Failed to copy:', err);
            });
        },

        // Helper method to format file size
        formatFileSize(size) {
            if (!size || size === 0) return '0 KB';
            const kb = size / 1024;
            if (kb < 1024) return `${kb.toFixed(1)} KB`;
            const mb = kb / 1024;
            return `${mb.toFixed(1)} MB`;
        },

        // Helper method to format file date
        formatFileDate(date) {
            if (!date) return 'Unknown';
            try {
                const now = new Date();
                const fileDate = new Date(date);
                const diffMs = now - fileDate;
                const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

                if (diffDays === 0) {
                    return fileDate.toLocaleTimeString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                } else if (diffDays === 1) {
                    return 'Yesterday';
                } else if (diffDays < 7) {
                    return `${diffDays} days ago`;
                } else {
                    return fileDate.toLocaleDateString('en-US', {
                        month: 'short',
                        day: 'numeric'
                    });
                }
            } catch (error) {
                return 'Invalid date';
            }
        },

        // Helper method to check if document has unsaved changes
        hasUnsavedChangesForDocument(file) {
            return this.isCurrentDocument(file) && this.hasUnsavedChanges;
        },

        // ‚úÖ TIPTAP PERFECT COMPLIANCE: Debounced content check outside onUpdate
        debouncedCheckUserIntentAndCreatePersistence() {

            // ‚úÖ REACTIVE PATTERN: Check intent immediately, no artificial delays
            if (this.isCreatingPersistence || !this.isTemporaryDocument || this.indexeddbProvider) {
                return;
            }

            // ‚úÖ FIX: Don't create persistence if editor was JUST created
            const editorAge = Date.now() - (this.editorCreatedAt || 0);
            if (editorAge < 1000) { // Wait at least 1 second after editor creation
                return;
            }

            // ‚úÖ FIX: Don't create persistence during initialization or document loading
            if (!this.editorInitialized || this.isLoadingDocument) {
                return;
            }

            // ‚úÖ FIX: Any user interaction shows intent - create persistence immediately
            this.createIndexedDBForTempDocument();
        },

        // ===== JSON PREVIEW METHODS =====

        // Get body content as markdown (Hive posts are markdown)
        getBodyContent() {
            if (!this.bodyEditor) return '';

            // Always return markdown for Hive posts
            return this.getMarkdownContent().replace(/^# .*\n\n/, ''); // Remove title if present
        },

        // Open JSON preview modal
        openJsonPreview() {

            // Update the preview data
            this.updateJsonPreview();

            // Show the modal
            this.jsonPreviewModal.show = true;
            this.jsonPreviewModal.tab = 'complete';

            // Validate the structure
            this.validateJsonStructure();
        },

        // Update JSON preview data
        updateJsonPreview() {
            // Get current comment operation
            const commentOp = this.commentOperation;
            this.jsonPreview.comment = commentOp;

            // Get comment options if non-default
            const commentOptionsOp = this.commentOptionsOperation;
            this.jsonPreview.commentOptions = commentOptionsOp;

            // Get complete operations array
            this.jsonPreview.complete = this.completeOperations;

            // Get custom JSON data
            this.jsonPreview.customJson = this.reactiveCustomJson;

            // Update metadata
            this.jsonPreview.metadata = {
                author: this.username || 'anonymous',
                permlink: this.actualPermlink,
                title: this.titleInput || 'Untitled',
                hasCommentOptions: !!commentOptionsOp,
                tagsCount: this.displayTags.length,
                beneficiariesCount: this.beneficiariesArray.length,
                hasCustomJson: Object.keys(this.reactiveCustomJson).length > 0,
                generatedAt: new Date().toISOString()
            };
        },

        // Validate JSON structure for Hive
        validateJsonStructure() {
            const errors = [];
            const warnings = [];

            // Check required fields
            if (!this.titleInput || !this.titleInput.trim()) {
                errors.push('Title is required');
            }

            if (!this.actualPermlink) {
                errors.push('Permlink is required');
            }

            if (!this.username) {
                errors.push('Username is required for publishing');
            }

            // Check body content
            const bodyContent = this.getBodyContent();
            if (!bodyContent || bodyContent.trim() === '<p></p>' || bodyContent.trim() === '') {
                errors.push('Body content is required');
            }

            // Check permlink format
            if (this.actualPermlink && !/^[a-z0-9-]+$/.test(this.actualPermlink)) {
                errors.push('Permlink must contain only lowercase letters, numbers, and hyphens');
            }

            // Check beneficiaries
            if (this.beneficiariesArray.length > 0) {
                const totalWeight = this.beneficiariesArray.reduce((sum, b) => sum + (b.weight || 0), 0);
                if (totalWeight > 10000) {
                    errors.push(`Total beneficiaries weight (${totalWeight / 100}%) exceeds 100%`);
                }

                // Check for duplicate beneficiaries
                const accounts = this.beneficiariesArray.map(b => b.account);
                const duplicates = accounts.filter((acc, idx) => accounts.indexOf(acc) !== idx);
                if (duplicates.length > 0) {
                    errors.push(`Duplicate beneficiaries: ${duplicates.join(', ')}`);
                }
            }

            // Warnings
            if (this.displayTags.length === 0) {
                warnings.push('No tags specified - consider adding tags for better discoverability');
            }

            if (this.displayTags.length > 5) {
                warnings.push(`Using ${this.displayTags.length} tags - only first 5 tags are indexed by Hive`);
            }

            // Update validation state
            this.jsonPreviewModal.validation = {
                valid: errors.length === 0,
                errors,
                warnings
            };
        },

        // Copy JSON to clipboard
        copyJsonToClipboard(jsonData) {
            const jsonString = JSON.stringify(jsonData, null, 2);
            navigator.clipboard.writeText(jsonString).then(() => {
                // You might want to show a toast notification here
            }).catch(err => {
                console.error('‚ùå Failed to copy JSON:', err);
            });
        },

        publishToHive() {
            if (!this.jsonPreviewModal.validation.valid) {
                alert('Please fix all errors before publishing');
                return;
            }

            // Build the operations array for Hive
            const operations = [];

            // Comment operation (always comes first)
            const commentOperation = ["comment", this.commentOperation.comment];
            operations.push(commentOperation);

            // Add comment_options only if we have non-default values
            if (this.commentOptionsOperation) {
                const commentOptionsOperation = ["comment_options", this.commentOptionsOperation.comment_options];
                operations.push(commentOptionsOperation);
            }

            // Console log the complete operation for debugging

            // Package the operation for sendIt() - this is the format expected by the signing system
            const signOperation = {
                type: "raw",
                key: "posting",
                op: JSON.stringify(operations),
                callbacks: [], //get new replies for a/p
                txid: `posting...`,
            }

            // Close the modal
            this.jsonPreviewModal.show = false;
        },

        // ‚úÖ PHASE 1: Missing debouncedUpdateContent method - fixes hanging saving indicator
        debouncedUpdateContent() {
            // ‚úÖ FIX: Prevent auto-save during initialization or document loading
            if (!this.editorInitialized || this.isLoadingDocument) {
                return;
            }

            // ‚úÖ READ-ONLY PROTECTION: Block auto-save for read-only users
            if (this.isReadOnlyMode) {
                return;
            }

            // Clear any existing content update timer
            if (this.contentUpdateTimeout) {
                clearTimeout(this.contentUpdateTimeout);
            }

            // ‚úÖ TIPTAP BEST PRACTICE: Debounced auto-save for content changes
            this.contentUpdateTimestamp = Date.now();
            const scheduleContentUpdate = () => {
                this.contentUpdateFrame = requestAnimationFrame(() => {
                    const elapsed = Date.now() - this.contentUpdateTimestamp;
                    if (elapsed >= 2000) {
                        // ‚úÖ AUTO-SAVE COMPLETION: Clear unsaved flag when auto-save completes
                        // For persistent documents (IndexedDB or WebSocket), auto-save is automatic via Y.js
                        if (this.hasIndexedDBPersistence || this.connectionStatus === 'connected') {
                            this.hasUnsavedChanges = false;

                            // Show save completed message
                            if (this.connectionStatus === 'connected') {
                                this.showSaveMessage('Synced to cloud', false);
                            } else {
                                this.showSaveMessage('Saved locally', false);
                            }
                        } else {
                            // ‚úÖ TEMP DOCUMENT CONVERSION: Trigger persistence creation if needed
                            if (this.isTemporaryDocument && !this.indexeddbProvider && !this.isCreatingPersistence) {
                                // ‚úÖ FIX: User interaction detected - convert temp document to persistent
                                this.debouncedCreateIndexedDBForTempDocument();
                            }
                        }
                    } else {
                        scheduleContentUpdate();
                    }
                });
            };
            scheduleContentUpdate();
        },

        // ‚úÖ DEPRECATED: debouncedTitleAutoSave was causing infinite save message loop
        // Now using consistent autoSave() pattern like other metadata fields

        // ‚úÖ CRITICAL FIX: Add missing debounced method for metadata persistence
        debouncedCreateIndexedDBForTempDocument() {
            // ‚úÖ FIX: Extra safety check - don't even start the timer for young editors
            const editorAge = Date.now() - (this.editorCreatedAt || 0);
            if (editorAge < 2000) {
                return;
            }

            // Debounce wrapper to prevent rapid calls when metadata changes
            if (this.createPersistenceDebounceTimer) {
                cancelAnimationFrame(this.createPersistenceDebounceTimer);
            }

            // ‚úÖ ARCHITECTURE RULE 6: Replace setTimeout with requestAnimationFrame
            const startTime = Date.now();
            const delay = 300; // 300ms debounce for metadata changes
            
            if (this.createPersistenceDebounceTimer) {
                cancelAnimationFrame(this.createPersistenceDebounceTimer);
            }
            
            const checkAndCreate = () => {
                if (Date.now() - startTime >= delay) {
                    // ‚úÖ FIX: Metadata changes ARE user intent - create persistence immediately
                    this.createIndexedDBForTempDocument();
                } else {
                    this.createPersistenceDebounceTimer = requestAnimationFrame(checkAndCreate);
                }
            };
            
            this.createPersistenceDebounceTimer = requestAnimationFrame(checkAndCreate);
        },


        async createIndexedDBForTempDocument() {

            if (!this.isTemporaryDocument || this.indexeddbProvider || this.isCreatingPersistence || !this.ydoc) {
                return;
            }

            try {
                this.isCreatingPersistence = true;

                // Generate a real local document ID
                const documentId = `local_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;

                // ‚úÖ CORRECT: Use smart access pattern like editor components
                const tiptapBundle = window.TiptapCollaboration?.Editor
                    ? window.TiptapCollaboration
                    : window.TiptapCollaboration?.default;
                const IndexeddbPersistence = tiptapBundle?.IndexeddbPersistence;

                if (!IndexeddbPersistence) {
                    console.error('‚ùå IndexedDB persistence not available');
                    return;
                }

                // ‚úÖ DEBUG: Check Y.js state before IndexedDB creation

                // Create persistence with proper onSynced handling
                this.indexeddbProvider = new IndexeddbPersistence(documentId, this.ydoc);
                this.contentTimestamps.lastIndexedDBCreation = Date.now(); // Track creation time

                // ‚úÖ DEBUG: Check Y.js state immediately after IndexedDB creation

                // ‚úÖ ENHANCED: Monitor Y.js updates during sync
                const yjsUpdateHandler = (update, origin) => {
                };

                const unsubscribeUpdate = ydocService.onUpdate(yjsUpdateHandler);

                // ‚úÖ REACTIVE PATTERN: Use onSynced callback with safety timeout
                await new Promise((resolve, reject) => {
                    // Check if already synced
                    if (this.indexeddbProvider.synced) {
                        resolve();
                        return;
                    }

                    // ‚úÖ ARCHITECTURE RULE 6: Use requestAnimationFrame for safety timeout
                    const frames = Math.ceil(5000 / 16); // ~313 frames for 5000ms at 60fps
                    let frameCount = 0;
                    let safetyTimeoutId = null;
                    const frameTimeout = () => {
                        if (++frameCount >= frames) {
                            console.warn('‚ö†Ô∏è IndexedDB sync timeout - resolving anyway');
                            resolve(); // Resolve instead of reject to prevent breaking the flow
                        } else {
                            safetyTimeoutId = requestAnimationFrame(frameTimeout);
                        }
                    };
                    safetyTimeoutId = requestAnimationFrame(frameTimeout);

                    // Add error handler for debugging
                    this.indexeddbProvider.on('connection-error', (error) => {
                        if (safetyTimeoutId) {
                            cancelAnimationFrame(safetyTimeoutId);
                        }
                        console.error('‚ùå IndexedDB connection error:', error);
                        reject(new Error(`IndexedDB connection failed: ${error.message}`));
                    });

                    // Wait for sync event
                    this.indexeddbProvider.once('synced', () => {
                        if (safetyTimeoutId) {
                            cancelAnimationFrame(safetyTimeoutId);
                        }

                        // ‚úÖ CLEANUP: Remove Y.js update monitoring after sync
                        unsubscribeUpdate();

                        // ‚úÖ STABILIZATION: Track Y.js sync completion for command timing
                        this.contentTimestamps.lastChange = Date.now();

                        // ‚úÖ CRITICAL FIX: Add micro-task delay to ensure Y.js state is fully settled
                        // This helps prevent "mismatched transaction" errors that occur when
                        // ProseMirror state hasn't fully synchronized with Y.js after IndexedDB load
                        Promise.resolve().then(() => {
                            this.isCreatingPersistence = false; // Clear the flag when sync is complete
                            resolve();
                        });
                    });

                    // ‚úÖ DEBUG: Log provider state for troubleshooting
                });

                // Update document state
                this.isTemporaryDocument = false;
                this.hasIndexedDBPersistence = true;
                this.isPersistenceReady = true;

                // Show save message when persistence is first created
                this.$nextTick(() => {
                    this.showSaveMessage('Saved locally', false);
                });

                // ‚úÖ TIPTAP v3 COMPLIANT: Always get document name from config, never from content
                let documentName = ydocService.getConfig('documentName');

                // If no document name set, create one now
                if (!documentName) {
                    documentName = `Untitled - ${new Date().toLocaleDateString()}`;
                    // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
                    ydocService.updateConfig('documentName', documentName);
                }

                const fileEntry = {
                    id: documentId,
                    name: documentName,
                    type: 'local',
                    created: new Date().toISOString(),
                    lastModified: new Date().toISOString(),
                    hasIndexedDBPersistence: true,
                    owner: this.username // CRITICAL: Must set owner for file to appear in drafts
                };

                // Save to localStorage
                const localFiles = this.documentStorageService.getAllDocuments();
                localFiles.unshift(fileEntry);
                this.documentStorageService.saveAllDocuments(localFiles);

                // Update current file reference
                this.setCurrentFile(fileEntry);
                this.fileType = 'local';

                // ‚úÖ PERFORMANCE: Update document metadata - caching handled internally
                documentService.updateDocumentMetadata(documentId, {
                    documentName,
                    timestamp: Date.now(),
                    documentId,
                    type: 'local'
                });

                // ‚úÖ URL UPDATE: Update URL now that document is persisted locally
                // Local documents (with user intent) should have URLs for shareability
                this.updateURLWithLocalParams(this.username || 'anonymous', documentId);

                // ‚úÖ CRITICAL: Clear unsaved changes flag after successful persistence
                this.hasUnsavedChanges = false;
                this.hasUserIntent = false;

                // ‚úÖ PHANTOM FIX: Don't call loadLocalFiles here - it causes phantom documents during conversion
                // The document is already added to localStorage above, Vue reactivity will handle updates
                // await this.loadLocalFiles();

                // ‚úÖ TIPTAP COMPLIANCE: Use nextTick for Vue reactivity
                await this.$nextTick();

            } catch (error) {
                console.error('‚ùå Failed to create IndexedDB persistence:', error);

                // ‚úÖ FALLBACK: Even if IndexedDB fails, promote temp document for in-memory persistence
                this.isTemporaryDocument = false;
                this.hasIndexedDBPersistence = false; // Indicate no IndexedDB but document is promoted
                this.hasUnsavedChanges = false; // Clear saving state

                // Still try to save to localStorage drafts list
                try {
                    const documentId = `local_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;
                    // ‚úÖ FALLBACK: Use default name - don't extract from title
                    const documentName = 'Untitled Document';

                    const fileEntry = {
                        id: documentId,
                        name: documentName,
                        type: 'local',
                        created: new Date().toISOString(),
                        lastModified: new Date().toISOString(),
                        hasIndexedDBPersistence: false,
                        owner: this.username
                    };

                    const localFiles = this.documentStorageService.getAllDocuments();
                    localFiles.unshift(fileEntry);
                    this.documentStorageService.saveAllDocuments(localFiles);

                    this.setCurrentFile(fileEntry);
                    this.fileType = 'local';

                } catch (fallbackError) {
                    console.error('‚ùå Fallback document promotion also failed:', fallbackError);
                }
            } finally {
                this.isCreatingPersistence = false;
            }
        },

        // ===== MODAL METHOD STUBS =====
        async requestAuthentication(context = null) {
            // ‚úÖ CENTRALIZED AUTH: Use DLUXAuthBridge for all authentication requests
            const authBridge = this.authBridgeInstance;

            if (authBridge) {
                console.log('üîë AUTH: Requesting authentication via DLUXAuthBridge', { context });

                // Check if this is for cloud conversion
                if (context?.forConversion) {
                    console.log('‚òÅÔ∏è AUTH: Cloud conversion auth request', {
                        context,
                        hasPendingConversion: !!this.pendingConversion,
                        pendingConversionType: this.pendingConversion?.type
                    });
                    
                    // Don't pass owner/permlink to avoid triggering document reload
                    const documentInfo = {
                        name: this.titleInput || 'Converting to Cloud',
                        type: 'conversion'
                        // NO owner/permlink - this prevents reload in authRetryReady
                    };
                    
                    console.log('‚òÅÔ∏è AUTH: Document info for conversion', {
                        documentInfo,
                        note: 'No owner/permlink to prevent reload'
                    });
                    
                    const action = !this.username || this.username === 'GUEST' ? 'login' :
                        this.isAuthExpired ? 'authenticate' : 'login';
                        
                    authBridge.showAuthPrompt(action, {
                        ...documentInfo,
                        autoTrigger: context?.autoTrigger
                    });
                } else if (context?.forDocumentList) {
                    // Check if this is for document list access
                    console.log('üìÅ AUTH: Requesting authentication for document list access');
                    // Don't pass pendingDocumentAccess - this triggers the else block in authRetryReady
                    const action = !this.username || this.username === 'GUEST' ? 'login' :
                        this.isAuthExpired ? 'authenticate' : 'login';
                    
                    // Pass autoTrigger flag for document list authentication
                    authBridge.showAuthPrompt(action, { 
                        autoTrigger: context?.autoTrigger 
                    });
                } else {
                    // Existing logic for document-specific auth
                    const documentInfo = this.currentFile ? {
                        name: this.currentFile.documentName || this.currentFile.name || 'document',
                        owner: this.currentFile.owner,
                        permlink: this.currentFile.permlink,
                        id: this.currentFile.id,
                        type: this.currentFile.type
                    } : {
                        name: this.titleInput || 'New Document',
                        type: 'new'
                    };

                    // Determine auth action based on current state
                    let action;
                    
                    // Handle explicit refresh request - always authenticate to get fresh headers
                    if (context?.forceRefresh) {
                        action = 'authenticate';
                    } 
                    // Auto-trigger for logged-in users (document list, cloud conversion)
                    else if (context?.autoTrigger && this.username && this.username !== 'GUEST') {
                        action = 'authenticate';
                    }
                    // Standard flow based on auth state
                    else {
                        action = !this.username || this.username === 'GUEST' ? 'login' :
                            this.isAuthExpired ? 'authenticate' : 'login';
                    }

                    authBridge.showAuthPrompt(action, {
                        ...documentInfo,
                        autoTrigger: context?.autoTrigger,
                        forceRefresh: context?.forceRefresh
                    });
                }
            } else {
                // Log error if authBridge not available
                console.error('‚ö†Ô∏è AUTH: DLUXAuthBridge not available, cannot request authentication');
                // Create a temporary event bus if needed
                if (!window.editorEventBus) {
                    window.editorEventBus = new EventTarget();
                }
                window.editorEventBus.dispatchEvent(new CustomEvent('request-auth-headers'));
            }
        },
        
        // ‚úÖ HEADLESS AUTH: Authentication for document list without modal
        async authenticateForDocumentList() {
            console.log('üìÅ HEADLESS AUTH: Starting authentication for document list');
            
            const authBridge = this.authBridgeInstance;
            if (!authBridge) {
                console.error('‚ùå HEADLESS AUTH: No auth bridge available');
                return;
            }
            
            // Request headless authentication
            const action = !this.username || this.username === 'GUEST' ? 'login' :
                this.isAuthExpired ? 'authenticate' : 'login';
            
            // If login is needed, we can't do it headless - show modal
            if (action === 'login') {
                console.log('üìÅ HEADLESS AUTH: Login required, showing modal');
                this.requestAuthentication({ forDocumentList: true, autoTrigger: true });
                return;
            }
            
            // For authentication (re-auth), we can do it headless
            console.log('üìÅ HEADLESS AUTH: Attempting headless authentication');
            authBridge.showAuthPrompt(action, { 
                headless: true,
                forDocumentList: true
            });
        },

        async refreshDocumentLists() {

            // ‚úÖ PERFORMANCE: Skip if already refreshing to prevent duplicate calls
            if (this.isRefreshingDocuments) {

                return;
            }

            this.isRefreshingDocuments = true;

            try {
                // ‚úÖ PERFORMANCE: Parallel loading instead of sequential
                const promises = [
                    this.loadLocalFiles()
                ];

                // Only load collaborative docs if authenticated
                if (this.isAuthenticated) {
                    promises.push(this.loadCollaborativeDocs());
                }

                // ‚úÖ OFFLINE-FIRST: Execute in parallel (non-blocking)
                Promise.allSettled(promises).catch(error => {
                    console.warn('‚ö†Ô∏è Background document list loading failed:', error);
                });

                // ‚úÖ PERFORMANCE: Lazy permission loading (non-blocking) with throttling
                this.$nextTick(() => {
                    // ‚úÖ PERFORMANCE: Throttle permission loading to prevent excessive calls
                    if (this.permissionLoadThrottleFrame) {
                        cancelAnimationFrame(this.permissionLoadThrottleFrame);
                    }

                    this.permissionLoadThrottleTimestamp = Date.now();
                    const schedulePermissionLoad = () => {
                        this.permissionLoadThrottleFrame = requestAnimationFrame(() => {
                            const elapsed = Date.now() - this.permissionLoadThrottleTimestamp;
                            if (elapsed >= 200) {
                                this.getPermissionsForFiles(this.allDocuments);
                            } else {
                                schedulePermissionLoad();
                            }
                        });
                    };
                    schedulePermissionLoad();
                });

            } catch (error) {
                console.error('‚ùå Failed to refresh document lists:', error);
            } finally {
                this.isRefreshingDocuments = false;
            }
        },

        // ‚úÖ PERFORMANCE: Optimized IndexedDB scanning with caching
        async scanIndexedDBDocuments() {
            console.log('üì± OFFLINE-FIRST: Vue scanIndexedDBDocuments called');
            console.log('  username:', this.username);
            console.log('  hasDocumentManager:', !!this.documentManager);
            console.log('  hasDocumentService:', !!(this.documentManager?.documentService));
            console.log('  hasIndexedDB:', !!indexedDB);
            console.log('  hasDatabasesAPI:', !!(indexedDB && indexedDB.databases));

            // ‚úÖ OFFLINE-FIRST: Use documentManager's DocumentService method which has all the logging
            if (this.documentManager && this.documentManager.documentService && this.documentManager.documentService.scanIndexedDBDocuments) {
                console.log('üì± OFFLINE-FIRST: Delegating to documentManager.documentService.scanIndexedDBDocuments');
                try {
                    const result = await this.documentManager.documentService.scanIndexedDBDocuments();
                    console.log('üì± OFFLINE-FIRST: DocumentService scan returned', {
                        additionalDocs: result?.length || 0,
                        offlineCachesAfter: this.offlineCaches?.length || 0
                    });
                    return result;
                } catch (error) {
                    console.error('‚ùå OFFLINE-FIRST: DocumentService.scanIndexedDBDocuments failed:', error);
                    throw error;
                }
            }

            // Fallback to original implementation if DocumentService not available
            console.log('üì± OFFLINE-FIRST: Using Vue implementation (fallback)');
            
            // ‚úÖ REACTIVITY FIX: Clear the array properly for Vue reactivity
            // Never re-initialize, just clear contents
            this.offlineCaches.length = 0;
            
            // ‚úÖ PERFORMANCE: Cache scan results for 5 minutes (was 30 seconds)
            const cachedScan = documentService.getIndexedDBScanCache();
            if (cachedScan) {
                console.log('üì± OFFLINE-FIRST: Returning cached scan');
                return cachedScan;
            }

            try {
                if (!indexedDB || !indexedDB.databases) {
                    console.warn('‚ö†Ô∏è OFFLINE-FIRST: IndexedDB.databases not available');
                    return [];
                }
                
                const databases = await indexedDB.databases();
                console.log('üì± OFFLINE-FIRST: Vue method found databases:', databases.length);
                console.log('  Database names:');
                databases.forEach((db, i) => {
                    console.log(`    [${i}]: ${db.name} (version: ${db.version})`);
                });

                // ‚úÖ OFFLINE-FIRST: Check for collaborative caches first
                // Pattern: username__owner/permlink
                const collaborativeCaches = databases.filter(db => 
                    db.name && db.name.includes('__') && db.name.includes('/')
                );
                
                console.log('üì± OFFLINE-FIRST: Found collaborative caches:', collaborativeCaches.length);
                if (collaborativeCaches.length > 0) {
                    console.log('  Collaborative cache names:');
                    collaborativeCaches.forEach((db, i) => {
                        const [userPrefix, ownerPermlink] = db.name.split('__');
                        console.log(`    [${i}]: ${db.name} (user: ${userPrefix}, matches current: ${userPrefix === this.username})`);
                    });
                    
                    // Process collaborative caches for current user
                    for (const db of collaborativeCaches) {
                        const [userPrefix, ownerPermlink] = db.name.split('__');
                        if (userPrefix === this.username && ownerPermlink) {
                            const [owner, permlink] = ownerPermlink.split('/');
                            if (owner && permlink) {
                                // ‚úÖ REACTIVITY FIX: Never re-initialize the array
                                // The array is already defined in data() and cleared at start
                                
                                // Check if already added
                                const exists = this.offlineCaches.some(c => 
                                    c.owner === owner && c.permlink === permlink
                                );
                                
                                if (!exists) {
                                    const cachedDoc = {
                                        id: db.name,
                                        type: 'collaborative',
                                        owner: owner,
                                        permlink: permlink,
                                        name: `${owner}/${permlink}`,
                                        isOfflineCache: true,
                                        hasLocalVersion: true,
                                        created: new Date().toISOString(),
                                        modified: new Date().toISOString()
                                    };
                                    this.offlineCaches.push(cachedDoc);
                                    console.log(`üì± OFFLINE-FIRST: Added collaborative cache: ${db.name}`);
                                }
                            }
                        }
                    }
                    
                    // ‚úÖ FORCE VUE REACTIVITY: Reassign array to trigger reactivity
                    if (this.offlineCaches && this.offlineCaches.length > 0) {
                        console.log('üì± OFFLINE-FIRST: Forcing Vue reactivity for offlineCaches');
                        this.offlineCaches = [...this.offlineCaches];
                    }
                }
                
                // ‚úÖ PERFORMANCE: Filter Y.js documents before detailed scanning
                // Based on actual patterns seen in logs: local_1750185651604_qqd9ladv7
                const yjsDatabases = databases.filter(db =>
                    db.name &&
                    (db.name.startsWith('y-indexeddb-') ||
                        db.name.startsWith('dlux-local-') ||
                        db.name.startsWith('local_') ||  // Added: actual pattern from logs
                        db.name.includes('collaborative') ||
                        db.name.match(/^[a-zA-Z0-9_-]+\/[a-zA-Z0-9_-]+$/)) // Added: owner/permlink pattern
                );

                // ‚úÖ PERFORMANCE: Limit concurrent database operations
                const batchSize = 5;
                const localDocuments = [];

                for (let i = 0; i < yjsDatabases.length; i += batchSize) {
                    const batch = yjsDatabases.slice(i, i + batchSize);
                    const batchPromises = batch.map(async (dbInfo) => {
                        try {
                            const documentName = await this.extractDocumentNameFromIndexedDB(dbInfo.name);
                            
                            // Identify collaborative caches vs local documents
                            let docObject;
                            if (dbInfo.name.includes('__') && dbInfo.name.includes('/')) {
                                // Parse collaborative cache: username__owner/permlink
                                const [userPrefix, ownerPermlink] = dbInfo.name.split('__');
                                const [owner, permlink] = ownerPermlink.split('/');
                                
                                // Only include if it's the current user's cache
                                if (userPrefix !== this.username) {
                                    return null; // Skip other users' caches
                                }
                                
                                docObject = {
                                    id: dbInfo.name,
                                    type: 'collaborative',
                                    owner: owner,
                                    permlink: permlink,
                                    name: documentName || `${owner}/${permlink}`,
                                    isOfflineCache: true,
                                    hasLocalVersion: true,
                                    created: new Date().toISOString(),
                                    modified: new Date().toISOString()
                                };
                            } else {
                                // Local/temp document
                                docObject = {
                                    id: dbInfo.name,
                                    name: documentName || `Document ${dbInfo.name.substring(0, 8)}...`,
                                    type: 'local',
                                    created: new Date().toISOString(),
                                    modified: new Date().toISOString(),
                                    isOfflineFirst: true,
                                    hasLocalVersion: true,
                                    owner: this.username
                                };
                            }
                            
                            return docObject;
                        } catch (error) {
                            console.warn('‚ö†Ô∏è Failed to extract from', dbInfo.name, ':', error.message);
                            return null;
                        }
                    });

                    const batchResults = await Promise.allSettled(batchPromises);
                    batchResults.forEach(result => {
                        if (result.status === 'fulfilled' && result.value) {
                            localDocuments.push(result.value);
                        }
                    });
                }

                // ‚úÖ FIX: Populate indexedDBDocuments map for status indicators
                if (!this.indexedDBDocuments) {
                    this.indexedDBDocuments = new Map();
                }

                // Clear existing cache and rebuild
                this.indexedDBDocuments.clear();
                localDocuments.forEach(doc => {
                    if (doc.id) {
                        // For collaborative documents, use owner/permlink as key
                        if (doc.owner && doc.permlink) {
                            const key = `${doc.owner}/${doc.permlink}`;
                            this.indexedDBDocuments.set(key, doc);
                        } else {
                            // For local documents, use the document ID
                            this.indexedDBDocuments.set(doc.id, doc);
                        }
                    }
                });

                // ‚úÖ PERFORMANCE: Cache results
                documentService.cacheIndexedDBScan(localDocuments);

                console.log('üì± OFFLINE-FIRST: Vue scanIndexedDBDocuments complete');
                console.log('  offlineCachesFound:', this.offlineCaches?.length || 0);
                console.log('  localDocumentsFound:', localDocuments.length);
                console.log('  totalDocuments:', (this.offlineCaches?.length || 0) + localDocuments.length);
                if (this.offlineCaches && this.offlineCaches.length > 0) {
                    console.log('  Offline caches in array:');
                    this.offlineCaches.forEach((c, i) => {
                        console.log(`    [${i}]: ${c.id}`);
                    });
                }

                return localDocuments;

            } catch (error) {
                console.error('‚ùå OFFLINE-FIRST: Failed to scan IndexedDB:', error);
                console.error('  Error details:', error.message, error.stack);
                return [];
            }
        },

        // ‚úÖ PERFORMANCE: Debounced permission loading for file table
        async getPermissionsForFiles(files) {
            if (!files || files.length === 0) return;

            // ‚úÖ PERFORMANCE: Debounce permission loading to avoid excessive calls
            if (this.permissionLoadTimeout) {
                cancelAnimationFrame(this.permissionLoadTimeout);
            }

            // ‚úÖ ARCHITECTURE RULE 6: Replace setTimeout with requestAnimationFrame
            const startTime = Date.now();
            const delay = 100; // 100ms debounce
            
            if (this.permissionLoadTimeout) {
                cancelAnimationFrame(this.permissionLoadTimeout);
            }
            
            const checkAndExecute = () => {
                if (Date.now() - startTime >= delay) {
                    // Execute the batched permission loading
                    (async () => {
                        // ‚úÖ PERFORMANCE: Batch permission operations with limits
                        const maxConcurrent = 3;
                        const batches = [];

                        for (let i = 0; i < files.length; i += maxConcurrent) {
                            batches.push(files.slice(i, i + maxConcurrent));
                        }

                        for (const batch of batches) {
                            const permissionPromises = batch.map(async (file) => {
                                try {
                                    // ‚úÖ PERFORMANCE: Skip if already cached and fresh (less than 5 minutes old)
                                    const cachedPermission = this.authStateManager?.getCachedFilePermission(file);
                                    if (cachedPermission) {
                                        const cacheAge = cachedPermission.timestamp ? Date.now() - cachedPermission.timestamp : 0;
                                        if (cacheAge < 300000) { // 5 minutes
                                            return; // Use cached permission
                                        }
                                    }

                                    let permissionLevel;

                                    if (file.type === 'local') {
                                        // ‚úÖ LOCAL FILES: Fast ownership check
                                        const fileOwner = file.owner;
                                        if (!this.username) {
                                            permissionLevel = !fileOwner ? 'owner' : 'no-access';
                                        } else {
                                            // ‚úÖ UNIFIED: Use getUserPermissionLevel for owner check
                                            permissionLevel = this.getUserPermissionLevel(file);
                                        }
                                    } else if (file.type === 'collaborative') {
                                        // ‚úÖ COLLABORATIVE FILES: Enhanced permission resolution with async loading
                                        if (!this.isAuthenticated) {
                                            permissionLevel = this.getNoAccessPermissionLevel();
                                        } else if (this.isOwnerPermission(this.getUserPermissionLevel(file))) {
                                            permissionLevel = 'owner';
                                        } else {
                                            // ‚úÖ ENHANCED: Try to load actual permissions for better UX
                                            try {
                                                // Only load permissions for first 10 files to avoid overwhelming the server
                                                const fileIndex = this.collaborativeDocs.findIndex(f =>
                                                    f.owner === file.owner && f.permlink === file.permlink);

                                                if (fileIndex < 10) { // Limit async permission loading
                                                    // ‚úÖ ENHANCED: Check if we have a fresh cached permission first
                                                    const cachedPerm = this.authStateManager?.getCachedFilePermission(file);
                                                    if (cachedPerm && cachedPerm.timestamp && (Date.now() - cachedPerm.timestamp) < 300000) { // 5 minutes
                                                        // Use cached permission if fresh
                                                        permissionLevel = cachedPerm.level;
                                                    } else {
                                                        // ‚úÖ FIX: Force refresh permissions for file table to get latest permissions

                                                        // ‚úÖ OFFLINE-FIRST: Non-blocking permission loading for file browser
                                                        this.getMasterPermissionForDocument(file, true, 'file-browser').then(permissionResult => {
                                                            permissionLevel = permissionResult.level;
                                                            // Permission caching is handled internally by getMasterPermissionForDocument
                                                            // Vue reactivity handles UI updates
                                                        }).catch(permissionError => {
                                                            // ‚úÖ FILE BROWSER FALLBACK: Use conservative permission for display
                                                            console.warn(`‚ö†Ô∏è File browser permission check failed for ${file.name}:`, permissionError.message);
                                                            // ‚úÖ TIPTAP COMPLIANCE: Check cached permission before defaulting
                                                            const cachedPerm = this.authStateManager?.getCachedPermission(file.owner, file.permlink);
                                                            if (cachedPerm) {
                                                                permissionLevel = cachedPerm; // Use cached permission
                                                            } else {
                                                                permissionLevel = 'readonly'; // Default to readonly for collaborative documents
                                                            }
                                                            // Permission caching is handled internally by getMasterPermissionForDocument
                                                        });

                                                        // ‚úÖ TIPTAP COMPLIANCE: Check cached permission first before defaulting
                                                        const cachedPermission = this.authStateManager?.getCachedPermission(file.owner, file.permlink);
                                                        if (cachedPermission) {
                                                            permissionLevel = cachedPermission; // Use cached permission
                                                        } else {
                                                            permissionLevel = 'readonly'; // Conservative default while loading
                                                        }
                                                    }
                                                } else {
                                                    permissionLevel = 'unknown'; // Conservative default for non-priority files
                                                }
                                            } catch (error) {
                                                console.warn('‚ö†Ô∏è Failed to load permission, using default:', error.message);
                                                permissionLevel = 'unknown'; // Conservative fallback
                                            }
                                        }
                                    } else {
                                        permissionLevel = this.getNoAccessPermissionLevel();
                                    }

                                    // Permission caching is handled internally by getMasterPermissionForDocument

                                } catch (error) {
                                    console.warn('‚ö†Ô∏è Error getting permission for file:', file.name, error);
                                    // Permission caching is handled internally by getMasterPermissionForDocument
                                }
                            });

                            // ‚úÖ PERFORMANCE: Process batch in parallel with error handling
                            await Promise.allSettled(permissionPromises);
                        }
                        
                        // ‚úÖ CLEANUP: Clear timeout reference after execution
                        this.permissionLoadTimeout = null;
                    })();
                } else {
                    this.permissionLoadTimeout = requestAnimationFrame(checkAndExecute);
                }
            };
            
            this.permissionLoadTimeout = requestAnimationFrame(checkAndExecute);
        },

        // ‚úÖ TIPTAP BEST PRACTICE: Optimized new document creation
        async newDocument() {

            // ‚úÖ TIPTAP BEST PRACTICE: Clear all URL parameters for new documents
            this.clearAllURLParams();

            // ‚úÖ PERFORMANCE: Skip cleanup if no current document
            if (this.currentFile || this.ydoc) {
                await this.documentManager.lifecycleManager.cleanupDocument();
            }

            // ‚úÖ TIPTAP COMPLIANCE: Create new document with proper lifecycle
            return await this.documentManager.newDocument();

        },

        // ‚úÖ REMOVED: Moved to computed section for proper Vue reactivity

        // ===== UNIFIED SYNC INDICATOR: Offline-First Architecture =====
        clearUnsavedAfterSync() {
            // ‚úÖ REACTIVE PATTERN: Clear flags immediately after successful persistence
            // No timeouts - rely on actual sync events from IndexedDB/WebSocket providers
            if (this.hasIndexedDBPersistence || this.connectionStatus === 'connected') {
                this.hasUnsavedChanges = false;
                this.hasUserIntent = false;
            }
        },

        // ===== CONTENT DETECTION =====
        // ‚úÖ TIPTAP BEST PRACTICE: Content detection outside onUpdate for perfect compliance
        hasContentToSave() {
            // ‚úÖ FIX: Check for actual content in titleInput and editor
            if (!this.bodyEditor) {
                return false;
            }

            const hasTitle = Boolean(this.titleInput?.trim());
            const hasBody = Boolean(this.bodyEditor.getText().trim());

            return hasTitle || hasBody;
        },

        // ‚úÖ TIPTAP v3 COMPLIANT: Check if we have metadata to save
        hasMetadataToSave() {
            if (!ydocService.isReady()) return false;

            // Check if we have any metadata worth saving
            const hasTags = (ydocService.getMetadata('tags') || []).length > 0;
            const hasBeneficiaries = (ydocService.getMetadata('beneficiaries') || []).length > 0;
            const hasCustomJson = !!ydocService.getMetadata('customJson');
            const hasPermlink = !!ydocService.getMetadata('permlink');
            const hasCommentOptions = ydocService.getMetadata('allowVotes') !== undefined ||
                ydocService.getMetadata('allowCurationRewards') !== undefined ||
                ydocService.getMetadata('maxAcceptedPayout') !== undefined ||
                ydocService.getMetadata('percentHbd') !== undefined;

            return hasTags || hasBeneficiaries || hasCustomJson || hasPermlink || hasCommentOptions;
        },

        // ‚úÖ REMOVED: checkRealContentForIntent() - metadata changes ARE user intent

        // ‚úÖ TIPTAP v3 COMPLIANT: Load metadata from Y.js to Vue reactive data
        loadMetadataFromYjs() {
            if (!ydocService.isReady()) return;

            // Load tags
            const tags = ydocService.getMetadata('tags') || [];
            this.reactiveTags = tags; // ‚úÖ REACTIVE PATTERN

            // Load beneficiaries - use array mutation for Vue 3 reactivity
            const beneficiaries = ydocService.getMetadata('beneficiaries') || [];
            this.reactiveBeneficiaries.length = 0;
            beneficiaries.forEach(ben => {
                this.reactiveBeneficiaries.push(ben);
            });

            // Load comment options - ‚úÖ REACTIVE PATTERN
            const loadedCommentOptions = {
                allowVotes: ydocService.getMetadata('allowVotes'),
                allowCurationRewards: ydocService.getMetadata('allowCurationRewards'),
                maxAcceptedPayout: ydocService.getMetadata('maxAcceptedPayout'),
                percentHbd: ydocService.getMetadata('percentHbd')
            };
            
            console.log('üìù COMMENT OPTIONS: Loading during document load', {
                fromYjs: loadedCommentOptions,
                documentId: this.currentFile?.id,
                documentType: this.currentFile?.type,
                timestamp: Date.now()
            });
            
            this.reactiveCommentOptions = {
                allowVotes: loadedCommentOptions.allowVotes !== false,
                allowCurationRewards: loadedCommentOptions.allowCurationRewards !== false,
                maxAcceptedPayout: loadedCommentOptions.maxAcceptedPayout === true,
                percentHbd: loadedCommentOptions.percentHbd === true
            };
            
            console.log('üìù COMMENT OPTIONS: After conversion to reactive', {
                reactive: this.reactiveCommentOptions
            });

            // Sync reactive properties to non-reactive object for API compatibility
            this.commentOptions.allowVotes = this.reactiveCommentOptions.allowVotes;
            this.commentOptions.allowCurationRewards = this.reactiveCommentOptions.allowCurationRewards;
            this.commentOptions.maxAcceptedPayout = this.reactiveCommentOptions.maxAcceptedPayout;
            this.commentOptions.percentHbd = this.reactiveCommentOptions.percentHbd;

            // Load custom JSON - ‚úÖ REACTIVE PATTERN
            const customJson = ydocService.getMetadata('customJson') || {};
            this.reactiveCustomJson = { ...customJson }; // Create new object for reactivity
            this.customJsonString = JSON.stringify(customJson, null, 2);

            // Load permlink - ‚úÖ REACTIVE PATTERN
            const permlink = ydocService.getMetadata('permlink') || '';

            // ‚úÖ FIX: Populate permlinkInput with custom permlinks for editing
            // Only set permlinkInput if it's a custom permlink (not auto-generated)
            if (permlink && permlink !== this.generatedPermlink) {
                // This is a custom permlink - populate input field for editing
                this.permlinkInput = permlink;
            } else {
                // This is either empty or matches generated permlink - keep input empty
                // so actualPermlink() will show the generated version
                this.permlinkInput = '';
            }

            // Load title
            const title = ydocService.getMetadata('title') || '';
            this.titleInput = title;

            // Load document name
            const documentName = ydocService.getConfig('documentName');
            if (documentName && this.currentFile) {
                this.currentFile.name = documentName;
                this.currentFile.documentName = documentName;
                // Initialize reactive document name for UI display
                this.reactiveDocumentName = documentName;
            }

        },

        // ‚úÖ TIPTAP v3 COMPLIANT: Ensure metadata is synchronized before persistence
        async ensureMetadataInYjs() {
            if (!ydocService.isReady()) return;

            const metadataUpdates = {};
            const configUpdates = {};

            // Tags - ‚úÖ REACTIVE PATTERN: Use reactive property
            if (this.reactiveTags && this.reactiveTags.length > 0) {
                metadataUpdates.tags = [...this.reactiveTags];
            }

            // Beneficiaries - ‚úÖ REACTIVE PATTERN: Use reactive property
            if (this.reactiveBeneficiaries && this.reactiveBeneficiaries.length > 0) {
                metadataUpdates.beneficiaries = [...this.reactiveBeneficiaries];
            }

            // Comment options - ‚úÖ REACTIVE PATTERN: Use reactive properties
            console.log('üìù COMMENT OPTIONS: Preparing to save to Y.js', {
                reactive: this.reactiveCommentOptions,
                willSave: {
                    allowVotes: this.reactiveCommentOptions.allowVotes,
                    allowCurationRewards: this.reactiveCommentOptions.allowCurationRewards,
                    maxAcceptedPayout: this.reactiveCommentOptions.maxAcceptedPayout,
                    percentHbd: this.reactiveCommentOptions.percentHbd
                }
            });
            
            metadataUpdates.allowVotes = this.reactiveCommentOptions.allowVotes;
            metadataUpdates.allowCurationRewards = this.reactiveCommentOptions.allowCurationRewards;
            metadataUpdates.maxAcceptedPayout = this.reactiveCommentOptions.maxAcceptedPayout;
            metadataUpdates.percentHbd = this.reactiveCommentOptions.percentHbd;

            // Custom JSON
            if (this.customJsonString && this.customJsonString.trim()) {
                try {
                    const customJson = JSON.parse(this.customJsonString);
                    metadataUpdates.customJson = customJson;
                } catch (e) {
                    // Invalid JSON, skip
                }
            }
            // ‚úÖ RECURSION FIX: Don't set permlink here - it's managed by permlinkInput watcher
            // Permlink is updated via debouncedSetPermlinkInMetadata() from user input

            // Document name - CRITICAL for persistence
            const documentName = ydocService.getConfig('documentName') || `Untitled - ${new Date().toLocaleDateString()}`;
            configUpdates.documentName = documentName;
            configUpdates.lastModified = new Date().toISOString();

            // ‚úÖ TipTap v3 Best Practice: Use Y.js transactions with origin tags
            ydocService.batchUpdate(configUpdates, metadataUpdates, 'metadata-sync'); // Origin tag to identify this transaction
            
            console.log('üìù COMMENT OPTIONS: Saved to Y.js', {
                savedValues: {
                    allowVotes: metadataUpdates.allowVotes,
                    allowCurationRewards: metadataUpdates.allowCurationRewards,
                    maxAcceptedPayout: metadataUpdates.maxAcceptedPayout,
                    percentHbd: metadataUpdates.percentHbd
                },
                documentId: this.currentFile?.id,
                timestamp: Date.now()
            });

            // Only log metadata sync in debug mode
        },

        // ‚úÖ TIPTAP v3 COMPLIANT: Validate document structure before persistence
        validateDocumentStructure() {
            if (!ydocService.isReady()) return false;

            // Check editor is created (fragment will be auto-created by Collaboration extension)
            const hasEditor = !!this.bodyEditor;

            // YDocService ensures config and metadata maps exist when document is created
            return hasEditor;
        },

        // ‚úÖ TIPTAP v3 COMPLIANT: Unified document persistence method
        async ensureDocumentPersistence() {
            // Skip if already persistent or in progress
            if (!this.isTemporaryDocument || this.indexeddbProvider || this.isCreatingPersistence || !this.ydoc) {
                // ‚úÖ FIX: For existing documents, just ensure metadata is synced
                if (this.currentFile && this.ydoc) {
                    await this.ensureMetadataInYjs();
                }
                return;
            }

            // Validate document structure
            if (!this.validateDocumentStructure()) {
                console.warn('‚ö†Ô∏è Document structure not ready for persistence');
                return;
            }

            // Ensure all metadata is in Y.js
            await this.ensureMetadataInYjs();

            // Wait for Vue reactivity
            await this.$nextTick();

            // Create persistence
            await this.createIndexedDBForTempDocument();
        },

        // ‚úÖ TIPTAP COMPLIANCE: Create IndexedDB persistence for temp document
        // (Duplicate method removed - using the working reactive version below)

        async clearAllLocalFiles() {
            // ‚úÖ SAFETY CHECK: If current document is local, warn and offer to create new document first
            if (this.currentFile && this.currentFile.id && this.currentFile.id.startsWith('local_')) {
                const currentDocName = this.currentFile.name || 'current document';
                if (!confirm(`‚ö†Ô∏è You are currently editing a local document: "${currentDocName}"\n\nThis document will be deleted in the clear operation.\n\nDo you want to continue and create a new document?\n\n(Click Cancel to save your work first)`)) {
                    return;
                }

                await this.documentManager.lifecycleManager.cleanupDocument();
                await this.documentManager.newDocument();

            }

            if (confirm('‚ö†Ô∏è This will delete ALL local files. This action cannot be undone. Are you sure?')) {
                try {

                    // Clear localStorage
                    this.documentStorageService.clearAllDocuments();

                    // Clear IndexedDB documents
                    if (indexedDB.databases) {
                        const databases = await indexedDB.databases();

                        let deletedCount = 0;
                        let skippedCount = 0;

                        for (const dbInfo of databases) {
                            const dbName = dbInfo.name;

                            // Match the same pattern as scanIndexedDBDocuments()
                            // Delete temp documents, local documents, and collaborative documents (with /)
                            if (dbName && (dbName.startsWith('temp_') ||
                                dbName.startsWith('local_') ||
                                dbName.includes('/') ||
                                dbName.includes('dlux'))) {
                                try {
                                    const deleteReq = indexedDB.deleteDatabase(dbName);
                                    await new Promise((resolve) => {
                                        deleteReq.onsuccess = () => {
                                            resolve();
                                        };
                                        deleteReq.onerror = (error) => {
                                            console.error(`‚ùå Failed to delete ${dbName}:`, error);
                                            reject(error);
                                        };
                                        deleteReq.onblocked = () => {
                                            console.warn(`‚ö†Ô∏è Database deletion blocked: ${dbName}`);
                                            resolve(); // Continue anyway
                                        };
                                    });
                                    deletedCount++;
                                } catch (error) {
                                    console.warn(`‚ö†Ô∏è Could not delete database ${dbName}:`, error.message);
                                }
                            } else {
                                skippedCount++;
                            }
                        }

                    }

                    // Clear component state
                    this.localFiles = [];
                    this.clearCollaborativeDocs();

                    // Close any open modal
                    this.showLoadModal = false;

                    // Refresh the document lists to ensure UI is updated
                    // ‚úÖ OFFLINE-FIRST: Non-blocking document list refresh
                    this.refreshDocumentLists().catch(error => {
                        console.warn('‚ö†Ô∏è Background document list refresh failed:', error);
                    });

                    alert('All local files have been deleted.');

                } catch (error) {
                    console.error('‚ùå Failed to clear local files:', error);
                    alert('Error clearing local files: ' + error.message);
                }
            }
        },

        // ===== DROPDOWN MENU METHODS =====

        disconnectCollaboration(clearUrl = true) {

            // OFFLINE-FIRST: Only disconnect WebSocket, keep Y.js document and editors intact
            if (this.provider) {
                this.provider.destroy();
                this.provider = null;
            }

            // Update connection status
            this.connectionStatus = 'offline';
            // isCollaborativeMode is now a computed property

            // Clear collaborative URL parameters only if requested (default true for backward compatibility)
            if (clearUrl) {
                this.clearCollabURLParams();
            }

        },

        async reconnectToCollaborativeDocument() {
            if (!this.currentFile || this.currentFile.type !== 'collaborative') {
                console.error('Cannot reconnect: no collaborative document loaded');
                return;
            }

            try {

                // Set connecting status
                this.connectionStatus = 'connecting';

                // Disconnect existing WebSocket provider only
                if (this.provider) {
                    this.provider.destroy();
                    this.provider = null;
                }

                // Reconnect to the collaboration server using persistence manager
                if (ydocService.isReady()) {
                    await this.documentManager.persistenceManager.setupCloudPersistence(this.ydoc, this.currentFile);
                    // WebSocket connects in background, will upgrade editors when ready
                }

                // Restore URL parameters after successful reconnection
                this.updateURLWithCollabParams(this.currentFile.owner, this.currentFile.permlink);

            } catch (error) {
                console.error('‚ùå Failed to reconnect:', error);
                this.connectionStatus = 'offline';
                alert(`Failed to reconnect to collaborative document:\n\n${error.message}`);
            }
        },

        getStatusTextClass(state) {
            const textClasses = {
                // Temp documents (not yet drafts)
                'temp-editing': 'text-muted',
                'temp-ready': 'text-muted',
                'initializing': 'text-muted',
                'cleaning-up': 'text-muted',
                'no-document': 'text-muted',

                // Local documents
                'saving-local': 'text-warning',
                'saved-local': 'text-info',

                // Collaborative documents offline mode
                'offline-saving': 'text-warning',
                'offline-ready': 'text-info',
                'unsynced-changes': 'text-warning',
                'offline': 'text-info',

                // Collaborative documents online mode
                'connecting': 'text-primary',
                'syncing': 'text-warning',
                'collaborating': 'text-success',
                'synced': 'text-success',

                // New states for collaborative documents
                'read-only-collaborative': 'text-muted',
                'loading-collaborative': 'text-primary',

                // Error states
                'error': 'text-danger',
                'unknown': 'text-muted'
            };
            return textClasses[state] || textClasses.unknown;
        },

        handleStatusAction(action) {
            if (action.actionType === 'reconnect') {
                this.reconnectToCollaborativeDocument();
            }
        },

        // ===== COLLABORATIVE USER WIDGET METHODS =====

        toggleColorPicker() {
            this.showColorPicker = !this.showColorPicker;
        },

        updateUserColor(color) {
            this.userColor = color;

            // Update provider awareness if available
            if (this.provider && this.provider.awareness) {
                // ‚úÖ TIPTAP BEST PRACTICE: Allow color updates for read-only users
                // They should be visible with their chosen color
                const currentState = this.provider.awareness.getLocalState() || {};
                const updatedState = {
                    ...currentState,
                    user: {
                        ...currentState.user,
                        color: color
                    }
                };

                // Maintain read-only indicator
                if (this.isReadOnlyMode) {
                    updatedState.user.isReadOnly = true;
                }

                this.provider.awareness.setLocalState(updatedState);
            }

            // Store in cache service for persistence
            if (this.username) {
                cacheService.setUserColor(this.username, color);
            }

        },

        getRandomColor() {
            const colors = this.userColors;
            return colors[Math.floor(Math.random() * colors.length)];
        },

        handleAvatarError(event, user) {
            // Fallback to a default avatar or colored circle
            const canvas = document.createElement('canvas');
            canvas.width = 24;
            canvas.height = 24;
            const ctx = canvas.getContext('2d');

            // Draw colored circle with first letter of username
            ctx.fillStyle = user.color || this.getUserColor;
            ctx.beginPath();
            ctx.arc(12, 12, 12, 0, 2 * Math.PI);
            ctx.fill();

            // Draw letter
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText((user.name || 'U').charAt(0).toUpperCase(), 12, 12);

            event.target.src = canvas.toDataURL();
        },

        // Initialize user color from localStorage
        initializeUserColor() {
            if (this.username) {
                const savedColor = cacheService.getUserColor(this.username);
                if (savedColor) {
                    this.userColor = savedColor;
                }
            }
        },

        // Update connected users from provider awareness
        updateConnectedUsers() {
            if (!this.provider || !this.provider.awareness) {
                this.connectedUsers = [];
                return;
            }

            const users = [];
            this.provider.awareness.getStates().forEach((state, clientId) => {
                // ‚úÖ PERMISSION BROADCAST DETECTION: Check for permission updates from server
                if (state.permissionUpdate && state.permissionUpdate.timestamp > this.lastPermissionCheck) {
                    // ‚úÖ RATE LIMITING: Prevent broadcast spam (minimum 1-second interval)
                    if (Date.now() - this.permissionTimestamps.lastBroadcast < 1000) {
                        return;
                    }

                    // ‚úÖ PERMISSION VALIDATION: Only process if authenticated and have current file
                    if (!this.isAuthenticated || !this.currentFile) {
                        console.warn('‚ö†Ô∏è Ignoring permission broadcast - not authenticated or no current file');
                        return;
                    }

                    this.handlePermissionBroadcast(state.permissionUpdate);
                    this.permissionTimestamps.lastBroadcast = Date.now();
                }

                if (state.user && clientId !== this.provider.awareness.clientID) {
                    users.push({
                        id: clientId,
                        name: state.user.name || `User ${clientId}`,
                        color: state.user.color || this.userColors[clientId % this.userColors.length]
                    });
                }
            });

            this.connectedUsers = users;
        },

        // ===== REACTIVE Y.JS DOCUMENT NAME: Update reactive property when Y.js config changes =====
        updateReactiveDocumentName(newDocumentName) {
            // Only log name changes when they actually change
            if (this.reactiveDocumentName !== newDocumentName) {
            }

            // ‚úÖ BEST PRACTICE: Use Vue reactivity directly - no $forceUpdate needed
            this.reactiveDocumentName = newDocumentName;

            // ‚úÖ PERFORMANCE: Let Vue's reactive system handle DOM updates automatically
            // No manual DOM manipulation or forced updates required
        },

        // ‚úÖ PERFORMANCE: Cache document metadata - REMOVED, use documentService.cacheDocumentMetadata() directly

        // ‚úÖ PERFORMANCE: Cache local document metadata - REMOVED, use documentService.cacheDocumentMetadata() directly

        // ‚úÖ PERFORMANCE: Preload collaborative document metadata from cache
        // ‚úÖ REMOVED: preloadCollaborativeMetadata - use documentService.getDocumentMetadata() directly

        // ‚úÖ REMOVED: preloadLocalDocumentMetadata - use documentService.getDocumentMetadata() directly

        // ===== EXPORT METHODS =====

        exportAsMarkdown() {
            const markdown = this.getMarkdownContent();
            const filename = (this.currentFile?.name || 'untitled') + '.md';

            // Create and download file
            const blob = new Blob([markdown], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

        },

        showJsonPreview() {
            // Use the new openJsonPreview method that updates reactive data
            this.openJsonPreview();
        },

        // ===== SERVER VERSION CHECKING =====
        async checkServerVersion() {
            // Prevent duplicate checks
            if (this.isCheckingServerVersion) return this.serverVersion;

            // Use cached version if fresh (1 hour)
            const now = Date.now();
            if (this.serverVersion && (now - this.serverVersionCheckTime) < this.serverVersionCheckInterval) {
                return this.serverVersion;
            }

            this.isCheckingServerVersion = true;

            try {
                // ‚úÖ CORRECT API: Use system/versions endpoint as documented in docker-data
                // ‚úÖ FIX: Handle CORS properly for cross-origin requests
                const response = await fetch('https://data.dlux.io/api/system/versions', {
                    method: 'GET',
                    mode: 'cors',
                    credentials: 'omit', // Don't send cookies for this endpoint
                    headers: {
                        'Accept': 'application/json'
                    }
                });

                if (response.ok) {
                    // ‚úÖ FIX: Handle potential JSON parsing issues with version endpoint
                    let data;
                    try {
                        const responseText = await response.text();
                        if (responseText) {
                            data = JSON.parse(responseText);
                        } else {
                            console.warn('‚ö†Ô∏è Empty response from version endpoint');
                            return null;
                        }
                    } catch (parseError) {
                        console.warn('‚ö†Ô∏è Failed to parse version response:', parseError.message);
                        return null;
                    }

                    // ‚úÖ FIX: Correct path to version based on actual API response structure
                    const version = data.application?.version || data.version || '1.0.0';

                    // Store in localStorage for offline access via CacheService
                    try {
                        cacheService.cacheServerVersion(version);
                    } catch (e) {
                        console.warn('‚ö†Ô∏è Could not cache server version:', e.message);
                    }

                    // Check for version mismatch
                    const versionMismatch = version !== this.expectedServerVersion;

                    if (versionMismatch) {
                        console.warn('‚ö†Ô∏è Server version mismatch:', {
                            server: version,
                            expected: this.expectedServerVersion
                        });
                    } else {
                    }

                    return version;
                } else {
                    // Version endpoint might not be implemented yet
                    if (response.status === 404) {
                    } else {
                        console.warn('‚ö†Ô∏è Server version check failed:', response.status, response.statusText);
                    }
                }
            } catch (error) {
                // Don't log as error - version check is optional
                if (error.message.includes('Failed to fetch') || error.message.includes('ERR_FAILED')) {
                } else {
                    console.warn('‚ö†Ô∏è Failed to check server version:', error.message);
                }

                // Try to load from localStorage cache
                try {
                    const cached = cacheService.getServerVersion();
                    if (cached) {
                        const { version } = cached;
                        // Use cached version even if older than 1 hour in case of network issues
                        return version;
                    }
                } catch (e) {
                    console.warn('‚ö†Ô∏è Could not load cached server version:', e.message);
                }
            } finally {
                this.isCheckingServerVersion = false;
            }

            return null;
        },

        // =============== HELPER METHODS ===============

        async extractDocumentNameFromYjs(documentId) {
            try {

                const tempDoc = new Y.Doc();

                // ‚úÖ TIPTAP COMPLIANCE: Use TipTap bundle pattern instead of direct Y.js
                const bundle = window.TiptapCollaboration;
                const tiptapBundle = bundle.Y ? bundle : bundle.default;
                const IndexeddbPersistence = tiptapBundle?.IndexeddbPersistence;

                if (!IndexeddbPersistence) {
                    console.warn('‚ö†Ô∏è IndexeddbPersistence not available in TipTap bundle');
                    return null;
                }

                const provider = new IndexeddbPersistence(documentId, tempDoc);

                // ‚úÖ TIPTAP COMPLIANCE: Use 'synced' event pattern for IndexeddbPersistence
                await new Promise((resolve) => {
                    provider.once('synced', resolve);
                });

                // Use a temporary YDocService instance for temp doc validation
                const tempDocService = new ydocService.constructor();
                tempDocService.loadDocument(tempDoc, 'temp-doc');
                const documentName = tempDocService.getConfig('documentName');
                tempDocService.destroyDocument();

                provider.destroy();

                return documentName;

            } catch (error) {
                console.warn('‚ö†Ô∏è Could not extract document name:', error);
                return null;
            }
        },

        isRecentTempDocument(documentId) {
            try {
                // Check if this is a temp document with timestamp
                const tempMatch = documentId.match(/^temp_(\d+)/);
                if (!tempMatch) {
                    return false;
                }

                const timestamp = parseInt(tempMatch[1]);
                const currentTime = Date.now();
                const documentAge = currentTime - timestamp;

                // Consider document "recent" if created within last 10 minutes
                const isRecent = documentAge < (10 * 60 * 1000);

                return isRecent;

            } catch (error) {
                console.warn('‚ö†Ô∏è Error checking document recency:', error);
                return false;
            }
        },

        // =============== PERMISSION CHECKING METHODS ===============

        async checkDocumentExistsInIndexedDB(documentId) {
            try {

                // First, let's check if IndexedDB database exists at all
                if (indexedDB.databases) {
                    const databases = await indexedDB.databases();
                    const dbExists = databases.find(db => db.name === documentId);

                    if (!dbExists) {

                        return false;
                    }
                }

                // ‚úÖ TIPTAP COMPLIANCE: Use TipTap bundle pattern instead of direct Y.js
                const bundle = window.TiptapCollaboration;
                if (!bundle) {
                    console.warn('‚ö†Ô∏è TipTap bundle not available');
                    return false;
                }

                // Access components from bundle (check default export pattern)
                const tiptapBundle = bundle.Y ? bundle : bundle.default;
                if (!tiptapBundle || !tiptapBundle.Y || !tiptapBundle.IndexeddbPersistence) {
                    console.warn('‚ö†Ô∏è Y.js or IndexeddbPersistence not available in TipTap bundle');
                    return false;
                }

                const Y = tiptapBundle.Y;
                const IndexeddbPersistence = tiptapBundle.IndexeddbPersistence;

                // Create temporary Y.js document and provider
                const tempDoc = new Y.Doc();

                const provider = new IndexeddbPersistence(documentId, tempDoc);

                // ‚úÖ TIPTAP COMPLIANCE: Use 'synced' event pattern for IndexeddbPersistence
                // Add timeout to handle case where document doesn't exist
                await this.waitForProviderSync(provider, 500);

                // Check if document has any meaningful content/schema
                const tempDocService2 = new ydocService.constructor();
                tempDocService2.loadDocument(tempDoc, 'temp-doc');
                const config = tempDocService2.getMap('config');
                const hasConfig = config && config.size > 0;
                tempDocService2.destroyDocument();

                // ‚úÖ TIPTAP COMPLIANT: Check if Y.js document has been initialized (has basic structure)
                // This checks for any Y.js structure without accessing content fragments
                const hasAnyStructure = (tempDoc.store && tempDoc.store.clients && tempDoc.store.clients.size > 0) ||
                    (tempDoc._subdocs && tempDoc._subdocs.size > 0);

                // Check if document has any Y.js shared types
                const hasSharedTypes = tempDoc.share && Object.keys(tempDoc.share).length > 0;

                // Document exists if it has config data OR any Y.js structure indicating it was created
                const documentExists = hasConfig || hasAnyStructure || hasSharedTypes;

                // Clean up
                provider.destroy();

                return documentExists;

            } catch (error) {
                console.error('‚ùå Error checking IndexedDB document:', documentId, error);
                return false;
            }
        },

        async checkDocumentPermissionsFromYjs(documentId) {
            try {

                // ‚úÖ TIPTAP BEST PRACTICE: Load Y.js document to read metadata maps
                // Note: This accesses Y.js Maps (metadata), NOT XML fragments (content)
                const tempDoc = new Y.Doc();

                // ‚úÖ TIPTAP COMPLIANCE: Use TipTap bundle pattern instead of direct Y.js
                const bundle = window.TiptapCollaboration;
                const tiptapBundle = bundle.Y ? bundle : bundle.default;
                const IndexeddbPersistence = tiptapBundle?.IndexeddbPersistence;

                if (!IndexeddbPersistence) {
                    console.warn('‚ö†Ô∏è IndexeddbPersistence not available in TipTap bundle');
                    return {
                        canRead: false,
                        reason: 'IndexeddbPersistence not available in TipTap bundle'
                    };
                }

                const provider = new IndexeddbPersistence(documentId, tempDoc);

                // ‚úÖ TIPTAP COMPLIANCE: Use 'synced' event pattern for IndexeddbPersistence
                await new Promise((resolve) => {
                    provider.once('synced', resolve);
                });

                // ‚úÖ CORRECT: Access Y.js maps for metadata (following TipTap best practices)
                const tempDocService3 = new ydocService.constructor();
                tempDocService3.loadDocument(tempDoc, 'temp-doc');
                const config = tempDocService3.getMap('config');
                const permissions = tempDocService3.getMap('permissions');
                // Get all needed values before destroying
                const isLocal = config.get('isLocal');
                const fileOwner = config.get('owner');
                const documentName = config.get('documentName');
                const userPermissions = permissions.get(this.username);
                
                // Now destroy the temporary service
                tempDocService3.destroyDocument();

                // Clean up temporary resources
                provider.destroy();

                // ‚úÖ TIPTAP SECURITY: Enhanced permission logic for user boundary enforcement
                if (isLocal || isLocal === undefined) {
                    // Local file: STRICT owner matching with enhanced security
                    const currentUser = this.username || 'anonymous';

                    if (!this.username) {
                        // Anonymous users can only access files with no owner
                        if (fileOwner) {
                            return {
                                canRead: false,
                                reason: `TipTap Security: Anonymous user cannot access owned local file (owner: ${fileOwner})`
                            };
                        }
                        return {
                            canRead: true,
                            reason: `Anonymous access granted to unowned local file`
                        };
                    } else {
                        // Authenticated users: STRICT ownership enforcement
                        if (fileOwner && fileOwner !== currentUser) {
                            return {
                                canRead: false,
                                reason: `TipTap Security: Local file belongs to ${fileOwner}, but you are ${currentUser}`
                            };
                        }
                        return {
                            canRead: true,
                            reason: `Local file access granted for owner ${currentUser}`
                        };
                    }
                } else {
                    // Collaborative file: check permissions map using saved value

                    if (!userPermissions || !userPermissions.canRead) {
                        return {
                            canRead: false,
                            reason: `Access denied: No read permissions for user ${this.username}`
                        };
                    }

                    return {
                        canRead: true,
                        reason: `Collaborative file access granted for user ${this.username}`
                    };
                }

            } catch (error) {
                console.error('‚ùå Error checking document permissions from Y.js:', error);
                return {
                    canRead: false,
                    reason: `Error checking permissions: ${error.message}`
                };
            }
        },

        // Get user's permission level for a specific document

        // ‚úÖ SECURITY: Enhanced permission display with no-access support
        getPermissionDisplayInfo(permissionLevel) {
            const permissionMap = {
                'owner': {
                    label: 'Owner',
                    icon: 'fas fa-crown',
                    color: 'warning',
                    description: 'Full control - can edit, share, and delete'
                },
                'postable': {
                    label: 'Publisher',
                    icon: 'fas fa-edit',
                    color: 'success',
                    description: 'Can edit content and publish to Hive'
                },
                'editable': {
                    label: 'Editor',
                    icon: 'fas fa-pen',
                    color: 'primary',
                    description: 'Can edit content but cannot publish'
                },
                'readonly': {
                    label: 'Viewer',
                    icon: 'fas fa-eye',
                    color: 'info',
                    description: 'Can view content only'
                },
                'no-access': {
                    label: 'No Access',
                    icon: 'fas fa-ban',
                    color: 'danger',
                    description: 'Cannot access this document'
                },
                'unknown': {
                    label: 'Unknown',
                    icon: 'fas fa-question',
                    color: 'secondary',
                    description: 'Permission level unknown'
                }
            };

            return permissionMap[permissionLevel] || permissionMap['no-access'];
        },

        // ‚úÖ CACHE MIGRATION: Clean up legacy cache keys
        migrateLegacyCacheKeys() {
            const DEBUG = this.DEBUG || window.DEBUG;
            let removedCount = 0;

            try {
                // Find all localStorage keys using CacheService
                const keysToRemove = this.cacheService.findKeysByPattern(key => {
                    // Legacy permission keys: dlux_permission_{owner}/{permlink}
                    if (key.startsWith('dlux_permission_') && !key.includes('_cache_')) {
                        return true;
                    }
                    
                    // Legacy document metadata keys: dlux_doc_metadata_{owner}/{permlink}
                    if (key.startsWith('dlux_doc_metadata_')) {
                        return true;
                    }
                    
                    // Legacy user color keys: dlux_user_color_{username}
                    if (key.startsWith('dlux_user_color_') && !key.includes('_cache')) {
                        return true;
                    }
                    
                    return false;
                });
                
                // Remove legacy keys using CacheService
                removedCount = this.cacheService.removeLegacyKeys(keysToRemove);
                
                if (DEBUG && removedCount > 0) {
                    console.log('üßπ Cache Migration: Removed legacy cache keys', {
                        removedCount,
                        keys: keysToRemove
                    });
                }
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Cache migration error:', error);
            }
        },

        // ‚úÖ CONSOLIDATED: Single method to clear all caches
        clearAllCaches() {
            // Delegate to services - they handle their own cache clearing
            if (this.authStateManager) {
                this.authStateManager.clearFilePermissionCache();
            }
            
            if (this.cacheService) {
                this.cacheService.clearAll();
            }
            
            if (collaborationService) {
                collaborationService.clearAllCaches();
            }
            
            if (documentService) {
                documentService.clearAllCaches();
            }
            
            // Clear component-level state
            this.clearCollaborativeDocs();
            this.loadCollaborativeDocsRetryCount = 0;

            console.log('üîÑ CACHE: All caches cleared', {
                services: ['authStateManager', 'cacheService', 'collaborationService', 'documentService'],
                componentState: ['collaborativeDocs', 'permissionLevel', 'retryCounter']
            });
        },
        
        // ‚úÖ ALIAS: Maintain backward compatibility
        clearAllPermissionCaches() {
            this.clearAllCaches();
        },

        // ‚úÖ SECURITY FIX: Validate current document permissions after auth change
        async validateCurrentDocumentPermissions() {
            if (!this.currentFile || this.currentFile.type !== 'collaborative') {
                return;
            }

            // ‚úÖ AUTH STATE MANAGER: Use centralized access control if available
            if (this.authStateManager && window.USE_AUTH_STATE_MANAGER !== false) {
                console.log('üîê AuthStateManager: Validating document permissions');
                await this.authStateManager.checkDocumentAccess(
                    this.currentFile,
                    'permission-validation'
                );

                // AuthStateManager will emit events if needed
                // No need to manually handle here
                return;
            }

            // Legacy implementation follows...
            const owner = this.currentFile.owner || this.currentFile.author;
            const permlink = this.currentFile.permlink;

            if (!owner || !permlink) {
                console.warn('‚ö†Ô∏è Cannot validate permissions - missing owner/permlink');
                return;
            }

            try {
                // Clear cache for this specific document to force fresh check
                if (this.authStateManager) {
                    this.authStateManager.clearFilePermissionCache();
                }

                // ‚úÖ SECURITY FIX: Declare permissionLevel in outer scope
                let permissionLevel = this.getNoAccessPermissionLevel();

                // Check authentication first - unauthenticated users have no access
                if (!this.isAuthenticated || !this.username) {
                    // Force no-access for unauthenticated users
                    permissionLevel = this.getNoAccessPermissionLevel();

                    // Clear permission cache via AuthStateManager
                    if (this.authStateManager) {
                        this.authStateManager.clearFilePermissionCache();
                    }
                } else {
                    // User is authenticated - fetch fresh permissions from server
                    try {
                        // Try to fetch from server
                        const response = await fetch(`https://data.dlux.io/api/collaboration/permissions/${owner}/${permlink}`, {
                            headers: {
                                ...this.getAuthHeadersForRequest(),
                                'Connection': 'close'  // Prevent connection reuse to avoid ERR_CONNECTION_CLOSED
                            }
                        });

                        if (response.ok) {
                            const data = await response.json();
                            // Find current user's permission
                            // ‚úÖ UNIFIED: Direct API response access (not our array)
                            const userPermission = data.find(p => p.account === this.username);
                            permissionLevel = userPermission ? userPermission.permission : 'no-access';

                            // Permission caching is handled internally by getMasterPermissionForDocument
                        }
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Failed to fetch fresh permissions:', error);
                        // ‚úÖ SECURITY: Do NOT fall back to cache for authentication failures
                        // permissionLevel remains 'no-access'
                    }
                }

                // If user has no access, clear document and trigger auth flow
                if (this.permissionService.hasNoAccess(permissionLevel)) {

                    // ‚úÖ NULL SAFETY: Re-check currentFile exists before accessing
                    if (!this.currentFile) {
                        console.warn('‚ö†Ô∏è currentFile became null during permission validation');
                        return;
                    }

                    // ‚úÖ SECURITY BOUNDARY: Extract document info before clearing
                    // ‚úÖ NULL SAFETY: Add proper null checks
                    const documentInfo = {
                        name: this.currentFile?.name || this.currentFile?.documentName || `${owner}/${permlink}`,
                        owner: owner,
                        permlink: permlink,
                        type: 'collaborative'
                    };

                    // ‚úÖ CRITICAL FIX: Clear document FIRST to match fresh load behavior
                    // This ensures no document information is visible to unauthorized users
                    this.setCurrentFile(null);

                    // Now call the access denial handler which will:
                    // 1. Call partialCleanupForAuth() to destroy editors
                    // 2. Disconnect WebSocket (preserving URL)
                    // 3. Show auth modal
                    // 4. Preserve URL for retry
                    await this.handleDocumentAccessDenied(documentInfo);

                    return; // Exit early - handleDocumentAccessDenied handles everything
                }
                // If permission level changed, update editor state and reconnect
                else if (this.currentPermissionLevel !== permissionLevel) {

                    // Update the file's permission level - computed property will react
                    if (this.currentFile) {
                        this.updateFilePermission(this.currentFile, permissionLevel);

                        // Permission caching is handled internally by getMasterPermissionForDocument
                    }

                    // Vue reactivity automatically handled by AuthStateManager's reactive state

                    // Update editor editable state based on new permission
                    // ‚úÖ UNIFIED: Use helper for permission check
                    const canEdit = this.canEditWithPermission(permissionLevel);
                    if (this.bodyEditor && !this.bodyEditor.isDestroyed) {
                        this.bodyEditor.setEditable(canEdit);
                    }

                    // Reconnect WebSocket with new permission level if we have a provider
                    if (this.provider) {
                        if (this.collaborationManager && this.collaborationManager.reconnectWebSocketForPermissionUpgrade) {
                            await this.collaborationManager.reconnectWebSocketForPermissionUpgrade();
                        } else {
                            console.warn('‚ö†Ô∏è Cannot reconnect WebSocket - collaboration manager not available');
                        }
                    }
                }
            } catch (error) {
                console.error('‚ùå Error validating permissions:', error);
                // ‚úÖ FIX: Don't create new document on permission validation errors
                // This preserves URL context for user to try authentication
                // ‚úÖ FIX: Remove legacy dialog - auth modal handles this now
                // this.showError('Unable to verify permissions. Access denied.');

                // Set error state without clearing document context
                this.connectionStatus = 'error';
                this.connectionMessage = 'Permission validation failed. Please check your account permissions.';

                // ‚úÖ PRESERVE CONTEXT: Don't call newDocument() - let user retry with different account
            }
        },

        // ‚úÖ DEPRECATED: Use clearAllCaches() instead
        clearAllAnalyticsCaches() {
            // Delegate to clearAllCaches for consistency
            this.clearAllCaches();
        },

        // ‚úÖ DEPRECATED: Use service methods directly
        clearDocumentPermissionCache(doc) {
            // Services handle their own cache clearing
            if (this.authStateManager && doc) {
                this.authStateManager.clearFilePermissionCache();
                delete doc._collaborativeDefaultProcessed;
            }
        },

        // ===== COLLABORATION ANALYTICS METHODS =====

        async loadCollaborationInfo(forceRefresh = false) {
            if (!this.currentFile || this.currentFile.type !== 'collaborative') {
                return;
            }

            const documentKey = `${this.currentFile.owner}/${this.currentFile.permlink}`;

            // üö® DEBUGGING: Force refresh to bypass cache
            if (forceRefresh) {
                collaborationService.forceRefresh(documentKey);
            }

            // ‚úÖ OFFLINE-FIRST: Check cache first (5 minute TTL)
            const cachedInfo = collaborationService.getCollaborationInfo(documentKey);
            if (cachedInfo && !forceRefresh) {
                return cachedInfo;
            }

            this.loadingInfo = true;

            try {
                const infoUrl = `https://data.dlux.io/api/collaboration/info/${this.currentFile.owner}/${this.currentFile.permlink}`;

                const response = await fetch(infoUrl, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        ...this.getAuthHeadersForRequest()
                    }
                });

                if (response.ok) {
                    const data = await response.json();

                    const collaborationInfo = data.document || data;

                    // üö® CRITICAL: Show the complete JSON structure

                    // ‚úÖ OFFLINE-FIRST: Cache the result
                    collaborationService.cacheCollaborationInfo(documentKey, collaborationInfo);

                    // üö® CRITICAL DEBUGGING: Log complete INFO API response structure
                    return collaborationInfo;
                } else {
                    console.warn('‚ö†Ô∏è INFO: Failed to load collaboration document info', {
                        status: response.status,
                        statusText: response.statusText,
                        document: documentKey
                    });

                    // ‚úÖ OFFLINE-FIRST: Return cached data as fallback
                    return cachedInfo || null;
                }
            } catch (error) {
                console.error('‚ùå INFO: Error loading collaboration document info:', error);

                // ‚úÖ OFFLINE-FIRST: Return cached data as fallback
                return cachedInfo || null;

            } finally {
                this.loadingInfo = false;
            }
        },

        async loadCollaborationStats(forceRefresh = false) {
            if (!this.currentFile || this.currentFile.type !== 'collaborative' || !this.isAuthenticated) {
                return;
            }

            const documentKey = `${this.currentFile.owner}/${this.currentFile.permlink}`;

            // üö® DEBUGGING: Force refresh to bypass cache
            if (forceRefresh) {
                collaborationService.forceRefresh(documentKey);
            }

            // ‚úÖ OFFLINE-FIRST: Check cache first (now unified 5 minute TTL)
            const cachedStats = collaborationService.getCollaborationStats(documentKey);
            if (cachedStats && !forceRefresh) {
                return cachedStats;
            }

            this.loadingStats = true;

            try {
                const statsUrl = `https://data.dlux.io/api/collaboration/stats/${this.currentFile.owner}/${this.currentFile.permlink}`;

                const response = await fetch(statsUrl, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        ...this.getAuthHeadersForRequest()
                    }
                });

                if (response.ok) {
                    const data = await response.json();

                    const collaborationStats = data.stats || data;

                    // üö® CRITICAL: Show the complete JSON structure

                    // ‚úÖ OFFLINE-FIRST: Cache the result
                    collaborationService.cacheCollaborationStats(documentKey, collaborationStats);

                    return collaborationStats;
                } else {
                    console.warn('‚ö†Ô∏è STATS: Failed to load collaboration statistics', {
                        status: response.status,
                        statusText: response.statusText,
                        document: documentKey,
                        usingCachedFallback: !!cachedStats
                    });

                    // ‚úÖ OFFLINE-FIRST: Return cached data as fallback
                    return cachedStats || null;
                }
            } catch (error) {
                console.error('‚ùå STATS: Error loading collaboration statistics:', error);

                // ‚úÖ OFFLINE-FIRST: Return cached data as fallback
                return cachedStats || null;
            } finally {
                this.loadingStats = false;
            }

        },

        async loadCollaborationActivity(limit = 50, offset = 0) {
            if (!this.currentFile || this.currentFile.type !== 'collaborative' || !this.isAuthenticated) {
                return;
            }

            const documentKey = `${this.currentFile.owner}/${this.currentFile.permlink}`;

            // Note: Activity caching not yet implemented in CollaborationService
            // Activity data is ephemeral and changes frequently, so caching may not be beneficial

            this.loadingActivity = true;

            try {
                const activityUrl = `https://data.dlux.io/api/collaboration/activity/${this.currentFile.owner}/${this.currentFile.permlink}?limit=${limit}&offset=${offset}`;

                const response = await fetch(activityUrl, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        ...this.getAuthHeadersForRequest()
                    }
                });

                if (response.ok) {
                    const data = await response.json();

                    // Return activity data directly without storing on component
                    const activity = data.activity || [];

                    return {
                        activity,
                        pagination: data.pagination,
                        hasMore: data.pagination?.hasMore || false
                    };
                } else {
                    console.warn('‚ö†Ô∏è ACTIVITY: Failed to load collaboration activity', {
                        status: response.status,
                        statusText: response.statusText,
                        document: documentKey
                    });

                    // Return empty activity on error
                    return {
                        activity: [],
                        hasMore: false
                    };
                }
            } catch (error) {
                console.error('‚ùå ACTIVITY: Error loading collaboration activity:', error);

                // Return empty activity on error
                return {
                    activity: [],
                    hasMore: false
                };
            } finally {
                this.loadingActivity = false;
            }
        },

        async refreshCollaborationAnalytics() {
            if (!this.currentFile || this.currentFile.type !== 'collaborative') {
                return;
            }

            // Refresh analytics data with cache bypass
            await Promise.all([
                this.loadCollaborationInfo(true),
                this.loadCollaborationStats(true),
                this.loadCollaborationActivity()
            ]);
        },

        startCollaborationAnalyticsRefresh() {
            // Analytics refresh removed - load once on document open
            // Users can manually refresh if needed
            if (this.currentFile && this.currentFile.type === 'collaborative' && this.isAuthenticated) {
                console.log('üìä ANALYTICS: Loading initial stats and activity (no polling)');
                // Load once
                this.loadCollaborationStats(false);
                this.loadCollaborationInfo(false);
                this.loadCollaborationActivity(10, 0);
            }
        },

        stopCollaborationAnalyticsRefresh() {
            // No intervals to clear - polling removed
            console.log('üìä ANALYTICS: Stop called (no-op - no polling to stop)');
        },

        // ===== OFFLINE-FIRST PERMISSION SYSTEM =====

        /**
         * üöÄ OFFLINE-FIRST: Permission refresh now relies on WebSocket broadcasts
         * Polling has been removed in favor of real-time updates
         */
        startPermissionRefresh() {
            // WebSocket broadcasts handle real-time permission updates
            // No polling needed - the handlePermissionBroadcast method processes updates
            console.log('üîÑ PERMISSION REFRESH: Using WebSocket broadcasts only (no polling)');
            
            // Perform one initial refresh to ensure we have latest permissions
            const timeSinceLastRefresh = Date.now() - this.permissionTimestamps.lastRefresh;
            if (timeSinceLastRefresh > 60000) { // Only if more than 1 minute old
                console.log('üîÑ PERMISSION REFRESH: Performing initial refresh');
                this.$nextTick(() => {
                    this.backgroundPermissionRefresh();
                });
            }
        },

        /**
         * üõë OFFLINE-FIRST: Stop permission refresh (no longer needed - no polling)
         */
        stopPermissionRefresh() {
            // No interval to clear - using WebSocket broadcasts only
            console.log('üîÑ PERMISSION REFRESH: Stop called (no-op - no polling to stop)');
        },

        /**
         * üîî WEBSOCKET PERMISSION BROADCAST: Handle real-time permission updates from server
         */
        async handlePermissionBroadcast(updateData) {

            try {
                // Store previous permission level for comparison
                const previousPermissionLevel = this.currentPermissionLevel;

                // ‚úÖ ENHANCED ERROR HANDLING: Retry failed permission loads with exponential backoff
                let attempt = 1;
                const maxAttempts = 3;

                while (attempt <= maxAttempts) {
                    try {
                        await this.loadDocumentPermissions('broadcast-triggered');
                        break; // Success - exit retry loop

                    } catch (error) {
                        console.warn(`‚ö†Ô∏è Permission broadcast attempt ${attempt}/${maxAttempts} failed:`, error.message);

                        if (attempt === maxAttempts) {
                            throw error; // Final attempt failed
                        }

                        // ‚úÖ ARCHITECTURE RULE 6: Exponential backoff using requestAnimationFrame
                        const delay = 1000 * Math.pow(2, attempt - 1);
                        const frames = Math.ceil(delay / 16); // Convert ms to frames at 60fps
                        await new Promise(resolve => {
                            let frameCount = 0;
                            const frameTimeout = () => {
                                if (++frameCount >= frames) {
                                    resolve();
                                } else {
                                    requestAnimationFrame(frameTimeout);
                                }
                            };
                            requestAnimationFrame(frameTimeout);
                        });
                        attempt++;
                    }
                }

                // Update last permission check timestamp to prevent re-processing same broadcast
                this.permissionTimestamps.lastCheck = Date.now();

                // ‚úÖ Reactive state updates UI automatically through computed properties

                // Log permission change if detected
                if (this.currentPermissionLevel !== previousPermissionLevel) {
                }

            } catch (error) {
                console.error('‚ùå Permission broadcast processing failed after all retries:', error);
                // Fall back to regular polling - next refresh will catch the change
            }
        },

        /**
         * üîÑ OFFLINE-FIRST: Background permission refresh (non-blocking, cached-first)
         */
        async backgroundPermissionRefresh() {
            if (!this.isAuthenticated) {
                return;
            }


            try {
                // Only refresh document list if we're not viewing a single document
                const isViewingSingleDoc = this.currentFile && 
                                         this.currentFile.type === 'collaborative' &&
                                         this.currentFile.owner && 
                                         this.currentFile.permlink;
                                         
                if (!isViewingSingleDoc) {
                    // ‚úÖ OFFLINE-FIRST: Non-blocking collaborative documents refresh (includes accessType)
                    this.loadCollaborativeDocs().catch(error => {
                        console.warn('‚ö†Ô∏è Background collaborative docs refresh failed:', error);
                    });
                } else {
                    console.log('‚ÑπÔ∏è Skipping background document list refresh - viewing single document');
                }

                // ‚úÖ OFFLINE-FIRST: Refresh current document permissions if available
                if (this.currentFile && this.currentFile.type === 'collaborative') {
                    // Non-blocking permission refresh for current document
                    this.loadDocumentPermissions('background-refresh').catch(error => {
                        console.warn('‚ö†Ô∏è BACKGROUND REFRESH: Current document permission refresh failed:', error.message);
                    });
                }

                // ‚úÖ OFFLINE-FIRST: Update shared users if share modal is open
                if (this.showShareModal) {
                    this.loadSharedUsers().catch(error => {
                        console.warn('‚ö†Ô∏è BACKGROUND REFRESH: Shared users refresh failed:', error.message);
                    });
                }

                this.permissionTimestamps.lastRefresh = Date.now();

            } catch (error) {
                console.warn('‚ö†Ô∏è BACKGROUND PERMISSION REFRESH: Failed, using cached permissions', error.message);
            }
        },

        // Helper methods for collaboration insights
        getActivityLevel(inactivityDays) {
            if (inactivityDays === 0) return { level: 'very-active', label: 'Very Active', color: 'success' };
            if (inactivityDays <= 1) return { level: 'active', label: 'Active', color: 'primary' };
            if (inactivityDays <= 7) return { level: 'moderate', label: 'Moderate', color: 'warning' };
            return { level: 'inactive', label: 'Inactive', color: 'danger' };
        },

        getEditFrequency(totalEdits, lastActivity) {
            if (!lastActivity || totalEdits === 0) {
                return { frequency: 'none', label: 'No Edits', rate: 0 };
            }

            const daysSinceCreation = Math.max(1, Math.floor((Date.now() - new Date(lastActivity).getTime()) / (24 * 60 * 60 * 1000)));
            const editsPerDay = totalEdits / daysSinceCreation;

            if (editsPerDay >= 10) return { frequency: 'high', label: 'High Frequency', rate: editsPerDay.toFixed(1) };
            if (editsPerDay >= 1) return { frequency: 'medium', label: 'Medium Frequency', rate: editsPerDay.toFixed(1) };
            return { frequency: 'low', label: 'Low Frequency', rate: editsPerDay.toFixed(2) };
        },

        getCollaborationHealth(stats, info = {}) {
            const score = this.calculateHealthScore(stats, info);

            if (score >= 80) return { health: 'excellent', label: 'Excellent', color: 'success', score };
            if (score >= 60) return { health: 'good', label: 'Good', color: 'primary', score };
            if (score >= 40) return { health: 'fair', label: 'Fair', color: 'warning', score };
            return { health: 'poor', label: 'Poor', color: 'danger', score };
        },

        calculateHealthScore(stats, info = {}) {
            let score = 0;

            // Activity recency (30 points)
            const inactivityDays = stats.inactivity_days || 0;
            if (inactivityDays === 0) score += 30;
            else if (inactivityDays <= 1) score += 25;
            else if (inactivityDays <= 7) score += 15;
            else if (inactivityDays <= 30) score += 8;

            // User engagement (25 points)
            const totalUsers = stats.total_users || 0;
            const activeUsers = stats.active_users || 0;
            if (totalUsers > 0) {
                const engagementRatio = activeUsers / totalUsers;
                score += Math.floor(engagementRatio * 25);
            }

            // Edit activity (20 points)
            const totalEdits = stats.total_edits || 0;
            if (totalEdits >= 100) score += 20;
            else if (totalEdits >= 50) score += 15;
            else if (totalEdits >= 20) score += 10;
            else if (totalEdits >= 5) score += 5;

            // Document content quality (15 points)
            const documentSize = stats.document_size || info.contentSize || 0;
            const hasContent = info.hasContent !== undefined ? info.hasContent : documentSize > 0;

            if (hasContent && documentSize >= 10000) score += 15; // 10KB+ with content
            else if (hasContent && documentSize >= 5000) score += 12;  // 5KB+ with content
            else if (hasContent && documentSize >= 1000) score += 8;   // 1KB+ with content
            else if (hasContent && documentSize >= 100) score += 5;    // 100B+ with content
            else if (hasContent) score += 2; // Has content but small

            // Document accessibility (10 points)
            if (info.accessType === 'owner') score += 5; // Owner control
            if (totalUsers > 1) score += 5; // Shared with other users
            if (info.accessType && this.canEditWithPermission(info.accessType)) score += 2; // Edit access

            return Math.min(100, score);
        },

        // Helper methods for document insights
        getDocumentAge(createdAt) {
            if (!createdAt) return 'Unknown';

            const created = new Date(createdAt);
            const now = new Date();
            const diffTime = Math.abs(now - created);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

            if (diffDays === 1) return '1 day old';
            if (diffDays < 30) return `${diffDays} days old`;
            if (diffDays < 365) return `${Math.floor(diffDays / 30)} months old`;
            return `${Math.floor(diffDays / 365)} years old`;
        },

        getTimeSince(timestamp) {
            if (!timestamp) return 'Never';

            const past = new Date(timestamp);
            const now = new Date();
            const diffTime = Math.abs(now - past);
            const diffMinutes = Math.floor(diffTime / (1000 * 60));
            const diffHours = Math.floor(diffTime / (1000 * 60 * 60));
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

            if (diffMinutes < 1) return 'Just now';
            if (diffMinutes < 60) return `${diffMinutes} minutes ago`;
            if (diffHours < 24) return `${diffHours} hours ago`;
            if (diffDays < 30) return `${diffDays} days ago`;
            return this.formatTime(past);
        },

        // ‚úÖ REMOVED: cachePermissionForFile - use authStateManager.cacheFilePermission() directly
        // ‚úÖ REMOVED: getCachedFilePermission - use authStateManager.getCachedFilePermission() directly

        // ‚úÖ REMOVED: updateReactivePermissionState - now using AuthStateManager's reactive cache

        // ‚úÖ REMOVED: preloadCollaborativePermissions - AuthStateManager handles permission caching
        // ‚úÖ REMOVED: preloadDocumentMetadata - DocumentService handles metadata caching

        // ‚úÖ REMOVED: validatePendingCachePermissions - no longer needed with AuthStateManager
        // ‚úÖ REMOVED: loadPersistedPermissions - AuthStateManager handles permission persistence

        // ‚úÖ REMOVED: triggerPermissionReactivity - no longer needed with reactive AuthStateManager

        // ‚úÖ NEW: Update editor editable state based on current permissions
        // ‚úÖ TIPTAP BEST PRACTICE: Dynamic editor mode switching following TipTap.dev guidelines
        updateEditorMode() {
            // Add early return if no current file
            if (!this.currentFile) {
                return; // No file to update editor mode for
            }
            
            // Add guard for user switching
            if (this._processingUserChange) {
                return; // Skip during user switch
            }
            
            // ‚úÖ TIPTAP COMPLIANCE: Validate editor instance before calling setEditable
            if (!this.bodyEditor) {
                // ‚úÖ PERFORMANCE: Reduce console noise for normal initialization flow
                return; // No editor to update
            }

            // ‚úÖ TIPTAP COMPLIANCE: Check if editor is destroyed before calling methods
            if (this.bodyEditor.isDestroyed) {
                console.warn('‚ö†Ô∏è TipTap: Cannot update editor mode - editor is destroyed');
                return;
            }

            // ‚úÖ TIPTAP COMPLIANCE: Check if editor is ready for transactions
            if (!this.bodyEditor.view) {
                console.warn('‚ö†Ô∏è TipTap: Cannot update editor mode - editor view not ready');
                return;
            }

            try {
                const shouldBeEditable = !this.isReadOnlyMode;
                const currentPermissionLevel = this.getUserPermissionLevel(this.currentFile);

                // ‚úÖ TIPTAP BEST PRACTICE: Only update if the state has changed to avoid unnecessary operations
                if (this.bodyEditor.isEditable !== shouldBeEditable) {
                    const wasReadOnly = !this.bodyEditor.isEditable;
                    const willBeEditable = shouldBeEditable;

                    // ‚úÖ PERMISSION TRANSITIONS: Handle all permission level changes with WebSocket reconnection
                    const currentPermission = this.getUserPermissionLevel(this.currentFile);
                    const needsWebSocketReconnect = this.provider && this.currentFile?.type === 'collaborative' &&
                        (wasReadOnly !== !shouldBeEditable); // Any readonly/editable transition

                    if (needsWebSocketReconnect) {

                        // Reconnect WebSocket with new permission level for server authentication
                        this.$nextTick(async () => {
                            try {
                                if (this.collaborationManager && this.collaborationManager.reconnectWebSocketForPermissionUpgrade) {
                                    await this.collaborationManager.reconnectWebSocketForPermissionUpgrade();
                                } else {
                                    console.warn('‚ö†Ô∏è Collaboration manager not available for WebSocket reconnection');
                                    // Fall back to basic editor update
                                    this.bodyEditor.setEditable(shouldBeEditable, false);
                                }
                            } catch (error) {
                                console.warn('‚ö†Ô∏è WebSocket reconnection failed after permission change:', error.message);
                                // Fall back to basic editor update
                                this.bodyEditor.setEditable(shouldBeEditable, false);
                            }
                        });
                        return; // WebSocket reconnection will handle editor update
                    }

                    // ‚úÖ TIPTAP BEST PRACTICE: Use setEditable method with emitUpdate parameter
                    // Set emitUpdate to false to avoid unnecessary update events during mode switching
                    this.bodyEditor.setEditable(shouldBeEditable, false);

                    // ‚úÖ TIPTAP BEST PRACTICE: Avoid focus() during mode transitions to prevent transaction errors
                    // Focus can cause "Applying a mismatched transaction" errors during editor state changes

                } else {
                    // ‚úÖ PERFORMANCE: Skip redundant permission updates but log for debugging
                    const timeSinceLastSkip = Date.now() - (this.permissionTimestamps.lastSkippedLog || 0);
                    if (timeSinceLastSkip > 10000) { // Log once every 10 seconds max
                        this.permissionTimestamps.lastSkippedLog = Date.now();
                    }
                }
            } catch (error) {
                console.error('‚ùå TipTap: Failed to update editor mode:', {
                    error: error.message,
                    stack: error.stack,
                    document: this.currentFile ? `${this.currentFile.owner}/${this.currentFile.permlink}` : 'none'
                });
            }
        },

        // ‚úÖ REACTIVE PERMISSIONS: Handle remote permission updates from WebSocket broadcasts
        handleRemotePermissionUpdate(payload) {
            if (!payload || !this.currentFile) return;

            const { targetAccount, permissionType, grantedBy, revokedBy } = payload;

            // Verify this update is for the current user
            if (targetAccount !== this.username) {
                console.warn('‚ö†Ô∏è Permission update for different user:', targetAccount);
                return;
            }

            // Verify this update is for the current document
            const documentKey = this.getDocumentKey(this.currentFile);
            const payloadDocKey = `${payload.owner || this.currentFile.owner}/${payload.permlink || this.currentFile.permlink}`;

            if (documentKey !== payloadDocKey) {
                return;
            }

            // Permission caching is handled internally by getMasterPermissionForDocument

            // Update document permissions array if it exists
            if (this.documentPermissions) {
                // ‚úÖ CONSOLIDATED: Check if user already has permission
                const existingIndex = this.documentPermissions.findIndex(p => p.account === this.username);
                if (existingIndex >= 0) {
                    // Update existing permission
                    this.documentPermissions[existingIndex] = {
                        ...this.documentPermissions[existingIndex],
                        permissionType: permissionType,
                        grantedBy: grantedBy || revokedBy,
                        grantedAt: new Date().toISOString()
                    };
                } else if (permissionType !== 'no-access') {
                    // Add new permission (not for revocations)
                    this.documentPermissions.push({
                        account: this.username,
                        permissionType: permissionType,
                        grantedBy: grantedBy || 'unknown',
                        grantedAt: new Date().toISOString()
                    });
                }

                // Remove entry if access was revoked
                if (permissionType === 'no-access' && existingIndex >= 0) {
                    this.documentPermissions.splice(existingIndex, 1);
                }
            }

            // Show user notification about the permission change
            const permissionMessages = {
                'owner': 'You now have owner access',
                'postable': 'You can now edit and publish this document',
                'editable': 'You can now edit this document',
                'readonly': 'You now have read-only access',
                'no-access': 'Your access has been revoked'
            };

            const message = permissionMessages[permissionType] || `Permission changed to ${permissionType}`;

            // Show notification to user

            // For significant permission changes, show an alert
            if (permissionType === 'no-access' ||
                (this.bodyEditor?.isEditable && this.isReadonlyPermission(permissionType)) ||
                (!this.bodyEditor?.isEditable && this.canEditWithPermission(permissionType))) {
                // ‚úÖ ARCHITECTURE RULE 6: Use nextTick to avoid blocking the permission update process
                this.$nextTick(() => {
                    alert(message);
                });
            }

            // Update editor mode after permission change
            this.$nextTick(() => {
                this.updateEditorMode();

                // Vue reactivity automatically handled by AuthStateManager's reactive state

                // If access was revoked, consider redirecting or showing access denied
                if (permissionType === 'no-access') {
                    console.warn('üö´ Access revoked - user may need to close document');
                    // Let the UI handle this appropriately based on UX requirements
                }
            });
        },

        // Efficiently get permissions for multiple files (for file table display)

        // ‚úÖ NEW: Simplified permission getter for UI (uses master authority)
        async getPermissionLevel(file, forceRefresh = false) {
            const result = await this.getMasterPermissionForDocument(file, forceRefresh);
            return result.level;
        },

        // ‚úÖ NEW: Permission debugging tool
        async debugPermissions(file = null) {
            const targetFile = file || this.currentFile;
            if (!targetFile) {
                return;
            }

            const result = await this.getMasterPermissionForDocument(targetFile, true);

            // Additional context for current document
            if (targetFile === this.currentFile) {
            }

            return result;
        },

        // ‚úÖ SIMPLIFIED: getUserPermissionLevel for backward compatibility
        getUserPermissionLevel(file) {
            // Debug logging for offline cache issue
            console.log('üîç OFFLINE-DEBUG: getUserPermissionLevel called', JSON.stringify({
                fileId: file?.id,
                fileType: file?.type,
                isOfflineCache: file?.isOfflineCache,
                isAuthenticated: this.isAuthenticated,
                username: this.username,
                hasDoubleUnderscore: file?.id?.includes('__')
            }, null, 2));
            
            // ‚úÖ OFFLINE-FIRST: Handle offline cached documents when not authenticated
            if (file && file.isOfflineCache && !this.isAuthenticated && this.username) {
                console.log('üîç OFFLINE-DEBUG: Entered offline cache handling block');
                // Parse the cache key to check ownership
                if (file.id && file.id.includes('__')) {
                    const [cacheUser] = file.id.split('__');
                    
                    // Security check: Only allow access to caches created by this user
                    if (cacheUser !== this.username) {
                        console.log('üîç OFFLINE-DEBUG: Access denied - not user\'s cache', JSON.stringify({
                            cacheUser,
                            currentUser: this.username,
                            documentId: file.id
                        }, null, 2));
                        return 'no-access'; // Not their cache
                    }
                    
                    // Check if user owns the document
                    if (file.owner === this.username) {
                        console.log('üîç OFFLINE-DEBUG: Owner access granted', JSON.stringify({
                            document: `${file.owner}/${file.permlink}`,
                            user: this.username
                        }, null, 2));
                        return 'owner'; // Always owner of own docs
                    }
                    
                    // Try to get cached permission from localStorage via CacheService
                    // Permission caches use pattern: dlux_permissions_cache_owner/permlink_username
                    const documentId = `${file.owner}/${file.permlink}`;
                    const cachedPermission = this.cacheService?.getCachedUserPermissionLevel(documentId, this.username);
                    
                    if (cachedPermission && cachedPermission.level) {
                        console.log('üîç OFFLINE-DEBUG: Using cached permission from CacheService', JSON.stringify({
                            document: documentId,
                            cachedLevel: cachedPermission.level,
                            fromCache: true,
                            timestamp: cachedPermission.timestamp
                        }, null, 2));
                        return cachedPermission.level;
                    }
                    
                    // Also check AuthStateManager's memory cache
                    const authCachedPermission = this.authStateManager?.getCachedFilePermission(file);
                    if (authCachedPermission && authCachedPermission.level) {
                        console.log('üîç OFFLINE-DEBUG: Using cached permission from AuthStateManager', JSON.stringify({
                            document: documentId,
                            cachedLevel: authCachedPermission.level,
                            cachedAt: authCachedPermission.timestamp
                        }, null, 2));
                        return authCachedPermission.level;
                    }
                    
                    // Fallback to readonly if no cached permission
                    console.log('üîç OFFLINE-DEBUG: No cached permission, defaulting to readonly', JSON.stringify({
                        document: documentId,
                        checkedCacheService: !!this.cacheService,
                        checkedAuthStateManager: !!this.authStateManager
                    }, null, 2));
                    return 'readonly';
                } else {
                    console.log('üîç OFFLINE-DEBUG: Skipped - file.id does not contain __');
                }
            } else {
                console.log('üîç OFFLINE-DEBUG: Condition not met for offline cache handling', JSON.stringify({
                    hasFile: !!file,
                    isOfflineCache: file?.isOfflineCache,
                    notAuthenticated: !this.isAuthenticated,
                    hasUsername: !!this.username
                }, null, 2));
            }
            
            // Use the refactored permission service with all required parameters
            const baseLevel = this.permissionService.determinePermissionLevel(
                file,
                this.username,
                this.isAuthenticated,
                this.documentPermissions,
                this.collaborativeDocs
            );

            console.log('üîç OFFLINE-DEBUG: determinePermissionLevel returned', {
                fileId: file?.id,
                baseLevel: baseLevel
            });

            // If service returned a definitive answer, use it
            if (baseLevel !== 'unknown') {
                // For collaborative docs, also check caches
                if (file && file.type === 'collaborative') {
                    // Check in-memory cache via AuthStateManager
                    const cachedFilePermission = this.authStateManager?.getCachedFilePermission(file);
                    if (cachedFilePermission) {
                        const cachedLevel = cachedFilePermission.level;
                        const cacheTimestamp = cachedFilePermission.timestamp || Date.now();

                        if (Date.now() - cacheTimestamp < 300000) { // 5 min cache
                            return cachedLevel;
                        }
                    }

                    // 3. Check URL parameters for permission fallbacks
                    const urlPermission = this.getPermissionFromURLParams(file);
                    if (urlPermission && urlPermission !== 'unknown') {
                        // Permission caching is handled internally by getMasterPermissionForDocument
                        return urlPermission;
                    }
                }

                return baseLevel;
            }

            // If unknown, check with AuthStateManager for collaborative docs
            if (file && file.type === 'collaborative' && this.authStateManager && this.username) {
                // Check permission cache from AuthStateManager
                const cached = this.authStateManager.getCachedFilePermission(file);
                if (cached && cached.timestamp && Date.now() - cached.timestamp < 5 * 60 * 1000) { // 5 minute cache
                    console.log('üîç PERMISSION: Using AuthStateManager cache', {
                        file: `${file.owner}/${file.permlink}`,
                        username: this.username,
                        level: cached.level
                    });
                    return cached.level;
                }
            }

            // Default to readonly for unknown cases
            return 'readonly';
        },

        // ‚úÖ REMOVED: Duplicate method - using optimized version at line 4897

        // ==================== ENHANCED SECURITY PERMISSION SYSTEM ====================
        // ‚úÖ SECURITY: Master permission authority with NO ACCESS controls
        async getMasterPermissionForDocument(file, forceRefresh = false, context = 'document-access') {
            if (!file) return { level: 'no-access', source: 'no-file', confidence: 'high' };

            const debugInfo = {
                file: this.getDocumentDisplayName(file) || `${file.owner}/${file.permlink}`,
                type: file.type,
                username: this.username,
                isAuthenticated: this.isAuthenticated,
                isAuthExpired: this.isAuthExpired,
                checks: []
            };

            // ‚úÖ PERFORMANCE: Request deduplication - return pending request if exists
            const requestKey = `${file.owner || 'local'}/${file.permlink || file.id}_${this.username}_${forceRefresh}`;
            if (this.pendingPermissionRequests.has(requestKey)) {
                return this.pendingPermissionRequests.get(requestKey);
            }

            // Create deduplication wrapper for the actual permission check
            const permissionPromise = this._getMasterPermissionForDocumentInternal(file, forceRefresh, context, debugInfo);

            // Store the promise for deduplication
            this.pendingPermissionRequests.set(requestKey, permissionPromise);

            // Clean up after completion
            permissionPromise.finally(() => {
                this.pendingPermissionRequests.delete(requestKey);
            });

            return permissionPromise;
        },

        async _getMasterPermissionForDocumentInternal(file, forceRefresh, context, debugInfo) {

            // ‚úÖ STEP 1: Local documents - STRICT ownership check
            const isLocalFile = file.id && !file.owner && !file.permlink;
            if (isLocalFile) {
                const fileOwner = file.owner;
                debugInfo.checks.push({ step: 'local-ownership', fileOwner, currentUser: this.username });

                // ‚úÖ SECURITY: Local files require exact user match or anonymous ownership
                if (!this.username) {
                    // Anonymous users can only access files with no owner
                    if (!fileOwner) {
                        return {
                            level: 'owner',
                            source: 'anonymous-local-access',
                            confidence: 'high',
                            debug: debugInfo
                        };
                    } else {
                        return {
                            level: 'no-access',
                            source: 'anonymous-no-access-to-owned-local',
                            confidence: 'high',
                            debug: debugInfo
                        };
                    }
                } else {
                    // Authenticated users can only access their own files
                    if (!fileOwner || fileOwner === this.username) {
                        return {
                            level: 'owner',
                            source: 'local-ownership',
                            confidence: 'high',
                            debug: debugInfo
                        };
                    } else {
                        // ‚úÖ SECURITY: NO ACCESS to other users' local files
                        return {
                            level: 'no-access',
                            source: 'local-cross-user-blocked',
                            confidence: 'high',
                            debug: debugInfo
                        };
                    }
                }
            }

            // ‚úÖ STEP 2: Collaborative documents - STRICT permission enforcement
            const isCollaborativeFile = (file.type === 'collaborative' || file.isCollaborative) && file.owner && file.permlink;
            if (isCollaborativeFile) {
                // Check 1: Authentication required for collaborative documents
                if (!this.isAuthenticated || this.isAuthExpired) {

                    debugInfo.checks.push({ step: 'auth-check', authenticated: false });

                    // ‚úÖ FIX: Allow access to documents that exist in IndexedDB for offline-first
                    // Even if authentication hasn't loaded yet
                    const documentId = `${file.owner}/${file.permlink}`;
                    if (this.indexedDBDocuments && this.indexedDBDocuments.has(documentId)) {
                        return {
                            level: 'readonly',
                            source: 'offline-while-auth-loading',
                            confidence: 'medium',
                            debug: debugInfo
                        };
                    }

                    // ‚úÖ ENHANCED FIX: For collaborative documents that don't exist offline,
                    // allow readonly access initially if this is during page load
                    // The authentication watcher will upgrade permissions once auth loads
                    if (!this.hasInitialAuthCheck) {
                        this.hasInitialAuthCheck = true; // Mark that we've done initial check
                        return {
                            level: 'readonly',
                            source: 'initial-load-fallback',
                            confidence: 'low',
                            debug: debugInfo
                        };
                    }

                    return {
                        level: 'no-access',
                        source: 'collaborative-requires-auth',
                        confidence: 'high',
                        debug: debugInfo
                    };
                }

                // Check 2: Document owner always has full access
                // ‚úÖ UNIFIED: This is the master permission method - direct owner check is appropriate here
                // ‚úÖ UNIFIED: Use helper for owner check
                if (this.isUserOwner(file)) {
                    debugInfo.checks.push({ step: 'owner-check', isOwner: true });
                    return {
                        level: 'owner',
                        source: 'document-owner',
                        confidence: 'high',
                        debug: debugInfo
                    };
                }

                // Check 3: Use document access API instead of permission list API for cross-user access
                const isCurrentDocument = this.currentFile &&
                    // ‚úÖ UNIFIED: Use helper for document matching
                    this.isDocumentMatch(file, this.currentFile);

                // ‚úÖ FIX: Also try to load permissions for documents being accessed via URL
                // ‚úÖ FIX: Check type/flag to identify collaborative documents
                const isBeingLoaded = !this.currentFile && (file.type === 'collaborative' || file.isCollaborative) && file.owner && file.permlink;

                if (isBeingLoaded) {
                }

                // Check 3: Use cached permissions first (offline-first strategy)
                const cachedPermission = this.authStateManager?.getCachedFilePermission(file);
                if (cachedPermission) {
                    const permissionLevel = cachedPermission.level;
                    const cacheAge = typeof cachedPermission === 'object' && cachedPermission.timestamp
                        ? Date.now() - cachedPermission.timestamp
                        : 0;

                    // ‚úÖ CACHE-FIRST: Always use cached permission first, even if stale
                    if (cacheAge < 300000) {
                        debugInfo.checks.push({ step: 'cached-permission-fresh', level: permissionLevel, cacheAge });

                        // ‚úÖ BACKGROUND REFRESH: Trigger background refresh for non-force requests
                        if (!forceRefresh && cacheAge > 240000) { // 4 minutes - refresh in background
                            this.$nextTick(() => {
                                this.getMasterPermissionForDocument(file, true, 'background-cache-refresh').catch(error => {
                                    console.warn('‚ö†Ô∏è Background cache refresh failed:', error);
                                });
                            });
                        }

                        return {
                            level: permissionLevel,
                            source: 'cached-permission-fresh',
                            confidence: 'high',
                            debug: debugInfo
                        };
                    } else if (!forceRefresh) {
                        // ‚úÖ CACHE-FIRST: Use stale cache for better UX, trigger background refresh
                        debugInfo.checks.push({ step: 'cached-permission-stale', level: permissionLevel, cacheAge });

                        // Using stale cache for better UX, refreshing in background - removed verbose logging

                        // ‚úÖ BACKGROUND REFRESH: Trigger fresh load in background
                        this.$nextTick(() => {
                            this.getMasterPermissionForDocument(file, true, 'background-stale-refresh').catch(error => {
                                console.warn('‚ö†Ô∏è Background stale refresh failed:', error);
                            });
                        });

                        return {
                            level: permissionLevel,
                            source: 'cached-permission-stale',
                            confidence: 'medium',
                            debug: debugInfo
                        };
                    } else {
                        // ‚úÖ FORCE REFRESH: Only bypass cache when explicitly requested
                    }
                } else {
                }

                // Check 4: Load unified server permissions (Info + Permissions) only when needed
                // ‚úÖ CRITICAL FIX: Always check for collaborative documents during URL refresh
                // Check if we have permissions specifically for THIS document
                const hasPermissionsForThisDocument = this.documentPermissions &&
                    this.documentPermissions.length > 0 &&
                    isCurrentDocument;

                const shouldLoadPermissions = forceRefresh ||
                    !hasPermissionsForThisDocument ||
                    (!isCurrentDocument && !this.authStateManager?.getCachedFilePermission(file));

                if (shouldLoadPermissions) {
                    debugInfo.checks.push({ step: 'loading-unified-server-permissions', isCurrentDocument, isBeingLoaded, shouldLoadPermissions });

                    // ‚úÖ CRITICAL: Check if authentication is fully ready before making API calls
                    if (this.isAuthExpired) {

                        // Return cached permissions if available, otherwise readonly fallback
                        const cachedPermission = this.authStateManager?.getCachedFilePermission(file);
                        if (cachedPermission) {
                            const cachedLevel = cachedPermission.level;
                            return {
                                level: cachedLevel,
                                source: 'cached-auth-expired',
                                confidence: 'medium',
                                debug: debugInfo
                            };
                        }

                        return {
                            level: 'readonly',
                            source: 'auth-expired-fallback',
                            confidence: 'low',
                            debug: debugInfo
                        };
                    }

                    try {
                        // ‚úÖ ENHANCED: Load unified permissions for the specific document being checked
                        if (isBeingLoaded || !isCurrentDocument) {
                            // ‚úÖ TIPTAP BEST PRACTICE: Non-blocking permission loading with file parameter
                            this.loadDocumentPermissions(context, file).catch(error => {
                                console.warn('‚ö†Ô∏è Background permission loading failed for non-current document:', error);
                            });
                        } else {
                            // ‚úÖ TIPTAP BEST PRACTICE: Non-blocking permission loading
                            this.loadDocumentPermissions(context).catch(error => {
                                console.warn('‚ö†Ô∏è Background permission loading failed for current document:', error);
                            });
                        }
                    } catch (error) {
                        debugInfo.checks.push({ step: 'unified-permission-load-error', error: error.message });

                        // ‚úÖ ENHANCED: Use cached permissions as fallback for offline-first
                        const cachedPermission = this.authStateManager?.getCachedFilePermission(file);
                        if (cachedPermission) {
                            const cachedLevel = cachedPermission.level;

                            return {
                                level: cachedLevel,
                                source: 'cached-after-server-error',
                                confidence: 'medium',
                                debug: debugInfo
                            };
                        }

                        // ‚úÖ CONTEXT-AWARE COLLABORATIVE DOCUMENT LOGIC
                        if (error.message.includes('404') || error.message.includes('403')) {
                            // ‚úÖ CHECK DOCUMENT SOURCE: Only apply collaborative rule for verified documents
                            const isURLLoaded = file.isURLLoaded || file.loadedFromURL;

                            if (isURLLoaded && error.message.includes('403')) {
                                // ‚úÖ URL-LOADED DOCUMENTS: Respect server 403 as genuine no-access

                                return {
                                    level: 'no-access',
                                    source: 'url-loaded-permission-denied',
                                    confidence: 'high',
                                    debug: debugInfo
                                };
                            } else if (!isURLLoaded) {
                                // ‚úÖ VERIFIED DOCUMENTS: Apply collaborative rule for documents from user's list
                                console.warn('üîç UNIFIED PERMISSION LOAD: Server returned error for verified collaborative document', {
                                    document: `${file.owner}/${file.permlink}`,
                                    error: error.message,
                                    documentInCollaborativeList: true,
                                    reasoning: 'Document exists in collaborative list, so user has at least readonly access'
                                });

                                // ‚úÖ COLLABORATIVE DOCUMENT RULE: If document appears in collaborative list,
                                // user has at least readonly access (server wouldn't return it otherwise)
                                this.authStateManager.cacheFilePermission(file, 'readonly');

                                return {
                                    level: 'readonly',
                                    source: 'collaborative-list-implied-readonly',
                                    confidence: 'medium',
                                    debug: debugInfo
                                };
                            } else {
                                // ‚úÖ URL-LOADED 404: Treat as no-access (document doesn't exist or no permission)

                                return {
                                    level: 'no-access',
                                    source: 'url-loaded-not-found',
                                    confidence: 'high',
                                    debug: debugInfo
                                };
                            }
                        }

                        return {
                            level: 'no-access',
                            source: 'unified-permission-load-failed',
                            confidence: 'high',
                            debug: debugInfo
                        };
                    }
                }

                // Check 5: Use loaded server permissions (most authoritative) and cache them
                if ((isCurrentDocument || isBeingLoaded) && this.documentPermissions && this.documentPermissions.length > 0) {
                    // ‚úÖ CONSOLIDATED: Get user permission from array
                    const userPermission = this.documentPermissions.find(p => p.account === this.username);
                    debugInfo.checks.push({
                        step: 'server-permissions',
                        totalPermissions: this.documentPermissions.length,
                        userPermission: userPermission?.permissionType || 'none',
                        checkingDocument: `${file.owner}/${file.permlink}`
                    });

                    if (userPermission) {
                        // ‚úÖ CACHE: Store the permission for offline-first access
                        this.authStateManager.cacheFilePermission(file, userPermission.permissionType);

                        return {
                            level: userPermission.permissionType,
                            source: 'server-permissions',
                            confidence: 'high',
                            debug: debugInfo
                        };
                    } else {
                        // ‚úÖ SECURITY: Explicit server denial = no access, cache it
                        this.authStateManager.cacheFilePermission(file, 'no-access');

                        return {
                            level: 'no-access',
                            source: 'server-permissions-denied',
                            confidence: 'high',
                            debug: debugInfo
                        };
                    }
                }

                // Check 6: Fallback to Y.js ownership (lower confidence, but still secure)
                if (isCurrentDocument && ydocService.isReady()) {
                    const docOwner = ydocService.getConfig('owner');  // ‚úÖ FIX: Removed creator fallback - creator is never written to Y.js
                    debugInfo.checks.push({ step: 'yjs-fallback', docOwner });

                    // ‚úÖ UNIFIED: Use helper for owner check
                    if (docOwner === this.username) {
                        // ‚úÖ CACHE: Store the owner permission
                        this.authStateManager.cacheFilePermission(file, 'owner');

                        return {
                            level: 'owner',
                            source: 'yjs-ownership',
                            confidence: 'medium',
                            debug: debugInfo
                        };
                    }
                }

                // Check 7: Use stale cached permissions if available (offline-first fallback)
                const staleCachedPermission = this.authStateManager?.getCachedFilePermission(file);
                if (staleCachedPermission) {
                    const cachedLevel = staleCachedPermission.level;
                    const cacheAge = staleCachedPermission.timestamp ? Date.now() - staleCachedPermission.timestamp : Infinity;

                    debugInfo.checks.push({ step: 'stale-cached-permissions', level: cachedLevel, cacheAge });

                    // ‚úÖ OFFLINE-FIRST: Even stale cache is better than no access for UX

                    return {
                        level: cachedLevel,
                        source: 'stale-cached-permissions',
                        confidence: 'low',
                        debug: debugInfo
                    };
                }

                // ‚úÖ CONTEXT-AWARE DEFAULT: Only assume readonly for verified documents
                const isURLLoaded = file.isURLLoaded || file.loadedFromURL;

                if (isURLLoaded) {
                    // ‚úÖ URL-LOADED DOCUMENTS: Default to no-access when no explicit permissions found

                    debugInfo.checks.push({ step: 'default-no-access', reason: 'url-loaded-requires-explicit-permission' });

                    return {
                        level: 'no-access',
                        source: 'url-loaded-default-no-access',
                        confidence: 'high',
                        debug: debugInfo
                    };
                } else {
                    // ‚úÖ VERIFIED DOCUMENTS: Apply collaborative rule for documents from user's list
                    debugInfo.checks.push({ step: 'default-readonly', reason: 'collaborative-list-implies-readonly' });

                    // Cache the readonly result to prevent repeated expensive checks
                    this.authStateManager.cacheFilePermission(file, 'readonly');

                    return {
                        level: 'readonly',
                        source: 'collaborative-list-default-readonly',
                        confidence: 'medium',
                        debug: debugInfo
                    };
                }
            }

            // Unknown document type = no access
            debugInfo.checks.push({ step: 'unknown-type', type: file.type });
            return {
                level: 'no-access',
                source: 'unknown-type',
                confidence: 'high',
                debug: debugInfo
            };
        },

        // ‚úÖ REMOVED: Duplicate method - using enhanced version above

        // ‚úÖ SECURITY: Document access validator
        async validateDocumentAccess(file) {
            if (!file) return { allowed: false, reason: 'No file specified' };

            const permission = await this.getMasterPermissionForDocument(file, true);

            if (permission.level === 'no-access') {
                return {
                    allowed: false,
                    reason: `Access denied: ${permission.source}`,
                    debug: permission.debug
                };
            }

            return {
                allowed: true,
                permission: permission.level,
                source: permission.source
            };
        },

        // ‚úÖ UI HELPER: Quick access check for template use
        canAccessDocument(file) {
            if (!file) return false;
            const permissionLevel = this.getUserPermissionLevel(file);
            return this.permissionService.hasAccess(permissionLevel);
        },

        // ‚úÖ UNIFIED PERMISSION HELPERS: Consistent permission checks using getUserPermissionLevel

        /**
         * Check if a file is read-only for the current user
         * @param {Object} file - The file to check
         * @returns {boolean} true if file is read-only or no-access
         */
        isFileReadOnly(file) {
            if (!file) return true;
            const level = this.getUserPermissionLevel(file);
            return this.isViewOnlyPermission(level);
        },

        /**
         * Check if user can delete a specific file
         * @param {Object} file - The file to check
         * @returns {boolean} true if user has owner permission
         */
        canDeleteFile(file) {
            if (!file) return false;
            return this.isOwnerPermission(this.getUserPermissionLevel(file));
        },

        /**
         * Check if user has write access to a file
         * @param {Object} file - The file to check
         * @returns {boolean} true if user can edit the file
         */
        hasWriteAccess(file) {
            if (!file) return false;
            const level = this.getUserPermissionLevel(file);
            // ‚úÖ UNIFIED: Use helper for permission check
            return this.canEditWithPermission(level);
        },

        // getUserPermissionFromArray removed - use getUserPermissionLevel() instead

        // REMOVED: getValidatedAuthHeaders() - Use authStateManager methods instead
        // To get validated headers: 
        // - Check if authenticated: this.authStateManager.isAuthenticated()
        // - Get headers: this.authHeaders (already validated by AuthStateManager)
        // - Validate manually: this.authStateManager.validateAuthHeaders(headers)

        /**
         * ‚úÖ UNIFIED HELPER: Check if document matches another document
         * @param {Object} doc1 - First document to compare
         * @param {Object} doc2 - Second document to compare
         * @returns {boolean} true if documents match by owner and permlink
         */
        isDocumentMatch(doc1, doc2) {
            if (!doc1 || !doc2) return false;
            return doc1.owner === doc2.owner && doc1.permlink === doc2.permlink;
        },

        /**
         * ‚úÖ UNIFIED HELPER: Check if cache data is valid for current user
         * @param {Object} cacheData - Cache data containing username
         * @returns {boolean} true if cache is for current user
         */
        isCacheValidForUser(cacheData) {
            return this.permissionService.isCacheValidForUser(cacheData, this.username);
        },

        /**
         * ‚úÖ UNIFIED HELPER: Check if current user is a guest
         * @returns {boolean} true if user is not authenticated or is GUEST
         */
        isGuestUser() {
            return this.permissionService.isGuestUser(this.username);
        },

        /**
         * ‚úÖ UNIFIED HELPER: Check if user is owner without full permission calculation
         * @param {Object} file - File/document to check
         * @returns {boolean} true if current user owns the file
         */
        isUserOwner(file) {
            return this.permissionService.isUserOwner(file, this.username);
        },

        /**
         * ‚úÖ UNIFIED HELPER: Check if permission level allows editing
         * @param {string} permissionLevel - Permission level to check
         * @returns {boolean} true if permission allows editing
         */
        canEditWithPermission(permissionLevel) {
            return this.permissionService.canEditWithPermission(permissionLevel);
        },

        // ‚úÖ REMOVED hasNoAccess method - using computed property instead to avoid Vue conflict

        /**
         * ‚úÖ UNIFIED HELPER: Get auth headers for API requests
         * @returns {Object} Auth headers object or empty object if not authenticated
         */
        getAuthHeadersForRequest() {
            // ‚úÖ GOLDEN RULE #3: Trust AuthStateManager as single source of truth
            const authHeaders = this.authStateManager?.getAuthHeaders();
            const authUser = this.authStateManager?.getUser();
            
            // ‚úÖ GOLDEN RULE #7: Single responsibility - just return headers if valid
            if (!authUser || !authHeaders) {
                return {};
            }
            
            // AuthStateManager already validates headers match user internally
            // We trust its state completely
            return authHeaders;
        },

        /**
         * ‚úÖ UNIFIED HELPER: Check if permission level allows access
         * @param {string} permissionLevel - Permission level to check
         * @returns {boolean} true if access is allowed
         */
        hasAccess(permissionLevel) {
            return permissionLevel !== 'no-access';
        },
        
        /**
         * ‚úÖ GOLDEN RULE #7: Show auth prompt safely without duplicates
         * @param {string} action - Auth action to perform
         * @param {Object} documentInfo - Document context
         */
        async showAuthPromptSafely(action, documentInfo) {
            // Prevent duplicate modals
            if (this.authModalActive) {
                console.log('‚è≠Ô∏è Skipping auth prompt - modal already active', {
                    currentAction: action,
                    timestamp: new Date().toISOString()
                });
                return;
            }
            
            this.authModalActive = true;
            try {
                if (this.authBridgeInstance) {
                    await this.authBridgeInstance.showAuthPrompt(action, documentInfo);
                }
            } finally {
                // Always clear the flag, even if there was an error
                this.authModalActive = false;
            }
        },

        /**
         * ‚úÖ UNIFIED HELPER: Check if permission level is owner
         * @param {string} permissionLevel - Permission level to check
         * @returns {boolean} true if owner permission
         */
        isOwnerPermission(permissionLevel) {
            return this.permissionService.isOwnerPermission(permissionLevel);
        },

        /**
         * ‚úÖ UNIFIED HELPER: Check if permission level is read-only or worse
         * @param {string} permissionLevel - Permission level to check
         * @returns {boolean} true if readonly, no-access, or unknown
         */
        isReadOnlyOrWorse(permissionLevel) {
            return this.permissionService.isReadOnlyOrWorse(permissionLevel);
        },

        /**
         * ‚úÖ UNIFIED HELPER: Check if permission level is readonly
         * @param {string} permissionLevel - Permission level to check
         * @returns {boolean} true if readonly permission
         */
        isReadonlyPermission(permissionLevel) {
            return this.permissionService.isReadonlyPermission(permissionLevel);
        },

        /**
         * ‚úÖ UNIFIED HELPER: Check if permission level is view-only (readonly or no-access)
         * @param {string} permissionLevel - Permission level to check
         * @returns {boolean} true if view-only permission
         */
        isViewOnlyPermission(permissionLevel) {
            return this.permissionService.isViewOnlyPermission(permissionLevel);
        },

        /**
         * ‚úÖ UNIFIED HELPER: Check if permission level allows publishing
         * @param {string} permissionLevel - Permission level to check
         * @returns {boolean} true if can publish to blockchain
         */
        canPublishWithPermission(permissionLevel) {
            return this.permissionService.canPublishWithPermission(permissionLevel);
        },

        /**
         * ‚úÖ UNIFIED HELPER: Parse access type string to permission level
         * @param {string} accessType - Access type string (various formats)
         * @returns {string|null} Normalized permission level or null
         */
        parseAccessTypeToPermission(accessType) {
            if (!accessType) return null;

            const normalized = accessType.toLowerCase();

            // Check for postable permission variants
            if (normalized === 'postable' || normalized === 'publisher' || normalized === 'post') {
                return 'postable';
            }

            // Check for editable permission variants
            if (normalized === 'editable' || normalized === 'editor' || normalized === 'edit' ||
                normalized.includes('edit') || normalized.includes('write')) {
                return 'editable';
            }

            // Check for readonly permission variants
            if (normalized === 'readonly' || normalized === 'read' || normalized === 'viewer' ||
                normalized.includes('read')) {
                return 'readonly';
            }

            // Check for owner permission
            if (normalized === 'owner') {
                return 'owner';
            }

            // Check for no-access
            if (normalized === 'no-access' || normalized === 'none' || normalized === 'denied') {
                return 'no-access';
            }

            return null;
        },

        /**
         * ‚úÖ UNIFIED HELPER: Get default permission level for fallback scenarios
         * @returns {string} Default permission level
         */
        getDefaultPermissionLevel() {
            return 'readonly';
        },

        /**
         * ‚úÖ UNIFIED HELPER: Get no-access permission level
         * @returns {string} No-access permission level
         */
        getNoAccessPermissionLevel() {
            return 'no-access';
        },

        /**
         * ‚úÖ UNIFIED HELPER: Check if permission level is view-only (readonly or no-access)
         * @param {string} permissionLevel - Permission level to check
         * @returns {boolean} true if readonly or no-access
         */
        isViewOnlyPermission(permissionLevel) {
            return this.permissionService.isViewOnlyPermission(permissionLevel);
        },

        /**
         * ‚úÖ UNIFIED HELPER: Check if permission level allows publishing
         * @param {string} permissionLevel - Permission level to check
         * @returns {boolean} true if postable or owner
         */
        canPublishWithPermission(permissionLevel) {
            return this.permissionService.canPublishWithPermission(permissionLevel);
        },

        /**
         * ‚úÖ UNIFIED HELPER: Check if permission level is readonly
         * @param {string} permissionLevel - Permission level to check
         * @returns {boolean} true if readonly
         */
        isReadonlyPermission(permissionLevel) {
            return this.permissionService.isReadonlyPermission(permissionLevel);
        },

        /**
         * ‚úÖ UNIFIED HELPER: Valid permission levels constant
         * @returns {Array<string>} Array of valid permission levels
         */
        getValidPermissionLevels() {
            return ['owner', 'postable', 'editable', 'readonly', 'no-access'];
        },

        /**
         * ‚úÖ UNIFIED HELPER: Normalize access type strings to permission levels
         * @param {string} accessType - Access type string to normalize
         * @returns {string} Normalized permission level
         */
        normalizeAccessType(accessType) {
            if (!accessType) return 'unknown';

            const normalized = accessType.toLowerCase().trim();

            // Check for owner permission
            if (normalized === 'owner' || normalized === 'admin') {
                return 'owner';
            }

            // Check for postable permission variants
            if (normalized === 'postable' || normalized === 'publisher' || normalized === 'post' ||
                normalized.includes('publish')) {
                return 'postable';
            }

            // Check for editable permission variants
            if (normalized === 'editable' || normalized === 'editor' || normalized === 'edit' ||
                normalized.includes('edit') || normalized.includes('write')) {
                return 'editable';
            }

            // Check for readonly permission variants
            if (normalized === 'readonly' || normalized === 'read' || normalized === 'viewer' ||
                normalized.includes('read')) {
                return 'readonly';
            }

            // Check for no-access
            if (normalized === 'no-access' || normalized === 'none' || normalized === 'denied') {
                return 'no-access';
            }

            return 'unknown';
        },

        // ‚úÖ TIPTAP SECURITY: Debounced permission validation to prevent cascading checks
        debouncedPermissionValidation() {
            if (this.permissionValidationTimeout) {
                cancelAnimationFrame(this.permissionValidationTimeout);
            }

            // ‚úÖ ARCHITECTURE RULE 6: Replace setTimeout with requestAnimationFrame
            const startTime = Date.now();
            const delay = 250; // 250ms debounce
            
            if (this.permissionValidationTimeout) {
                cancelAnimationFrame(this.permissionValidationTimeout);
            }
            
            const checkAndValidate = () => {
                if (Date.now() - startTime >= delay) {
                    // Execute the validation
                    (async () => {
                        const now = Date.now();

                        // Prevent excessive permission checks
                        if (now - this.lastPermissionCheck < 1000) { // 1 second minimum
                            return;
                        }

                        this.permissionTimestamps.lastCheck = now;

                        if (this.currentFile) {

                            const permission = await this.getMasterPermissionForDocument(this.currentFile, true);

                            if (permission.level === 'no-access') {
                                console.warn('üö´ TipTap Security: Debounced validation found no-access');
                                await this.handleDocumentAccessDenied();
                            }
                        }
                    })();
                } else {
                    this.permissionValidationTimeout = requestAnimationFrame(checkAndValidate);
                }
            };
            
            this.permissionValidationTimeout = requestAnimationFrame(checkAndValidate);
        },

        // ‚úÖ TIPTAP.DEV RESILIENCE: Background document link validation
        scheduleDocumentLinkValidation(localFile) {
            // Use Vue's nextTick to avoid blocking the computed property
            this.$nextTick(async () => {
                try {
                    const linkValid = await this.validateDocumentLink(localFile);
                    if (!linkValid) {
                        console.warn('üîß Broken link detected, attempting repair...', localFile.id);
                        await this.repairBrokenDocumentLink(localFile);
                        // ‚úÖ Document repair updates reactive state automatically
                    }
                } catch (error) {
                    console.error('‚ùå Background link validation failed:', error);
                }
            });
        },

        // ‚úÖ RESILIENCE: Validate that linked documents actually exist
        async validateDocumentLink(localFile) {
            try {
                if (!localFile.collaborativeOwner || !localFile.collaborativePermlink) {
                    return false;
                }

                const cloudDocumentId = `${localFile.collaborativeOwner}/${localFile.collaborativePermlink}`;

                // ‚úÖ Check if cloud IndexedDB document exists
                const cloudExists = await this.checkDocumentExistsInIndexedDB(cloudDocumentId);

                // ‚úÖ Check if collaborative document exists in server list
                const serverExists = this.collaborativeDocs.some(doc =>
                    doc.owner === localFile.collaborativeOwner &&
                    doc.permlink === localFile.collaborativePermlink
                );

                const isValid = cloudExists || serverExists;

                return isValid;

            } catch (error) {
                console.error('‚ùå Link validation error:', error);
                return false;
            }
        },

        // ‚úÖ RESILIENCE: Repair broken document links
        async repairBrokenDocumentLink(localFile) {
            try {

                // ‚úÖ Option 1: Try to find the collaborative document by name
                const matchingCloudDoc = this.collaborativeDocs.find(doc =>
                    doc.documentName === localFile.name ||
                    doc.permlink === localFile.name.toLowerCase().replace(/[^a-z0-9]/g, '-')
                );

                if (matchingCloudDoc) {
                    await this.linkLocalDocumentToCloud(localFile, matchingCloudDoc);

                    return true;
                }

                // ‚úÖ Option 2: Clear broken link metadata to prevent duplicates
                const clearMetadata = {
                    collaborativeOwner: null,
                    collaborativePermlink: null,
                    convertedToCollaborative: false,
                    collaborativeConvertedAt: null,
                    originalLocalId: null,
                    cloudDocumentId: null
                };

                const success = await this.atomicUpdateLocalFileMetadata(localFile.id, clearMetadata);

                if (success) {

                    return true;
                } else {
                    console.error('‚ùå Failed to clear broken link metadata');
                    return false;
                }

            } catch (error) {
                console.error('‚ùå Failed to repair broken document link:', error);
                return false;
            }
        }
    },

    // ==================== HTML TEMPLATE ====================
    template: `
    <div class="tiptap-editor-modular w-100 mb-auto">
        <!-- ==================== TOP TOOLBAR ==================== -->
        <div class="d-flex rounded-top bg-dark mb-3 px-2 py-1 justify-content-between align-items-center">
          <!-- File Menu -->
          <div class="btn-group me-3">
            <button class="btn btn-primary bg-card dropdown-toggle no-caret" data-bs-toggle="dropdown">
                  <i class="fas fa-fw fa-file me-1"></i>File
            </button>
            <ul class="dropdown-menu bg-dark">
              <li><a class="dropdown-item" href="#" @click="newDocument()">
                <i class="fas fa-fw fa-plus me-2"></i>New
              </a></li>
              <li><a class="dropdown-item" href="#" @click="openLoadModal()">
                <i class="fas fa-fw fa-folder-open me-2"></i>Open
              </a></li>
              <li v-if="currentFile"><a class="dropdown-item" href="#" @click="canDuplicate && duplicateDocument()" 
                                    :class="{ disabled: !canDuplicate }"
                                    :title="canDuplicate ? 'Create a copy of this document' : 'Document must be saved before it can be duplicated'">
                <i class="fas fa-fw fa-copy me-2"></i>Duplicate
              </a></li>
                <li><hr class="dropdown-divider"></li>
                <li v-if="currentFile?.type !== 'collaborative'">
                         <a class="dropdown-item" href="#" @click.prevent="convertToCollaborative">
                             <i class="fas fa-cloud-upload me-2"></i>Cloud Collaboration
                             <small v-if="!isAuthenticated" class="d-block text-muted">Authentication required</small>
                         </a>
                     </li>
              <li v-if="canShare"><a class="dropdown-item" href="#" @click="shareDocument()">
                <i class="fas fa-fw fa-user-plus me-2"></i>Share
              </a></li>
                <li><a class="dropdown-item" href="#" @click="showJsonPreview()">
                        <i class="fas fa-fw fa-code me-2"></i>Preview JSON
                    </a></li>
                    <li><hr class="dropdown-divider"></li>
                    <li><a class="dropdown-item" href="#" @click="exportAsMarkdown()">
                <i class="fas fa-fw fa-file-text me-2"></i>Export Markdown
              </a></li> 
              <li><a class="dropdown-item" href="#" @click.prevent="canPublish && publishDocument()" 
                     :class="{ disabled: !canPublish }">
                <i class="fas fa-fw fa-paper-plane me-2"></i>Publish to Hive
              </a></li>
              <li v-if="isOwner"><hr class="dropdown-divider"></li>
              <li v-if="isOwner"><a class="dropdown-item" href="#" @click="deleteDocument()">
                <i class="fas fa-fw fa-trash me-2"></i>Delete
              </a></li>
            </ul>
          </div>

          <!-- Test Button: Clear Auth Headers -->
          <button v-if="isAuthenticated && currentFile?.type === 'collaborative'" 
                  @click="clearAuthHeadersForTesting" 
                  class="d-none btn btn-warning btn-sm me-2"
                  title="Clear auth headers for testing offline cache">
            <i class="fas fa-user-slash me-1"></i>Clear Auth
          </button>

          <!-- Document Status & Name -->
         
            <div class="d-flex align-items-center flex-grow-1 gap-1">

            <!-- Permission indicator -->
            <div class="d-none">
                <span v-if="currentFile?.type === 'collaborative'" class="ms-2">
                  <span v-if="isReadOnlyMode" class="badge bg-warning text-dark">
                    <i class="fas fa-eye"></i>Read-Only
                  </span>
                  <span v-else class="badge bg-success">
                    <i class="fas fa-edit"></i>Editable
                  </span>
                </span>
                </div>
          
                <!-- Document Name Display/Edit -->
                <span class="fs-4" v-if="!isEditingDocumentName">
                  <span v-if="currentFile" 
                        @click="isReadOnlyMode ? null : startEditingDocumentName()" 
                        :class="isReadOnlyMode ? '' : 'cursor-pointer'"
                        :title="isReadOnlyMode ? 'Read-only users cannot edit document name' : 'Click to edit document name'">
                    {{ displayDocumentName }}
                  </span>
                  <span v-else 
                        @click="isReadOnlyMode ? null : startEditingDocumentName()" 
                        :class="isReadOnlyMode ? '' : 'cursor-pointer'"
                        :title="isReadOnlyMode ? 'Read-only users cannot edit document name' : 'Click to edit document name'">
                    Untitled - {{ new Date().toLocaleDateString() }}
                  </span>
                </span>
                
                <!-- Document Name Input Field -->
                <span v-else class="d-inline-flex align-items-center">
                  <input 
                    ref="documentNameInput"
                    v-model="documentNameInput" 
                    @keydown="handleDocumentNameKeydown"
                    @blur="saveDocumentName"
                    class="form-control form-control-sm d-inline-block me-2" 
                    style="width: 200px;"
                    placeholder="Enter document name..."
                    :disabled="isReadOnlyMode"
                  />
                  <button @click="saveDocumentName" class="btn btn-sm btn-success me-1" title="Save name">
                    <i class="fas fa-check"></i>
                  </button>
                  <button @click="cancelDocumentNameEdit" class="btn btn-sm btn-secondary" title="Cancel">
                    <i class="fas fa-times"></i>
                  </button>
                </span>
                
                <!-- Save Status Indicator (only show after persistence) -->
                <div v-if="saveStatus.visible" class="ms-2 save-indicator d-flex align-items-center" style="width: 250px;">
                <!-- Icon with popover trigger -->
                <span class="save-icon position-relative" 
                    @click="showSavePopover = !showSavePopover"
                    style="cursor: pointer;">
                    <i :class="saveStatus.icon"></i>
                    
                    <!-- Popover with details -->
                    <div v-if="showSavePopover" 
                        class="save-popover position-absolute bg-dark text-white p-3 rounded shadow"
                        style="bottom: 100%; right: 0; margin-bottom: 10px; min-width: 250px; z-index: 1000;">
                        <div class="d-flex justify-content-between align-items-start mb-2">
                            <h6 class="mb-0">Save Status</h6>
                            <button @click="showSavePopover = false" class="btn-close btn-close-white btn-sm"></button>
                        </div>
                        <div class="small">
                            <div class="mb-2">
                                <strong>Current:</strong> {{ saveStatus.message }}
                            </div>
                            <div class="mb-2" v-if="cloudConnectionStatus.state !== 'non-collaborative'">
                                <strong>Cloud:</strong> {{ cloudConnectionStatus.message }}
                            </div>
                            <div v-if="currentFile">
                                <strong>Document:</strong> {{ currentFile.name || 'Untitled' }}
                            </div>
                        </div>
                    </div>
                </span>
                
                <!-- Message (can fade or persist) -->
                <transition name="fade">
                    <span v-if="saveMessageVisible" 
                        :class="'ms-2 small ' + saveStatus.class">
                        {{ saveMessageText }}
                    </span>
                </transition>
                </div>
       
             </div>
          <!--Collaborative Indicators -->
            <div class="d-flex align-items-center ms-1">
                <div v-if="currentFile?.type === 'collaborative'" class="d-flex align-items-center gap-1 mx-1">
                    
                    <!-- Current User -->
                    <div class="position-relative">
                        <img :src="avatarUrl"
                            :alt="username"
                            class="user-avatar-small rounded-circle cursor-pointer"
                            :title="'You (' + username + ') - Click to change color'"
                            @click="toggleColorPicker"
                            @error="handleAvatarError($event, {name: username, color: getUserColor})"
                            :style="{
                                width: '24px',
                                height: '24px',
                                objectFit: 'cover',
                                border: '2px solid ' + getUserColor,
                                boxShadow: '0 0 0 1px rgba(255,255,255,0.2)'
                            }">

                        <!-- Color picker dropdown -->
                        <div v-if="showColorPicker"
                            class="box-shadow-1 position-absolute bg-dark border border-secondary rounded p-2 shadow-lg"
                            style="top: 30px; right: 0; z-index: 1000; width: 200px;">
                            <div class="mb-2">
                                <small class="text-white fw-bold">Choose your cursor color:</small>
                            </div>
                            <div class="d-flex flex-wrap gap-1 mb-2">
                                <div v-for="(color, index) in ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e']"
                                    :key="index" @click="updateUserColor(color)"
                                    class="color-swatch cursor-pointer rounded"
                                    :style="{backgroundColor: color, width: '20px', height: '20px', border: color === getUserColor ? '2px solid white' : '1px solid #ccc' }"
                                    :title="color">
                                </div>
                            </div>
                            <div class="d-flex gap-1 mb-2">
                                <input type="color" :value="getUserColor" @input="updateUserColor($event.target.value)"
                                    class="form-control form-control-sm flex-grow-1" style="height: 25px;">
                                <button @click="updateUserColor(getRandomColor())" class="btn btn-sm btn-outline-light"
                                    title="Random color">
                                    <i class="fas fa-random fa-xs"></i>
                                </button>
                            </div>
                            <button @click="showColorPicker = false" class="btn btn-sm btn-secondary w-100">
                                Done
                            </button>
                        </div>
                    </div>

                    <!--Other Connected Users-->
                    <div v-for="user in connectedUsers.filter(u => u.id !== (provider && provider.awareness ? provider.awareness.clientID : null)).slice(0, 3)" :key="user.id"
                        class="position-relative">
                        <img :src="'https://images.hive.blog/u/' + user.name + '/avatar/small'" :alt="user.name"
                            class="user-avatar-small rounded-circle" :title="user.name + ' (ID: ' + user.id + ')'"
                            @error="handleAvatarError($event, user)" :style="{ 
                                        width: '24px', 
                                        height: '24px', 
                                        objectFit: 'cover',
                                        border: '2px solid ' + user.color,
                                        boxShadow: '0 0 0 1px rgba(255,255,255,0.2)'
                                    }">
                    </div>
                    <span v-if="connectedUsers.filter(u => u.id !== (provider && provider.awareness ? provider.awareness.clientID : null)).length > 3"
                        class="badge bg-light text-dark small">
                        +{{ connectedUsers.filter(u => u.id !== (provider && provider.awareness ? provider.awareness.clientID : null)).length - 3 }}
                    </span>
                    
                    <!-- Add User Button -->
                    <button v-if="canShare" 
                        @click="shareDocument"
                        class="btn btn-sm btn-outline-light rounded-circle d-flex align-items-center justify-content-center"
                        style="width: 24px; height: 24px; padding: 0;"
                        title="Add collaborators">
                        <i class="fas fa-plus" style="font-size: 10px;"></i>
                    </button>
                </div>
     
          <!-- Cloud Status Indicator   -->
          <div class="btn-group ms-2">
            <button class="btn btn-dark no-caret dropdown-toggle" 
                    :style="cloudButtonStyle"
                     data-bs-toggle="dropdown" aria-expanded="false">
              <span v-html="documentTitleIndicator"></span>
              
            </button>

            <ul class="dropdown-menu dropdown-menu-dark dropdown-menu-end bg-dark">
                    
                        <!-- Document Sharing & Collaboration -->
                     <li v-if="canShare"><a class="dropdown-item" href="#" @click.prevent="shareDocument">
                             <i class="fas fa-user-plus me-2"></i>Share Document
                         </a></li>
                    
                    <li><hr class="dropdown-divider"></li>

                    <!-- Document Publishing & Connection -->
                     <li v-if="currentFile?.type !== 'collaborative'">
                         <a class="dropdown-item" href="#" @click.prevent="convertToCollaborative">
                             <i class="fas fa-cloud-upload-alt me-2"></i>Turn On Cloud Collaboration
                             <small v-if="!isAuthenticated" class="d-block text-muted">Authentication required</small>
                         </a>
                     </li>
                     <li v-else-if="currentFile?.type === 'collaborative' && connectionStatus === 'connected'">
                         <a class="dropdown-item" href="#" @click.prevent="disconnectCollaboration(false)">
                             <i class="fas fa-unlink me-2"></i>Disconnect from Cloud
                         </a>
                     </li>
                     <li v-else-if="currentFile?.type === 'collaborative' && (connectionStatus === 'disconnected' || connectionStatus === 'offline' || connectionStatus === 'auth-required' || connectionStatus === 'error' || connectionStatus === 'connecting')">
                         <a class="dropdown-item text-warning" href="#" @click.prevent="reconnectToCollaborativeDocument()">
                             <i class="fas fa-plug me-2"></i>Reconnect to Cloud
                             <small class="d-block text-muted">
                                 <span v-if="connectionStatus === 'auth-required'">Authentication required for cloud sync</span>
                                 <span v-else-if="connectionStatus === 'error'">Connection error - retrying</span>
                                 <span v-else-if="connectionStatus === 'connecting'">Connecting to cloud...</span>
                                 <span v-else>Working offline - changes saved locally</span>
                             </small>
                         </a>
                     </li>
                     
                     <li><hr class=" dropdown-divider"></li>

                     <!-- Authentication Status -->
                     <li v-if="!isAuthenticated || isAuthExpired" class="d-none dropdown-header bg-warning text-dark d-flex align-items-center justify-content-center">
                            <i class="fas fa-key me-1"></i>{{ isAuthExpired ? 'Authentication Expired' : 'Authentication Required' }}
                    </li>
                    <li v-else class="d-none dropdown-header bg-success-50 text-dark d-flex align-items-center justify-content-center">
                            <i class="fas fa-check me-1"></i>Authentication Valid
                    </li>
                    
                    <!-- Authentication Actions -->
                    <li class="" v-if="!isAuthenticated || isAuthExpired">
                        <a class="dropdown-item text-warning fw-bold" href="#" @click.prevent="requestAuthentication({ autoTrigger: true })">
                            <i class="fas fa-key me-2"></i>{{ isAuthExpired ? 'Re-authenticate' : 'Authenticate Now' }}
                        </a>
                    </li>
                    <li v-else>
                        <a class="dropdown-item text-muted" href="#" @click.prevent="requestAuthentication({ forceRefresh: true, autoTrigger: true })">
                            <i class="fas fa-redo me-2"></i>Refresh Authentication
                        </a>
                    </li>                                             
                </ul>
            
            <!-- Status Details Dropdown -->
            <div v-if="showStatusDetails" class="status-details">
              <div class="details-text">{{ unifiedStatusInfo.details }}</div>
              <div class="status-actions">
                <button v-if="!isAuthenticated && currentFile?.type === 'collaborative'" 
                        @click="requestAuthentication()" class="status-action-btn">
                  Authenticate
                </button>
                <button v-if="currentFile?.type === 'local'" 
                        @click="convertToCollaborative" class="status-action-btn">
                  Enable Collaboration
                </button>
                <button v-if="canShare" @click="shareDocument()" class="status-action-btn">
                  Share Document
                </button>
              </div>
            </div>
          </div>
        </div>
        </div>

        <!-- ==================== MAIN EDITOR SECTIONS ==================== -->
        <div class="d-flex flex-column gap-4 mx-2">
          
          <!-- Title Input Section (Single Editor Solution) -->
          <div class="title-section">
            <div class="bg-dark border border-secondary rounded">
              <input 
                v-model="titleInput"
                @input="handleTitleInput"
                type="text" 
                class="form-control bg-dark text-white border-0 mb-0 p-2 fs-4" 
                placeholder="Enter title..." 
                :disabled="isReadOnlyMode"
              />
            </div>
            <!-- Auto-generated permlink display -->
            <div v-if="actualPermlink" class="mt-2">
              <small class="text-muted font-monospace">/@{{ username }}/{{ actualPermlink }}</small>
            </div>
          </div>

          <!-- Body Editor Section -->
          <div class="body-section d-flex flex-column">
            <!-- WYSIWYG Toolbar -->
            <div class="editor-toolbar bg-dark border border-secondary rounded-top" 
                 :class="{ 'opacity-50': isReadOnlyMode }">
              <div class="d-flex flex-wrap gap-1 align-items-center">
                
                <!-- Read-only indicator -->
                <div v-if="isReadOnlyMode" class="small text-muted me-2">
                  <i class="fas fa-eye me-1"></i>Read-only mode
                </div>
                
                <!-- Text Formatting -->
                <div role="group">
                  <button @click="formatBold()" @mousedown.prevent :class="{active: isActive('bold')}" 
                          class="btn btn-sm btn-dark" title="Bold"
                          :disabled="isReadOnlyMode">
                    <i class="fas fa-bold"></i>
                  </button>
                  <button @click="formatItalic()" @mousedown.prevent :class="{active: isActive('italic')}" 
                          class="btn btn-sm btn-dark" title="Italic"
                          :disabled="isReadOnlyMode">
                    <i class="fas fa-italic"></i>
                  </button>
                  <button @click="formatStrike()" @mousedown.prevent :class="{active: isActive('strike')}" 
                          class="btn btn-sm btn-dark" title="Strikethrough"
                          :disabled="isReadOnlyMode">
                    <i class="fas fa-strikethrough"></i>
                  </button>
                  <button @click="formatUnderline()" @mousedown.prevent :class="{active: isActive('underline')}" 
                          class="btn btn-sm btn-dark" title="Underline"
                          :disabled="isReadOnlyMode">
                    <i class="fas fa-underline"></i>
                  </button>
                  <button @click="formatCode()" @mousedown.prevent :class="{active: isActive('code')}" 
                          class="btn btn-sm btn-dark" title="Inline Code"
                          :disabled="isReadOnlyMode">
                    <i class="fas fa-code"></i>
                  </button>
                  <button @click="formatSubscript()" @mousedown.prevent :class="{active: isActive('subscript')}" 
                          class="btn btn-sm btn-dark" title="Subscript"
                          :disabled="isReadOnlyMode">
                    <i class="fas fa-subscript"></i>
                  </button>
                  <button @click="formatSuperscript()" @mousedown.prevent :class="{active: isActive('superscript')}" 
                          class="btn btn-sm btn-dark" title="Superscript"
                          :disabled="isReadOnlyMode">
                    <i class="fas fa-superscript"></i>
                  </button>
                  <button @click="insertLink()" class="btn btn-sm btn-dark" title="Insert Link"
                          :disabled="isReadOnlyMode">
                    <i class="fas fa-link"></i>
                  </button>
                </div>

                <div class="vr"></div>

                <!-- Text Alignment -->
                <div role="group">
                  <button @click="setTextAlign('left')" @mousedown.prevent :class="{active: isActive({textAlign: 'left'})}" 
                          class="btn btn-sm btn-dark" title="Align Left"
                          :disabled="isReadOnlyMode || !canUseTextAlign">
                    <i class="fas fa-align-left"></i>
                  </button>
                  <button @click="setTextAlign('center')" @mousedown.prevent :class="{active: isActive({textAlign: 'center'})}" 
                          class="btn btn-sm btn-dark" title="Align Center"
                          :disabled="isReadOnlyMode || !canUseTextAlign">
                    <i class="fas fa-align-center"></i>
                  </button>
                  <button @click="setTextAlign('right')" @mousedown.prevent :class="{active: isActive({textAlign: 'right'})}" 
                          class="btn btn-sm btn-dark" title="Align Right"
                          :disabled="isReadOnlyMode || !canUseTextAlign">
                    <i class="fas fa-align-right"></i>
                  </button>
                  <button @click="setTextAlign('justify')" @mousedown.prevent :class="{active: isActive({textAlign: 'justify'})}" 
                          class="btn btn-sm btn-dark" title="Justify"
                          :disabled="isReadOnlyMode || !canUseTextAlign">
                    <i class="fas fa-align-justify"></i>
                  </button>
                </div>

                <div class="vr"></div>

                <!-- Text Format Dropdown -->
                <div class="btn-group">
                  <button type="button" class="btn btn-sm btn-dark dropdown-toggle" 
                          data-bs-toggle="dropdown" aria-expanded="false"
                          :disabled="isReadOnlyMode || isInTable">
                    {{ currentTextFormat }}
                  </button>
                  <ul class="dropdown-menu dropdown-menu-dark">
                    <li><a class="dropdown-item" href="#" @click.prevent="setParagraph()" @mousedown.prevent
                           :class="{ active: isActive('paragraph') }">
                      <i class="fas fa-paragraph me-2"></i>Paragraph
                    </a></li>
                    <li><hr class="dropdown-divider"></li>
                    <li><a class="dropdown-item" href="#" @click.prevent="setHeading(1)" @mousedown.prevent
                           :class="{ active: isActive('heading', {level: 1}) }">
                      <span class="fw-bold">H1</span> - Heading 1
                    </a></li>
                    <li><a class="dropdown-item" href="#" @click.prevent="setHeading(2)" @mousedown.prevent
                           :class="{ active: isActive('heading', {level: 2}) }">
                      <span class="fw-bold">H2</span> - Heading 2
                    </a></li>
                    <li><a class="dropdown-item" href="#" @click.prevent="setHeading(3)" @mousedown.prevent
                           :class="{ active: isActive('heading', {level: 3}) }">
                      <span class="fw-bold">H3</span> - Heading 3
                    </a></li>
                    <li><a class="dropdown-item" href="#" @click.prevent="setHeading(4)" @mousedown.prevent
                           :class="{ active: isActive('heading', {level: 4}) }">
                      <span class="fw-bold">H4</span> - Heading 4
                    </a></li>
                    <li><a class="dropdown-item" href="#" @click.prevent="setHeading(5)" @mousedown.prevent
                           :class="{ active: isActive('heading', {level: 5}) }">
                      <span class="fw-bold">H5</span> - Heading 5
                    </a></li>
                    <li><a class="dropdown-item" href="#" @click.prevent="setHeading(6)" @mousedown.prevent
                           :class="{ active: isActive('heading', {level: 6}) }">
                      <span class="fw-bold">H6</span> - Heading 6
                    </a></li>
                  </ul>
                </div>

                <div class="vr"></div>

                <!-- Lists -->
                <div role="group">
                  <button @click="toggleBulletList()" @mousedown.prevent :class="{active: isActive('bulletList')}" 
                          class="btn btn-sm btn-dark" title="Bullet List"
                          :disabled="isReadOnlyMode || isInTable">
                    <i class="fas fa-list-ul"></i>
                  </button>
                  <button @click="toggleOrderedList()" @mousedown.prevent :class="{active: isActive('orderedList')}" 
                          class="btn btn-sm btn-dark" title="Numbered List"
                          :disabled="isReadOnlyMode || isInTable">
                    <i class="fas fa-list-ol"></i>
                  </button>
                </div>

                <div class="vr"></div>

                <!-- Block Elements -->
                <div role="group">
                  <button @click="setBlockquote()" @mousedown.prevent :class="{active: isActive('blockquote')}" 
                          class="btn btn-sm btn-dark" title="Quote"
                          :disabled="isReadOnlyMode || isInTable">
                    <i class="fas fa-quote-left"></i>
                  </button>
                  <button @click="toggleCodeBlock()" @mousedown.prevent :class="{active: isActive('codeBlock')}" 
                          class="btn btn-sm btn-dark" title="Code Block"
                          :disabled="isReadOnlyMode || isInTable">
                    <i class="fas fa-terminal"></i>
                  </button>
                  <button @click="insertHorizontalRule()" @mousedown.prevent class="btn btn-sm btn-dark" title="Horizontal Rule"
                          :disabled="isReadOnlyMode || isInTable">
                    <i class="fas fa-minus"></i>
                  </button>
                </div>
                <button @click="insertTable()" class="btn btn-sm btn-dark" 
                          :title="isInTable ? 'Cannot insert table inside another table' : 'Insert Table'"
                          :disabled="isReadOnlyMode || isInTable">
                    <i class="fas fa-table"></i>
                </button>
                <div class="vr"></div>

                <!-- Insert Tools -->
                <div role="group">
                  <button @click="insertImage()" class="btn btn-sm btn-dark" title="Insert Image"
                          :disabled="isReadOnlyMode">
                    <i class="fas fa-image"></i>
                  </button>
                  <button @click="insertVideo()" class="btn btn-sm btn-dark" title="Insert Video"
                          :disabled="isReadOnlyMode">
                    <i class="fas fa-video"></i>
                  </button>
                 
                </div>
              </div>
            </div>

            <!-- Floating Menu for empty lines -->
            <div ref="floatingMenu" class="floating-menu">
              <div class="dropdown">
                <button type="button" 
                        class="btn btn-sm btn-secondary dropdown-toggle"
                        data-bs-toggle="dropdown"
                        aria-expanded="false"
                        :disabled="isReadOnlyMode">
                  <i class="fas fa-plus fa-fw"></i>
                </button>
                <ul class="dropdown-menu dropdown-menu-dark bg-dark">
                  <!-- Text -->
                  <li v-if="!isInTable">
                    <a class="dropdown-item" href="#">
                      <i class="fas fa-font me-2"></i>Text &raquo;
                    </a>
                    <div class="dropdown-submenu-horizontal">
                      <div class="btn-group">
                        <button type="button" class="btn btn-sm btn-dark" @click.prevent="setParagraph()" @mousedown.prevent title="Paragraph">
                          <i class="fas fa-paragraph"></i>
                        </button>
                        <button type="button" class="btn btn-sm btn-dark" @click.prevent="setHeading(1)" @mousedown.prevent title="Heading 1">
                          H1
                        </button>
                        <button type="button" class="btn btn-sm btn-dark" @click.prevent="setHeading(2)" @mousedown.prevent title="Heading 2">
                          H2
                        </button>
                        <button type="button" class="btn btn-sm btn-dark" @click.prevent="setHeading(3)" @mousedown.prevent title="Heading 3">
                          H3
                        </button>
                        <button type="button" class="btn btn-sm btn-dark" @click.prevent="setHeading(4)" @mousedown.prevent title="Heading 4">
                          H4
                        </button>
                        <button type="button" class="btn btn-sm btn-dark" @click.prevent="setHeading(5)" @mousedown.prevent title="Heading 5">
                          H5
                        </button>
                        <button type="button" class="btn btn-sm btn-dark" @click.prevent="setHeading(6)" @mousedown.prevent title="Heading 6">
                          H6
                        </button>
                      </div>
                    </div>
                  </li>
                  
                  <!-- Lists -->
                  <li v-if="!isInTable">
                    <a class="dropdown-item" href="#">
                      <i class="fas fa-list me-2"></i>Lists &raquo;
                    </a>
                    <div class="dropdown-submenu-horizontal">
                      <div class="btn-group">
                        <button type="button" class="btn btn-sm btn-dark" @click.prevent="toggleBulletList()" @mousedown.prevent title="Bullet List">
                          <i class="fas fa-list-ul"></i>
                        </button>
                        <button type="button" class="btn btn-sm btn-dark" @click.prevent="toggleOrderedList()" @mousedown.prevent title="Numbered List">
                          <i class="fas fa-list-ol"></i>
                        </button>
                      </div>
                    </div>
                  </li>
                  
                  <!-- Blocks -->
                  <li v-if="!isInTable">
                    <a class="dropdown-item" href="#">
                      <i class="fas fa-th-large me-2"></i>Blocks &raquo;
                    </a>
                    <div class="dropdown-submenu-horizontal">
                      <div class="btn-group">
                        <button type="button" class="btn btn-sm btn-dark" @click.prevent="setBlockquote()" @mousedown.prevent title="Blockquote">
                          <i class="fas fa-quote-left"></i>
                        </button>
                        <button type="button" class="btn btn-sm btn-dark" @click.prevent="toggleCodeBlock()" @mousedown.prevent title="Code Block">
                          <i class="fas fa-code"></i>
                        </button>
                        <button type="button" class="btn btn-sm btn-dark" @click.prevent="insertHorizontalRule()" @mousedown.prevent title="Horizontal Rule">
                          <i class="fas fa-minus"></i>
                        </button>
                        <button type="button" class="btn btn-sm btn-dark" @click.prevent="insertTable()" @mousedown.prevent 
                                title="Table" :disabled="isInTable">
                          <i class="fas fa-table"></i>
                        </button>
                      </div>
                    </div>
                  </li>
                  
                  <!-- Media -->
                  <li>
                    <a class="dropdown-item" href="#">
                      <i class="fas fa-photo-video me-2"></i>Media &raquo;
                    </a>
                    <div class="dropdown-submenu-horizontal">
                      <div class="btn-group">
                        <button type="button" class="btn btn-sm btn-dark" @click.prevent="insertImage()" @mousedown.prevent title="Image">
                          <i class="fas fa-image"></i>
                        </button>
                        <button type="button" class="btn btn-sm btn-dark" @click.prevent="insertVideo()" @mousedown.prevent title="Video">
                          <i class="fas fa-video"></i>
                        </button>
                      </div>
                    </div>
                  </li>
                </ul>
                
              </div>
            </div>
            
            <!-- Body Editor -->
            <div class="editor-field-body bg-dark border border-secondary border-top-0 rounded-bottom">
              <div ref="bodyEditor" class="tiptap-editor-content"></div>
            </div>
            
            <!-- Bubble Menu (floating toolbar) - Always in DOM for TipTap reference -->
            <div ref="bubbleMenu" class="bubble-menu justify-content-center">
              
            <div class="btn-group" role="group">
                <button type="button" 
                        class="btn btn-sm btn-secondary"
                        :class="{ 'active': bodyEditor && bodyEditor.isActive('subscript') }"
                        @click="formatSubscript()"
                        @mousedown.prevent
                        :disabled="!bodyEditor"
                        title="Subscript">
                  <i class="fas fa-subscript"></i>
                </button>
                
                <button type="button" 
                        class="btn btn-sm btn-secondary"
                        :class="{ 'active': bodyEditor && bodyEditor.isActive('superscript') }"
                        @click="formatSuperscript()"
                        @mousedown.prevent
                        :disabled="!bodyEditor"
                        title="Superscript">
                  <i class="fas fa-superscript"></i>
                </button>
                
              </div>
              
              <!-- Alignment buttons -->
              <div class="btn-group ms-1" role="group">
                <button type="button"
                        class="btn btn-sm btn-secondary"
                        :class="{active: isActive({textAlign: 'left'})}"
                        @click="setTextAlign('left')"
                        @mousedown.prevent
                        :disabled="!bodyEditor || isReadOnlyMode || !canUseTextAlign"
                        title="Align Left">
                  <i class="fas fa-align-left"></i>
                </button>
                <button type="button"
                        class="btn btn-sm btn-secondary"
                        :class="{active: isActive({textAlign: 'center'})}"
                        @click="setTextAlign('center')"
                        @mousedown.prevent
                        :disabled="!bodyEditor || isReadOnlyMode || !canUseTextAlign"
                        title="Align Center">
                  <i class="fas fa-align-center"></i>
                </button>
                <button type="button"
                        class="btn btn-sm btn-secondary"
                        :class="{active: isActive({textAlign: 'right'})}"
                        @click="setTextAlign('right')"
                        @mousedown.prevent
                        :disabled="!bodyEditor || isReadOnlyMode || !canUseTextAlign"
                        title="Align Right">
                  <i class="fas fa-align-right"></i>
                </button>
                <button type="button"
                        class="btn btn-sm btn-secondary"
                        :class="{active: isActive({textAlign: 'justify'})}"
                        @click="setTextAlign('justify')"
                        @mousedown.prevent
                        :disabled="!bodyEditor || isReadOnlyMode || !canUseTextAlign"
                        title="Justify">
                  <i class="fas fa-align-justify"></i>
                </button>
              </div>

              <div class="btn-group" role="group">
                <button type="button" 
                        class="btn btn-sm btn-secondary"
                        :class="{ 'active': bodyEditor && bodyEditor.isActive('bold') }"
                        @click="formatBold()"
                        @mousedown.prevent
                        :disabled="!bodyEditor"
                        title="Bold">
                  <i class="fas fa-bold"></i>
                </button>
                <button type="button" 
                        class="btn btn-sm btn-secondary"
                        :class="{ 'active': bodyEditor && bodyEditor.isActive('italic') }"
                        @click="formatItalic()"
                        @mousedown.prevent
                        :disabled="!bodyEditor"
                        title="Italic">
                  <i class="fas fa-italic"></i>
                </button>
                <button type="button" 
                        class="btn btn-sm btn-secondary"
                        :class="{ 'active': bodyEditor && bodyEditor.isActive('strike') }"
                        @click="formatStrike()"
                        @mousedown.prevent
                        :disabled="!bodyEditor"
                        title="Strikethrough">
                  <i class="fas fa-strikethrough"></i>
                </button>
                <button type="button" 
                        class="btn btn-sm btn-secondary"
                        :class="{ 'active': bodyEditor && bodyEditor.isActive('underline') }"
                        @click="formatUnderline()"
                        @mousedown.prevent
                        :disabled="!bodyEditor"
                        title="Underline">
                  <i class="fas fa-underline"></i>
                </button>
                <button type="button" 
                        class="btn btn-sm btn-secondary"
                        :class="{ 'active': bodyEditor && bodyEditor.isActive('code') }"
                        @click="formatCode()"
                        @mousedown.prevent
                        :disabled="!bodyEditor"
                        title="Inline Code">
                  <i class="fas fa-code"></i>
                </button>
                <button type="button" 
                        class="btn btn-sm btn-secondary"
                        :class="{ 'active': bodyEditor && bodyEditor.isActive('link') }"
                        @click="insertLink()"
                        @mousedown.prevent
                        :disabled="!bodyEditor"
                        title="Insert/Edit Link">
                  <i class="fas fa-link"></i>
                </button>
            </div>
            </div>
            
            <!-- Table Toolbar - CSS controls visibility and positioning -->
            <div class="table-toolbar" :class="{ 'table-toolbar-visible': isInTable }">
              <div class="btn-group" role="group">
                <button type="button" 
                        class="btn btn-sm btn-secondary"
                        @click="addTableRowBefore()"
                        :disabled="!bodyEditor || isReadOnlyMode"
                        title="Add row above">
                  <i class="fas fa-plus"></i><i class="fas fa-arrow-up ms-1"></i>
                </button>
                <button type="button" 
                        class="btn btn-sm btn-secondary"
                        @click="addTableRowAfter()"
                        :disabled="!bodyEditor || isReadOnlyMode"
                        title="Add row below">
                  <i class="fas fa-plus"></i><i class="fas fa-arrow-down ms-1"></i>
                </button>
                <button type="button" 
                        class="btn btn-sm btn-secondary"
                        @click="addTableColumnBefore()"
                        :disabled="!bodyEditor || isReadOnlyMode"
                        title="Add column before">
                  <i class="fas fa-plus"></i><i class="fas fa-arrow-left ms-1"></i>
                </button>
                <button type="button" 
                        class="btn btn-sm btn-secondary"
                        @click="addTableColumnAfter()"
                        :disabled="!bodyEditor || isReadOnlyMode"
                        title="Add column after">
                  <i class="fas fa-plus"></i><i class="fas fa-arrow-right ms-1"></i>
                </button>
                <div class="btn-group-divider mx-1"></div>
                <button type="button" 
                        class="btn btn-sm btn-secondary"
                        @click="deleteTableRow()"
                        :disabled="!bodyEditor || isReadOnlyMode"
                        title="Delete row">
                  <i class="fas fa-minus"></i><i class="fas fa-grip-lines ms-1"></i>
                </button>
                <button type="button" 
                        class="btn btn-sm btn-secondary"
                        @click="deleteTableColumn()"
                        :disabled="!bodyEditor || isReadOnlyMode"
                        title="Delete column">
                  <i class="fas fa-minus"></i><i class="fas fa-grip-lines-vertical ms-1"></i>
                </button>
                <div class="btn-group-divider mx-1"></div>
                <button type="button" 
                        class="btn btn-sm btn-danger"
                        @click="deleteTable()"
                        :disabled="!bodyEditor || isReadOnlyMode"
                        title="Delete table">
                  <i class="fas fa-trash"></i>
                </button>
              </div>
            </div>
            
            <small class="text-muted text-center mt-1">Full WYSIWYG editor with markdown export support.</small>
          </div>

          <!-- Tags Section -->
          <div class="tags-section">
            <div class="d-flex flex-wrap align-items-center gap-2">
              <!-- Add tag input -->
              <div class="input-group" style="width: 200px;">
                <input v-model="tagInput" @keydown.enter="addTag"
                       class="form-control bg-dark text-white border-secondary"
                       placeholder="Add a tag..." maxlength="50" 
                       :disabled="displayTags.length >= 10 || isReadOnlyMode">
                <button @click="addTag" class="btn btn-dark border-secondary"
                        :disabled="displayTags.length >= 10 || !tagInput.trim() || isReadOnlyMode">
                  <i class="fas fa-plus"></i>
                </button>
              </div>

              <!-- Current tags -->
              <span v-for="(tag, index) in displayTags" :key="index"
                    class="badge bg-primary d-flex align-items-center">
                {{ tag }}
                <button @click="removeTag(index)" class="btn-close btn-close-white ms-2 small"
                        :disabled="isReadOnlyMode"></button>
              </span>
            </div>
            <small v-if="displayTags.length >= 10" class="text-warning">
              Maximum 10 tags allowed
            </small>
          </div>

          <!-- Advanced Options Collapsible -->
          <div class="advanced-options-section">
            <button class="btn btn-lg py-3 mb-2 btn-secondary d-flex align-items-center w-100"
                    data-bs-toggle="collapse" data-bs-target="#advancedOptions">
              <i class="fas fa-cog me-2"></i>
              Advanced Options
              <i class="fas fa-chevron-down ms-auto"></i>
            </button>

            <div class="collapse mt-3" id="advancedOptions">
              
              <!-- Permlink Editor Section -->
              <div class="permlink-section mb-4">
                <label class="form-label text-white fw-bold">
                  <i class="fas fa-link me-2"></i>URL Slug (Permlink)
                </label>
                <div class="d-flex align-items-center gap-2">
                  <code class="text-info">/@{{ username }}/</code>
                  <div class="flex-grow-1">
                    <div v-if="!showPermlinkEditor" @click="!isReadOnlyMode && togglePermlinkEditor()"
                         class="bg-dark border border-secondary rounded p-2 text-white"
                         :class="{ 'cursor-pointer': !isReadOnlyMode, 'opacity-50': isReadOnlyMode }">
                      {{ actualPermlink || 'Click to edit...' }}
                    </div>
                    <div v-else class="d-flex align-items-center gap-2">
                      <input 
                        ref="permlinkInput"
                        v-model="permlinkInputTemp"
                        @keydown="handlePermlinkKeydown"
                        type="text" 
                        class="form-control bg-dark text-white border-secondary flex-grow-1" 
                        placeholder="Auto-generated from title"
                        :disabled="isReadOnlyMode"
                      />
                      <button @click="savePermlink" class="btn btn-sm btn-success" title="Save permlink">
                        <i class="fas fa-check"></i>
                      </button>
                      <button @click="cancelPermlinkEdit" class="btn btn-sm btn-secondary" title="Cancel">
                        <i class="fas fa-times"></i>
                      </button>
                    </div>
                  </div>
                  <button @click="useGeneratedPermlink" 
                          :disabled="!titleInput || !titleInput.trim() || isReadOnlyMode"
                          class="btn btn-sm btn-outline-secondary"
                          title="Generate URL slug from title">
                    Auto-generate
                  </button>
                </div>
                <small class="text-muted">URL-safe characters only.</small>
              </div>

              <!-- Beneficiaries Section -->
              <div class="beneficiaries-section mb-4">
                <label class="form-label text-white fw-bold">
                  <i class="fas fa-users me-2"></i>Beneficiaries (Reward Sharing)
                </label>
                <div class="bg-dark border border-secondary rounded p-3">
                  <div class="d-flex align-items-center gap-2 mb-2">
                    <input type="text" class="form-control bg-dark text-white border-secondary"
                           placeholder="@username" v-model="beneficiaryInput.account" :disabled="isReadOnlyMode">
                    <input type="number" class="form-control bg-dark text-white border-secondary"
                           placeholder="%" v-model="beneficiaryInput.percent" min="0.01" max="100" step="0.01" :disabled="isReadOnlyMode">
                    <button @click="addBeneficiary()" class="btn btn-outline-success" :disabled="isReadOnlyMode">
                      <i class="fas fa-plus"></i>
                    </button>
                  </div>
                  <div v-if="displayBeneficiaries.length > 0" class="mt-2">
                    <div v-for="(ben, index) in displayBeneficiaries" :key="index"
                         class="d-flex align-items-center justify-content-between bg-secondary rounded p-2 mb-1">
                      <span>
                        <i v-if="ben.required" class="fas fa-lock text-warning me-1" title="Required beneficiary"></i>
                        @{{ ben.account }} - {{ (ben.weight / 100).toFixed(2) }}%
                      </span>
                      <button @click="removeBeneficiary(index)" 
                              class="btn btn-sm btn-outline-danger" 
                              :disabled="isReadOnlyMode || ben.required"
                              :title="ben.required ? 'Cannot remove required beneficiary' : ''">
                        <i class="fas fa-trash"></i>
                      </button>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Custom JSON Section -->
              <div class="custom-json-section mb-4">
                <label class="form-label text-white fw-bold">
                  <i class="fas fa-code me-2"></i>Custom JSON Metadata
                </label>
                <div class="bg-dark border border-secondary rounded p-3">
                  <textarea v-model="customJsonString" @input="handleCustomJsonInput"
                            class="form-control bg-dark text-white border-secondary font-monospace" 
                            rows="6" placeholder="Enter custom JSON metadata..." :disabled="isReadOnlyMode"></textarea>
                  <div v-if="customJsonError" class="text-danger small mt-1">
                    <i class="fas fa-exclamation-triangle me-1"></i>{{ customJsonError }}
                  </div>
                </div>
              </div>

              <!-- Comment Options Section -->
              <div class="comment-options-section mb-2">
                <label class="form-label text-white fw-bold">
                  <i class="fas fa-cog me-2"></i>Comment Options
                </label>
                <div class="bg-dark border border-secondary rounded p-3">
                  <div class="row">
                    <div class="col-md-6">
                      <div class="form-check">
                        <input class="form-check-input" type="checkbox" v-model="reactiveCommentOptions.allowVotes" @change="handleCommentOptionChanged" :disabled="isReadOnlyMode">
                        <label class="form-check-label text-white">Allow votes</label>
                      </div>
                      <div class="form-check">
                        <input class="form-check-input" type="checkbox" v-model="reactiveCommentOptions.allowCurationRewards" @change="handleCommentOptionChanged" :disabled="isReadOnlyMode">
                        <label class="form-check-label text-white">Allow curation rewards</label>
                      </div>
                    </div>
                    <div class="col-md-6">
                      <div class="form-check">
                        <input class="form-check-input" type="checkbox" v-model="reactiveCommentOptions.maxAcceptedPayout" @change="handleCommentOptionChanged" :disabled="isReadOnlyMode">
                        <label class="form-check-label text-white">Decline payout</label>
                      </div>
                      <div class="form-check">
                        <input class="form-check-input" type="checkbox" v-model="reactiveCommentOptions.percentHbd" @change="handleCommentOptionChanged" :disabled="isReadOnlyMode || areRewardsDeclined">
                        <label class="form-check-label text-white">100% Power Up</label>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

            </div>
          </div>
        </div>

        <!-- ==================== MODALS ==================== -->
        <!-- All modals would be teleported to body -->
        <teleport to="body">
          <!-- Load Modal -->
          <div v-if="showLoadModal" class="modal fade show d-block" style="background: rgba(0,0,0,0.5)">
            <div class="modal-dialog modal-dialog-centered modal-lg">
              <div class="modal-content bg-dark text-white">
                <div class="modal-header border-secondary">
                  <h5 class="modal-title">
                    <i class="fas fa-folder-open me-2"></i>Saved Drafts
                    <small v-if="autoRefreshTimer" class="text-muted ms-2">
                      <i class="fas fa-sync-alt fa-spin"></i> Auto-refreshing
                    </small>
                  </h5>
                  <button @click="closeLoadModal()" class="btn-close btn-close-white"></button>
                </div>
                <div class="modal-body p-1">
                  <!-- Auth prompt if needed -->
                  <div v-if="!isAuthenticated || isAuthExpired"
                      class="text-center py-4 border border-secondary rounded mb-3 p-1">
                    <!-- Show processing state if auth is in progress -->
                    <div v-if="isAuthProcessing" class="text-muted mb-2">
                      <i class="fas fa-spinner fa-spin fa-2x mb-2"></i>
                      <p>Authenticating with blockchain...</p>
                      <small class="text-muted">Please sign the transaction in your wallet</small>
                    </div>
                    <!-- Show error state if auth failed -->
                    <div v-else-if="authError" class="text-danger mb-2">
                      <i class="fas fa-exclamation-triangle fa-2x mb-2"></i>
                      <p>Authentication failed</p>
                      <small>{{ authError }}</small>
                      <div class="mt-2">
                        <button @click="authenticateForDocumentList()" class="btn btn-primary btn-sm">
                          <i class="fas fa-redo me-1"></i>Try Again
                        </button>
                      </div>
                    </div>
                    <!-- Show initial auth prompt -->
                    <div v-else class="text-muted mb-2">
                      <i class="fas fa-lock fa-2x mb-2"></i>
                      <p>{{ isAuthExpired ? 'Authentication expired' : 'Authentication required' }}</p>
                      <button @click="authenticateForDocumentList()" class="btn btn-primary btn-sm">
                        <i class="fas fa-key me-1"></i>Authenticate for Collaboration
                      </button>
                    </div>
                  </div>

                  <!-- Table of documents -->
                  <div class="d-flex justify-content-between align-items-center mb-2">
                    <div class="d-flex align-items-center gap-3">
            
                      <button @click="refreshDocumentLists" class="btn btn-sm btn-primary bg-card" 
                          :disabled="loadingDocs" title="Refresh document list">
                        <i class="fas" :class="loadingDocs ? 'fa-spinner fa-spin' : 'fa-sync-alt'"></i>
                        <span class="d-none d-sm-inline ms-1">{{ loadingDocs ? 'Refreshing...' : 'Refresh' }}</span>
                      </button>
                      <button v-if="localFiles.length > 0" @click="clearAllLocalFiles"
                          class="btn btn-sm btn-danger bg-card">
                        <i class="fas fa-desktop me-1"></i>Delete All Local Drafts
                      </button>
                      <button v-if="ownedCloudFiles.length > 0" @click="clearAllCloudFiles"
                          class="btn btn-sm btn-danger bg-card">
                        <i class="fas fa-cloud me-1"></i>Delete All Cloud Drafts
                      </button>
                    </div>
                  </div>

                  <div v-if="loadingDocs && isAuthenticated" class="text-center py-4">
                    <i class="fas fa-spinner fa-spin fa-lg"></i><span class="ms-2">Loading documents...</span>
                  </div>
                  <div v-else-if="allDocuments.length === 0"
                      class="text-muted text-center py-4 border border-secondary rounded">
                    No documents found.
                  </div>
                  <div v-else class="table-responsive">
                    <table class="table table-hover table-dark align-middle mb-0 documents-table">
                      <thead>
                        <tr>
                          <th scope="col" class="col-type cursor-pointer" @click="sortTable('type')">
                            Type
                            <i v-if="sortColumn === 'type'" class="fas ms-1" :class="sortDirection === 'asc' ? 'fa-sort-up' : 'fa-sort-down'"></i>
                          </th>
                          <th scope="col" class="col-name cursor-pointer" @click="sortTable('name')">
                            Name
                            <i v-if="sortColumn === 'name'" class="fas ms-1" :class="sortDirection === 'asc' ? 'fa-sort-up' : 'fa-sort-down'"></i>
                          </th>
                          <th scope="col" class="col-owner cursor-pointer" @click="sortTable('owner')">
                            Owner
                            <i v-if="sortColumn === 'owner'" class="fas ms-1" :class="sortDirection === 'asc' ? 'fa-sort-up' : 'fa-sort-down'"></i>
                          </th>
                          <th scope="col" class="col-access cursor-pointer" @click="sortTable('access')">
                            Access
                            <i v-if="sortColumn === 'access'" class="fas ms-1" :class="sortDirection === 'asc' ? 'fa-sort-up' : 'fa-sort-down'"></i>
                          </th>
                          <th scope="col" class="col-modified cursor-pointer" @click="sortTable('lastModified')">
                            Modified
                            <i v-if="sortColumn === 'lastModified'" class="fas ms-1" :class="sortDirection === 'asc' ? 'fa-sort-up' : 'fa-sort-down'"></i>
                          </th>
                          <th scope="col" class="col-actions text-end">Actions</th>
                        </tr>
                      </thead>
                      <tbody>
                                                  <tr v-for="file in accessibleDocuments" :key="file.id || file.documentPath || (file.owner + '_' + file.permlink)"
                            class="unified-document-row">
                          <!-- Type -->
                          <td class="col-type cursor-pointer text-center" @click="canAccessDocument(file) && ((file.preferredType === 'collaborative' ? loadDocument(file) : loadLocalFile(file)), closeLoadModal())">
                            <i v-if="file.hasCloudVersion" class="fas fa-cloud text-muted" title="Cloud document"></i>
                            <i v-else class="fas fa-desktop text-muted" title="Local document"></i>
                            <i v-if="isCurrentDocument(file) && hasUnsavedChanges" class="fas fa-circle fa-xs text-warning ms-1" title="Has unsaved changes"></i>
                          </td>
                          
                          <!-- Document Name -->
                          <td class="col-name cursor-pointer" @click="canAccessDocument(file) && ((file.preferredType === 'collaborative' ? loadDocument(file) : loadLocalFile(file)), closeLoadModal())">
                            <strong class="d-block text-white text-truncate">{{ getDocumentDisplayName(file) }}</strong>
                            <small v-if="file.hasCloudVersion && file.documentName && file.documentName !== file.permlink" class="text-muted text-truncate d-block">{{ file.permlink }}</small>
                          </td>
                          
                          <!-- Owner -->
                          <td class="col-owner cursor-pointer" @click="canAccessDocument(file) && ((file.preferredType === 'collaborative' ? loadDocument(file) : loadLocalFile(file)), closeLoadModal())">
                            <small class="text-muted">@{{ file.owner || username }}</small>
                          </td>
                          
                          <!-- Access Level -->
                          <td class="col-access cursor-pointer" @click="canAccessDocument(file) && ((file.preferredType === 'collaborative' ? loadDocument(file) : loadLocalFile(file)), closeLoadModal())">
                            <span class="badge border" 
                                :class="'border-' + getPermissionDisplayInfo(getUserPermissionLevel(file)).color + ' text-' + getPermissionDisplayInfo(getUserPermissionLevel(file)).color"
                                :title="getPermissionDisplayInfo(getUserPermissionLevel(file)).description">
                              <i :class="getPermissionDisplayInfo(getUserPermissionLevel(file)).icon" class="me-1"></i>
                              {{ getPermissionDisplayInfo(getUserPermissionLevel(file)).label }}
                            </span>
                          </td>
                          
                          <!-- Last Modified -->
                          <td class="col-modified cursor-pointer text-nowrap" @click="canAccessDocument(file) && ((file.preferredType === 'collaborative' ? loadDocument(file) : loadLocalFile(file)), closeLoadModal())">
                            <small>{{ formatTime(file.lastModified || file.updatedAt) }}</small>
                          </td>
                          
                          <!-- Actions -->
                          <td class="col-actions text-end">
                            <!-- Load Button - Always uses preferred type -->
                            <button @click.stop="canAccessDocument(file) && ((file.preferredType === 'collaborative' ? loadDocument(file) : loadLocalFile(file)), closeLoadModal())" 
                                class="btn btn-sm btn-secondary me-1"
                                :disabled="!canAccessDocument(file)"
                                :title="canAccessDocument(file) ? ('Load document' + (file.preferredType === 'collaborative' ? ' (collaborative mode)' : ' (local mode)')) : 'Access denied - you do not have permission to view this document'">
                              <i class="fas fa-folder-open"></i>
                            </button>
                            
                            <!-- Delete Button - Show for local files or owned cloud files -->
                            <button v-if="file.hasLocalVersion && !file.hasCloudVersion" 
                                @click.stop="deleteDocument(file)"
                                class="btn btn-sm btn-danger" title="Delete local file">
                              <i class="fas fa-trash"></i>
                            </button>
                            <button v-else-if="file.hasCloudVersion && canDeleteFile(file)"
                                @click.stop="deleteDocument(file)"
                                class="btn btn-sm btn-danger"
                                title="Delete cloud document">
                              <i class="fas fa-trash"></i>
                            </button>
                            <button v-else-if="file.hasCloudVersion"
                                class="btn btn-sm btn-danger opacity-50"
                                disabled
                                title="Only document owner can delete">
                              <i class="fas fa-trash"></i>
                            </button>
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </div>
                <div class="modal-footer border-secondary">
                  <button @click="closeLoadModal()" class="btn btn-secondary">Close</button>
                </div>
              </div>
            </div>
          </div>

          <!-- Media Edit Modal (Modular System) -->
          <div v-if="showMediaEditModal" class="modal fade show d-block" style="background: rgba(0,0,0,0.5)" @click.self="closeMediaEditModal">
            <div class="modal-dialog modal-dialog-centered">
              <div class="modal-content bg-dark text-white">
                <div class="modal-header border-secondary">
                  <h5 class="modal-title">
                    Edit {{ mediaEditData.type.charAt(0).toUpperCase() + mediaEditData.type.slice(1) }}
                  </h5>
                  <button type="button" class="btn-close btn-close-white" @click="closeMediaEditModal"></button>
                </div>
                <div class="modal-body">
                  <!-- URL field (always read-only) -->
                  <div class="mb-3">
                    <label for="mediaEditSrc" class="form-label">
                      {{ mediaEditData.type.charAt(0).toUpperCase() + mediaEditData.type.slice(1) }} URL 
                      <i class="fas fa-lock ms-1 text-muted" title="URL cannot be edited"></i>
                    </label>
                    <input 
                      id="mediaEditSrc"
                      v-model="mediaEditData.src" 
                      type="text" 
                      class="form-control bg-dark text-white border-secondary"
                      readonly
                    >
                    <small class="text-muted">To change the URL, delete this {{ mediaEditData.type }} and insert a new one</small>
                  </div>
                  
                  <!-- Alt text for images -->
                  <div v-if="mediaEditData.type === 'image'" class="mb-3">
                    <label for="mediaEditAlt" class="form-label">Caption (Alt Text)</label>
                    <input 
                      id="mediaEditAlt"
                      v-model="mediaEditData.alt" 
                      type="text" 
                      class="form-control bg-dark text-white border-secondary"
                      placeholder="Describe the image"
                      @keyup.enter="saveMediaEdit"
                    >
                    <small class="text-muted">This appears in markdown as ![caption](url)</small>
                  </div>
                  
                  <!-- Video-specific controls -->
                  <div v-if="mediaEditData.type === 'video'">
                    <div class="mb-3">
                      <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" v-model="mediaEditData.controls" id="videoControls">
                        <label class="form-check-label" for="videoControls">Show Controls</label>
                      </div>
                    </div>
                    <div class="mb-3">
                      <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" v-model="mediaEditData.autoplay" id="videoAutoplay">
                        <label class="form-check-label" for="videoAutoplay">Autoplay</label>
                      </div>
                    </div>
                    <div class="mb-3">
                      <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" v-model="mediaEditData.loop" id="videoLoop">
                        <label class="form-check-label" for="videoLoop">Loop</label>
                      </div>
                    </div>
                    <div class="mb-3">
                      <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" v-model="mediaEditData.muted" id="videoMuted">
                        <label class="form-check-label" for="videoMuted">Muted</label>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="modal-footer border-secondary d-flex justify-content-between">
                  <button type="button" class="btn btn-outline-danger" @click="deleteMediaNode" title="Delete from document">
                    <i class="fas fa-trash me-1"></i>Delete
                  </button>
                  <div>
                    <button type="button" class="btn btn-secondary me-2" @click="closeMediaEditModal">Cancel</button>
                    <button type="button" class="btn btn-primary" @click="saveMediaEdit">Save Changes</button>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Share Modal -->
          <div v-if="showShareModal" class="modal fade show d-block" style="background: rgba(0,0,0,0.5)">
            <div class="modal-dialog modal-dialog-centered modal-lg">
              <div class="modal-content bg-dark text-white">
                <div class="modal-header border-secondary">
                  <h5 class="modal-title">
                    <i class="fas fa-share me-2"></i>Share Document
                  </h5>
                  <button @click="closeShareModal()" class="btn-close btn-close-white"></button>
                </div>
                <div class="modal-body">
                  <!-- Current Document Info -->
                  <div class="mb-4">
                    <h6 class="fw-bold mb-3">Document Access</h6>
                    <div class="d-flex align-items-center justify-content-between p-2 bg-secondary rounded mb-2">
                      <div class="d-flex align-items-center">
                        <div class="user-avatar-fallback me-2 bg-primary rounded-circle d-flex align-items-center justify-content-center"
                             style="width: 40px; height: 40px; font-size: 1rem; font-weight: bold; color: white;">
                          {{ currentFile?.owner?.charAt(0).toUpperCase() || 'U' }}
                        </div>
                        <div>
                          <strong>@{{ currentFile?.owner || username }}</strong>
                          <div class="text-muted small">Owner</div>
                        </div>
                      </div>
                      <span class="badge bg-success">Full Access</span>
                    </div>
                    
                    <!-- Show current user's permission if not owner -->
                    <div v-if="!isOwner" class="d-flex align-items-center justify-content-between p-2 bg-secondary rounded">
                      <div class="d-flex align-items-center">
                        <div class="user-avatar-fallback me-2 bg-info rounded-circle d-flex align-items-center justify-content-center"
                             style="width: 40px; height: 40px; font-size: 1rem; font-weight: bold; color: white;">
                          {{ username?.charAt(0).toUpperCase() || 'U' }}
                        </div>
                        <div>
                          <strong>@{{ username }}</strong>
                          <div class="text-muted small">Your Permission</div>
                        </div>
                      </div>
                      <span class="badge" 
                            :class="'bg-' + getPermissionDisplayInfo(currentPermissionLevel).color">
                        {{ getPermissionDisplayInfo(currentPermissionLevel).label }}
                      </span>
                    </div>
                  </div>

                  <!-- Shared Users -->
                  <div v-if="sharedUsers.length > 0" class="mb-4">
                    <h6 class="fw-bold mb-3">Shared With</h6>
                    <div v-for="user in sharedUsers" :key="user.account" class="d-flex align-items-center justify-content-between p-2 bg-secondary rounded mb-2">
                      <div class="d-flex align-items-center">
                        <div class="user-avatar-fallback me-2 bg-info rounded-circle d-flex align-items-center justify-content-center"
                             style="width: 40px; height: 40px; font-size: 1rem; font-weight: bold; color: white;">
                          {{ user.account?.charAt(0).toUpperCase() || 'U' }}
                        </div>
                        <div>
                          <strong>@{{ user.account }}</strong>
                          <div class="text-muted small">{{ getPermissionDisplayInfo(user.permissionType).label }}</div>
                        </div>
                      </div>
                      <div class="d-flex align-items-center">
                        <select @change="updateUserPermission(user.account, $event.target.value)" 
                                :value="user.permissionType" 
                                class="form-select form-select-sm bg-dark text-white border-secondary me-2" 
                                style="width: auto;">
                          <option value="readonly">Read Only</option>
                          <option value="editable">Editable</option>
                          <option value="postable">Full Access</option>
                        </select>
                        <button @click="removeUserAccess(user.account)" class="btn btn-sm btn-outline-danger" title="Remove access">
                          <i class="fas fa-times"></i>
                        </button>
                      </div>
                    </div>
                  </div>

                  <hr class="border-secondary">

                  <!-- Share URL -->
                  <div class="mb-4">
                    <h6 class="fw-bold mb-3">Shareable Link</h6>
                    <div class="input-group">
                      <input :value="shareableDocumentURL" class="form-control bg-dark text-white border-secondary" readonly>
                      <button @click="copyToClipboard(shareableDocumentURL)" class="btn btn-outline-primary">
                        <i class="fas fa-copy"></i>
                      </button>
                    </div>
                    <small class="text-muted">Anyone with this link can view the document</small>
                  </div>

                  <!-- Add User -->
                  <div>
                    <h6 class="fw-bold mb-3">Grant User Access</h6>
                    <div class="mb-3">
                      <label class="form-label">Username</label>
                      <div class="input-group">
                        <span class="input-group-text">@</span>
                        <input v-model="shareForm.username" class="form-control bg-dark text-white border-secondary" 
                               placeholder="Enter username"
                               @keyup.enter="shareWithUser">
                      </div>
                    </div>

                    <div class="mb-3">
                      <label class="form-label">Permission level</label>
                      <select v-model="shareForm.permission" class="form-select bg-dark text-white border-secondary">
                        <option value="readonly">Read Only - Can view</option>
                        <option value="editable">Editable - Can view and edit</option>
                        <option value="postable">Full Access - Can edit and publish</option>
                      </select>
                    </div>
                  </div>

                  <div class="alert alert-info border-info">
                    <i class="fas fa-info-circle me-1"></i>
                    Users need to authenticate to access shared documents.
                  </div>
                </div>
                <div class="modal-footer border-secondary">
                  <button @click="closeShareModal()" class="btn btn-secondary">Close</button>
                  <button @click="shareWithUser()" class="btn btn-primary" :disabled="!shareForm.username || !shareForm.username.trim()">
                    <i class="fas fa-user-plus me-1"></i>Grant Access
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Publish Modal -->
          <div v-if="showPublishModal" class="modal fade show d-block" style="background: rgba(0,0,0,0.5)">
            <div class="modal-dialog modal-dialog-centered modal-lg">
              <div class="modal-content bg-dark text-white">
                <div class="modal-header border-secondary">
                  <h5 class="modal-title">
                    <i class="fas fa-paper-plane me-2"></i>Publish to Hive
                  </h5>
                  <button @click="closePublishModal()" class="btn-close btn-close-white"></button>
                </div>
                <div class="modal-body">
                  <!-- Validation Status -->
                  <div class="mb-3">
                    <div v-if="canPublish" class="alert alert-success border-success">
                      <i class="fas fa-check-circle me-2"></i>
                      <strong>Ready to Publish</strong> - All required fields are complete
                    </div>
                    <div v-else class="alert alert-warning border-warning">
                      <i class="fas fa-exclamation-triangle me-2"></i>
                      <strong>Missing Required Fields</strong>
                      <ul class="mb-0 mt-2">
                        <li v-if="!displayTitleExists">Title is required</li>
                        <li v-if="!displayBodyExists">Content is required</li>
                        <li v-if="displayTags.length === 0">At least one tag is required</li>
                      </ul>
                    </div>
                  </div>

                  <!-- Preview -->
                  <div class="mb-3">
                    <h6 class="fw-bold">Post Preview</h6>
                    <div class="border border-secondary rounded p-3">
                      <h5 class="text-white">{{ titleInput || 'No title yet...' }}</h5>
                      <div class="text-muted small mb-2">
                        by @{{ username }} 
                        <span v-if="displayTags.length > 0">
                          in 
                          <span v-for="(tag, index) in displayTags.slice(0, 3)" :key="tag">
                            #{{ tag }}<span v-if="index < Math.min(displayTags.length, 3) - 1">, </span>
                          </span>
                          <span v-if="displayTags.length > 3">...</span>
                        </span>
                      </div>
                      <div class="post-content">
                        {{ getPlainTextContent().substring(0, 200) }}{{ getPlainTextContent().length > 200 ? '...' : '' }}
                      </div>
                    </div>
                  </div>

                  <!-- Publish Options -->
                  <div class="mb-3">
                    <h6 class="fw-bold">Publishing Options</h6>
                    <div class="form-check">
                      <input v-model="publishAsDraft" class="form-check-input" type="checkbox" id="publishAsDraft">
                      <label class="form-check-label" for="publishAsDraft">
                        Publish as draft (won't appear in feeds)
                      </label>
                    </div>
                  </div>
                </div>
                <div class="modal-footer border-secondary">
                  <button @click="closePublishModal()" class="btn btn-secondary">Cancel</button>
                  <button @click="publishToHive()" class="btn btn-primary" :disabled="!canPublish">
                    <i class="fas fa-paper-plane me-1"></i>Publish to Hive
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- JSON Preview Modal -->
          <!-- JSON Preview Modal -->
          <div v-if="jsonPreviewModal.show" class="modal fade show d-block" style="background: rgba(0,0,0,0.8)">
            <div class="modal-dialog modal-xl modal-dialog-centered">
              <div class="modal-content bg-dark text-white">
                <div class="modal-header border-secondary">
                  <h5 class="modal-title">
                    <i class="fas fa-code me-2"></i>Hive JSON Preview
                  </h5>
                  <button @click="jsonPreviewModal.show = false" class="btn-close btn-close-white"></button>
                </div>
                <div class="modal-body">
                  <!-- Validation Status -->
                  <div v-if="jsonPreviewModal.validation.errors.length > 0" class="alert alert-danger border-danger mb-3">
                    <i class="fas fa-exclamation-circle me-2"></i>
                    <strong>Validation Errors</strong>
                    <ul class="mb-0 mt-2">
                      <li v-for="error in jsonPreviewModal.validation.errors" :key="error">{{ error }}</li>
                    </ul>
                  </div>
                  <div v-else-if="jsonPreviewModal.validation.warnings.length > 0" class="alert alert-warning border-warning mb-3">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    <strong>Warnings</strong>
                    <ul class="mb-0 mt-2">
                      <li v-for="warning in jsonPreviewModal.validation.warnings" :key="warning">{{ warning }}</li>
                    </ul>
                  </div>
                  <div v-else class="alert alert-success border-success mb-3">
                    <i class="fas fa-check-circle me-2"></i>
                    <strong>Valid</strong> - Ready for Hive blockchain
                  </div>

                  <!-- Tab Navigation -->
                  <ul class="nav nav-tabs nav-tabs-dark mb-3">
                    <li class="nav-item">
                      <a class="nav-link" :class="{active: jsonPreviewModal.tab === 'complete'}"
                         @click="jsonPreviewModal.tab = 'complete'" href="#" @click.prevent>
                        <i class="fas fa-list me-2"></i>Complete Operations
                      </a>
                    </li>
                    <li class="nav-item">
                      <a class="nav-link" :class="{active: jsonPreviewModal.tab === 'comment'}"
                         @click="jsonPreviewModal.tab = 'comment'" href="#" @click.prevent>
                        <i class="fas fa-comment me-2"></i>Comment Operation
                      </a>
                    </li>
                    <li class="nav-item">
                      <a class="nav-link" :class="{active: jsonPreviewModal.tab === 'options'}"
                         @click="jsonPreviewModal.tab = 'options'" href="#" @click.prevent>
                        <i class="fas fa-cog me-2"></i>Comment Options
                      </a>
                    </li>
                    <li class="nav-item">
                      <a class="nav-link" :class="{active: jsonPreviewModal.tab === 'metadata'}"
                         @click="jsonPreviewModal.tab = 'metadata'" href="#" @click.prevent>
                        <i class="fas fa-info-circle me-2"></i>Metadata
                      </a>
                    </li>
                    <li class="nav-item">
                      <a class="nav-link" :class="{active: jsonPreviewModal.tab === 'customJson'}"
                         @click="jsonPreviewModal.tab = 'customJson'" href="#" @click.prevent>
                        <i class="fas fa-puzzle-piece me-2"></i>Custom JSON
                      </a>
                    </li>
                  </ul>

                  <!-- Tab Content -->
                  <div class="tab-content">
                    <!-- Complete Operations Tab -->
                    <div v-if="jsonPreviewModal.tab === 'complete'" class="tab-pane active">
                      <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="text-info mb-0">Complete Operations Array</h6>
                        <button @click="copyJsonToClipboard(jsonPreview.complete)" 
                                class="btn btn-sm btn-outline-success">
                          <i class="fas fa-copy me-1"></i>Copy JSON
                        </button>
                      </div>
                      <pre class="bg-secondary text-white p-3 rounded" style="max-height: 500px; overflow-y: auto; font-size: 0.85em;">{{ JSON.stringify(jsonPreview.complete, null, 2) }}</pre>
                    </div>

                    <!-- Comment Operation Tab -->
                    <div v-if="jsonPreviewModal.tab === 'comment'" class="tab-pane active">
                      <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="text-info mb-0">Comment Operation</h6>
                        <button @click="copyJsonToClipboard(jsonPreview.comment)" 
                                class="btn btn-sm btn-outline-success">
                          <i class="fas fa-copy me-1"></i>Copy JSON
                        </button>
                      </div>
                      <pre class="bg-secondary text-white p-3 rounded" style="max-height: 500px; overflow-y: auto; font-size: 0.85em;">{{ JSON.stringify(jsonPreview.comment, null, 2) }}</pre>
                    </div>

                    <!-- Comment Options Tab -->
                    <div v-if="jsonPreviewModal.tab === 'options'" class="tab-pane active">
                      <div v-if="jsonPreview.commentOptions">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                          <h6 class="text-info mb-0">Comment Options Operation</h6>
                          <button @click="copyJsonToClipboard(jsonPreview.commentOptions)" 
                                  class="btn btn-sm btn-outline-success">
                            <i class="fas fa-copy me-1"></i>Copy JSON
                          </button>
                        </div>
                        <pre class="bg-secondary text-white p-3 rounded" style="max-height: 500px; overflow-y: auto; font-size: 0.85em;">{{ JSON.stringify(jsonPreview.commentOptions, null, 2) }}</pre>
                      </div>
                      <div v-else class="text-center py-5">
                        <i class="fas fa-info-circle fa-3x text-muted mb-3"></i>
                        <h6 class="text-muted">Using Default Comment Options</h6>
                        <p class="text-muted">No custom comment options have been set for this post.</p>
                        <small class="text-muted">
                          Default options: Voting enabled, curation rewards enabled,<br>
                          no max payout limit, rewards as 50% HBD / 50% HP
                        </small>
                      </div>
                    </div>

                    <!-- Metadata Tab -->
                    <div v-if="jsonPreviewModal.tab === 'metadata'" class="tab-pane active">
                      <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="text-info mb-0">Generation Metadata</h6>
                        <button @click="copyJsonToClipboard(jsonPreview.metadata)" 
                                class="btn btn-sm btn-outline-success">
                          <i class="fas fa-copy me-1"></i>Copy JSON
                        </button>
                      </div>
                      <pre class="bg-secondary text-white p-3 rounded" style="max-height: 500px; overflow-y: auto; font-size: 0.85em;">{{ JSON.stringify(jsonPreview.metadata, null, 2) }}</pre>
                    </div>

                    <!-- Custom JSON Tab -->
                    <div v-if="jsonPreviewModal.tab === 'customJson'" class="tab-pane active">
                      <div v-if="Object.keys(reactiveCustomJson).length > 0">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                          <h6 class="text-info mb-0">Custom JSON from External Apps</h6>
                          <button @click="copyJsonToClipboard(reactiveCustomJson)" 
                                  class="btn btn-sm btn-outline-success">
                            <i class="fas fa-copy me-1"></i>Copy JSON
                          </button>
                        </div>
                        <pre class="bg-secondary text-white p-3 rounded" style="max-height: 500px; overflow-y: auto; font-size: 0.85em;">{{ JSON.stringify(reactiveCustomJson, null, 2) }}</pre>
                      </div>
                      <div v-else class="text-center py-5">
                        <i class="fas fa-puzzle-piece fa-3x text-muted mb-3"></i>
                        <h6 class="text-muted">No Custom JSON Data</h6>
                        <p class="text-muted">External iframe apps can populate this field with custom data.</p>
                        <small class="text-muted">
                          This data will be included in the post's json_metadata field.
                        </small>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="modal-footer border-secondary">
                  <div class="me-auto small text-muted">
                    <i class="fas fa-clock me-1"></i>
                    Generated: {{ formatTime(new Date()) }}
                  </div>
                  <button @click="jsonPreviewModal.show = false" class="btn btn-secondary">Close</button>
                  <button @click="publishToHive()" class="btn btn-primary" :disabled="!jsonPreviewModal.validation.valid">
                    <i class="fas fa-paper-plane me-1"></i>Publish to Hive
                  </button>
                </div>
              </div>
            </div>
          </div>
        </teleport>

      </div>
    `
};