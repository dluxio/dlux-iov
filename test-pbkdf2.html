<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PBKDF2 Encryption Test</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>
<body>
    <h1>PBKDF2 Encryption Test</h1>
    <div id="output"></div>
    
    <script>
        const log = (message) => {
            const output = document.getElementById('output');
            output.innerHTML += `<p>${message}</p>`;
            console.log(message);
        };

        // Test encryption/decryption functions (copied from v3-nav.js)
        class CryptoTest {
            // Benchmark PBKDF2 to find iteration count for target duration
            async benchmarkPBKDF2(targetDurationMs = 2000) {
                const testPassword = "benchmark-test-password";
                const testSalt = crypto.getRandomValues(new Uint8Array(32));
                
                // Start with a reasonable baseline
                let iterations = 100000;
                let duration = 0;
                
                // Binary search approach to find optimal iteration count
                let minIterations = 50000;
                let maxIterations = 1000000;
                
                while (maxIterations - minIterations > 10000) {
                    const startTime = performance.now();
                    
                    const encoder = new TextEncoder();
                    const keyMaterial = await crypto.subtle.importKey(
                        "raw",
                        encoder.encode(testPassword),
                        { name: "PBKDF2" },
                        false,
                        ["deriveBits"]
                    );
                    
                    await crypto.subtle.deriveBits(
                        {
                            name: "PBKDF2",
                            salt: testSalt,
                            iterations: iterations,
                            hash: "SHA-256"
                        },
                        keyMaterial,
                        256
                    );
                    
                    duration = performance.now() - startTime;
                    
                    if (duration < targetDurationMs * 0.9) {
                        minIterations = iterations;
                        iterations = Math.floor((iterations + maxIterations) / 2);
                    } else if (duration > targetDurationMs * 1.1) {
                        maxIterations = iterations;
                        iterations = Math.floor((minIterations + iterations) / 2);
                    } else {
                        break;
                    }
                }
                
                log(`PBKDF2 benchmark: ${iterations} iterations = ${Math.round(duration)}ms`);
                return iterations;
            }
            
            // Generate cryptographically secure salt
            generateSalt() {
                return crypto.getRandomValues(new Uint8Array(32));
            }
            
            // Derive key using PBKDF2
            async deriveKey(password, salt, iterations) {
                const encoder = new TextEncoder();
                const keyMaterial = await crypto.subtle.importKey(
                    "raw",
                    encoder.encode(password),
                    { name: "PBKDF2" },
                    false,
                    ["deriveBits"]
                );
                
                const derivedBits = await crypto.subtle.deriveBits(
                    {
                        name: "PBKDF2",
                        salt: salt,
                        iterations: iterations,
                        hash: "SHA-256"
                    },
                    keyMaterial,
                    256
                );
                
                return new Uint8Array(derivedBits);
            }
            
            // Convert Uint8Array to hex string
            uint8ArrayToHex(uint8Array) {
                return Array.from(uint8Array)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
            }
            
            // Convert hex string to Uint8Array
            hexToUint8Array(hexString) {
                const bytes = new Uint8Array(hexString.length / 2);
                for (let i = 0; i < hexString.length; i += 2) {
                    bytes[i / 2] = parseInt(hexString.substr(i, 2), 16);
                }
                return bytes;
            }
            
            // Hardened encryption using PBKDF2 + AES
            async encryptWithPBKDF2(data, password) {
                try {
                    // Generate salt and determine iteration count
                    const salt = this.generateSalt();
                    const iterations = await this.benchmarkPBKDF2(2000); // Target 2 seconds
                    
                    // Derive key using PBKDF2
                    const derivedKey = await this.deriveKey(password, salt, iterations);
                    
                    // Convert derived key to CryptoJS format
                    const keyHex = this.uint8ArrayToHex(derivedKey);
                    const key = CryptoJS.enc.Hex.parse(keyHex);
                    
                    // Encrypt the data using CBC mode (more widely supported)
                    const encrypted = CryptoJS.AES.encrypt(JSON.stringify(data), key, {
                        mode: CryptoJS.mode.CBC,
                        padding: CryptoJS.pad.Pkcs7
                    });
                    
                    // Package everything together
                    const packagedData = {
                        version: "1.0",
                        salt: this.uint8ArrayToHex(salt),
                        iterations: iterations,
                        encrypted: encrypted.toString(),
                        timestamp: Date.now()
                    };
                    
                    return JSON.stringify(packagedData);
                } catch (error) {
                    console.error("Encryption failed:", error);
                    throw new Error("Failed to encrypt data");
                }
            }
            
            // Hardened decryption using PBKDF2 + AES
            async decryptWithPBKDF2(encryptedPackage, password) {
                try {
                    const packagedData = JSON.parse(encryptedPackage);
                    
                    // Validate package format
                    if (!packagedData.salt || !packagedData.iterations || !packagedData.encrypted) {
                        throw new Error("Invalid encrypted package format");
                    }
                    
                    // Convert salt back to Uint8Array
                    const salt = this.hexToUint8Array(packagedData.salt);
                    
                    // Derive the same key using stored parameters
                    const derivedKey = await this.deriveKey(password, salt, packagedData.iterations);
                    
                    // Convert derived key to CryptoJS format
                    const keyHex = this.uint8ArrayToHex(derivedKey);
                    const key = CryptoJS.enc.Hex.parse(keyHex);
                    
                    // Decrypt the data using CBC mode
                    const decrypted = CryptoJS.AES.decrypt(packagedData.encrypted, key, {
                        mode: CryptoJS.mode.CBC,
                        padding: CryptoJS.pad.Pkcs7
                    });
                    
                    const decryptedString = decrypted.toString(CryptoJS.enc.Utf8);
                    if (!decryptedString) {
                        throw new Error("Failed to decrypt - incorrect password or corrupted data");
                    }
                    
                    return JSON.parse(decryptedString);
                } catch (error) {
                    console.error("Decryption failed:", error);
                    throw new Error("Failed to decrypt data - check password");
                }
            }
        }

        // Run tests
        async function runTests() {
            const crypto = new CryptoTest();
            
            log("Starting PBKDF2 encryption test...");
            
            // Test data
            const testData = {
                accounts: {
                    "testuser": {
                        posting: "5K_test_posting_key_123456789",
                        active: "5K_test_active_key_987654321",
                        memo: "5K_test_memo_key_abcdef"
                    }
                },
                pin: true
            };
            
            const password = "test-pin-1234";
            
            try {
                // Test encryption
                log("Encrypting test data...");
                const encrypted = await crypto.encryptWithPBKDF2(testData, password);
                log(`Encrypted data length: ${encrypted.length} characters`);
                
                // Test decryption
                log("Decrypting test data...");
                const decrypted = await crypto.decryptWithPBKDF2(encrypted, password);
                
                // Verify data integrity
                const dataMatch = JSON.stringify(testData) === JSON.stringify(decrypted);
                log(`Data integrity check: ${dataMatch ? 'PASSED' : 'FAILED'}`);
                
                if (dataMatch) {
                    log("✅ All tests PASSED! PBKDF2 encryption is working correctly.");
                } else {
                    log("❌ Data integrity test FAILED!");
                    log(`Original: ${JSON.stringify(testData)}`);
                    log(`Decrypted: ${JSON.stringify(decrypted)}`);
                }
                
                // Test wrong password
                try {
                    log("Testing wrong password...");
                    await crypto.decryptWithPBKDF2(encrypted, "wrong-password");
                    log("❌ Wrong password test FAILED - should have thrown error");
                } catch (error) {
                    log("✅ Wrong password correctly rejected");
                }
                
            } catch (error) {
                log(`❌ Test FAILED: ${error.message}`);
                console.error(error);
            }
        }

        // Run tests when page loads
        window.addEventListener('load', runTests);
    </script>
</body>
</html> 