this.version = "2025.06.01.1";
console.log("SW:" + version + " - online.");
const CACHE_NAME = "sw-cache-v" + version;

// PRIORITY 1: Critical resources for first paint and basic functionality
const criticalResources = [
  // Core HTML pages
  `/index.html`,
  `/about/index.html`,
  
  // Essential CSS for layout and theming
  `/css/bootstrap/bootstrap.css`,
  `/css/custom.css`,
  `/css/v3.css`,
  
  // Core JavaScript for app functionality
  `/js/vue.esm-browser.js`,
  `/js/v3-app.js`,
  `/js/v3-index.js`,
  `/js/v3-nav.js`,
  `/js/bootstrap.bundle.min.js`,
  
  // Essential images and icons
  `/img/dlux-hive-logo-alpha.svg`,
  `/img/dlux-icon-192.png`,
  `/img/dlux-logo.png`,
  `/img/no-user.png`,
  
  // Core utilities
  `/reg-sw.js`
];

// PRIORITY 2: Important resources for common interactions
const importantResources = [
  // Common HTML pages
  `/create/index.html`,
  `/nfts/index.html`,
  `/user/index.html`,
  `/dlux/index.html`,
  `/dex/index.html`,
  `/hub/index.html`,
  `/dao/index.html`,
  `/blog/index.html`,
  
  // Additional CSS
  `/css/bootstrap/bootstrap-grid.css`,
  `/css/bootstrap/bootstrap-utilities.css`,
  `/css/tagify.css`,
  `/css/drag-sort.css`,
  
  // Important JavaScript modules
  `/js/v3-user.js`,
  `/js/v3-dex.js`,
  `/js/v3-hub.js`,
  `/js/v3-nfts.js`,
  `/js/methods-common.js`,
  `/js/navue.js`,
  `/js/session.js`,
  `/js/dataCommon.js`,
  
  // Common images
  `/img/tokens/dlux_icon.png`,
  `/img/tokens/hive_icon.svg`,
  `/img/tokens/hbd_icon.svg`,
  `/img/spknetwork.png`
];

// PRIORITY 3: Page-specific resource groups (cached on-demand)
const pageSpecificResources = {
  '/create': [
    `/create/index.html`,
    `/js/uploadvue.js`,
    `/js/filesvue.js`,
    `/js/mde.js`,
    `/js/tagify.min.js`,
    `/css/smde.css`,
    `/css/simplemde-bs-dark.css`
  ],
  
  '/aframe': [
    `/aframe-builder/index.html`,
    `/aframe-builder/aframe.min.js`,
    `/js/aframe.min.js`,
    `/js/aframe-extras.min.js`,
    `/js/aframe-environment-component.min.js`,
    `/img/aframe.png`
  ],
  
  '/monaco': [
    `/naf-playground/monaco-editor/vs/loader.js`,
    `/naf-playground/monaco-editor/vs/editor/editor.main.js`,
    `/naf-playground/monaco-editor/vs/editor/editor.main.css`,
    `/naf-playground/monaco-editor/vs/language/javascript/javascript.js`,
    `/naf-playground/monaco-editor/vs/language/html/htmlMode.js`,
    `/naf-playground/monaco-editor/vs/language/css/cssMode.js`
  ],
  
  '/playground': [
    `/playground/index.html`,
    `/naf-playground/index.html`,
    `/naf-playground/js/main.js`,
    `/naf-playground/css/style.css`,
    `/js/aframe.min.js`,
    `/js/aframe-extras.min.js`
  ],
  
  '/chat': [
    `/chat/index.html`,
    `/chat/gpt.html`,
    `/js/chatvue.js`,
    `/img/chatgpt-icon.png`
  ],
  
  '/mint': [
    `/mint/index.html`,
    `/new/index.html`,
    `/new/token/index.html`,
    `/js/uploadvue.js`,
    `/js/nftcard.js`
  ]
};

// PRIORITY 4: Skipped resources (files explicitly excluded from caching)
const skippedResources = [
  // Add files here that should not be cached
  // This prevents them from being prompted again in future runs
];

// Cache management flags
let priorityTwoCached = false;
let backgroundCacheInProgress = false;

self.nftscripts = {};
const scriptPromises = {}; // Store ongoing fetch promises

self.addEventListener("install", function (event) {
    console.log("SW: Installing with tiered caching strategy...");
    
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(cache => {
                console.log("SW: Caching critical resources for fast first paint...");
                return cache.addAll(criticalResources);
            })
            .then(() => {
                console.log("SW: Critical resources cached successfully");
                // Skip waiting to activate immediately for faster updates
                return self.skipWaiting();
            })
            .catch(error => {
                console.error('SW: Critical cache installation failed:', error);
                throw error;
            })
    );
});

// Background caching of important resources
function scheduleBackgroundCache() {
    if (backgroundCacheInProgress) return;
    backgroundCacheInProgress = true;
    
    // Use setTimeout to avoid blocking the install event
    setTimeout(() => {
        cacheImportantResources();
    }, 1000);
}

async function cacheImportantResources() {
    if (priorityTwoCached) return;
    
    try {
        const cache = await caches.open(CACHE_NAME);
        console.log("SW: Background caching important resources...");
        
        // Cache in smaller batches to avoid overwhelming the browser
        const batchSize = 10;
        for (let i = 0; i < importantResources.length; i += batchSize) {
            const batch = importantResources.slice(i, i + batchSize);
            try {
                await cache.addAll(batch);
                console.log(`SW: Cached batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(importantResources.length/batchSize)}`);
            } catch (error) {
                console.warn('SW: Some resources in batch failed to cache:', error);
                // Continue with next batch even if some fail
            }
            
            // Small delay between batches to avoid blocking
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        priorityTwoCached = true;
        console.log("SW: Important resources background caching completed");
    } catch (error) {
        console.error('SW: Background caching failed:', error);
    } finally {
        backgroundCacheInProgress = false;
    }
}

// Cache page-specific resources on navigation
async function cachePageResources(pathname) {
    const cache = await caches.open(CACHE_NAME);
    
    // Determine which page-specific resources to cache
    let resourcesToCache = [];
    
    if (pathname.startsWith('/create') || pathname.startsWith('/new')) {
        resourcesToCache = pageSpecificResources['/create'];
    } else if (pathname.startsWith('/aframe-builder') || pathname.includes('aframe')) {
        resourcesToCache = pageSpecificResources['/aframe'];
    } else if (pathname.startsWith('/playground') || pathname.startsWith('/naf-playground')) {
        resourcesToCache = [...pageSpecificResources['/playground'], ...pageSpecificResources['/monaco']];
    } else if (pathname.startsWith('/chat')) {
        resourcesToCache = pageSpecificResources['/chat'];
    } else if (pathname.startsWith('/mint') || pathname.startsWith('/new')) {
        resourcesToCache = pageSpecificResources['/mint'];
    }
    
    if (resourcesToCache.length > 0) {
        console.log(`SW: Proactively caching resources for ${pathname}`);
        try {
            // Check which resources aren't already cached
            const uncachedResources = [];
            for (const resource of resourcesToCache) {
                const cached = await cache.match(resource);
                if (!cached) {
                    uncachedResources.push(resource);
                }
            }
            
            if (uncachedResources.length > 0) {
                // Cache in smaller batches
                const batchSize = 5;
                for (let i = 0; i < uncachedResources.length; i += batchSize) {
                    const batch = uncachedResources.slice(i, i + batchSize);
                    try {
                        await cache.addAll(batch);
                    } catch (error) {
                        console.warn('SW: Some page-specific resources failed to cache:', error);
                    }
                }
                console.log(`SW: Cached ${uncachedResources.length} page-specific resources`);
            }
        } catch (error) {
            console.warn('SW: Page-specific caching failed:', error);
        }
    }
}

self.addEventListener('fetch', function(event) {    
    const url = new URL(event.request.url);
    
    // Trigger page-specific caching for same-origin navigations
    if (url.origin === self.location.origin && event.request.mode === 'navigate') {
        // Don't await this - let it run in background
        cachePageResources(url.pathname).catch(error => 
            console.warn('SW: Page-specific caching failed:', error)
        );
    }
    
    if (url.hostname === 'api.coingecko.com') {
        event.respondWith(
            caches.open(CACHE_NAME).then(async cache => {
                const request = event.request;
                const CACHE_MAX_AGE_MS = 15 * 60 * 1000; // 15 minutes

                const cachedResponse = await cache.match(request);

                if (cachedResponse) {
                    const timestampHeader = cachedResponse.headers.get('sw-cache-timestamp');
                    if (timestampHeader) {
                        const cachedTime = parseInt(timestampHeader, 10);
                        if (Date.now() - cachedTime < CACHE_MAX_AGE_MS) {
                            return cachedResponse;
                        }
                    }
                }
                try {
                    const networkResponse = await fetch(request);
                    if (networkResponse && networkResponse.ok) {
                        const responseToCache = networkResponse.clone();
                        const newHeaders = new Headers(responseToCache.headers);
                        newHeaders.set('sw-cache-timestamp', Date.now().toString());
                        const body = await responseToCache.arrayBuffer(); 
                        
                        const cacheableResponse = new Response(body, {
                            status: responseToCache.status,
                            statusText: responseToCache.statusText,
                            headers: newHeaders
                        });

                        cache.put(request, cacheableResponse)
                        return networkResponse
                    } else {
                        if (cachedResponse) { 
                            return cachedResponse;
                        }
                        return networkResponse || new Response(JSON.stringify({ error: 'CoinGecko API request failed to fetch and no cache available' }), {
                            status: 503,
                            statusText: 'Service Unavailable',
                            headers: { 'Content-Type': 'application/json' }
                        });
                    }
                } catch (error) {
                    console.error(`SW: Fetch error for ${request.url}:`, error);
                    if (cachedResponse) { 
                        return cachedResponse;
                    }
                    return new Response(JSON.stringify({ error: 'CoinGecko API request failed due to network error and no cache available' }), {
                        status: 503,
                        statusText: 'Service Unavailable',
                        headers: { 'Content-Type': 'application/json' }
                    });
                }
            })
        );
        return
    }

    if (url.origin !== self.location.origin) {
        // For specific external resources we want to handle
        if (url.pathname.endsWith('.m4v')) { // MODIFIED: Removed "|| url.hostname === 'api.coingecko.com'"
            event.respondWith(
                fetch(event.request)
                    .catch(error => {
                        console.error('Network error for external resource:', event.request.url, error);
                        return new Response(null, { status: 503 }); // Service Unavailable
                    })
            );
        }
        return; // Let browser handle all other external requests
    }

    // Handle routing rules from Caddyfile for same-origin requests
    event.respondWith(handleRouting(event.request));
});

// Handle routing based on Caddyfile rules
async function handleRouting(request) {
    const url = new URL(request.url);
    const pathname = url.pathname;
    
    // Helper function to try serving a static file, fallback to rewrite
    async function tryStaticOrRewrite(rewriteTarget) {
        // First try to get the exact file from cache
        const cachedResponse = await caches.match(request);
        if (cachedResponse) {
            return cachedResponse;
        }
        
        // Try to fetch the exact file from network
        try {
            const networkResponse = await fetch(request);
            if (networkResponse && networkResponse.ok) {
                // Cache the response
                const responseToCache = networkResponse.clone();
                caches.open(CACHE_NAME)
                    .then(cache => {
                        cache.put(request, responseToCache)
                            .catch(error => console.error('Cache put failed:', request.url, error));
                    });
                return networkResponse;
            }
        } catch (error) {
            console.log('File not found, falling back to rewrite:', request.url);
        }
        
        // File doesn't exist, rewrite to target
        const rewriteRequest = new Request(rewriteTarget, {
            method: request.method,
            headers: request.headers,
            body: request.body,
            mode: request.mode,
            credentials: request.credentials,
            cache: request.cache,
            redirect: request.redirect,
            referrer: request.referrer
        });
        
        return cacheFirstStrategy(rewriteRequest);
    }
    
    // Handle /nfts/set/* -> rewrite to /nfts/set/index.html if file doesn't exist
    if (pathname.startsWith('/nfts/set/')) {
        return tryStaticOrRewrite('/nfts/set/index.html');
    }
    
    // Handle /@* -> rewrite to /user/index.html if file doesn't exist
    // Note: Bot handling with reverse proxy is not implemented in SW (can't proxy to 127.0.0.1:3000)
    if (pathname.startsWith('/@')) {
        return tryStaticOrRewrite('/user/index.html');
    }
    
    // Handle /me* -> rewrite to /user/index.html
    if (pathname.startsWith('/me')) {
        const rewriteRequest = new Request('/user/index.html', {
            method: request.method,
            headers: request.headers,
            body: request.body,
            mode: request.mode,
            credentials: request.credentials,
            cache: request.cache,
            redirect: request.redirect,
            referrer: request.referrer
        });
        return cacheFirstStrategy(rewriteRequest);
    }
    
    // Handle /vr/@* -> rewrite to /vr/index.html
    if (pathname.startsWith('/vr/@')) {
        const rewriteRequest = new Request('/vr/index.html', {
            method: request.method,
            headers: request.headers,
            body: request.body,
            mode: request.mode,
            credentials: request.credentials,
            cache: request.cache,
            redirect: request.redirect,
            referrer: request.referrer
        });
        return cacheFirstStrategy(rewriteRequest);
    }
    
    // Handle /docs* -> try files in order: {path}, {path}.html, {path}/index.html, fallback to 404.html
    // Note: Different root directory handling not implemented in SW (would need different cache)
    if (pathname.startsWith('/docs')) {
        // Try exact path first
        let cachedResponse = await caches.match(request);
        if (cachedResponse) {
            return cachedResponse;
        }
        
        try {
            let networkResponse = await fetch(request);
            if (networkResponse && networkResponse.ok) {
                const responseToCache = networkResponse.clone();
                caches.open(CACHE_NAME)
                    .then(cache => cache.put(request, responseToCache));
                return networkResponse;
            }
        } catch (error) {
            // Continue to try alternatives
        }
        
        // Try with .html extension
        if (!pathname.endsWith('.html')) {
            const htmlRequest = new Request(pathname + '.html', {
                method: request.method,
                headers: request.headers,
                body: request.body,
                mode: request.mode,
                credentials: request.credentials,
                cache: request.cache,
                redirect: request.redirect,
                referrer: request.referrer
            });
            
            cachedResponse = await caches.match(htmlRequest);
            if (cachedResponse) {
                return cachedResponse;
            }
            
            try {
                let networkResponse = await fetch(htmlRequest);
                if (networkResponse && networkResponse.ok) {
                    const responseToCache = networkResponse.clone();
                    caches.open(CACHE_NAME)
                        .then(cache => cache.put(htmlRequest, responseToCache));
                    return networkResponse;
                }
            } catch (error) {
                // Continue to try alternatives
            }
        }
        
        // Try with /index.html
        if (!pathname.endsWith('/')) {
            const indexRequest = new Request(pathname + '/index.html', {
                method: request.method,
                headers: request.headers,
                body: request.body,
                mode: request.mode,
                credentials: request.credentials,
                cache: request.cache,
                redirect: request.redirect,
                referrer: request.referrer
            });
            
            cachedResponse = await caches.match(indexRequest);
            if (cachedResponse) {
                return cachedResponse;
            }
            
            try {
                let networkResponse = await fetch(indexRequest);
                if (networkResponse && networkResponse.ok) {
                    const responseToCache = networkResponse.clone();
                    caches.open(CACHE_NAME)
                        .then(cache => cache.put(indexRequest, responseToCache));
                    return networkResponse;
                }
            } catch (error) {
                // Continue to fallback
            }
        }
        
        // Fallback to 404.html for docs
        return cacheFirstStrategy(new Request('/404.html', {
            method: request.method,
            headers: request.headers,
            body: request.body,
            mode: request.mode,
            credentials: request.credentials,
            cache: request.cache,
            redirect: request.redirect,
            referrer: request.referrer
        }));
    }
    
    // Handle /dlux/* -> rewrite to /dlux/index.html if file doesn't exist
    // Note: Bot handling with reverse proxy is not implemented in SW
    if (pathname.startsWith('/dlux/')) {
        return tryStaticOrRewrite('/dlux/index.html');
    }
    
    // Handle /blog/* -> rewrite to /blog/index.html if file doesn't exist
    // Note: Bot handling with reverse proxy is not implemented in SW
    if (pathname.startsWith('/blog/')) {
        return tryStaticOrRewrite('/blog/index.html');
    }
    
    // Default cache-first strategy for all other requests
    return cacheFirstStrategy(request);
}

// Cache-first strategy implementation
async function cacheFirstStrategy(request) {
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
        return cachedResponse;
    }

    try {
        const networkResponse = await fetch(request);
        if (!networkResponse || networkResponse.status !== 200) {
            return networkResponse;
        }

        const responseToCache = networkResponse.clone();
        caches.open(CACHE_NAME)
            .then(cache => {
                cache.put(request, responseToCache)
                    .catch(error => console.error('Cache put failed:', request.url, error));
            });

        return networkResponse;
    } catch (error) {
        console.error('Network error for:', request.url, error);
        return new Response(null, { status: 503 }); // Service Unavailable
    }
}

self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        console.log('SKIP_WAITING received, activating now...');
        self.skipWaiting()
            .then(() => {
                console.log('Skip waiting completed, claiming clients...');
                return self.clients.claim();
            })
            .then(() => {
                console.log('Clients claimed, notifying all clients...');
                return self.clients.matchAll({ includeUncontrolled: true, type: 'window' });
            })
            .then(clients => {
                clients.forEach(client => {
                    client.postMessage({ type: 'SW_UPDATED' });
                    console.log('Notified client:', client.id);
                });
            })
            .catch(err => console.error('Skip waiting or claim failed:', err));
    }
});

self.addEventListener("activate", function (event) {
    event.waitUntil(
        Promise.all([
            caches.keys().then(cacheNames => {
                return Promise.all(
                    cacheNames
                        .filter(cacheName => cacheName !== CACHE_NAME)
                        .map(cacheName => {
                            console.log("Deleting cache: " + cacheName);
                            return caches.delete(cacheName);
                        })
                );
            }),
            self.clients.claim()
        ])
        .then(() => {
            return self.clients.matchAll({ includeUncontrolled: true, type: 'window' });
        })
        .then(clients => {
            clients.forEach(client => {
                client.postMessage({ type: 'SW_UPDATED' });
                console.log('Notified client:', client.id);
            });
            
            // Start background caching of important resources after activation
            scheduleBackgroundCache();
        })
        .catch(error => console.error('Activation failed:', error))
    );
});

// NFT script handling
self.addEventListener("message", function (e) {
    const message = e.data, p = e.source;
    switch (message.id) {
        case "callScript":
            callScript(message.o, p);
            break;
        default:
            console.log("SW msg:", message);
    }
});

function callScript(o, p) {
    if (self.nftscripts[o.script] && self.nftscripts[o.script] !== "Loading...") {
        const code = `(//${self.nftscripts[o.script]}\n)("${o.uid ? o.uid : 0}")`;
        const computed = eval(code);
        computed.uid = o.uid || "";
        computed.owner = o.owner || "";
        computed.script = o.script;
        computed.setname = o.set;
        computed.token = o.token;
        p.postMessage(computed);
    } else {
        pullScript(o.script).then(() => callScript(o, p));
    }
}

function pullScript(id) {
    if (self.nftscripts[id] && self.nftscripts[id] !== "Loading...") {
        return Promise.resolve("OK");
    } else if (scriptPromises[id]) {
        return scriptPromises[id];
    } else {
        scriptPromises[id] = fetch(`https://ipfs.dlux.io/ipfs/${id}`)
            .then(response => response.text())
            .then(data => {
                self.nftscripts[id] = data;
                delete scriptPromises[id];
                return "OK";
            })
            .catch(error => {
                console.error('Failed to fetch script:', id, error);
                delete scriptPromises[id];
                throw error;
            });
        return scriptPromises[id];
    }
}