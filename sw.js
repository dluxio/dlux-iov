this.version = "2025.06.04.24";
console.log("SW:" + version + " - online.");
const CACHE_NAME = "sw-cache-v" + version;

// All cacheable files are now managed through self.cacheManifest at the bottom of this file
// This includes critical, important, page-specific, and lazy (previously skipped) files
// The manifest is auto-generated by generate-cache-manifest.sh with checksums and priorities

// Cache management flags
let priorityTwoCached = false;
let backgroundCacheInProgress = false;

self.nftscripts = {};
const scriptPromises = {}; // Store ongoing fetch promises

self.addEventListener("install", function (event) {
    console.log("SW: Installing with checksum-based smart caching...");

    event.waitUntil(
        smartCacheInstall()
            .then(() => {
                console.log("SW: Smart cache installation completed");
                // Skip waiting to activate immediately for faster updates
                return self.skipWaiting();
            })
            .catch(error => {
                console.error('SW: Smart cache installation failed:', error);
                throw error;
            })
    );
});

// Helper function to notify all clients
function notifyClients(message) {
    self.clients.matchAll({ includeUncontrolled: true, type: 'window' })
        .then(clients => {
            clients.forEach(client => {
                client.postMessage(message);
            });
        })
        .catch(error => console.error('Failed to notify clients:', error));
}

// Smart cache installation with checksum comparison
async function smartCacheInstall() {
    const newCache = await caches.open(CACHE_NAME);
    
    // Check if we have a cache manifest with checksums
    if (!self.cacheManifest || !self.cacheManifest.files) {
        console.log("SW: No cache manifest found, skipping installation");
        console.error("SW: self.cacheManifest is required for smart caching");
        return;
    }
    
    console.log(`SW: Smart caching v${self.cacheManifest.version} with ${Object.keys(self.cacheManifest.files).length} files`);
    
    // Get previous cache if it exists
    const oldCacheNames = await caches.keys();
    const oldCacheName = oldCacheNames.find(name => name.startsWith('sw-cache-v') && name !== CACHE_NAME);
    const oldCache = oldCacheName ? await caches.open(oldCacheName) : null;
    
    let transferredFiles = 0;
    let downloadedFiles = 0;
    let totalSize = 0;
    
    // Process files by priority: critical first, then important, then page-specific
    const criticalFiles = Object.entries(self.cacheManifest.files)
        .filter(([url, info]) => info.priority === 'critical');
    const importantFiles = Object.entries(self.cacheManifest.files)
        .filter(([url, info]) => info.priority === 'important');
    const pageSpecificFiles = Object.entries(self.cacheManifest.files)
        .filter(([url, info]) => info.priority === 'page-specific');
    
    // Process critical files first
    console.log("SW: Processing critical files for fast first paint...");
    const criticalStats = await processCacheFiles(criticalFiles, newCache, oldCache, 'critical');
    
    // Schedule important and page-specific files for background processing
    setTimeout(() => {
        Promise.all([
            processCacheFiles(importantFiles, newCache, oldCache, 'important'),
            processCacheFiles(pageSpecificFiles, newCache, oldCache, 'page-specific')
        ]).then(([importantStats, pageStats]) => {
            console.log("SW: Background smart caching completed");
            
            // Calculate total stats
            const totalStats = {
                transferred: (criticalStats.transferred || 0) + (importantStats.transferred || 0) + (pageStats.transferred || 0),
                downloaded: (criticalStats.downloaded || 0) + (importantStats.downloaded || 0) + (pageStats.downloaded || 0)
            };
            
            // Mark priority two as cached to prevent old system from running
            priorityTwoCached = true;
            
            notifyClients({ 
                type: 'SMART_CACHE_COMPLETE',
                data: { stats: totalStats }
            });
        }).catch(error => {
            console.error("SW: Background smart caching failed:", error);
            notifyClients({ type: 'ERROR', data: { message: 'Smart cache failed' } });
        });
    }, 1000);
}

// Process cache files with smart checksum comparison
async function processCacheFiles(fileEntries, newCache, oldCache, priority) {
    let transferredCount = 0;
    let downloadedCount = 0;
    
    for (const [url, fileInfo] of fileEntries) {
        try {
            let needsDownload = true;
            
            // Check if file exists in old cache with same checksum
            if (oldCache) {
                const oldResponse = await oldCache.match(url);
                if (oldResponse) {
                    const oldChecksum = oldResponse.headers.get('x-cache-checksum');
                    if (oldChecksum === fileInfo.checksum) {
                        // Checksums match, transfer from old cache
                        const responseToTransfer = oldResponse.clone();
                        await newCache.put(url, responseToTransfer);
                        transferredCount++;
                        needsDownload = false;
                        console.log(`SW: ✓ Transferred ${url} (checksum: ${fileInfo.checksum.substring(0, 8)}...)`);
                    }
                }
            }
            
            if (needsDownload) {
                // Download new/changed file
                try {
                    const response = await fetch(url);
                    if (response && response.ok) {
                        // Add checksum header for future comparisons
                        const responseToCache = new Response(response.body, {
                            status: response.status,
                            statusText: response.statusText,
                            headers: {
                                ...Object.fromEntries(response.headers.entries()),
                                'x-cache-checksum': fileInfo.checksum,
                                'x-cache-size': fileInfo.size.toString()
                            }
                        });
                        await newCache.put(url, responseToCache);
                        downloadedCount++;
                        console.log(`SW: ⬇ Downloaded ${url} (${formatBytes(fileInfo.size)})`);
                    }
                } catch (fetchError) {
                    console.warn(`SW: Failed to cache ${url}:`, fetchError);
                }
            }
        } catch (error) {
            console.warn(`SW: Error processing ${url}:`, error);
        }
    }
    
    console.log(`SW: ${priority} files - transferred: ${transferredCount}, downloaded: ${downloadedCount}`);
    return { transferred: transferredCount, downloaded: downloadedCount };
}

// Background caching of important resources (fallback for when smart caching is not available)
function scheduleBackgroundCache() {
    if (backgroundCacheInProgress || priorityTwoCached) return;
    
    // Only use fallback caching if no smart cache manifest is available
    if (self.cacheManifest && self.cacheManifest.files) {
        console.log("SW: Smart cache available, skipping fallback background cache");
        return;
    }
    
    backgroundCacheInProgress = true;
    console.log("SW: Using fallback background caching (no smart cache manifest)");

    // Use setTimeout to avoid blocking the install event
    setTimeout(() => {
        cacheImportantResources();
    }, 1000);
}

async function cacheImportantResources() {
    if (priorityTwoCached) return;

    try {
        const cache = await caches.open(CACHE_NAME);
        console.log("SW: Background caching important resources...");

        // Notify clients that caching has started
        self.clients.matchAll({ includeUncontrolled: true, type: 'window' })
            .then(clients => {
                clients.forEach(client => {
                    client.postMessage({ type: 'CACHE_STARTED' });
                });
            })
            .catch(error => console.error('Failed to notify clients of cache start:', error));

        // Fallback caching is no longer needed - all files are managed through cacheManifest
        console.log("SW: Fallback caching disabled - using smart cache manifest only");
        
        priorityTwoCached = true;
        
        // Notify all clients that caching is complete
        self.clients.matchAll({ includeUncontrolled: true, type: 'window' })
            .then(clients => {
                clients.forEach(client => {
                    client.postMessage({ type: 'CACHE_COMPLETE' });
                });
            })
            .catch(error => console.error('Failed to notify clients of cache completion:', error));
    } catch (error) {
        console.error('SW: Background caching failed:', error);

        // Notify clients of caching error
        self.clients.matchAll({ includeUncontrolled: true, type: 'window' })
            .then(clients => {
                clients.forEach(client => {
                    client.postMessage({ type: 'ERROR', data: { message: 'Background caching failed' } });
                });
            })
            .catch(err => console.error('Failed to notify clients of cache error:', err));
    } finally {
        backgroundCacheInProgress = false;
    }
}

// Cache page-specific resources on navigation
async function cachePageResources(pathname) {
    const cache = await caches.open(CACHE_NAME);

    // Get page-specific resources from cacheManifest
    if (!self.cacheManifest || !self.cacheManifest.files) {
        console.log("SW: No cache manifest available for page-specific caching");
        return;
    }

    // Get all page-specific files from the manifest
    const pageSpecificFiles = Object.entries(self.cacheManifest.files)
        .filter(([url, info]) => info.priority === 'page-specific')
        .map(([url, info]) => url);

    // For now, cache all page-specific files when navigating to any page
    // This could be optimized later to be more selective based on pathname
    let resourcesToCache = pageSpecificFiles;

    if (resourcesToCache.length > 0) {
        console.log(`SW: Proactively caching resources for ${pathname}`);
        try {
            // Check which resources aren't already cached
            const uncachedResources = [];
            for (const resource of resourcesToCache) {
                const cached = await cache.match(resource);
                if (!cached) {
                    uncachedResources.push(resource);
                }
            }

            if (uncachedResources.length > 0) {
                // Cache in smaller batches
                const batchSize = 5;
                for (let i = 0; i < uncachedResources.length; i += batchSize) {
                    const batch = uncachedResources.slice(i, i + batchSize);
                    try {
                        await cache.addAll(batch);
                    } catch (error) {
                        console.warn('SW: Some page-specific resources failed to cache:', error);
                    }
                }
                console.log(`SW: Cached ${uncachedResources.length} page-specific resources`);
            }
        } catch (error) {
            console.warn('SW: Page-specific caching failed:', error);
        }
    }
}

self.addEventListener('fetch', function (event) {
    const url = new URL(event.request.url);

    // Trigger page-specific caching for same-origin navigations
    if (url.origin === self.location.origin && event.request.mode === 'navigate') {
        // Don't await this - let it run in background
        cachePageResources(url.pathname).catch(error =>
            console.warn('SW: Page-specific caching failed:', error)
        );
    }

    if (url.hostname === 'api.coingecko.com') {
        event.respondWith(
            caches.open(CACHE_NAME).then(async cache => {
                const request = event.request;
                const CACHE_MAX_AGE_MS = 15 * 60 * 1000; // 15 minutes

                const cachedResponse = await cache.match(request);

                if (cachedResponse) {
                    const timestampHeader = cachedResponse.headers.get('sw-cache-timestamp');
                    if (timestampHeader) {
                        const cachedTime = parseInt(timestampHeader, 10);
                        if (Date.now() - cachedTime < CACHE_MAX_AGE_MS) {
                            return cachedResponse;
                        }
                    }
                }
                try {
                    const networkResponse = await fetch(request);
                    if (networkResponse && networkResponse.ok) {
                        const responseToCache = networkResponse.clone();
                        const newHeaders = new Headers(responseToCache.headers);
                        newHeaders.set('sw-cache-timestamp', Date.now().toString());
                        const body = await responseToCache.arrayBuffer();

                        const cacheableResponse = new Response(body, {
                            status: responseToCache.status,
                            statusText: responseToCache.statusText,
                            headers: newHeaders
                        });

                        cache.put(request, cacheableResponse)
                        return networkResponse
                    } else {
                        if (cachedResponse) {
                            return cachedResponse;
                        }
                        return networkResponse || new Response(JSON.stringify({ error: 'CoinGecko API request failed to fetch and no cache available' }), {
                            status: 503,
                            statusText: 'Service Unavailable',
                            headers: { 'Content-Type': 'application/json' }
                        });
                    }
                } catch (error) {
                    console.error(`SW: Fetch error for ${request.url}:`, error);
                    if (cachedResponse) {
                        return cachedResponse;
                    }
                    return new Response(JSON.stringify({ error: 'CoinGecko API request failed due to network error and no cache available' }), {
                        status: 503,
                        statusText: 'Service Unavailable',
                        headers: { 'Content-Type': 'application/json' }
                    });
                }
            })
        );
        return
    }

    if (url.origin !== self.location.origin) {
        // For specific external resources we want to handle
        if (url.pathname.endsWith('.m4v')) { // MODIFIED: Removed "|| url.hostname === 'api.coingecko.com'"
            event.respondWith(
                fetch(event.request)
                    .catch(error => {
                        console.error('Network error for external resource:', event.request.url, error);
                        return new Response(null, { status: 503 }); // Service Unavailable
                    })
            );
        }
        return; // Let browser handle all other external requests
    }

    // Handle routing rules from Caddyfile for same-origin requests
    event.respondWith(handleRouting(event.request));
});

// Handle routing based on Caddyfile rules
async function handleRouting(request) {
    const url = new URL(request.url);
    const pathname = url.pathname;

    console.log('SW: Handling route:', pathname, 'Full URL:', url.href);

    // Helper function to try serving a static file, fallback to rewrite
    async function tryStaticOrRewrite(rewriteTarget) {
        // First try to get the exact file from cache
        const cachedResponse = await caches.match(request);
        if (cachedResponse) {
            return cachedResponse;
        }

        // Try to fetch the exact file from network
        try {
            const networkResponse = await fetch(request);
            if (networkResponse && networkResponse.ok) {
                // Cache the response
                const responseToCache = networkResponse.clone();
                caches.open(CACHE_NAME)
                    .then(cache => {
                        cache.put(request, responseToCache)
                            .catch(error => console.error('Cache put failed:', request.url, error));
                    });
                return networkResponse;
            }
        } catch (error) {
            console.log('File not found, falling back to rewrite:', request.url);
        }

        // File doesn't exist, rewrite to target
        const rewriteRequest = new Request(rewriteTarget, {
            method: request.method,
            headers: request.headers,
            body: request.method === 'GET' ? null : request.body,
            credentials: request.credentials,
            cache: request.cache,
            redirect: request.redirect,
            referrer: request.referrer
        });

        return cacheFirstStrategy(rewriteRequest);
    }

    // Handle /nfts/set/* -> rewrite to /nfts/set/index.html if file doesn't exist
    if (pathname.startsWith('/nfts/set/')) {
        return tryStaticOrRewrite('/nfts/set/index.html');
    }

    // Handle /@* -> rewrite to /user/index.html if file doesn't exist
    // Note: Bot handling with reverse proxy is not implemented in SW (can't proxy to 127.0.0.1:3000)
    if (pathname.startsWith('/@')) {
        return tryStaticOrRewrite('/user/index.html');
    }

    // Handle /me* -> rewrite to /user/index.html
    if (pathname.startsWith('/me')) {
        console.log('SW: Rewriting /me route to /user/index.html');
        const rewriteRequest = new Request('/user/index.html', {
            method: request.method,
            headers: request.headers,
            body: request.method === 'GET' ? null : request.body,
            credentials: request.credentials,
            cache: request.cache,
            redirect: request.redirect,
            referrer: request.referrer
        });
        return cacheFirstStrategy(rewriteRequest);
    }

    // Handle /vr/@* -> rewrite to /vr/index.html
    if (pathname.startsWith('/vr/@')) {
        console.log('SW: Rewriting /vr/@ route to /vr/index.html');
        const rewriteRequest = new Request('/vr/index.html', {
            method: request.method,
            headers: request.headers,
            body: request.method === 'GET' ? null : request.body,
            credentials: request.credentials,
            cache: request.cache,
            redirect: request.redirect,
            referrer: request.referrer
        });
        return cacheFirstStrategy(rewriteRequest);
    }



    // Handle /dlux/* -> rewrite to /dlux/index.html if file doesn't exist
    // Note: Bot handling with reverse proxy is not implemented in SW
    if (pathname.startsWith('/dlux/')) {
        return tryStaticOrRewrite('/dlux/index.html');
    }

    // Handle /blog/* -> rewrite to /blog/index.html if file doesn't exist
    // Note: Bot handling with reverse proxy is not implemented in SW
    if (pathname.startsWith('/blog/')) {
        return tryStaticOrRewrite('/blog/index.html');
    }

    // Default cache-first strategy for all other requests
    return cacheFirstStrategy(request);
}

// Cache-first strategy implementation
async function cacheFirstStrategy(request) {
    const url = new URL(request.url);
    console.log('SW: Cache-first strategy for:', url.pathname);

    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
        console.log('SW: Serving from cache:', url.pathname);
        return cachedResponse;
    }

    try {
        console.log('SW: Fetching from network:', url.pathname);
        const networkResponse = await fetch(request);

        if (!networkResponse) {
            console.error('SW: No network response for:', url.pathname);
            return new Response('Service Unavailable', { status: 503 });
        }

        if (networkResponse.status !== 200) {
            console.warn('SW: Non-200 response for:', url.pathname, 'Status:', networkResponse.status);
            return networkResponse;
        }

        const responseToCache = networkResponse.clone();
        caches.open(CACHE_NAME)
            .then(cache => {
                cache.put(request, responseToCache)
                    .catch(error => console.error('SW: Cache put failed:', request.url, error));
            });

        console.log('SW: Serving from network and cached:', url.pathname);
        return networkResponse;
    } catch (error) {
        console.error('SW: Network error for:', request.url, error);
        // Try to return a more helpful error page
        return new Response(`
            <html>
                <body>
                    <h1>Service Unavailable</h1>
                    <p>Unable to load ${url.pathname}</p>
                    <p>Error: ${error.message}</p>
                    <p>Please check your connection and try again.</p>
                </body>
            </html>
        `, {
            status: 503,
            statusText: 'Service Unavailable',
            headers: { 'Content-Type': 'text/html' }
        });
    }
}

self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        console.log('SKIP_WAITING received, activating now...');
        self.skipWaiting()
            .then(() => {
                console.log('Skip waiting completed, claiming clients...');
                return self.clients.claim();
            })
            .then(() => {
                console.log('Clients claimed, notifying all clients...');
                return self.clients.matchAll({ includeUncontrolled: true, type: 'window' });
            })
            .then(clients => {
                clients.forEach(client => {
                    client.postMessage({ type: 'SW_UPDATED' });
                    console.log('Notified client:', client.id);
                });
            })
            .catch(err => console.error('Skip waiting or claim failed:', err));
    }
});

self.addEventListener("activate", function (event) {
    event.waitUntil(
        Promise.all([
            caches.keys().then(cacheNames => {
                return Promise.all(
                    cacheNames
                        .filter(cacheName => cacheName !== CACHE_NAME)
                        .map(cacheName => {
                            console.log("Deleting cache: " + cacheName);
                            return caches.delete(cacheName);
                        })
                );
            }),
            self.clients.claim()
        ])
            .then(() => {
                return self.clients.matchAll({ includeUncontrolled: true, type: 'window' });
            })
            .then(clients => {
                clients.forEach(client => {
                    client.postMessage({ type: 'SW_UPDATED' });
                    console.log('Notified client:', client.id);
                });

                // Start background caching of important resources after activation (fallback only)
                scheduleBackgroundCache();
            })
            .catch(error => console.error('Activation failed:', error))
    );
});

// NFT script handling
self.addEventListener("message", function (e) {
    const message = e.data, p = e.source;
    switch (message.id) {
        case "callScript":
            callScript(message.o, p);
            break;
        default:
            console.log("SW msg:", message);
    }
});

function callScript(o, p) {
    if (self.nftscripts[o.script] && self.nftscripts[o.script] !== "Loading...") {
        const code = `(//${self.nftscripts[o.script]}\n)("${o.uid ? o.uid : 0}")`;
        const computed = eval(code);
        computed.uid = o.uid || "";
        computed.owner = o.owner || "";
        computed.script = o.script;
        computed.setname = o.set;
        computed.token = o.token;
        p.postMessage(computed);
    } else {
        pullScript(o.script).then(() => callScript(o, p));
    }
}

function pullScript(id) {
    if (self.nftscripts[id] && self.nftscripts[id] !== "Loading...") {
        return Promise.resolve("OK");
    } else if (scriptPromises[id]) {
        return scriptPromises[id];
    } else {
        scriptPromises[id] = fetch(`https://ipfs.dlux.io/ipfs/${id}`)
            .then(response => response.text())
            .then(data => {
                self.nftscripts[id] = data;
                delete scriptPromises[id];
                return "OK";
            })
            .catch(error => {
                console.error('Failed to fetch script:', id, error);
                delete scriptPromises[id];
                throw error;
            });
            return scriptPromises[id];
}

// Helper function to format bytes (duplicate of existing formatBytes for consistency)
function formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
}
// Cache manifest with checksums - auto-generated
self.cacheManifest = 
{
  "version": "2025.06.04.13",
  "generated": "2025-06-04T20:04:43Z",
  "files": {
    "/index.html": {
      "checksum": "34182fdc1ab540a6efb068ab2fc668e4",
      "size": 27470,
      "priority": "critical"
    },
    "/css/custom.css": {
      "checksum": "0935e3634304accec4568858a75c6b92",
      "size": 329461,
      "priority": "critical"
    },
    "/js/vue.esm-browser.js": {
      "checksum": "232af68f6551a87a4732981749dd5265",
      "size": 531704,
      "priority": "critical"
    },
    "/js/v3-nav.js": {
      "checksum": "9ed88bb30efaa4f756d54b4c507b14e2",
      "size": 172158,
      "priority": "critical"
    },
    "/sw.js": {
      "checksum": "ecfd661b54bb0542090c9e3dd34aadec",
      "size": 94890,
      "priority": "critical"
    }
  }
}
;
