this.version = "2025.07.01.13";
console.log("SW:" + version + " - online.");
const CACHE_NAME = "sw-cache-v" + version;

// All cacheable files are now managed through self.cacheManifest at the bottom of this file
// This includes critical, important, page-specific, and lazy (previously skipped) files
// The manifest is auto-generated by generate-cache-manifest.sh with checksums and priorities

// Cache management flags
let priorityTwoCached = false;
let backgroundCacheInProgress = false;

self.addEventListener("install", function (event) {

    event.waitUntil(
        smartCacheInstall()
            .then(() => {
                // Skip waiting to activate immediately for faster updates
                return self.skipWaiting();
            })
            .catch(error => {
                console.error('SW: Smart cache installation failed:', error);
                throw error;
            })
    );
});

// Helper function to notify all clients
function notifyClients(message) {
    self.clients.matchAll({ includeUncontrolled: true, type: 'window' })
        .then(clients => {
            clients.forEach(client => {
                client.postMessage(message);
            });
        })
        .catch(error => console.error('Failed to notify clients:', error));
}

// Smart cache installation with checksum comparison
async function smartCacheInstall() {
    const newCache = await caches.open(CACHE_NAME);
    
    // Check if we have a cache manifest with checksums
    if (!self.cacheManifest || !self.cacheManifest.files) {
        console.error("SW: self.cacheManifest is required for smart caching");
        return;
    }
    // Get previous cache if it exists
    const oldCacheNames = await caches.keys();
    const oldCacheName = oldCacheNames.find(name => name.startsWith('sw-cache-v') && name !== CACHE_NAME);
    const oldCache = oldCacheName ? await caches.open(oldCacheName) : null;
    
    // Process files by priority: critical first, then important, then page-specific
    const criticalFiles = Object.entries(self.cacheManifest.files)
        .filter(([url, info]) => info.priority === 'critical');
    const importantFiles = Object.entries(self.cacheManifest.files)
        .filter(([url, info]) => info.priority === 'important');
    const pageSpecificFiles = Object.entries(self.cacheManifest.files)
        .filter(([url, info]) => info.priority === 'page-specific');
    
    // Process critical files first
    const criticalStats = await processCacheFiles(criticalFiles, newCache, oldCache, 'critical');
    
    // Schedule important and page-specific files for background processing
    setTimeout(() => {
        Promise.all([
            processCacheFiles(importantFiles, newCache, oldCache, 'important'),
            processCacheFiles(pageSpecificFiles, newCache, oldCache, 'page-specific')
        ]).then(([importantStats, pageStats]) => {
            
            // Calculate total stats
            const totalStats = {
                transferred: (criticalStats.transferred || 0) + (importantStats.transferred || 0) + (pageStats.transferred || 0),
                downloaded: (criticalStats.downloaded || 0) + (importantStats.downloaded || 0) + (pageStats.downloaded || 0)
            };
            
            // Mark priority two as cached to prevent old system from running
            priorityTwoCached = true;
            
            notifyClients({ 
                type: 'SMART_CACHE_COMPLETE',
                data: { stats: totalStats }
            });
        }).catch(error => {
            console.error("SW: Background smart caching failed:", error);
            notifyClients({ type: 'ERROR', data: { message: 'Smart cache failed' } });
        });
    }, 1000);
}

// Process cache files with smart checksum comparison
async function processCacheFiles(fileEntries, newCache, oldCache, priority) {
    let transferredCount = 0;
    let downloadedCount = 0;
    
    for (const [url, fileInfo] of fileEntries) {
        try {
            let needsDownload = true;
            
            // Check if file exists in old cache with same checksum
            if (oldCache) {
                const oldResponse = await oldCache.match(url);
                if (oldResponse) {
                    const oldChecksum = oldResponse.headers.get('x-cache-checksum');
                    if (oldChecksum === fileInfo.checksum) {
                        // Checksums match, transfer from old cache
                        const responseToTransfer = oldResponse.clone();
                        await newCache.put(url, responseToTransfer);
                        transferredCount++;
                        needsDownload = false;
                    }
                }
            }
            
            if (needsDownload) {
                // Download new/changed file
                try {
                    const response = await fetch(url);
                    if (response && response.ok) {
                        // Add checksum header for future comparisons
                        const responseToCache = new Response(response.body, {
                            status: response.status,
                            statusText: response.statusText,
                            headers: {
                                ...Object.fromEntries(response.headers.entries()),
                                'x-cache-checksum': fileInfo.checksum,
                                'x-cache-size': fileInfo.size.toString()
                            }
                        });
                        await newCache.put(url, responseToCache);
                        downloadedCount++;
                    }
                } catch (fetchError) {
                    console.warn(`SW: Failed to cache ${url}:`, fetchError);
                }
            }
        } catch (error) {
            console.warn(`SW: Error processing ${url}:`, error);
        }
    }
    return { transferred: transferredCount, downloaded: downloadedCount };
}

// Background caching of important resources (fallback for when smart caching is not available)
function scheduleBackgroundCache() {
    if (backgroundCacheInProgress || priorityTwoCached) return;
    
    // Only use fallback caching if no smart cache manifest is available
    if (self.cacheManifest && self.cacheManifest.files) {
        return;
    }
    
    backgroundCacheInProgress = true;

    // Use setTimeout to avoid blocking the install event
    setTimeout(() => {
        cacheImportantResources();
    }, 1000);
}

async function cacheImportantResources() {
    if (priorityTwoCached) return;

    try {
        const cache = await caches.open(CACHE_NAME);

        // Notify clients that caching has started
        self.clients.matchAll({ includeUncontrolled: true, type: 'window' })
            .then(clients => {
                clients.forEach(client => {
                    client.postMessage({ type: 'CACHE_STARTED' });
                });
            })
            .catch(error => console.error('Failed to notify clients of cache start:', error));

        // Fallback caching is no longer needed - all files are managed through cacheManifest
        
        priorityTwoCached = true;
        
        // Notify all clients that caching is complete
        self.clients.matchAll({ includeUncontrolled: true, type: 'window' })
            .then(clients => {
                clients.forEach(client => {
                    client.postMessage({ type: 'CACHE_COMPLETE' });
                });
            })
            .catch(error => console.error('Failed to notify clients of cache completion:', error));
    } catch (error) {
        console.error('SW: Background caching failed:', error);

        // Notify clients of caching error
        self.clients.matchAll({ includeUncontrolled: true, type: 'window' })
            .then(clients => {
                clients.forEach(client => {
                    client.postMessage({ type: 'ERROR', data: { message: 'Background caching failed' } });
                });
            })
            .catch(err => console.error('Failed to notify clients of cache error:', err));
    } finally {
        backgroundCacheInProgress = false;
    }
}

// Cache page-specific resources on navigation
async function cachePageResources(pathname) {
    const cache = await caches.open(CACHE_NAME);

    // Get page-specific resources from cacheManifest
    if (!self.cacheManifest || !self.cacheManifest.files) {
        return;
    }

    // Get all page-specific files from the manifest
    const pageSpecificFiles = Object.entries(self.cacheManifest.files)
        .filter(([url, info]) => info.priority === 'page-specific')
        .map(([url, info]) => url);

    // For now, cache all page-specific files when navigating to any page
    // This could be optimized later to be more selective based on pathname
    let resourcesToCache = pageSpecificFiles;

    if (resourcesToCache.length > 0) {
        try {
            // Check which resources aren't already cached
            const uncachedResources = [];
            for (const resource of resourcesToCache) {
                const cached = await cache.match(resource);
                if (!cached) {
                    uncachedResources.push(resource);
                }
            }

            if (uncachedResources.length > 0) {
                // Cache in smaller batches
                const batchSize = 5;
                for (let i = 0; i < uncachedResources.length; i += batchSize) {
                    const batch = uncachedResources.slice(i, i + batchSize);
                    try {
                        await cache.addAll(batch);
                    } catch (error) {
                        console.warn('SW: Some page-specific resources failed to cache:', error);
                    }
                }
            }
        } catch (error) {
            console.warn('SW: Page-specific caching failed:', error);
        }
    }
}

self.addEventListener('fetch', function (event) {
    const url = new URL(event.request.url);

    // Trigger page-specific caching for same-origin navigations
    if (url.origin === self.location.origin && event.request.mode === 'navigate') {
        // Don't await this - let it run in background
        cachePageResources(url.pathname).catch(error =>
            console.warn('SW: Page-specific caching failed:', error)
        );
    }

    if (url.hostname === 'api.coingecko.com') {
        event.respondWith(
            caches.open(CACHE_NAME).then(async cache => {
                const request = event.request;
                const CACHE_MAX_AGE_MS = 15 * 60 * 1000; // 15 minutes

                const cachedResponse = await cache.match(request);

                if (cachedResponse) {
                    const timestampHeader = cachedResponse.headers.get('sw-cache-timestamp');
                    if (timestampHeader) {
                        const cachedTime = parseInt(timestampHeader, 10);
                        if (Date.now() - cachedTime < CACHE_MAX_AGE_MS) {
                            return cachedResponse;
                        }
                    }
                }
                try {
                    const networkResponse = await fetch(request);
                    if (networkResponse && networkResponse.ok) {
                        const responseToCache = networkResponse.clone();
                        const newHeaders = new Headers(responseToCache.headers);
                        newHeaders.set('sw-cache-timestamp', Date.now().toString());
                        const body = await responseToCache.arrayBuffer();

                        const cacheableResponse = new Response(body, {
                            status: responseToCache.status,
                            statusText: responseToCache.statusText,
                            headers: newHeaders
                        });

                        cache.put(request, cacheableResponse)
                        return networkResponse
                    } else {
                        if (cachedResponse) {
                            return cachedResponse;
                        }
                        return networkResponse || new Response(JSON.stringify({ error: 'CoinGecko API request failed to fetch and no cache available' }), {
                            status: 503,
                            statusText: 'Service Unavailable',
                            headers: { 'Content-Type': 'application/json' }
                        });
                    }
                } catch (error) {
                    console.error(`SW: Fetch error for ${request.url}:`, error);
                    if (cachedResponse) {
                        return cachedResponse;
                    }
                    return new Response(JSON.stringify({ error: 'CoinGecko API request failed due to network error and no cache available' }), {
                        status: 503,
                        statusText: 'Service Unavailable',
                        headers: { 'Content-Type': 'application/json' }
                    });
                }
            })
        );
        return
    }

    if (url.origin !== self.location.origin) {
        // For specific external resources we want to handle
        if (url.pathname.endsWith('.m4v')) { // MODIFIED: Removed "|| url.hostname === 'api.coingecko.com'"
            event.respondWith(
                fetch(event.request)
                    .catch(error => {
                        console.error('Network error for external resource:', event.request.url, error);
                        return new Response(null, { status: 503 }); // Service Unavailable
                    })
            );
        }
        return; // Let browser handle all other external requests
    }

    // Handle routing rules from Caddyfile for same-origin requests
    event.respondWith(handleRouting(event.request));
});

// Handle routing based on Caddyfile rules
async function handleRouting(request) {
    const url = new URL(request.url);
    const pathname = url.pathname;

    // Helper function to try serving a static file, fallback to rewrite
    async function tryStaticOrRewrite(rewriteTarget) {
        // First try to get the exact file from cache
        const cachedResponse = await caches.match(request);
        if (cachedResponse) {
            return cachedResponse;
        }

        // Try to fetch the exact file from network
        try {
            const networkResponse = await fetch(request);
            if (networkResponse && networkResponse.ok) {
                // Cache the response
                const responseToCache = networkResponse.clone();
                caches.open(CACHE_NAME)
                    .then(cache => {
                        cache.put(request, responseToCache)
                            .catch(error => console.error('Cache put failed:', request.url, error));
                    });
                return networkResponse;
            }
        } catch (error) {
        }

        // File doesn't exist, rewrite to target
        const rewriteRequest = new Request(rewriteTarget, {
            method: request.method,
            headers: request.headers,
            body: request.method === 'GET' ? null : request.body,
            credentials: request.credentials,
            cache: request.cache,
            redirect: request.redirect,
            referrer: request.referrer
        });

        return cacheFirstStrategy(rewriteRequest);
    }

    // Handle /nfts/set/* -> rewrite to /nfts/set/index.html if file doesn't exist
    if (pathname.startsWith('/nfts/set/')) {
        return tryStaticOrRewrite('/nfts/set/index.html');
    }

    // Handle /@* -> rewrite to /user/index.html if file doesn't exist
    // Note: Bot handling with reverse proxy is not implemented in SW (can't proxy to 127.0.0.1:3000)
    if (pathname.startsWith('/@')) {
        return tryStaticOrRewrite('/user/index.html');
    }

    // Handle /me* -> rewrite to /user/index.html
    if (pathname.startsWith('/me')) {
        const rewriteRequest = new Request('/user/index.html', {
            method: request.method,
            headers: request.headers,
            body: request.method === 'GET' ? null : request.body,
            credentials: request.credentials,
            cache: request.cache,
            redirect: request.redirect,
            referrer: request.referrer
        });
        return cacheFirstStrategy(rewriteRequest);
    }

    // Handle /vr/@* -> rewrite to /vr/index.html
    if (pathname.startsWith('/vr/@')) {
        const rewriteRequest = new Request('/vr/index.html', {
            method: request.method,
            headers: request.headers,
            body: request.method === 'GET' ? null : request.body,
            credentials: request.credentials,
            cache: request.cache,
            redirect: request.redirect,
            referrer: request.referrer
        });
        return cacheFirstStrategy(rewriteRequest);
    }



    // Handle /dlux/* -> rewrite to /dlux/index.html if file doesn't exist
    // Note: Bot handling with reverse proxy is not implemented in SW
    if (pathname.startsWith('/dlux/')) {
        return tryStaticOrRewrite('/dlux/index.html');
    }

    // Handle /blog/* -> rewrite to /blog/index.html if file doesn't exist
    // Note: Bot handling with reverse proxy is not implemented in SW
    if (pathname.startsWith('/blog/')) {
        return tryStaticOrRewrite('/blog/index.html');
    }

    // Handle /proposal/<id> -> rewrite to /proposals/index.html if file doesn't exist
    // This allows direct links like /proposal/123 to work with the proposals page
    if (pathname.startsWith('/proposal/')) {
        return tryStaticOrRewrite('/proposals/index.html');
    }

    // Default cache-first strategy for all other requests
    return cacheFirstStrategy(request);
}

// Cache-first strategy implementation
async function cacheFirstStrategy(request) {
    const url = new URL(request.url);

    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
        return cachedResponse;
    }

    try {
        const networkResponse = await fetch(request);

        if (!networkResponse) {
            console.error('SW: No network response for:', url.pathname);
            return new Response('Service Unavailable', { status: 503 });
        }

        if (networkResponse.status !== 200) {
            console.warn('SW: Non-200 response for:', url.pathname, 'Status:', networkResponse.status);
            return networkResponse;
        }

        const responseToCache = networkResponse.clone();
        caches.open(CACHE_NAME)
            .then(cache => {
                cache.put(request, responseToCache)
                    .catch(error => console.error('SW: Cache put failed:', request.url, error));
            });

        return networkResponse;
    } catch (error) {
        console.error('SW: Network error for:', request.url, error);
        // Try to return a more helpful error page
        return new Response(`
            <html>
                <body>
                    <h1>Service Unavailable</h1>
                    <p>Unable to load ${url.pathname}</p>
                    <p>Error: ${error.message}</p>
                    <p>Please check your connection and try again.</p>
                </body>
            </html>
        `, {
            status: 503,
            statusText: 'Service Unavailable',
            headers: { 'Content-Type': 'text/html' }
        });
    }
}

self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting()
            .then(() => {
                return self.clients.claim();
            })
            .then(() => {
                return self.clients.matchAll({ includeUncontrolled: true, type: 'window' });
            })
            .then(clients => {
                clients.forEach(client => {
                    client.postMessage({ type: 'SW_UPDATED' });
                });
            })
            .catch(err => console.error('Skip waiting or claim failed:', err));
    }
});

self.addEventListener("activate", function (event) {
    event.waitUntil(
        Promise.all([
            caches.keys().then(cacheNames => {
                return Promise.all(
                    cacheNames
                        .filter(cacheName => cacheName !== CACHE_NAME)
                        .map(cacheName => {
                            return caches.delete(cacheName);
                        })
                );
            }),
            self.clients.claim()
        ])
            .then(() => {
                return self.clients.matchAll({ includeUncontrolled: true, type: 'window' });
            })
            .then(clients => {
                clients.forEach(client => {
                    client.postMessage({ type: 'SW_UPDATED' });
                });

                // Start background caching of important resources after activation (fallback only)
                scheduleBackgroundCache();
            })
            .catch(error => console.error('Activation failed:', error))
    );
});

// NFT script handling has been moved to nft-script-executor.js for security
// Service worker no longer executes arbitrary user scripts

// Helper function to format bytes
function formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// Cache manifest with checksums - auto-generated
self.cacheManifest = 
{
  "version": "2025.07.01.13",
  "generated": "2025-07-01T20:03:09Z",
  "files": {
    "/js/scene.js": {
      "checksum": "aaed69b3bd0a5b44f45e4b3b3f773510",
      "size": 53733,
      "priority": "important"
    },
    "/js/session.js": {
      "checksum": "19fe354a509a25a48a47ae622f4c998e",
      "size": 48412,
      "priority": "important"
    },
    "/js/setcard.js": {
      "checksum": "a2f10e9bed812046f0d49a8a6a339d6f",
      "size": 2890,
      "priority": "important"
    },
    "/js/showdown.js": {
      "checksum": "c619f8b780850eff22845d1091cfa776",
      "size": 3760,
      "priority": "important"
    },
    "/js/simple-field-editor.js": {
      "checksum": "68b87c94d41b38740f445068e1188c2f",
      "size": 6226,
      "priority": "important"
    },
    "/js/spk-js.js": {
      "checksum": "f5907a46fadd42a17504c9aa6a4978b8",
      "size": 564485,
      "priority": "important"
    },
    "/js/spk-wallet.js": {
      "checksum": "df8d471e90bfebcb26298de1553f6417",
      "size": 70838,
      "priority": "important"
    },
    "/js/spkdrive.js": {
      "checksum": "8920e91980ed7d3e05acacb6c181c74b",
      "size": 84576,
      "priority": "important"
    },
    "/js/spkvue.js": {
      "checksum": "99073aee13e303e83415618eaa6dfbdb",
      "size": 92106,
      "priority": "important"
    },
    "/js/standard-modal.js": {
      "checksum": "5293322d7f75e2e2f70eb203c644230d",
      "size": 7356,
      "priority": "important"
    },
    "/js/stwidget.js": {
      "checksum": "0b8f564f8fc83e2587d7cdd557330753",
      "size": 25863,
      "priority": "important"
    },
    "/js/sw-monitor.js": {
      "checksum": "b9399cf964376bb2b7c2d2426950a9f1",
      "size": 36524,
      "priority": "important"
    },
    "/js/tagify.min.js": {
      "checksum": "245e4e1b9c956dbebd6b52a595eabd79",
      "size": 59697,
      "priority": "important"
    },
    "/js/tagifyvue.js": {
      "checksum": "8c083377956e9a936f47a35f45afc951",
      "size": 1127,
      "priority": "important"
    },
    "/js/tiptap-collaboration.bundle.js": {
      "checksum": "c44c3726815381d3b93b6933f9a3eb8d",
      "size": 2236966,
      "priority": "important"
    },
    "/js/tiptap-editor-with-file-menu.js": {
      "checksum": "7c6dad8ccec7bea9c58d1724e005da9f",
      "size": 725418,
      "priority": "important"
    },
    "/js/tiptap-editor.js": {
      "checksum": "f96826534f8ff1d4edd88a6aca40deeb",
      "size": 19217,
      "priority": "important"
    },
    "/js/tiptap-file-manager.js": {
      "checksum": "e3a24394bea2f379796abfc85a9b7c47",
      "size": 39205,
      "priority": "important"
    },
    "/js/toastvue.js": {
      "checksum": "15a042f49546393a84afe492cbe516d3",
      "size": 2374,
      "priority": "important"
    },
    "/js/trading-vue.min.js": {
      "checksum": "6e6bb2f8dd6f94e2c8656759eafc1a26",
      "size": 264037,
      "priority": "important"
    },
    "/js/upload-everywhere.js": {
      "checksum": "a36246a6149c569f08b4cd7a286c843b",
      "size": 62355,
      "priority": "important"
    },
    "/js/uploadvue-dd.js": {
      "checksum": "15f9d245846ef2bfc53bc9eb8bdfb3a9",
      "size": 143763,
      "priority": "important"
    },
    "/js/uploadvue.js": {
      "checksum": "a24c372511a3865e52d1194b8af5bfac",
      "size": 63528,
      "priority": "important"
    },
    "/js/uuidv.js": {
      "checksum": "e64fbbb49c9b48c9fb15e778de8d86ad",
      "size": 1105,
      "priority": "important"
    },
    "/js/v3-app.js": {
      "checksum": "4d7919c210198f0ac40a9f92a69e42d4",
      "size": 46537,
      "priority": "important"
    },
    "/js/v3-dex.js": {
      "checksum": "e4615048077bf0346e5be62a65600d20",
      "size": 49482,
      "priority": "important"
    },
    "/js/v3-hub.js": {
      "checksum": "f47a413f713e91899f9384c02767f2e1",
      "size": 88675,
      "priority": "important"
    },
    "/js/v3-index.js": {
      "checksum": "1e7ee27dde2b53c3c0596e8ed6d9f987",
      "size": 191632,
      "priority": "important"
    },
    "/js/v3-nfts.js": {
      "checksum": "af303885b3fea57983518ccffca8c8c4",
      "size": 127852,
      "priority": "important"
    },
    "/js/v3-qr.js": {
      "checksum": "507d3d19db9c15dfabb4c3c7dd61bf2a",
      "size": 131136,
      "priority": "important"
    },
    "/js/v3-user.js": {
      "checksum": "ba874cc7a183b1aed09f959ef94286af",
      "size": 282960,
      "priority": "important"
    },
    "/js/vote.js": {
      "checksum": "951ba298f73aa36777cb938de3081334",
      "size": 6129,
      "priority": "important"
    },
    "/js/voting-modal.js": {
      "checksum": "10fae48422e8e57ca87422eeeae572e2",
      "size": 7220,
      "priority": "important"
    },
    "/js/vrvue.js": {
      "checksum": "31e8b69c9bee400abf4603e754e600e3",
      "size": 44273,
      "priority": "important"
    },
    "/js/vueme.js": {
      "checksum": "17b7a8148f0850d12a53f1c587e6451d",
      "size": 149535,
      "priority": "important"
    },
    "/js/vueqr.js": {
      "checksum": "e5e2b75ee9fdc510a95b5d6de0c3e415",
      "size": 18813,
      "priority": "important"
    },
    "/js/watchers-common.js": {
      "checksum": "44cc578056cb32138f1a99d613a12633",
      "size": 407,
      "priority": "important"
    },
    "/lang/en.js": {
      "checksum": "a613800bae0e1b2e73add8f719340272",
      "size": 5689,
      "priority": "important"
    },
    "/mint/index.html": {
      "checksum": "6af3134b0368a9ac54dacdf2ab491d9f",
      "size": 4255,
      "priority": "important"
    },
    "/new/360-gallery/index-expanded.html": {
      "checksum": "b679848cec470474e4bc5aa63340b93d",
      "size": 16655,
      "priority": "important"
    },
    "/new/360-gallery/index.html": {
      "checksum": "bb0a1558c7cf973b389ea1b22f0e3f49",
      "size": 10245,
      "priority": "important"
    },
    "/new/advanced/index.html": {
      "checksum": "ce30ccec87a967de6103af2d3e583464",
      "size": 34006,
      "priority": "important"
    },
    "/new/index.html": {
      "checksum": "8beeb1516d2f5cdcbe151c4653e5018a",
      "size": 113839,
      "priority": "important"
    },
    "/new/token/index.html": {
      "checksum": "a687fbc86f8674d8b8bbdae0d25902c7",
      "size": 45307,
      "priority": "important"
    },
    "/nfts/create/example1.html": {
      "checksum": "edb083626d86e8b1bc69d38ca24915a8",
      "size": 2471,
      "priority": "important"
    },
    "/nfts/create/example2.html": {
      "checksum": "de98570a80f08f2c0260f72f002d0d9b",
      "size": 7898,
      "priority": "important"
    },
    "/nfts/create/index.html": {
      "checksum": "e2b47a24a25d77dcafc5a718e8990039",
      "size": 76931,
      "priority": "important"
    },
    "/nfts/index.html": {
      "checksum": "4e9b3045398f83dd32ba0e35e6883ca6",
      "size": 59238,
      "priority": "important"
    },
    "/nfts/old.html": {
      "checksum": "aeec88d5f54b6d086e6a850672349713",
      "size": 120053,
      "priority": "important"
    },
    "/nfts/set/index.html": {
      "checksum": "010a87a8d872fe7dfea46365944fe25f",
      "size": 43222,
      "priority": "important"
    },
    "/nfts/sets/index.html": {
      "checksum": "98c503b96638bfc0df8480e5d3dae619",
      "size": 9932,
      "priority": "important"
    },
    "/node/index.html": {
      "checksum": "1201263dae69cc6be1dbe6873c17b66e",
      "size": 12978,
      "priority": "important"
    },
    "/open.html": {
      "checksum": "902b0c3c4b34e27f0df076329353b481",
      "size": 5699,
      "priority": "important"
    },
    "/open/index.html": {
      "checksum": "14f053cf793e6b6d9a08ab1ccc8b41d4",
      "size": 5426,
      "priority": "important"
    },
    "/qr/index.html": {
      "checksum": "fb6b6d6ec2036bc1dd3859c46fee1499",
      "size": 70757,
      "priority": "important"
    },
    "/reg-sw.js": {
      "checksum": "ac49a51d2ade0da285354d68c38d1d32",
      "size": 7300,
      "priority": "important"
    },
    "/src/collaboration-bundle.js": {
      "checksum": "3fb1c80063e520fd82fea43be784d4bf",
      "size": 4315,
      "priority": "important"
    },
    "/storage/index.html": {
      "checksum": "f815c9c160305a0e993f937a4bd22e4a",
      "size": 12414,
      "priority": "important"
    },
    "/update.html": {
      "checksum": "95bad8ba0857205117ee5e96b08374d9",
      "size": 11375,
      "priority": "important"
    },
    "/update/index.html": {
      "checksum": "042f265f155fa2cf37f5a2cc888dcd15",
      "size": 30802,
      "priority": "important"
    },
    "/user/detailmodal.html": {
      "checksum": "262ab96e38f539f099642c426038e677",
      "size": 88809,
      "priority": "important"
    },
    "/user/index.html": {
      "checksum": "ee09580bb6811041c736bd5ae7cf4ddc",
      "size": 302425,
      "priority": "important"
    },
    "/vid/stills/blue_dust.jpg": {
      "checksum": "9048079c05ff24442ab88599d7e8920f",
      "size": 63175,
      "priority": "important"
    },
    "/vid/stills/connected_dots.jpg": {
      "checksum": "48953804461101ec1d484b86193d9463",
      "size": 627998,
      "priority": "important"
    },
    "/vid/stills/data_lake.jpg": {
      "checksum": "9330f312da73d45ae0c6d503ebaa35aa",
      "size": 452432,
      "priority": "important"
    },
    "/vid/stills/floating_abstract.jpg": {
      "checksum": "b57ba5c015102610c3f1844c79d432e3",
      "size": 274779,
      "priority": "important"
    },
    "/vid/stills/glowing_hexagon.jpg": {
      "checksum": "c4c67dd6fe719ebd2b56cc2d6a66157e",
      "size": 260964,
      "priority": "important"
    },
    "/vid/stills/gold_wave.jpg": {
      "checksum": "1b610f7ec6798a0c2ef1215791f49f88",
      "size": 521372,
      "priority": "important"
    },
    "/vid/stills/orange_cube.jpg": {
      "checksum": "3917fc5c39d416fc084c46d06c480a4b",
      "size": 631596,
      "priority": "important"
    },
    "/vr/index.html": {
      "checksum": "af23926e6aa73e55a7d853f014dde3d3",
      "size": 89688,
      "priority": "important"
    },
    "/vr/vue.html": {
      "checksum": "6a79a38b2ea49ca30ff547563f9f1efd",
      "size": 1218,
      "priority": "important"
    },
    "/wallet-example.html": {
      "checksum": "86d0014930a60bba3bb4007f63c3a5a6",
      "size": 26417,
      "priority": "important"
    },
    "/webpack.config.js": {
      "checksum": "273ac7907252d9c47389428022d1e912",
      "size": 854,
      "priority": "important"
    },
    "/playground/env_thumbs/volcano.png": {
      "checksum": "651fe82ed29f36db7d40f8b2cf207b45",
      "size": 141300,
      "priority": "page-specific"
    },
    "/playground/env_thumbs/yavapai.png": {
      "checksum": "2da358421be2ed384564de674057084a",
      "size": 163708,
      "priority": "page-specific"
    },
    "/playground/fogworking.html": {
      "checksum": "b67f8e095072c32c5b59c9f0a66b2adb",
      "size": 166798,
      "priority": "page-specific"
    },
    "/playground/index-monaco-fixed.html": {
      "checksum": "acedc1f1736c5e3124b1c6db6438a5c9",
      "size": 126951,
      "priority": "page-specific"
    },
    "/playground/index-monaco.html": {
      "checksum": "2bdebde35f52a3dfdd9ca75d35d4671a",
      "size": 69233,
      "priority": "page-specific"
    },
    "/playground/index.html": {
      "checksum": "575f56ba019b1780f56f116799e7648f",
      "size": 48598,
      "priority": "page-specific"
    },
    "/playground/last-try.html": {
      "checksum": "a64809066d4ff41d60aebe9a57d17b72",
      "size": 7021,
      "priority": "page-specific"
    },
    "/playground/new.html": {
      "checksum": "503b8d7cc8ca7a145a6b3680d89aaa51",
      "size": 21317,
      "priority": "page-specific"
    },
    "/packages/core/package/dist/umd/ffmpeg-core.js": {
      "checksum": "no-hash-symlink",
      "size": 0,
      "priority": "lazy"
    },
    "/packages/ffmpeg/package/dist/umd/ffmpeg-core.wasm": {
      "checksum": "no-hash-symlink",
      "size": 0,
      "priority": "lazy"
    }
  }
}
;
