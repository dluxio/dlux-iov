<!DOCTYPE html>
<html>

<head>
    <title>DLUX Scene Builder</title>
    <script src="/js/aframe.min.js"></script>
    <link rel="stylesheet" href="/css/codemirror.min.css">
    <link rel="stylesheet" href="/css/codemirror-monokai.min.css">
    <script src="/js/codemirror.min.js"></script>
    <script src="/js/codemirror-xml.min.js"></script>
    <script type="module" src="/js/model-viewer.min.js"></script>

    <style>
        /* Update CSS rules to use A-Frame's class */
        body.aframe-inspector-opened .sidebar,
        body.aframe-inspector-opened .toolbar {
            display: none !important;
        }

        body:not(.aframe-inspector-opened) .sidebar,
        body:not(.aframe-inspector-opened) .toolbar {
            display: block;
        }

        body:not(.aframe-inspector-opened) .toggle-edit {
            display: none;
        }

        body.aframe-inspector-opened .scene-container {
            margin-left: 0 !important;
            width: 100% !important;
        }

        body {
            margin: 0;
        }

        .sponsor-btn {
            display: none !important;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 200px;
            background: #1B1B1B;
            padding: 15px;
            overflow-y: auto;
            color: #fff;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .scene-container {
            flex: 1;
            position: relative;
        }

        .toolbar {
            padding: 10px;
            background: #1B1B1B;
        }

        .hidden {
            display: none;
        }

        #asset-preview {
            max-width: 100%;
            margin-top: 10px;
        }

        .CodeMirror {
            height: 100%;
            font-size: 14px;
        }


        #scene {
            width: 100%;
            height: 100%;
        }

        #code-panel {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            display: none;
        }

        /* Hide the default file input text */
        input[type="file"] {
            color: transparent;
            width: 90px;
            /* Adjust width to only show the button */
        }

        /* Show the "Choose File" button text */
        input[type="file"]::-webkit-file-upload-button {
            visibility: visible;
            color: initial;
        }

        /* Hide the selected filename */
        input[type="file"]::file-selector-button {
            color: initial;
        }

        .asset-preview {
            width: 100%;
            max-height: 150px;
            margin-bottom: 5px;
            display: block;
        }

        .asset-container {
            margin-bottom: 15px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .model-preview {
            width: 100%;
            height: 150px;
            margin-bottom: 5px;
        }

        model-viewer {
            width: 100%;
            height: 100%;
            background-color: #f0f0f0;
        }

        .asset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            padding: 5px;
        }

        .asset-item {
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 4px;
            transition: border-color 0.2s;
        }

        .asset-item:hover {
            border-color: #666;
        }

        .asset-item.active {
            border-color: #fff;
        }

        .preview-wrapper {
            width: 100%;
            padding-bottom: 100%;
            position: relative;
            overflow: hidden;
            border-radius: 4px;
        }

        .preview-wrapper img,
        .preview-wrapper video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* New styles for the sync button */
        .sync-to-code-panel-container {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #323232;
            padding: 5px 10px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #fff;
            cursor: pointer;
            z-index: 9999;
            white-space: nowrap;
            max-width: 180px;
            transition: left 0.3s;
        }

        .sync-to-code-panel-container.hidden {
            display: none;
        }

        .sync-to-code-panel-container:hover {
            background-color: #424242;
        }

        .sync-to-code-panel-container.syncing {
            background-color: #2196f3;
        }

        .sync-to-code-panel-container.synced {
            background-color: #4caf50;
        }

        .sync-to-code-panel-container.error {
            background-color: #f44336;
        }

        .sync-to-code-panel-status {
            margin-left: 5px;
        }

        body.aframe-inspector-opened .sync-to-code-panel-container {
            display: flex !important;
        }

        body:not(.aframe-inspector-opened) .sync-to-code-panel-container {
            display: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="sidebar">
            <h3>Add Objects</h3>
            <button onclick="addEntity('box')">Add Box</button>
            <button onclick="addEntity('sphere')">Add Sphere</button>
            <button onclick="addEntity('cylinder')">Add Cylinder</button>
            <button onclick="addEntity('plane')">Add Plane</button>

            <h3>Assets</h3>
            <input type="file" id="asset-upload" accept="image/*,video/*,.gltf,.glb" onchange="handleFileUpload()">
            <div id="asset-preview"></div>

            <h3>Asset Library</h3>
            <div id="asset-library"></div>

            <div class="panel-section">
                <h3>Skybox</h3>
                <div id="skybox-container" class="asset-grid" style="margin-bottom: 10px;">
                    <!-- Skybox previews will be added here -->
                </div>
                <div class="button-container">
                    <input type="file" id="skybox-input" accept="image/*,video/*" style="display: none;">
                    <button onclick="document.getElementById('skybox-input').click()">Add Skybox</button>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="toolbar">
                <button onclick="switchToView('code')">Edit Code</button>
                <button onclick="switchToView('scene')">Preview Scene</button>
                <button onclick="switchToView('inspector')">Inspector</button>
                <button onclick="saveScene()">Save Scene</button>
                <button onclick="resetScene()">Reset Scene</button>
                <button onclick="clearScene()">Clear Scene</button>
            </div>

            <div class="scene-container">
                <a-scene embedded id="scene">
                    <a-assets id="asset-container">
                        <!-- Uploaded assets will be added here -->
                    </a-assets>

                    <!-- Default scene setup -->
                    <a-box position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9"></a-box>
                    <a-sphere position="0 1.25 -5" radius="1.25" color="#EF2D5E"></a-sphere>
                    <a-cylinder position="1 0.75 -3" radius="0.5" height="1.5" color="#FFC65D"></a-cylinder>
                    <a-plane position="0 0 -4" rotation="-90 0 0" width="4" height="4" color="#7BC8A4"></a-plane>
                    <a-sky color="#ECECEC"></a-sky>
                    <a-camera position="0 1.6 0"></a-camera>
                </a-scene>
                <div id="code-panel"></div>
            </div>
        </div>
    </div>

    <div class="sync-to-code-panel-container hidden">
        <span class="sync-to-code-panel-status">Sync to Code Panel</span>
    </div>

    <script>
        let currentView = 'scene';
        let scene = document.querySelector('a-scene');
        const codePanel = document.querySelector('#code-panel');
        let editor;

        // Initialize CodeMirror
        editor = CodeMirror(codePanel, {
            mode: 'xml',
            theme: 'monokai',
            lineNumbers: true,
            lineWrapping: true,
            indentUnit: 4,
            autoCloseTags: true,
            value: '',
        });

        function switchToView(view) {
            const previousView = currentView;
            currentView = view;

            cleanupInspector(); // Ensure inspector is closed and cleaned up before switching views

            switch (view) {
                case 'scene':
                    scene.style.display = 'block';
                    codePanel.style.display = 'none';
                    if (previousView === 'code') {
                        updateSceneFromCode();
                    }
                    break;

                case 'code':
                    scene.style.display = 'none';
                    codePanel.style.display = 'block';
                    updateCodePanel();
                    break;

                case 'inspector':
                    scene.style.display = 'block';
                    codePanel.style.display = 'none';
                    if (previousView === 'code') {
                        updateSceneFromCode();
                    }
                    setTimeout(() => {
                        openInspector();
                    }, 100);
                    break;
            }
        }

        function updateSceneFromCode() {
            try {
                const newContent = editor.getValue();

                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = `<a-scene embedded>${newContent}</a-scene>`;

                const newScene = tempDiv.querySelector('a-scene');
                const currentScene = document.querySelector('a-scene');
                currentScene.parentNode.replaceChild(newScene, currentScene);

                scene = newScene;

                newScene.addEventListener('loaded', () => {
                    scene = newScene;
                    setupInspectorListeners();
                    updateCodePanel();
                });
            } catch (error) {
                console.error('Error updating scene:', error);
            }
        }

        function toggleInspector() {
            // Check if AFRAME.INSPECTOR exists, if not load it
            if (!AFRAME.INSPECTOR || !AFRAME.INSPECTOR.opened) {
                // Inject the inspector script if it hasn't been loaded
                const inspectorScript = document.createElement('script');
                inspectorScript.src = 'https://cdn.jsdelivr.net/gh/aframevr/aframe-inspector@master/dist/aframe-inspector.min.js';
                inspectorScript.onload = () => {
                    AFRAME.INSPECTOR.open();
                    setupInspectorListeners();
                };
                document.head.appendChild(inspectorScript);
            } else {
                // Toggle the inspector if it's already loaded
                AFRAME.INSPECTOR.opened ? AFRAME.INSPECTOR.close() : AFRAME.INSPECTOR.open();
            }
        }

        function setupInspectorListeners() {
            // Disconnect existing observer if present
            if (window.sceneObserver) {
                window.sceneObserver.disconnect();
            }

            // Create a new observer
            window.sceneObserver = new MutationObserver(() => {
                updateCodePanel();
            });

            // Observe all entities for attribute changes
            scene.querySelectorAll('*').forEach(entity => {
                window.sceneObserver.observe(entity, {
                    attributes: true,
                    childList: true,
                    subtree: true
                });
            });

            // Listen for new entities being added
            scene.addEventListener('child-attached', (evt) => {
                window.sceneObserver.observe(evt.detail.el, {
                    attributes: true,
                    childList: true,
                    subtree: true
                });
                updateCodePanel();
            });

            // Inspector events
            document.addEventListener('inspector-loaded', () => {
                document.body.classList.add('aframe-inspector-opened');
                setupInspectorChangeWatcher();
            });

            document.addEventListener('inspector-closed', () => {
                document.body.classList.remove('aframe-inspector-opened');
                if (currentView === 'inspector') {
                    switchToView('scene');
                }
                flushAllEntitiesToDOM();
                updateCodePanel();
            });
        }

        function updateCodePanel() {
            const sceneClone = scene.cloneNode(true);
            cleanupSceneElement(sceneClone);
            const formattedContent = formatSceneContent(sceneClone);
            editor.setValue(formattedContent);
            editor.refresh();
        }

        function cleanupSceneElement(el) {
            const injectedSelectors = [
                'canvas',
                '.a-enter-vr',
                '.a-orientation-modal',
                '.a-loader-title',
                '[aframe-injected]'
            ];
            injectedSelectors.forEach(selector => {
                el.querySelectorAll(selector).forEach(node => node.remove());
            });

            const attributesToRemove = [
                'aframe-injected',
                'data-aframe-canvas',
                'data-engine',
                'material',
                'geometry',
                'camera',
                'look-controls',
                'wasd-controls'
            ];
            el.querySelectorAll('*').forEach(node => {
                attributesToRemove.forEach(attr => {
                    if (node.getAttribute(attr) === '') {
                        node.removeAttribute(attr);
                    }
                });
            });
        }

        function addEntity(type) {
            const entity = document.createElement(`a-${type}`);
            entity.setAttribute('position', '0 1.5 -3');
            entity.setAttribute('color', '#' + Math.floor(Math.random() * 16777215).toString(16));

            insertEntityInScene(entity);
            flushAllEntitiesToDOM();
            updateCodePanel();
        }

        function useAsset(assetId, type) {
            let entity;
            const entityId = `${type.split('/')[0]}-${assetId}`; // Unique ID for the entity

            if (type.startsWith('image/')) {
                entity = document.createElement('a-image');
                entity.setAttribute('src', `#${assetId}`);
                entity.setAttribute('position', '0 1.5 -3');
                entity.setAttribute('id', entityId);
            } else if (type.startsWith('video/')) {
                entity = document.createElement('a-video');
                entity.setAttribute('src', `#${assetId}`);
                entity.setAttribute('position', '0 1.5 -3');
                entity.setAttribute('id', entityId);
            } else if (type.includes('gltf')) {
                entity = document.createElement('a-entity');
                entity.setAttribute('gltf-model', `#${assetId}`);
                entity.setAttribute('position', '0 1.5 -3');
                entity.setAttribute('scale', '1 1 1');
                entity.setAttribute('id', entityId);
            }
            
            insertEntityInScene(entity);
            flushAllEntitiesToDOM();
            updateCodePanel();
        }

        // Helper function to insert entities correctly
        function insertEntityInScene(entity) {
            const sky = scene.querySelector('a-sky');
            const firstLight = scene.querySelector('[light]');
            if (sky) {
                scene.insertBefore(entity, sky);
            } else if (firstLight) {
                scene.insertBefore(entity, firstLight);
            } else {
                scene.appendChild(entity);
            }

            // Notify inspector of new entity
            scene.emit('child-attached', { el: entity });

            updateCodePanel();
        }

        function handleFileUpload() {
            const fileInput = document.getElementById('asset-upload');
            const file = fileInput.files[0];
            const assetContainer = document.getElementById('asset-container');

            if (file) {
                const assetId = 'asset-' + Date.now();
                const assetUrl = URL.createObjectURL(file);

                let assetEl;
                if (file.type.startsWith('image/')) {
                    assetEl = document.createElement('img');
                    assetEl.setAttribute('src', assetUrl);
                    assetEl.setAttribute('id', assetId);
                    addToAssetLibrary(assetId, file.type);
                } else if (file.type.startsWith('video/')) {
                    assetEl = document.createElement('video');
                    assetEl.setAttribute('src', assetUrl);
                    assetEl.setAttribute('id', assetId);
                    assetEl.setAttribute('loop', '');
                    assetEl.setAttribute('preload', 'auto');
                    addToAssetLibrary(assetId, file.type);
                } else if (file.name.endsWith('.gltf') || file.name.endsWith('.glb')) {
                    assetEl = document.createElement('a-asset-item');
                    assetEl.setAttribute('id', assetId);
                    assetEl.setAttribute('src', assetUrl);
                    assetEl.setAttribute('response-type', 'arraybuffer');
                    assetEl.addEventListener('loaded', () => {
                        addToAssetLibrary(assetId, 'model/gltf-binary');
                    });
                }

                assetContainer.appendChild(assetEl);
                updateCodePanel();
            }
        }

        function addToAssetLibrary(assetId, type) {
            const library = document.getElementById('asset-library');
            const container = document.createElement('div');
            container.className = 'asset-container';

            // Get the original filename
            const fileInput = document.getElementById('asset-upload');
            const file = fileInput.files[0];
            const fileName = file.name;

            // Add preview based on type
            if (type.startsWith('image/')) {
                const preview = document.createElement('img');
                preview.src = URL.createObjectURL(file);
                preview.className = 'asset-preview';
                container.appendChild(preview);
            } else if (type.startsWith('video/')) {
                const preview = document.createElement('video');
                preview.src = URL.createObjectURL(file);
                preview.className = 'asset-preview';
                preview.setAttribute('muted', '');
                preview.setAttribute('loop', '');
                preview.play();
                container.appendChild(preview);
            } else if (type.includes('gltf')) {
                const preview = document.createElement('div');
                preview.className = 'model-preview';

                const modelViewer = document.createElement('model-viewer');
                modelViewer.src = URL.createObjectURL(file);
                modelViewer.setAttribute('auto-rotate', '');
                modelViewer.setAttribute('camera-controls', '');
                modelViewer.setAttribute('ar', '');
                modelViewer.setAttribute('shadow-intensity', '1');
                modelViewer.setAttribute('camera-orbit', '45deg 55deg 2.5m');
                modelViewer.setAttribute('auto-rotate-delay', '0');
                modelViewer.setAttribute('rotation-per-second', '30deg');

                preview.appendChild(modelViewer);
                container.appendChild(preview);
            }

            const button = document.createElement('button');
            button.textContent = type.includes('gltf') ? 'Use 3D Model' : `Use ${type.split('/')[0]}`;
            button.onclick = () => useAsset(assetId, type);

            const label = document.createElement('span');
            label.textContent = ` - ${fileName}`;
            label.style.marginLeft = '5px';

            container.appendChild(button);
            container.appendChild(label);
            library.appendChild(container);
        }

        function saveScene() {
            // Implement save functionality here
            // Could save to localStorage, server, or download as file
            const sceneContent = scene.innerHTML;
            localStorage.setItem('savedScene', sceneContent);
            alert('Scene saved!');
        }

        function initInspector() {
            window.addEventListener('keydown', function (evt) {
                if (evt.keyCode === 73 && evt.shiftKey && evt.ctrlKey) {
                    AFRAME.INSPECTOR.toggle();
                }
            });
        }

        function resetScene() {
            if (confirm('Are you sure you want to reset the scene to default?')) {
                // Close inspector if it's open
                try {
                    if (AFRAME.INSPECTOR && AFRAME.INSPECTOR.opened) {
                        AFRAME.INSPECTOR.close();
                    }
                } catch (e) {
                    console.warn('Inspector cleanup skipped:', e);
                }

                // Get the current scene and save all assets
                let currentScene = document.querySelector('a-scene');
                const currentAssets = Array.from(currentScene.querySelectorAll('a-assets > *')).map(asset => asset.cloneNode(true));

                // Create new scene with same configuration
                let newScene = document.createElement('a-scene');
                newScene.setAttribute('embedded', '');
                newScene.setAttribute('renderer', 'antialias: true; colorManagement: true; physicallyCorrectLights: true; sortObjects: true;');


                // Set default content
                newScene.innerHTML = `
                    <a-assets id="asset-container">
                        <!-- Assets will be re-added here -->
                    </a-assets>
                    
                    <!-- Camera -->
                    <a-camera position="0 1.6 0"></a-camera>

                    <!-- Scene Entities -->
                    <a-box position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9"></a-box>
                    <a-sphere position="0 1.25 -5" radius="1.25" color="#EF2D5E"></a-sphere>
                    <a-cylinder position="1 0.75 -3" radius="0.5" height="1.5" color="#FFC65D"></a-cylinder>
                    <a-plane position="0 0 -4" rotation="-90 0 0" width="4" height="4" color="#7BC8A4"></a-plane>

                    <!-- Environment -->
                    <a-sky color="#ECECEC"></a-sky>
                `;

                // Replace the old scene
                currentScene.parentNode.replaceChild(newScene, currentScene);

                // Update the scene reference
                scene = document.querySelector('a-scene');

                // Re-add all assets to the new scene
                const newAssetContainer = scene.querySelector('#asset-container');
                currentAssets.forEach(asset => {
                    newAssetContainer.appendChild(asset);
                });

                // Clean up inspector reference
                if (typeof AFRAME.INSPECTOR !== 'undefined') {
                    delete AFRAME.INSPECTOR;
                }

                // Switch to scene view and ensure it's visible
                if (currentView != 'scene') {
                    scene.style.display = 'none';
                }


                // Wait for scene to load then update code panel
                scene.addEventListener('loaded', () => {
                    updateCodePanel();
                });
            }
        }

        // Improve inspector change tracking
        function setupInspectorChangeWatcher() {
            if (!window.AFRAME || !window.AFRAME.INSPECTOR) return;

            console.log('Setting up Inspector change watcher');

            // Remove any existing sync buttons first
            const existingButtons = document.querySelectorAll('.sync-to-code-panel-container');
            existingButtons.forEach(button => button.remove());

            // Create a floating container for our button
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'sync-to-code-panel-container';
            buttonContainer.style.position = 'fixed';
            buttonContainer.style.bottom = '10px';  // Position at bottom
            buttonContainer.style.left = '50%';     // Center horizontally
            buttonContainer.style.transform = 'translateX(-50%)'; // Center alignment
            buttonContainer.style.zIndex = '9999999';  // Very high z-index
            buttonContainer.style.backgroundColor = '#323232'; // Match inspector toolbar color
            buttonContainer.style.padding = '5px 10px';
            buttonContainer.style.borderRadius = '4px';
            buttonContainer.style.flexDirection = 'row'; // Put items in a row
            buttonContainer.style.alignItems = 'center';
            buttonContainer.style.gap = '10px';

            // Create a button to force sync changes to code panel
            const syncButton = document.createElement('button');
            syncButton.textContent = 'Sync to Code Panel';
            syncButton.className = 'sync-to-code-panel';
            syncButton.style.padding = '5px 10px';
            syncButton.style.backgroundColor = '#4285f4';
            syncButton.style.color = 'white';
            syncButton.style.border = 'none';
            syncButton.style.borderRadius = '3px';
            syncButton.style.cursor = 'pointer';
            syncButton.style.fontWeight = 'bold';
            syncButton.style.fontSize = '12px';

            syncButton.onclick = () => {
                flushAllEntitiesToDOM();
                updateCodePanel();

                // Visual feedback
                syncButton.textContent = 'Synced! âœ“';
                syncButton.style.backgroundColor = '#0f9d58';
                setTimeout(() => {
                    syncButton.textContent = 'Sync to Code Panel';
                    syncButton.style.backgroundColor = '#4285f4';
                }, 2000);
            };

            // Create a status message element
            const statusMessage = document.createElement('div');
            statusMessage.textContent = 'Inspector watcher active';
            statusMessage.style.color = '#ccc';
            statusMessage.style.fontSize = '11px';
            statusMessage.style.whiteSpace = 'nowrap';

            // Add button and status to container
            buttonContainer.appendChild(syncButton);
            buttonContainer.appendChild(statusMessage);

            // Add container to document body
            document.body.appendChild(buttonContainer);

            // Add CSS to show/hide button based on body class
            const style = document.createElement('style');
            style.textContent = `
                .sync-to-code-panel {
                    transition: background-color 0.3s ease;
                }
                .sync-to-code-panel:hover {
                    background-color: #1a73e8;
                }
                .sync-to-code-panel-container {
                    transition: opacity 0.3s;
                    display: none !important; /* Hidden by default */
                }
                body.aframe-inspector-opened .sync-to-code-panel-container {
                    display: flex !important; /* Only show when inspector is open */
                }
            `;
            document.head.appendChild(style);

            console.log('Sync button container added, positioned at bottom toolbar');

            // Watch for changes in Inspector panels
            const inspectorPanels = document.querySelectorAll('.inspector-panel');
            if (inspectorPanels.length > 0) {
                inspectorPanels.forEach(panel => {
                    panel.addEventListener('change', () => {
                        flushAllEntitiesToDOM();
                    });

                    panel.addEventListener('input', () => {
                        flushAllEntitiesToDOM();
                    });
                });
            }

            // Add event listeners for Inspector changes
            document.addEventListener('componentchanged', event => {
                if (event.detail && event.detail.target) {
                    event.detail.target.flushToDOM();
                    updateCodePanel();
                    statusMessage.textContent = 'Component changed, DOM updated';
                    setTimeout(() => {
                        statusMessage.textContent = 'Inspector watcher active';
                    }, 2000);
                }
            });

            document.addEventListener('entitycreated', event => {
                if (event.detail && event.detail.entity) {
                    event.detail.entity.flushToDOM();
                    updateCodePanel();
                    statusMessage.textContent = 'Entity created, DOM updated';
                    setTimeout(() => {
                        statusMessage.textContent = 'Inspector watcher active';
                    }, 2000);
                }
            });

            document.addEventListener('entityremoved', () => {
                updateCodePanel();
                statusMessage.textContent = 'Entity removed, DOM updated';
                setTimeout(() => {
                    statusMessage.textContent = 'Inspector watcher active';
                }, 2000);
            });

            // Override Inspector's save function
            if (AFRAME.INSPECTOR) {
                const originalSaveFunction = AFRAME.INSPECTOR.onSaveButtonClick;
                AFRAME.INSPECTOR.onSaveButtonClick = function () {
                    // Call the original function (which will show the aframe-watcher message)
                    if (originalSaveFunction) originalSaveFunction.call(AFRAME.INSPECTOR);

                    // Now do our own saving logic
                    flushAllEntitiesToDOM();
                    updateCodePanel();
                    statusMessage.textContent = 'Changes synced to code panel';
                    setTimeout(() => {
                        statusMessage.textContent = 'Inspector watcher active';
                    }, 2000);
                };
            }

            // Override the "Back to Scene" button functionality
            setTimeout(() => {
                // Find the back to scene button
                const backButtons = document.querySelectorAll('.toggle-edit');
                backButtons.forEach(backButton => {
                    // Check if this button has been modified already
                    if (backButton.dataset.modifiedWithSync) return;

                    // Mark as modified to prevent duplicate handlers
                    backButton.dataset.modifiedWithSync = 'true';

                    // Clone the button to remove existing event listeners
                    const oldButton = backButton;
                    const newButton = oldButton.cloneNode(true);
                    oldButton.parentNode.replaceChild(newButton, oldButton);

                    // Add our custom click handler
                    newButton.addEventListener('click', (e) => {
                        // Prevent default behavior
                        e.preventDefault();
                        e.stopPropagation();

                        // Remove any inspector-specific entities from the DOM
                        const inspectorEntities = document.querySelectorAll('[data-aframe-inspector="true"], #aframeInspectorMouseCursor');
                        inspectorEntities.forEach(entity => {
                            console.log('Removing inspector entity:', entity.id);
                            if (entity.parentNode) {
                                entity.parentNode.removeChild(entity);
                            }
                        });

                        // Sync all changes to DOM and code panel
                        console.log('Back to Scene: syncing changes...');
                        flushAllEntitiesToDOM();
                        updateCodePanel();

                        // Show brief confirmation and then return to scene
                        statusMessage.textContent = 'Changes synced before exit';

                        // Small delay to ensure sync completes
                        setTimeout(() => {
                            // Now do the original action of closing the inspector
                            if (AFRAME.INSPECTOR) {
                                AFRAME.INSPECTOR.close();
                            }
                        }, 300);
                    });

                    console.log('Back to Scene button functionality overridden with sync capability');
                });
            }, 1500); // Delay to ensure inspector UI is fully loaded
        }

        // We also need to update the cleanupInspector function to sync before closing
        function cleanupInspector() {
            if (AFRAME.INSPECTOR && AFRAME.INSPECTOR.opened) {
                // Sync changes before closing
                flushAllEntitiesToDOM();

                // Remove any inspector-specific entities from the DOM
                const inspectorEntities = document.querySelectorAll('[data-aframe-inspector="true"], #aframeInspectorMouseCursor');
                inspectorEntities.forEach(entity => {
                    console.log('Removing inspector entity:', entity.id);
                    entity.parentNode.removeChild(entity);
                });

                updateCodePanel();
                console.log('Inspector cleanup: synced changes and removed inspector entities');

                // Then close the inspector
                AFRAME.INSPECTOR.close();
            }
            document.body.classList.remove('aframe-inspector-opened');
        }

        function showSyncButtonContainer() {
            console.log('Showing sync button container');
            const containers = document.querySelectorAll('.sync-to-code-panel-container');
            if (containers.length === 0) {
                console.log('No sync button containers found to show');
            }

            containers.forEach(container => {
                container.style.display = 'flex';
                container.dataset.visible = 'true';
                console.log('Sync button container displayed', container);
            });
        }

        function hideSyncButtonContainer() {
            console.log('Hiding sync button container');
            const containers = document.querySelectorAll('.sync-to-code-panel-container');
            if (containers.length === 0) {
                console.log('No sync button containers found to hide');
            }

            containers.forEach(container => {
                container.style.display = 'none';
                container.dataset.visible = 'false';
                console.log('Sync button container hidden', container);
            });
        }

        // Function to remove Inspector mouse cursor entity
        function removeInspectorCursor() {
            const cursorEntity = document.getElementById('aframeInspectorMouseCursor');
            if (cursorEntity) {
                console.log('Removing inspector cursor entity');
                if (cursorEntity.parentNode) {
                    cursorEntity.parentNode.removeChild(cursorEntity);
                }
            }
        }

        // Add a function specifically to watch for and remove the cursor entity
        function watchForInspectorCursor() {
            // Create a specific observer just for the cursor entity
            const cursorObserver = new MutationObserver(mutations => {
                for (let mutation of mutations) {
                    if (mutation.addedNodes) {
                        for (let node of mutation.addedNodes) {
                            if (node.id === 'aframeInspectorMouseCursor') {
                                console.log('Inspector cursor detected, marking for removal on exit');
                                // Mark for removal on exit
                                node.dataset.removeOnExit = 'true';
                            }
                        }
                    }
                }
            });

            // Start observing
            cursorObserver.observe(document.querySelector('a-scene'), {
                childList: true,
                subtree: true
            });

            // Store for later cleanup
            window.cursorObserver = cursorObserver;

            console.log('Inspector cursor watcher set up');

            // Also set up an interval to check for and mark the cursor
            const cursorCheckInterval = setInterval(() => {
                const cursor = document.getElementById('aframeInspectorMouseCursor');
                if (cursor) {
                    cursor.dataset.removeOnExit = 'true';
                }

                // Stop if inspector is closed
                if (!AFRAME.INSPECTOR || !AFRAME.INSPECTOR.opened) {
                    clearInterval(cursorCheckInterval);
                }
            }, 1000);
        }

        // Modify openInspector function
        function openInspector() {
            if (window.AFRAME.INSPECTOR && window.AFRAME.INSPECTOR.opened) {
                window.AFRAME.INSPECTOR.close();
            }

            // First, ensure any previous cursor is removed
            removeInspectorCursor();

            // Remove existing inspector script if present
            const existingScript = document.querySelector('script[src*="aframe-inspector.min.js"]');
            if (existingScript) existingScript.remove();

            // Remove existing inspector elements
            document.querySelectorAll('.a-inspector-loader, .a-inspector').forEach(el => el.remove());

            // Load inspector fresh each time
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/gh/aframevr/aframe-inspector@master/dist/aframe-inspector.min.js';
            script.onload = () => {
                AFRAME.INSPECTOR.open();
                document.body.classList.add('aframe-inspector-opened');
                setupInspectorListeners();

                // Set up cursor watcher immediately
                watchForInspectorCursor();

                // Set up the inspector change watcher after the inspector loads
                setTimeout(() => {
                    setupInspectorChangeWatcher();
                }, 1000);

                // Patch the inspector close method to always remove cursor
                if (AFRAME.INSPECTOR && !AFRAME.INSPECTOR._cursorRemovalPatched) {
                    const originalClose = AFRAME.INSPECTOR.close;
                    AFRAME.INSPECTOR.close = function () {
                        // Always remove the cursor before closing
                        removeInspectorCursor();

                        // Call original close function
                        originalClose.apply(this, arguments);

                        // Remove again after closing (just to be safe)
                        setTimeout(removeInspectorCursor, 100);

                        // Clean up observer
                        if (window.cursorObserver) {
                            window.cursorObserver.disconnect();
                        }
                    };

                    // Mark as patched to avoid double-patching
                    AFRAME.INSPECTOR._cursorRemovalPatched = true;
                    console.log('Inspector close method patched to remove cursor');
                }
            };
            document.head.appendChild(script);
        }

        // Make sure it's hidden when page loads
        window.addEventListener('load', () => {
            hideSyncButtonContainer();
        });

        function clearScene() {
            if (confirm('Are you sure you want to clear all models, images, and scene elements?')) {
                // Close inspector if it's open
                try {
                    if (AFRAME.INSPECTOR && AFRAME.INSPECTOR.opened) {
                        AFRAME.INSPECTOR.close();
                    }
                } catch (e) {
                    console.warn('Inspector cleanup skipped:', e);
                }

                // Get the current scene and save all assets
                let currentScene = document.querySelector('a-scene');
                const currentAssets = Array.from(currentScene.querySelectorAll('a-assets > *')).map(asset => asset.cloneNode(true));

                // Create new scene with same configuration
                let newScene = document.createElement('a-scene');
                newScene.setAttribute('embedded', '');
                newScene.setAttribute('renderer', 'antialias: true; colorManagement: true; physicallyCorrectLights: true; sortObjects: true;');

                // Set default content - just assets, camera, sky and lights
                newScene.innerHTML = `
                    <a-assets id="asset-container">
                        <!-- Assets will be re-added here -->
                    </a-assets>

                    <a-camera position="0 1.6 0"></a-camera>
                    <a-sky color="#ECECEC"></a-sky>

                    <!-- Default lighting -->
                    <a-entity light="color: #BBB; type: ambient" data-aframe-default-light="" aframe-injected=""></a-entity>
                    <a-entity light="intensity: 0.6; castShadow: true" position="-0.5 1 1" data-aframe-default-light="" aframe-injected=""></a-entity>
                `;

                // Replace the old scene
                currentScene.parentNode.replaceChild(newScene, currentScene);

                // Update the scene reference
                scene = document.querySelector('a-scene');

                // Re-add all assets to the new scene
                const newAssetContainer = scene.querySelector('#asset-container');
                currentAssets.forEach(asset => {
                    newAssetContainer.appendChild(asset);
                });

                // Clean up inspector reference
                if (typeof AFRAME.INSPECTOR !== 'undefined') {
                    delete AFRAME.INSPECTOR;
                }

                // Switch to scene view and ensure it's visible
                currentView = 'scene';
                scene.style.display = 'block';
                codePanel.style.display = 'none';

                // Wait for scene to load then update code panel
                scene.addEventListener('loaded', () => {
                    updateCodePanel();
                });
            }
        }

        let skyboxCounter = 0;

        document.getElementById('skybox-input').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) {
                console.log('No file selected');
                return;
            }
            console.log('File selected:', file.type);

            const url = URL.createObjectURL(file);
            const isVideo = file.type.startsWith('video/');
            const assetId = `skybox-asset-${skyboxCounter++}`;

            // Create preview element
            const previewDiv = document.createElement('div');
            previewDiv.className = 'asset-item';
            previewDiv.innerHTML = `
        <div class="preview-wrapper">
            ${isVideo ?
                    `<video src="${url}" style="width: 100%; height: 100%; object-fit: cover;" loop muted autoplay></video>` :
                    `<img src="${url}" style="width: 100%; height: 100%; object-fit: cover;">`
                }
        </div>
    `;

            // Add click handler to set as active skybox
            previewDiv.addEventListener('click', () => {
                // Remove existing sky/videosphere
                const existingSky = document.querySelector('a-sky, a-videosphere');
                if (existingSky) {
                    existingSky.remove();
                }

                // Create new sky element
                const skyEl = document.createElement(isVideo ? 'a-videosphere' : 'a-sky');
                skyEl.setAttribute('src', `#${assetId}`);

                // Add to scene
                const scene = document.querySelector('a-scene');
                scene.appendChild(skyEl);

                // If it's a video, ensure it's playing
                if (isVideo) {
                    const videoAsset = document.getElementById(assetId);
                    videoAsset.play().catch(e => console.error('Error playing video:', e));
                }

                // Update active state visually
                document.querySelectorAll('#skybox-container .asset-item').forEach(item => {
                    item.classList.remove('active');
                });
                previewDiv.classList.add('active');
            });

            // Add to skybox container
            document.getElementById('skybox-container').appendChild(previewDiv);

            // Get assets container
            const assets = document.querySelector('a-assets');

            // Create asset element
            const assetEl = document.createElement(isVideo ? 'video' : 'img');
            assetEl.id = assetId;
            assetEl.src = url;
            if (isVideo) {
                assetEl.setAttribute('preload', 'auto');
                assetEl.setAttribute('loop', '');
                assetEl.setAttribute('crossorigin', 'anonymous');
            }

            // Add new asset
            assets.appendChild(assetEl);

            // Trigger click to set as active skybox
            previewDiv.click();
        });

        function clearAssets() {
            if (confirm('Are you sure you want to clear all models, images, and scene elements?')) {
                // Close inspector if it's open
                try {
                    if (AFRAME.INSPECTOR && AFRAME.INSPECTOR.opened) {
                        AFRAME.INSPECTOR.close();
                    }
                } catch (e) {
                    console.warn('Inspector cleanup skipped:', e);
                }

                // Get the current scene and save all assets
                let currentScene = document.querySelector('a-scene');
                const currentAssets = Array.from(currentScene.querySelectorAll('a-assets > *')).map(asset => asset.cloneNode(true));

                // Create new scene with same configuration
                let newScene = document.createElement('a-scene');
                newScene.setAttribute('embedded', '');
                newScene.setAttribute('renderer', 'antialias: true; colorManagement: true; physicallyCorrectLights: true; sortObjects: true;');

                // Set default content - just assets, camera, sky and lights
                newScene.innerHTML = `
                    <a-assets id="asset-container">
                        <!-- Assets will be re-added here -->
                    </a-assets>

                    <a-camera position="0 1.6 0"></a-camera>
                    <a-sky color="#ECECEC"></a-sky>

                    <!-- Default lighting -->
                    <a-entity light="color: #BBB; type: ambient" data-aframe-default-light="" aframe-injected=""></a-entity>
                    <a-entity light="intensity: 0.6; castShadow: true" position="-0.5 1 1" data-aframe-default-light="" aframe-injected=""></a-entity>
                `;

                // Replace the old scene
                currentScene.parentNode.replaceChild(newScene, currentScene);

                // Update the scene reference
                scene = document.querySelector('a-scene');

                // Re-add all assets to the new scene
                const newAssetContainer = scene.querySelector('#asset-container');
                currentAssets.forEach(asset => {
                    newAssetContainer.appendChild(asset);
                });

                // Clean up inspector reference
                if (typeof AFRAME.INSPECTOR !== 'undefined') {
                    delete AFRAME.INSPECTOR;
                }

                // Switch to scene view and ensure it's visible
                currentView = 'scene';
                scene.style.display = 'block';
                codePanel.style.display = 'none';

                // Wait for scene to load then update code panel
                scene.addEventListener('loaded', () => {
                    updateCodePanel();
                });
            }
        }

        function formatSceneContent(sceneEl) {
            const assets = sceneEl.querySelector('a-assets');
            const camera = sceneEl.querySelector('a-camera');
            const sky = sceneEl.querySelector('a-sky');
            const lights = Array.from(sceneEl.querySelectorAll('[light]'));

            // Get all other entities (excluding assets, camera, sky, lights)
            const entities = Array.from(sceneEl.children).filter(el =>
                el !== assets &&
                el !== camera &&
                el !== sky &&
                !lights.includes(el)
            );

            let content = '';

            // Assets
            content += '<a-assets id="asset-container">\n';
            content += '    <!-- Assets -->\n';
            if (assets) {
                Array.from(assets.children).forEach(asset => {
                    content += '    ' + asset.outerHTML + '\n';
                });
            }
            content += '</a-assets>\n\n';

            // Camera
            if (camera) {
                content += '<!-- Camera -->\n';
                content += camera.outerHTML + '\n\n';
            }

            // Entities
            if (entities.length > 0) {
                content += '<!-- Scene Entities -->\n';
                entities.forEach(entity => {
                    content += entity.outerHTML + '\n';
                });
                content += '\n';
            }

            // Environment (Sky)
            if (sky) {
                content += '<!-- Environment -->\n';
                content += sky.outerHTML + '\n\n';
            }

            // Lighting
            if (lights.length > 0) {
                content += '<!-- Lighting -->\n';
                lights.forEach(light => {
                    content += light.outerHTML + '\n';
                });
            }

            return content;
        }

        // Flush all entities to DOM - modified to filter out inspector-specific entities
        function flushAllEntitiesToDOM() {
            // Get all entities in the scene
            const entities = document.querySelectorAll('a-scene > *');
            entities.forEach(entity => {
                // Skip entities created by the inspector itself
                if (entity.hasAttribute('data-aframe-inspector') ||
                    entity.id === 'aframeInspectorMouseCursor') {
                    console.log('Skipping inspector entity during sync:', entity.id);
                    return;
                }

                if (typeof entity.flushToDOM === 'function') {
                    entity.flushToDOM();
                }
            });
            updateCodePanel();
        }

        // Get attributes for an entity
        function getAttributes(entity) {
            const attributes = {};
            for (let i = 0; i < entity.attributes.length; i++) {
                const attr = entity.attributes[i];
                attributes[attr.name] = attr.value;
            }
            return attributes;
        }

        // Set attributes for an entity
        function setAttributes(entity, attributes) {
            Object.entries(attributes).forEach(([name, value]) => {
                entity.setAttribute(name, value);
            });
            entity.flushToDOM();
        }

        // Fix the use3DModel function to set the ID properly
        function use3DModel() {
            const modelUrl = document.getElementById('modelUrlInput').value.trim();
            if (!modelUrl) {
                alert('Please enter a model URL');
                return;
            }

            // Get base name for ID from URL
            let modelId = '';
            try {
                const url = new URL(modelUrl);
                const pathParts = url.pathname.split('/');
                const filename = pathParts[pathParts.length - 1];
                modelId = 'model-' + filename.split('.')[0].toLowerCase().replace(/[^a-z0-9]/g, '-');
            } catch (e) {
                // If URL parsing fails, create a generic ID
                modelId = 'model-' + Math.floor(Math.random() * 1000);
            }

            // Check if the model requires a specific format handler (GLTF vs OBJ)
            let modelEntity;
            if (modelUrl.toLowerCase().endsWith('.glb') || modelUrl.toLowerCase().endsWith('.gltf')) {
                modelEntity = document.createElement('a-entity');
                modelEntity.setAttribute('gltf-model', modelUrl);
                modelEntity.setAttribute('id', modelId);
                modelEntity.setAttribute('position', '0 1.5 -3');
                modelEntity.setAttribute('scale', '1 1 1');
            } else if (modelUrl.toLowerCase().endsWith('.obj')) {
                modelEntity = document.createElement('a-entity');
                modelEntity.setAttribute('obj-model', 'obj: ' + modelUrl);
                modelEntity.setAttribute('id', modelId);
                modelEntity.setAttribute('position', '0 1.5 -3');
                modelEntity.setAttribute('scale', '1 1 1');
            } else {
                alert('Unsupported model format. Please use .glb, .gltf, or .obj');
                return;
            }

            // Add the model to the scene
            scene.appendChild(modelEntity);
            updateCodePanel();

            // Close the model input dialog
            document.getElementById('modelUrlDialog').style.display = 'none';

            // Switch to scene view to see the model
            switchToView('scene');
        }
    </script>
</body>

</html>