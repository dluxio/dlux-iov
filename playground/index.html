<!DOCTYPE html>
<html>

<head>
    <title>DLUX Scene Builder</title>
    <script src="/js/aframe.min.js"></script>
    <link rel="stylesheet" href="/css/codemirror.min.css">
    <link rel="stylesheet" href="/css/codemirror-monokai.min.css">
    <script src="/js/codemirror.min.js"></script>
    <script src="/js/codemirror-xml.min.js"></script>
    <script type="module" src="/js/model-viewer.min.js"></script>

    <style>
        /* Update CSS rules to use A-Frame's class */
        body.aframe-inspector-opened .sidebar,
        body.aframe-inspector-opened .toolbar {
            display: none !important;
        }

        body:not(.aframe-inspector-opened) .sidebar,
        body:not(.aframe-inspector-opened) .toolbar {
            display: block;
        }

        body:not(.aframe-inspector-opened) .toggle-edit {
            display: none;
        }

        body.aframe-inspector-opened .scene-container {
            margin-left: 0 !important;
            width: 100% !important;
        }

        body {
            margin: 0;
        }

        .sponsor-btn {
            display: none !important;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 200px;
            background: #1B1B1B;
            padding: 15px;
            overflow-y: auto;
            color: #fff;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .scene-container {
            flex: 1;
            position: relative;
        }

        .toolbar {
            padding: 10px;
            background: #1B1B1B;
        }

        .hidden {
            display: none;
        }

        #asset-preview {
            max-width: 100%;
            margin-top: 10px;
        }

        .CodeMirror {
            height: 100%;
            font-size: 14px;
        }


        #scene {
            width: 100%;
            height: 100%;
        }

        #code-panel {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            display: none;
        }

        /* Hide the default file input text */
        input[type="file"] {
            color: transparent;
            width: 90px;
            /* Adjust width to only show the button */
        }

        /* Show the "Choose File" button text */
        input[type="file"]::-webkit-file-upload-button {
            visibility: visible;
            color: initial;
        }

        /* Hide the selected filename */
        input[type="file"]::file-selector-button {
            color: initial;
        }

        .asset-preview {
            width: 100%;
            max-height: 150px;
            margin-bottom: 5px;
            display: block;
        }

        .asset-container {
            margin-bottom: 15px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .model-preview {
            width: 100%;
            height: 150px;
            margin-bottom: 5px;
        }

        model-viewer {
            width: 100%;
            height: 100%;
            background-color: #f0f0f0;
        }

        .asset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            padding: 5px;
        }

        .asset-item {
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 4px;
            transition: border-color 0.2s;
        }

        .asset-item:hover {
            border-color: #666;
        }

        .asset-item.active {
            border-color: #fff;
        }

        .preview-wrapper {
            width: 100%;
            padding-bottom: 100%;
            position: relative;
            overflow: hidden;
            border-radius: 4px;
        }

        .preview-wrapper img,
        .preview-wrapper video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="sidebar">
            <h3>Add Objects</h3>
            <button onclick="addEntity('box')">Add Box</button>
            <button onclick="addEntity('sphere')">Add Sphere</button>
            <button onclick="addEntity('cylinder')">Add Cylinder</button>
            <button onclick="addEntity('plane')">Add Plane</button>

            <h3>Assets</h3>
            <input type="file" id="asset-upload" accept="image/*,video/*,.gltf,.glb" onchange="handleFileUpload()">
            <div id="asset-preview"></div>

            <h3>Asset Library</h3>
            <div id="asset-library"></div>

            <div class="panel-section">
                <h3>Skybox</h3>
                <div id="skybox-container" class="asset-grid" style="margin-bottom: 10px;">
                    <!-- Skybox previews will be added here -->
                </div>
                <div class="button-container">
                    <input type="file" id="skybox-input" accept="image/*,video/*" style="display: none;">
                    <button onclick="document.getElementById('skybox-input').click()">Add Skybox</button>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="toolbar">
                <button onclick="switchToView('scene')">Preview Scene</button>
                <button onclick="switchToView('code')">Edit Code</button>
                <button onclick="switchToView('inspector')">Inspector</button>
                <button onclick="saveScene()">Save Scene</button>
                <button onclick="resetScene()">Reset Scene</button>
                <button onclick="clearScene()">Clear Scene</button>
            </div>

            <div class="scene-container">
                <a-scene embedded id="scene">
                    <a-assets id="asset-container">
                        <!-- Uploaded assets will be added here -->
                    </a-assets>

                    <!-- Default scene setup -->
                    <a-box position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9"></a-box>
                    <a-sphere position="0 1.25 -5" radius="1.25" color="#EF2D5E"></a-sphere>
                    <a-cylinder position="1 0.75 -3" radius="0.5" height="1.5" color="#FFC65D"></a-cylinder>
                    <a-plane position="0 0 -4" rotation="-90 0 0" width="4" height="4" color="#7BC8A4"></a-plane>
                    <a-sky color="#ECECEC"></a-sky>
                    <a-camera position="0 1.6 0"></a-camera>
                </a-scene>
                <div id="code-panel"></div>
            </div>
        </div>
    </div>

    <script>
        let currentView = 'scene';
        let scene = document.querySelector('a-scene');
        const codePanel = document.querySelector('#code-panel');
        let editor;

        // Initialize CodeMirror
        editor = CodeMirror(codePanel, {
            mode: 'xml',
            theme: 'monokai',
            lineNumbers: true,
            lineWrapping: true,
            indentUnit: 4,
            autoCloseTags: true,
            value: '',
        });

        function switchToView(view) {
            const previousView = currentView;
            currentView = view;

            cleanupInspector(); // Ensure inspector is closed and cleaned up before switching views

            switch (view) {
                case 'scene':
                    scene.style.display = 'block';
                    codePanel.style.display = 'none';
                    if (previousView === 'code') {
                        updateSceneFromCode();
                    }
                    break;

                case 'code':
                    scene.style.display = 'none';
                    codePanel.style.display = 'block';
                    updateCodePanel();
                    break;

                case 'inspector':
                    scene.style.display = 'block';
                    codePanel.style.display = 'none';
                    if (previousView === 'code') {
                        updateSceneFromCode();
                    }
                    setTimeout(() => {
                        openInspector();
                    }, 100);
                    break;
            }
        }

        function updateSceneFromCode() {
            try {
                const newContent = editor.getValue();

                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = `<a-scene embedded>${newContent}</a-scene>`;

                const newScene = tempDiv.querySelector('a-scene');
                const currentScene = document.querySelector('a-scene');
                currentScene.parentNode.replaceChild(newScene, currentScene);

                scene = newScene;

                newScene.addEventListener('loaded', () => {
                    scene = newScene;
                    setupInspectorListeners();
                    updateCodePanel();
                });
            } catch (error) {
                console.error('Error updating scene:', error);
            }
        }

        function toggleInspector() {
            // Check if AFRAME.INSPECTOR exists, if not load it
            if (!AFRAME.INSPECTOR || !AFRAME.INSPECTOR.opened) {
                // Inject the inspector script if it hasn't been loaded
                const inspectorScript = document.createElement('script');
                inspectorScript.src = 'https://cdn.jsdelivr.net/gh/aframevr/aframe-inspector@master/dist/aframe-inspector.min.js';
                inspectorScript.onload = () => {
                    AFRAME.INSPECTOR.open();
                    setupInspectorListeners();
                };
                document.head.appendChild(inspectorScript);
            } else {
                // Toggle the inspector if it's already loaded
                AFRAME.INSPECTOR.opened ? AFRAME.INSPECTOR.close() : AFRAME.INSPECTOR.open();
            }
        }

        function setupInspectorListeners() {
            // Disconnect existing observer if present
            if (window.sceneObserver) {
                window.sceneObserver.disconnect();
            }

            // Create a new observer
            window.sceneObserver = new MutationObserver(() => {
                updateCodePanel();
            });

            // Observe all entities for attribute changes
            scene.querySelectorAll('*').forEach(entity => {
                window.sceneObserver.observe(entity, {
                    attributes: true,
                    childList: true,
                    subtree: true
                });
            });

            // Listen for new entities being added
            scene.addEventListener('child-attached', (evt) => {
                window.sceneObserver.observe(evt.detail.el, {
                    attributes: true,
                    childList: true,
                    subtree: true
                });
                updateCodePanel();
            });

            // Inspector events
            document.addEventListener('inspector-loaded', () => {
                document.body.classList.add('aframe-inspector-opened');
            });

            document.addEventListener('inspector-closed', () => {
                document.body.classList.remove('aframe-inspector-opened');
                if (currentView === 'inspector') {
                    switchToView('scene');
                }
                updateCodePanel();
            });
        }

        function updateCodePanel() {
            const sceneClone = scene.cloneNode(true);
            cleanupSceneElement(sceneClone);
            const formattedContent = formatSceneContent(sceneClone);
            editor.setValue(formattedContent);
            editor.refresh();
        }

        function cleanupSceneElement(el) {
            const injectedSelectors = [
                'canvas',
                '.a-enter-vr',
                '.a-orientation-modal',
                '.a-loader-title',
                '[aframe-injected]'
            ];
            injectedSelectors.forEach(selector => {
                el.querySelectorAll(selector).forEach(node => node.remove());
            });

            const attributesToRemove = [
                'aframe-injected',
                'data-aframe-canvas',
                'data-engine',
                'material',
                'geometry',
                'camera',
                'look-controls',
                'wasd-controls'
            ];
            el.querySelectorAll('*').forEach(node => {
                attributesToRemove.forEach(attr => {
                    if (node.getAttribute(attr) === '') {
                        node.removeAttribute(attr);
                    }
                });
            });
        }

        function addEntity(type) {
            const entity = document.createElement(`a-${type}`);
            entity.setAttribute('position', '0 1.5 -3');
            entity.setAttribute('color', '#' + Math.floor(Math.random() * 16777215).toString(16));

            insertEntityInScene(entity);
            updateCodePanel();
        }

        function useAsset(assetId, type) {
            let entity;
            if (type.startsWith('image/')) {
                entity = document.createElement('a-image');
                entity.setAttribute('src', `#${assetId}`);
                entity.setAttribute('position', '0 1.5 -3');
            } else if (type.startsWith('video/')) {
                entity = document.createElement('a-video');
                entity.setAttribute('src', `#${assetId}`);
                entity.setAttribute('position', '0 1.5 -3');
            } else if (type.includes('gltf')) {
                entity = document.createElement('a-entity');
                entity.setAttribute('gltf-model', `#${assetId}`);
                entity.setAttribute('position', '0 1.5 -3');
                entity.setAttribute('scale', '1 1 1');
            }

            insertEntityInScene(entity);
            updateCodePanel();
        }

        // Helper function to insert entities correctly
        function insertEntityInScene(entity) {
            const sky = scene.querySelector('a-sky');
            const firstLight = scene.querySelector('[light]');
            if (sky) {
                scene.insertBefore(entity, sky);
            } else if (firstLight) {
                scene.insertBefore(entity, firstLight);
            } else {
                scene.appendChild(entity);
            }

            // Notify inspector of new entity
            scene.emit('child-attached', { el: entity });

            updateCodePanel();
        }

        function handleFileUpload() {
            const fileInput = document.getElementById('asset-upload');
            const file = fileInput.files[0];
            const assetContainer = document.getElementById('asset-container');

            if (file) {
                const assetId = 'asset-' + Date.now();
                const assetUrl = URL.createObjectURL(file);

                let assetEl;
                if (file.type.startsWith('image/')) {
                    assetEl = document.createElement('img');
                    assetEl.setAttribute('src', assetUrl);
                    assetEl.setAttribute('id', assetId);
                    addToAssetLibrary(assetId, file.type);
                } else if (file.type.startsWith('video/')) {
                    assetEl = document.createElement('video');
                    assetEl.setAttribute('src', assetUrl);
                    assetEl.setAttribute('id', assetId);
                    assetEl.setAttribute('loop', '');
                    assetEl.setAttribute('preload', 'auto');
                    addToAssetLibrary(assetId, file.type);
                } else if (file.name.endsWith('.gltf') || file.name.endsWith('.glb')) {
                    assetEl = document.createElement('a-asset-item');
                    assetEl.setAttribute('id', assetId);
                    assetEl.setAttribute('src', assetUrl);
                    assetEl.setAttribute('response-type', 'arraybuffer');
                    assetEl.addEventListener('loaded', () => {
                        addToAssetLibrary(assetId, 'model/gltf-binary');
                    });
                }

                assetContainer.appendChild(assetEl);
                updateCodePanel();
            }
        }

        function addToAssetLibrary(assetId, type) {
            const library = document.getElementById('asset-library');
            const container = document.createElement('div');
            container.className = 'asset-container';

            // Get the original filename
            const fileInput = document.getElementById('asset-upload');
            const file = fileInput.files[0];
            const fileName = file.name;

            // Add preview based on type
            if (type.startsWith('image/')) {
                const preview = document.createElement('img');
                preview.src = URL.createObjectURL(file);
                preview.className = 'asset-preview';
                container.appendChild(preview);
            } else if (type.startsWith('video/')) {
                const preview = document.createElement('video');
                preview.src = URL.createObjectURL(file);
                preview.className = 'asset-preview';
                preview.setAttribute('muted', '');
                preview.setAttribute('loop', '');
                preview.play();
                container.appendChild(preview);
            } else if (type.includes('gltf')) {
                const preview = document.createElement('div');
                preview.className = 'model-preview';

                const modelViewer = document.createElement('model-viewer');
                modelViewer.src = URL.createObjectURL(file);
                modelViewer.setAttribute('auto-rotate', '');
                modelViewer.setAttribute('camera-controls', '');
                modelViewer.setAttribute('ar', '');
                modelViewer.setAttribute('shadow-intensity', '1');
                modelViewer.setAttribute('camera-orbit', '45deg 55deg 2.5m');
                modelViewer.setAttribute('auto-rotate-delay', '0');
                modelViewer.setAttribute('rotation-per-second', '30deg');

                preview.appendChild(modelViewer);
                container.appendChild(preview);
            }

            const button = document.createElement('button');
            button.textContent = type.includes('gltf') ? 'Use 3D Model' : `Use ${type.split('/')[0]}`;
            button.onclick = () => useAsset(assetId, type);

            const label = document.createElement('span');
            label.textContent = ` - ${fileName}`;
            label.style.marginLeft = '5px';

            container.appendChild(button);
            container.appendChild(label);
            library.appendChild(container);
        }

        function saveScene() {
            // Implement save functionality here
            // Could save to localStorage, server, or download as file
            const sceneContent = scene.innerHTML;
            localStorage.setItem('savedScene', sceneContent);
            alert('Scene saved!');
        }

        function initInspector() {
            window.addEventListener('keydown', function (evt) {
                if (evt.keyCode === 73 && evt.shiftKey && evt.ctrlKey) {
                    AFRAME.INSPECTOR.toggle();
                }
            });
        }

        function resetScene() {
            if (confirm('Are you sure you want to reset the scene to default?')) {
                // Close inspector if it's open
                try {
                    if (AFRAME.INSPECTOR && AFRAME.INSPECTOR.opened) {
                        AFRAME.INSPECTOR.close();
                    }
                } catch (e) {
                    console.warn('Inspector cleanup skipped:', e);
                }

                // Get the current scene and save all assets
                let currentScene = document.querySelector('a-scene');
                const currentAssets = Array.from(currentScene.querySelectorAll('a-assets > *')).map(asset => asset.cloneNode(true));

                // Create new scene with same configuration
                let newScene = document.createElement('a-scene');
                newScene.setAttribute('embedded', '');
                newScene.setAttribute('renderer', 'antialias: true; colorManagement: true; physicallyCorrectLights: true; sortObjects: true;');


                // Set default content
                newScene.innerHTML = `
                    <a-assets id="asset-container">
                        <!-- Assets will be re-added here -->
                    </a-assets>
                    
                    <!-- Camera -->
                    <a-camera position="0 1.6 0"></a-camera>

                    <!-- Scene Entities -->
                    <a-box position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9"></a-box>
                    <a-sphere position="0 1.25 -5" radius="1.25" color="#EF2D5E"></a-sphere>
                    <a-cylinder position="1 0.75 -3" radius="0.5" height="1.5" color="#FFC65D"></a-cylinder>
                    <a-plane position="0 0 -4" rotation="-90 0 0" width="4" height="4" color="#7BC8A4"></a-plane>

                    <!-- Environment -->
                    <a-sky color="#ECECEC"></a-sky>
                `;

                // Replace the old scene
                currentScene.parentNode.replaceChild(newScene, currentScene);

                // Update the scene reference
                scene = document.querySelector('a-scene');

                // Re-add all assets to the new scene
                const newAssetContainer = scene.querySelector('#asset-container');
                currentAssets.forEach(asset => {
                    newAssetContainer.appendChild(asset);
                });

                // Clean up inspector reference
                if (typeof AFRAME.INSPECTOR !== 'undefined') {
                    delete AFRAME.INSPECTOR;
                }

                // Switch to scene view and ensure it's visible
                if (currentView != 'scene') {
                    scene.style.display = 'none';
                }


                // Wait for scene to load then update code panel
                scene.addEventListener('loaded', () => {
                    updateCodePanel();
                });
            }
        }

        // Update the openInspector function
        function openInspector() {
            if (window.AFRAME.INSPECTOR && window.AFRAME.INSPECTOR.opened) {
                window.AFRAME.INSPECTOR.close();
            }

            // Remove existing inspector script if present
            const existingScript = document.querySelector('script[src*="aframe-inspector.min.js"]');
            if (existingScript) existingScript.remove();

            // Remove existing inspector elements
            document.querySelectorAll('.a-inspector-loader, .a-inspector').forEach(el => el.remove());

            // Load inspector fresh each time
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/gh/aframevr/aframe-inspector@master/dist/aframe-inspector.min.js';
            script.onload = () => {
                AFRAME.INSPECTOR.open();
                document.body.classList.add('aframe-inspector-opened');
                setupInspectorListeners();
            };
            document.head.appendChild(script);
        }

        // Add function to remove inspector
        function removeInspector() {
            // Remove the inspector script if it exists
            const inspectorScript = document.querySelector('script[src*="aframe-inspector.min.js"]');
            if (inspectorScript) {
                inspectorScript.remove();
            }

            // Remove inspector UI elements
            const inspectorElements = document.querySelectorAll('.a-inspector-loader, .a-inspector');
            inspectorElements.forEach(el => el.remove());
        }

        // Add inspector initialization to initial load
        document.addEventListener('DOMContentLoaded', () => {
            // ... existing DOMContentLoaded code ...
            initInspector();
            removeInspector();
        });

        function clearScene() {
            if (confirm('Are you sure you want to clear all models, images, and scene elements?')) {
                // Close inspector if it's open
                try {
                    if (AFRAME.INSPECTOR && AFRAME.INSPECTOR.opened) {
                        AFRAME.INSPECTOR.close();
                    }
                } catch (e) {
                    console.warn('Inspector cleanup skipped:', e);
                }

                // Get the current scene and save all assets
                let currentScene = document.querySelector('a-scene');
                const currentAssets = Array.from(currentScene.querySelectorAll('a-assets > *')).map(asset => asset.cloneNode(true));

                // Create new scene with same configuration
                let newScene = document.createElement('a-scene');
                newScene.setAttribute('embedded', '');
                newScene.setAttribute('renderer', 'antialias: true; colorManagement: true; physicallyCorrectLights: true; sortObjects: true;');

                // Set default content - just assets, camera, sky and lights
                newScene.innerHTML = `
                    <a-assets id="asset-container">
                        <!-- Assets will be re-added here -->
                    </a-assets>

                    <a-camera position="0 1.6 0"></a-camera>
                    <a-sky color="#ECECEC"></a-sky>

                    <!-- Default lighting -->
                    <a-entity light="color: #BBB; type: ambient" data-aframe-default-light="" aframe-injected=""></a-entity>
                    <a-entity light="intensity: 0.6; castShadow: true" position="-0.5 1 1" data-aframe-default-light="" aframe-injected=""></a-entity>
                `;

                // Replace the old scene
                currentScene.parentNode.replaceChild(newScene, currentScene);

                // Update the scene reference
                scene = document.querySelector('a-scene');

                // Re-add all assets to the new scene
                const newAssetContainer = scene.querySelector('#asset-container');
                currentAssets.forEach(asset => {
                    newAssetContainer.appendChild(asset);
                });

                // Clean up inspector reference
                if (typeof AFRAME.INSPECTOR !== 'undefined') {
                    delete AFRAME.INSPECTOR;
                }

                // Switch to scene view and ensure it's visible
                currentView = 'scene';
                scene.style.display = 'block';
                codePanel.style.display = 'none';

                // Wait for scene to load then update code panel
                scene.addEventListener('loaded', () => {
                    updateCodePanel();
                });
            }
        }

        let skyboxCounter = 0;

        document.getElementById('skybox-input').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) {
                console.log('No file selected');
                return;
            }
            console.log('File selected:', file.type);

            const url = URL.createObjectURL(file);
            const isVideo = file.type.startsWith('video/');
            const assetId = `skybox-asset-${skyboxCounter++}`;

            // Create preview element
            const previewDiv = document.createElement('div');
            previewDiv.className = 'asset-item';
            previewDiv.innerHTML = `
        <div class="preview-wrapper">
            ${isVideo ?
                    `<video src="${url}" style="width: 100%; height: 100%; object-fit: cover;" loop muted autoplay></video>` :
                    `<img src="${url}" style="width: 100%; height: 100%; object-fit: cover;">`
                }
        </div>
    `;

            // Add click handler to set as active skybox
            previewDiv.addEventListener('click', () => {
                // Remove existing sky/videosphere
                const existingSky = document.querySelector('a-sky, a-videosphere');
                if (existingSky) {
                    existingSky.remove();
                }

                // Create new sky element
                const skyEl = document.createElement(isVideo ? 'a-videosphere' : 'a-sky');
                skyEl.setAttribute('src', `#${assetId}`);

                // Add to scene
                const scene = document.querySelector('a-scene');
                scene.appendChild(skyEl);

                // If it's a video, ensure it's playing
                if (isVideo) {
                    const videoAsset = document.getElementById(assetId);
                    videoAsset.play().catch(e => console.error('Error playing video:', e));
                }

                // Update active state visually
                document.querySelectorAll('#skybox-container .asset-item').forEach(item => {
                    item.classList.remove('active');
                });
                previewDiv.classList.add('active');
            });

            // Add to skybox container
            document.getElementById('skybox-container').appendChild(previewDiv);

            // Get assets container
            const assets = document.querySelector('a-assets');

            // Create asset element
            const assetEl = document.createElement(isVideo ? 'video' : 'img');
            assetEl.id = assetId;
            assetEl.src = url;
            if (isVideo) {
                assetEl.setAttribute('preload', 'auto');
                assetEl.setAttribute('loop', '');
                assetEl.setAttribute('crossorigin', 'anonymous');
            }

            // Add new asset
            assets.appendChild(assetEl);

            // Trigger click to set as active skybox
            previewDiv.click();
        });

        function clearAssets() {
            if (confirm('Are you sure you want to clear all models, images, and scene elements?')) {
                // Close inspector if it's open
                try {
                    if (AFRAME.INSPECTOR && AFRAME.INSPECTOR.opened) {
                        AFRAME.INSPECTOR.close();
                    }
                } catch (e) {
                    console.warn('Inspector cleanup skipped:', e);
                }

                // Get the current scene and save all assets
                let currentScene = document.querySelector('a-scene');
                const currentAssets = Array.from(currentScene.querySelectorAll('a-assets > *')).map(asset => asset.cloneNode(true));

                // Create new scene with same configuration
                let newScene = document.createElement('a-scene');
                newScene.setAttribute('embedded', '');
                newScene.setAttribute('renderer', 'antialias: true; colorManagement: true; physicallyCorrectLights: true; sortObjects: true;');

                // Set default content - just assets, camera, sky and lights
                newScene.innerHTML = `
                    <a-assets id="asset-container">
                        <!-- Assets will be re-added here -->
                    </a-assets>

                    <a-camera position="0 1.6 0"></a-camera>
                    <a-sky color="#ECECEC"></a-sky>

                    <!-- Default lighting -->
                    <a-entity light="color: #BBB; type: ambient" data-aframe-default-light="" aframe-injected=""></a-entity>
                    <a-entity light="intensity: 0.6; castShadow: true" position="-0.5 1 1" data-aframe-default-light="" aframe-injected=""></a-entity>
                `;

                // Replace the old scene
                currentScene.parentNode.replaceChild(newScene, currentScene);

                // Update the scene reference
                scene = document.querySelector('a-scene');

                // Re-add all assets to the new scene
                const newAssetContainer = scene.querySelector('#asset-container');
                currentAssets.forEach(asset => {
                    newAssetContainer.appendChild(asset);
                });

                // Clean up inspector reference
                if (typeof AFRAME.INSPECTOR !== 'undefined') {
                    delete AFRAME.INSPECTOR;
                }

                // Switch to scene view and ensure it's visible
                currentView = 'scene';
                scene.style.display = 'block';
                codePanel.style.display = 'none';

                // Wait for scene to load then update code panel
                scene.addEventListener('loaded', () => {
                    updateCodePanel();
                });
            }
        }

        function formatSceneContent(sceneEl) {
            const assets = sceneEl.querySelector('a-assets');
            const camera = sceneEl.querySelector('a-camera');
            const sky = sceneEl.querySelector('a-sky');
            const lights = Array.from(sceneEl.querySelectorAll('[light]'));

            // Get all other entities (excluding assets, camera, sky, lights)
            const entities = Array.from(sceneEl.children).filter(el =>
                el !== assets &&
                el !== camera &&
                el !== sky &&
                !lights.includes(el)
            );

            let content = '';

            // Assets
            content += '<a-assets id="asset-container">\n';
            content += '    <!-- Assets -->\n';
            if (assets) {
                Array.from(assets.children).forEach(asset => {
                    content += '    ' + asset.outerHTML + '\n';
                });
            }
            content += '</a-assets>\n\n';

            // Camera
            if (camera) {
                content += '<!-- Camera -->\n';
                content += camera.outerHTML + '\n\n';
            }

            // Entities
            if (entities.length > 0) {
                content += '<!-- Scene Entities -->\n';
                entities.forEach(entity => {
                    content += entity.outerHTML + '\n';
                });
                content += '\n';
            }

            // Environment (Sky)
            if (sky) {
                content += '<!-- Environment -->\n';
                content += sky.outerHTML + '\n\n';
            }

            // Lighting
            if (lights.length > 0) {
                content += '<!-- Lighting -->\n';
                lights.forEach(light => {
                    content += light.outerHTML + '\n';
                });
            }

            return content;
        }

        function cleanupInspector() {
            if (AFRAME.INSPECTOR && AFRAME.INSPECTOR.opened) {
                AFRAME.INSPECTOR.close();
            }
            document.body.classList.remove('aframe-inspector-opened');
        }
    </script>
</body>

</html>